<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://many258.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://many258.github.io/" rel="alternate" type="text/html" /><updated>2021-03-13T22:19:21+09:00</updated><id>https://many258.github.io/feed.xml</id><title type="html">My expression</title><subtitle>My expression</subtitle><author><name>SG Yoo.</name><email>many258@naver.com</email></author><entry><title type="html">[데이터베이스] 데이터베이스 설계</title><link href="https://many258.github.io/study/database-design/" rel="alternate" type="text/html" title="[데이터베이스] 데이터베이스 설계" /><published>2021-03-13T00:00:00+09:00</published><updated>2021-03-13T22:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-design%7D</id><content type="html" xml:base="https://many258.github.io/study/database-design/">&lt;h1 id=&quot;데이터베이스-설계&quot;&gt;데이터베이스 설계&lt;/h1&gt;
&lt;h2 id=&quot;데이터베이스-설계-시-유의사항&quot;&gt;데이터베이스 설계 시 유의사항&lt;/h2&gt;
&lt;p&gt;저장된 데이터가 연산 수행 후에도 &lt;strong&gt;무결성&lt;/strong&gt;이 유지될 수 있도록 설계&lt;br /&gt;
시스템 장애 시 복구될 수 있도록 &lt;strong&gt;회복과 예비&lt;/strong&gt; 절차를 염두에 두고 설계&lt;br /&gt;
외부로부터 불법적인 접근을 방지할 수 있는 &lt;strong&gt;보안 절차&lt;/strong&gt;를 유의하여 설계&lt;br /&gt;
데이터 관리에 대한 &lt;strong&gt;효율성&lt;/strong&gt;과 &lt;strong&gt;일관성&lt;/strong&gt;이 유지되도록 설계&lt;br /&gt;
데이터베이스의 확장과 축소에 대비한 &lt;strong&gt;신축성&lt;/strong&gt;을 고려하여 설계&lt;/p&gt;

&lt;h2 id=&quot;데이터베이스의-생명주기&quot;&gt;데이터베이스의 생명주기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;요구 조건 분석&lt;/strong&gt; : 범위 설정을 위한 사용자와 그 응용을 식별하는 단계&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;설계&lt;/strong&gt; : 개념적 설계, 논리적 설계, 물리적 설계까지의 단계&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;구현&lt;/strong&gt; : 스키마 정의, 빈 데이터베이스 파일 생성, 응용 소프트웨어 구현 단계&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;운영&lt;/strong&gt; : 실제로 운영하여 사용자에게 서비스를 제공하는 단계&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;감시 및 개선&lt;/strong&gt; : 응용 과정에서 새로운 요구조건에 대처하고 성능을 개선하는 단계&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터베이스-설계-순서&quot;&gt;데이터베이스 설계 순서&lt;/h2&gt;
&lt;h3 id=&quot;요구-조건-분석-단계&quot;&gt;요구 조건 분석 단계&lt;/h3&gt;
&lt;p&gt;사용자 식별 및 범위 설정&lt;/p&gt;

&lt;p&gt;요구되는 개체와 속성, 관계성, 제약조건, 트랜잭션의 유형, 실행 횟수 등을 파악&lt;br /&gt;
  사용기관의 사용 목적과 내규, 법적인 규정, 데이터베이스의 사용자 식별, 사용 범위 결정 등 분석&lt;/p&gt;

&lt;h3 id=&quot;개념적-설계-단계&quot;&gt;개념적 설계 단계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;개념 스키마 모델링&lt;/strong&gt;&lt;br /&gt;
요구 분석 단계에서 나온 결과를 E-R 다이엉그램과 같은 DBMS에 독립적이고 고차원적인 표현 기법으로 기술하는 과정을 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;트랜잭션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모델링&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
요구 조건 분석 결과로 식별된 응용을 검토해서 이들을 구현할 수 있는 트랜잭션을 고차원 명세로 기술하는 과정&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;논리적-설계-단계&quot;&gt;논리적 설계 단계&lt;/h3&gt;
&lt;p&gt;DBMS에 따라 논리적 모델로 변환, 트랜잭션의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터페이스&lt;/code&gt; 설계, 스키마 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;평가&lt;/code&gt; 및 정제&lt;/p&gt;

&lt;h3 id=&quot;물리적-설계-단계&quot;&gt;물리적 설계 단계&lt;/h3&gt;
&lt;p&gt;물리적 구조 설계, 트랜잭션의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;세부 사항 설계&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;물리적 설계 사항
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;저장될 &lt;strong&gt;레코드의 양식&lt;/strong&gt; 설계&lt;br /&gt;
데이터 타입, 접근 횟수, 데이터 값의 분포 등을 고려&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;저장될 레코드들의 &lt;strong&gt;분포 및 집중&lt;/strong&gt;에 관한 설계&lt;br /&gt;
레코드의 저장 방식과 물리적 블록의 크기 고려&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;접근 경로&lt;/strong&gt;의 설계&lt;br /&gt;
데이터를 물리적 저장 장치에 어떻게 저장시킬 것이며, 그 저장된 데이터를 어떤 방법으로 가져다 쓸 것인지에 대한 접근 방법을 설계하는 것으로 인덱스 등을 설계&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;물리적 설계 옵션 선택 시 고려 사항
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;응답시간&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;저장 공간의 효율화&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;트랜잭션 처리도&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;물리적 데이터베이스 설계 시 결정 사항
    &lt;ul&gt;
      &lt;li&gt;어떤 인덱스를 만들 것인지 고려&lt;/li&gt;
      &lt;li&gt;성능 향상을 위한 개념 스키마의 변경 여부 검토&lt;/li&gt;
      &lt;li&gt;빈번한 질의와 트랜잭션들의 수행 속도를 높이기 위한 사항을 고려&lt;/li&gt;
      &lt;li&gt;파일에 대한 트랜잭션의 갱신과 참조 성향 검토&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;구현-단계&quot;&gt;구현 단계&lt;/h3&gt;
&lt;p&gt;DDL로 스키마 작성, 트랜잭션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그래밍&lt;/code&gt;(응용프로그램 작성)&lt;/p&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">데이터베이스 설계 데이터베이스 설계 시 유의사항 저장된 데이터가 연산 수행 후에도 무결성이 유지될 수 있도록 설계 시스템 장애 시 복구될 수 있도록 회복과 예비 절차를 염두에 두고 설계 외부로부터 불법적인 접근을 방지할 수 있는 보안 절차를 유의하여 설계 데이터 관리에 대한 효율성과 일관성이 유지되도록 설계 데이터베이스의 확장과 축소에 대비한 신축성을 고려하여 설계</summary></entry><entry><title type="html">[데이터베이스] 데이터베이스 정규화</title><link href="https://many258.github.io/study/database-normalization/" rel="alternate" type="text/html" title="[데이터베이스] 데이터베이스 정규화" /><published>2021-03-13T00:00:00+09:00</published><updated>2021-03-13T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-normalization%7D</id><content type="html" xml:base="https://many258.github.io/study/database-normalization/">&lt;h1 id=&quot;관계-스키마-설계&quot;&gt;관계 스키마 설계&lt;/h1&gt;
&lt;p&gt;데이터베이스 설계에서 중요한 사항 중 하나가 현실 세계를 가장 정확하게 표현하기 위한 데이터의 논리적 구조를 결정하는 것&lt;/p&gt;

&lt;h2 id=&quot;설계-원칙&quot;&gt;설계 원칙&lt;/h2&gt;
&lt;p&gt;필요한 속성, 개체, 관계성을 식별하여 릴레이션을 구성&lt;br /&gt;
불필요한 데이터의 중복이 발생하지 않도록 설계&lt;br /&gt;
속성 사이의 관계성과 데이터의 종속성을 고려하여 설계&lt;br /&gt;
효율적 데이터 처리와 일관성 유지 방법 등을 고려하여 설계&lt;/p&gt;

&lt;h2 id=&quot;스키마-변환schema-transformation&quot;&gt;스키마 변환(Schema Transformation)&lt;/h2&gt;
&lt;p&gt;관련된 어트리뷰트를 수집하고 이들 간에 존재하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;종속성&lt;/code&gt;을 파악하여 어트리뷰트의 집합인 릴레이션으로 만든 다음 보다 바람직한 형태의 릴레이션으로 다시 변환하는 과정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;스키마 변환 원칙&lt;/strong&gt;&lt;br /&gt;
공해의 원칙&lt;br /&gt;
정보 무손실 원칙&lt;br /&gt;
데이터 중복 감소의 원칙&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;이상anomaly-현상&quot;&gt;이상(Anomaly) 현상&lt;/h1&gt;
&lt;p&gt;관계 스킴이 잘못되면 불필요한 데이터 중복을 초래하게 된다. 이러한 데이터 중복은 릴레이션을 조작할 때 곤란한 현상을 발생시키는 현상을 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;삭제 이상&lt;/strong&gt;(Delete Anomaly)&lt;br /&gt;
임의의 튜플을 삭제했을 때 그것과 관계를 형성하고 있는 관계성까지 모두 삭제되는 현상&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;삽입 이상&lt;/strong&gt;(Insert Anomaly)&lt;br /&gt;
임의의 튜플을 삽입했을 때 삽입 의도가 없는 관계까지도 삽입되는 현상&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;갱신 이상&lt;/strong&gt;(Update Anomaly)&lt;br /&gt;
임의의 데이터를 갱신했을 때 그것과 관계를 맺고 있는 데이터에 대해 일관성을 유지할 수 없는 현상&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;정규화-과정&quot;&gt;정규화 과정&lt;/h1&gt;
&lt;p&gt;하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해 나가는 과정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;목적&lt;/strong&gt;
구성되는 릴레이션이 중복되지 않게 효과적으로 데이터베이스 내에 표현이 가능하도록 한다
보다 간단한 연산자에 의해 효과적인 연산이 가능하도록 한다
릴레이션에 삽입 이상, 삭제 이상, 갱신 이상의 목제가 발생하지 않도록 한다
새로운 형태의 데이터가 삽입될 때 릴레이션을 재구성할 필요성을 감소시키도록 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;필요성&lt;/strong&gt;
자료의 저장 공간을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소화&lt;/code&gt;
자료의 불일치를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소화&lt;/code&gt;
자료 구조 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안정화&lt;/code&gt;
자료의 삽입, 삭제, 갱신 시 이상 현상을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;방지&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;함수-종속&quot;&gt;함수 종속&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;어떤 릴레이션 R에서 A, B가 릴레이션 R의 부분 속성이라고 할 때,&lt;/p&gt;

  &lt;p&gt;임의 시점에서 A의 어떤 값도 반드시 B의 하나의 값에 대응되지만, B의 하나의 값이 A의 복수의 값에 대응되는 경우 B는 A의 함수 종속이라 하고, A → B로 표기한다.
여기서 A는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결정자&lt;/code&gt;, B는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;종속자&lt;/code&gt;라 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;기본-정규형&quot;&gt;기본 정규형&lt;/h2&gt;
&lt;h3 id=&quot;제1정규형&quot;&gt;제1정규형&lt;/h3&gt;
&lt;p&gt;어떤 릴레이션 R에 속한 모든 도메인이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;원자값&lt;/code&gt;(분해될 수 없는 값)으로만으로 되어 있다면 제1정규형에 속한다.&lt;/p&gt;

&lt;h3 id=&quot;제2정규형&quot;&gt;제2정규형&lt;/h3&gt;
&lt;p&gt;어떤 릴레이션 R이 제1정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완전 함수적 종속&lt;/code&gt;(부분 함수 종속 제거)이면 제 2정규형에 속한다.&lt;br /&gt;
기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;완전 함수 종속성&lt;br /&gt;
A, B가 각각 관계 R의 속성이고 B가 A에 함수 종속(A→B)인 경우, A의 임의의 부분 집합에 대하여 B의 어떤 값도 A의 부분 집합의 값에 대응하지 않으면 B는 A에 완전함수(적) 종속&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제3정규형&quot;&gt;제3정규형&lt;/h3&gt;
&lt;p&gt;어떤 릴레이션 R이 제2정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이행적 함수 종속&lt;/code&gt;이 아니면 제3정규형에 속한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이행 함수 종속성&lt;br /&gt;
A, B, C가 각각 관계 R에 상호 중복되지 않는 속성(다만, A는 1차 키 이외의 속성)인 경우에, A가 B에 함수 종속적이 아니면 이때 C는 A에 이행함수 종속이라고 한다. A-&amp;gt;B 이고 B-&amp;gt;C 일 경우에만 A-&amp;gt;C 이면 이행함수(적) 종속이라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;보이스-코드-정규형boyce-codd-normal-form--bcbf&quot;&gt;보이스 코드 정규형(Boyce-Codd Normal Form : BCBF)&lt;/h3&gt;
&lt;p&gt;릴레이션 R의 모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결정자&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;후보키&lt;/code&gt;이면 릴레이션 R은 BC(Boyce-Codd)정규형에 속한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;슈퍼키&lt;/strong&gt;&lt;br /&gt;
레코드를 유일하게 식별해낼 수 있는 속성들의 집합이다. 한 개의 테이블은 여러 개의 슈퍼키를 가질 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;후보키&lt;/strong&gt;&lt;br /&gt;
슈퍼 키에서 레코드를 유일하게 식별하는데 있어서 필요없는 속성을 제거한 슈퍼 키의 부분집합&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제4정규형&quot;&gt;제4정규형&lt;/h3&gt;
&lt;p&gt;릴레이션 R에 비당연 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVD&lt;/code&gt; A-»B가 존재할 때 R의 모든 속성도 A에 함수 종속이면 릴레이션 R은 제4정규형에 속한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;다치 종속성(MVD)&lt;/strong&gt;&lt;br /&gt;
어떤 레코드의 존재가 다른 레코드의 존재로 이어짐을 의미한다. 다치종속성은-»으로 표시하는데, R｛A,B,C｝일 때 (A,C)-»｛B｝≡(A) -&amp;gt;｛B｝ 성립한다. , A-»B이면 A-»C도 성립하고 A-»B│C이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제5정규형&quot;&gt;제5정규형&lt;/h3&gt;
&lt;p&gt;릴레이션 R에 존재하는 모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조인 종속&lt;/code&gt;(JD)이 릴레이션 R의 후보키를 통해서만 성립된다면 릴레이션 R은 제5정규형 또는 PJ/NF(Projection-Join Normal Form)에 속한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;조인 종속&lt;/strong&gt;&lt;br /&gt;
릴레이션 R이 그의 프로젝션 A,B,…..,Z의 조인과 동일하면 R은 JD*(A,B,….,Z )를 만족한다. 이때 A,B,….,Z는 R의 애트리뷰트에 대한 부분집합이다.&lt;br /&gt;
다시말해서, 테이블 R이 R의 속성의 부분집합을 가지는 여러 개의 테이블들을 조인하여 만들어질 수 있을 때, R은 조인 종속성을 가진다고 한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">관계 스키마 설계 데이터베이스 설계에서 중요한 사항 중 하나가 현실 세계를 가장 정확하게 표현하기 위한 데이터의 논리적 구조를 결정하는 것</summary></entry><entry><title type="html">[데이터베이스] 데이터 모델링</title><link href="https://many258.github.io/study/database-modeling/" rel="alternate" type="text/html" title="[데이터베이스] 데이터 모델링" /><published>2021-03-13T00:00:00+09:00</published><updated>2021-03-13T12:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-modeling%7D</id><content type="html" xml:base="https://many258.github.io/study/database-modeling/">&lt;h1 id=&quot;데이터-모델&quot;&gt;데이터 모델&lt;/h1&gt;
&lt;p&gt;현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위해 사용되는 도구&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;개념적 데이터 모델&lt;/strong&gt;(High-Level, Conceptual Data Model)&lt;br /&gt;
속성들로 기술된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개체&lt;/code&gt; 타입과 이 개체 타입들 간의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관계&lt;/code&gt;를 이용하여 현실 세계를 표현하는 방법
    &lt;ul&gt;
      &lt;li&gt;종류
        &lt;ul&gt;
          &lt;li&gt;E-R 모델(Entity-Relationship Model)&lt;/li&gt;
          &lt;li&gt;이진 모델(Binary Model)&lt;/li&gt;
          &lt;li&gt;의미적 데이터 모델(Semantic Data Model)&lt;/li&gt;
          &lt;li&gt;정보 논리 모델(Information Logical Model)&lt;/li&gt;
          &lt;li&gt;함수적 데이터 모델(Functional Data Model)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;논리적 데이터 모델&lt;/strong&gt;(Logical Data Model)&lt;br /&gt;
필드로 기술된 데이터 타입들 간의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관계&lt;/code&gt;를 이용하여 현실 세계를 표현하는 방법
    &lt;ul&gt;
      &lt;li&gt;종류
        &lt;ul&gt;
          &lt;li&gt;관계형 데이터 모델&lt;/li&gt;
          &lt;li&gt;계층형 데이터 모델&lt;/li&gt;
          &lt;li&gt;네트워크형 데이터 모델&lt;/li&gt;
          &lt;li&gt;객체지향형 데이터 모델&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-모델-구성요소&quot;&gt;데이터 모델 구성요소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Structure&lt;/strong&gt;&lt;br /&gt;
데이터의 논리적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구조&lt;/code&gt;&lt;br /&gt;
데이터 모델을 기술할 때는 데이터 사이의 관계성을 파악하여 그 논리적 구성 형태를 기술해 주어야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;br /&gt;
개체 인스턴스를 처리하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연산&lt;/code&gt;&lt;br /&gt;
실제 데이터를 어떤 방법으로 삽입, 선정, 변경, 삭제할 것인가 하는 사항을 기술해야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Constraint&lt;/strong&gt;&lt;br /&gt;
개체 인스턴스에 대한 논리적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제약 사항&lt;/code&gt;&lt;br /&gt;
실제 데이터의 특징과 특성을 파악하여 어떤 데이터만을 받아들이며 어떤 관계만을 허용할 것인가를 기술해야 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개념적-데이터-모델&quot;&gt;개념적 데이터 모델&lt;/h2&gt;
&lt;h3 id=&quot;개체-관계-모델entity-relationship-model&quot;&gt;개체 관계 모델(Entity-Relationship Model)&lt;/h3&gt;
&lt;p&gt;개념적 단계에서 개체 내의 관계, 개체와 개체 사이의 사상 관계를 표현하는 데 쓰이며 사용자의 관점에서 가장 좋은 도구로 많이 사용되는 모델&lt;/p&gt;

&lt;h4 id=&quot;특징&quot;&gt;특징&lt;/h4&gt;
&lt;p&gt;1976년 Peter Chen에 의해 제안된 이래 개념적 설계에 가장 많이 사용되는 모델&lt;br /&gt;
개체 타입과 관계 타입을 이용해서 현실 세계를 개념적으로 표현한 모델&lt;br /&gt;
개체라는 것은 현실 세계에 존재하는 객체들을 의미&lt;br /&gt;
관계라는 것은 개체들 사이의 관계를 표현하는 것&lt;br /&gt;
E-R 다이어그램은 그래프 형태로 표시&lt;br /&gt;
최초에는 Entity, Relationship, Attribute와 같은 개념들로 구성되었으나 나중에는 확장된 모델로 발전&lt;/p&gt;

&lt;h4 id=&quot;기호&quot;&gt;기호&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/database/EERD.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;사상-원소수mapping-cardinality&quot;&gt;사상 원소수(Mapping cardinality)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1:1&lt;/li&gt;
  &lt;li&gt;1:N&lt;/li&gt;
  &lt;li&gt;N:1&lt;/li&gt;
  &lt;li&gt;N:M&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;논리적-데이터-모델&quot;&gt;논리적 데이터 모델&lt;/h2&gt;
&lt;p&gt;논리적 단계에서 쓰이는 도구로서 개념적 단계에서 만들어진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개념적&lt;/code&gt; 구조를 컴퓨터에 저장시킬 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;논리적&lt;/code&gt; 구조로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;변환&lt;/code&gt;하고자 쓰이는 데이터 모델&lt;/p&gt;

&lt;p&gt;데이터베이스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전체적&lt;/code&gt;인 논리적 구조를 설명할 때 사용되는 데이터 모델
관계 표현 : 관계 데이터 모델 - &lt;strong&gt;테이블&lt;/strong&gt; 구조, 계층 데이터 모델 - &lt;strong&gt;트리&lt;/strong&gt; 구조, 네트워크 데이터 모델 - &lt;strong&gt;그래프&lt;/strong&gt; 구조&lt;/p&gt;

&lt;h3 id=&quot;관계형-데이터-모델relational-data-model&quot;&gt;관계형 데이터 모델(Relational Data Model)&lt;/h3&gt;
&lt;p&gt;통일적이고 단순한 데이터 구조로 되어 있다&lt;br /&gt;
사용자에게 가장 뛰어난 논리적 구조를 지원&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;릴레이션&lt;/code&gt; 구조로 운영되는 데이터베이스&lt;br /&gt;
개체나 관계 모두가 릴레이션 형태&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기본키&lt;/code&gt;와 이를 참조하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;외래키&lt;/code&gt;로 데이터 간의 관계를 표현&lt;/p&gt;

&lt;h3 id=&quot;계층형-데이터-모델hierarchical-data-model&quot;&gt;계층형 데이터 모델(Hierarchical Data Model)&lt;/h3&gt;
&lt;p&gt;데이터 간의 관계를 순서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트리&lt;/code&gt; 형태로 표현&lt;br /&gt;
속성 간의 관계를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;레코드&lt;/code&gt;, 레코드 간의 관계를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;링크&lt;/code&gt;로 표현&lt;br /&gt;
계층 정의 트리 형태로 나타낼 때 노드는 레코드 타입이 되며 가지는 두 레코드 타입 사이의 링크가 된다&lt;br /&gt;
모든 링크의 관계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1:N&lt;/code&gt; 관계&lt;br /&gt;
두 레코드 타입 간의 관계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나&lt;/code&gt;의 링크 관계만 있을 수 있으므로 별도의 이름을 부여하지 않음&lt;br /&gt;
레코드 타입 간에는 상하 계층이 존재, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사이클&lt;/code&gt;이 허용되지 않음&lt;br /&gt;
대표적인 DBMS = IMS&lt;/p&gt;

&lt;h3 id=&quot;네트워크-데이터-모델network-data-model&quot;&gt;네트워크 데이터 모델(Network Data Model)&lt;/h3&gt;
&lt;p&gt;데이터 간의 관계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그래프&lt;/code&gt; 구조 형태&lt;br /&gt;
1에 해당하는 레코드 타입을 오너 레코드 타입, N에 해당하는 레코드 타입을 멤버 레코드 타입, 이들의 관계를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오너-멤버&lt;/code&gt;(Owner-Member)관계라 한다.&lt;br /&gt;
레코드 타입 간의 관계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1:1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1:N&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N:1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N:M&lt;/code&gt;이 될 수 있다
다 대 다의 관계가 있기 때문에 데이터 간의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연계성&lt;/code&gt;이 매우 뛰어난 모델이나 복잡하고 구축 비용이 크다
노드는 레코드 타입이 되고 링크는 개체 집합 간의 관계성을 표현
링크는 어느 한쪽으로 반드시 함수적 관계로 해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;화살표&lt;/code&gt;로 표현
링크 위에는 두 레코드 타입 간의 관계를 레이블로 표시
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CDASYL&lt;/code&gt;(Conference On Data System Languages), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DBTG&lt;/code&gt;(Data Base Task Group) 보고서에서 DBTG 모델이라는 것을 정의하여 네트워크 데이터 모델에 대한 이론적 개념을 정립&lt;/p&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">데이터 모델 현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위해 사용되는 도구</summary></entry><entry><title type="html">[네트워크] TCP/IP 4계층 및 응용계층</title><link href="https://many258.github.io/study/tcp-ip-application/" rel="alternate" type="text/html" title="[네트워크] TCP/IP 4계층 및 응용계층" /><published>2021-03-11T00:00:00+09:00</published><updated>2021-03-10T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Btcp-ip-application%7D</id><content type="html" xml:base="https://many258.github.io/study/tcp-ip-application/">&lt;h1 id=&quot;tcpip&quot;&gt;TCP/IP&lt;/h1&gt;
&lt;p&gt;Transmission Control Protocol/Internet Protocol&lt;/p&gt;

&lt;p&gt;DoD(미국방성)모델이라고 하며 OSI 7계층과 흡사하나 OSI보다 먼저 만들어지고 가장 많이 사용중이다.&lt;/p&gt;

&lt;h2 id=&quot;tcpip-구조&quot;&gt;TCP/IP 구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Application&lt;/strong&gt;(Application/Presentation/Session)&lt;br /&gt;
네트워크를 실제로 사용하는 응용프로그램으로 구성&lt;br /&gt;
FTP, TELNET, SMTP 등등&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Transport&lt;/strong&gt;(Transport)&lt;br /&gt;
도착하고자 하는 시스템까지 데이터를 전송&lt;br /&gt;
Port를 가지고 있으며, 프로세스를 연결 또는 비연결해서 통신함&lt;br /&gt;
TCP, UDP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Internet&lt;/strong&gt;(Network)&lt;br /&gt;
Datagram을 정의하고 routing하는 일을 담당&lt;br /&gt;
IP, ARP, RARP, ICMP, IGMP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Network Access&lt;/strong&gt;(Data Link/Physical)&lt;br /&gt;
케이블, 송수신기, 링크 프로토콜, LAN 접속과 같은 물리적 연결 구성을 정의&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;application-layer&quot;&gt;Application Layer&lt;/h2&gt;
&lt;p&gt;일반 사용자들이 사용하는 프로그램이 있는 계층. 사용자는 프로그램을 사용하여 통신.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#ftp&quot;&gt;&lt;strong&gt;FTP&lt;/strong&gt;&lt;/a&gt;(File Transfer Protocol)&lt;br /&gt;
사용자 파일의 업로드 혹은 다운로드를 수행하는 프로그램
파일 전송을 위한 인터넷 표준으로 제어 접속과 데이터 접속을 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분리&lt;/code&gt;된 포트를 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DNS&lt;/strong&gt;(Domain Name Service)&lt;br /&gt;
DNS 쿼리를 사용해서 DNS서버에 URL을 전송하고 해당 URL에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;매핑&lt;/code&gt;되는 IP주소를 제공하는 서비스&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#http&quot;&gt;&lt;strong&gt;HTTP&lt;/strong&gt;&lt;/a&gt;(Hyper Text Transfer Protocol)
WWW(World Wide Web)로 시작되는 인터넷에서 웹브라우저와 웹 서버 사이에 웹 페이지의 Request 및 Response를 수행하는 W3C 표준 개방형 프로토콜&lt;br /&gt;
TCP 기반 프로토콜의 80번 포트를 사용, State-less로 프로토콜을 구성
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;HTTP v1.0&lt;br /&gt;
연결을 수행할 때 마다 3-Way Handshaking 기법 사용&lt;br /&gt;
HTML 페이지를 수신 받고 완전히 종료&lt;br /&gt;
필요 시 재연결하고 페이지를 수신받음&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HTTP v1.1&lt;br /&gt;
어느 정도 대기한 후에 연결을 종료(Keep Alive Connection)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HTTP v2.0&lt;br /&gt;
&lt;strong&gt;멀티플랙싱&lt;/strong&gt;(Multiplexing) : 순차적 연결이 아니라 동시 다발적인 양방향 통신 지원&lt;br /&gt;
&lt;strong&gt;헤더압축&lt;/strong&gt;(Header Compression) : 헤더 정보를 1/3 수준으로 압축. 속도 향상&lt;br /&gt;
&lt;strong&gt;서버푸시&lt;/strong&gt;(Server Push) : 웹 서버가 웹 브라우저에게 필요한 데이터를 알아서 미리 전송할 수 있는 기술&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Telnet&lt;/strong&gt;&lt;br /&gt;
특정 지역의 사용자가 지역적으로 다른 곳에 위치한 컴퓨터를 온라인으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연결&lt;/code&gt;하여 사용하는 서비스&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#smtp&quot;&gt;&lt;strong&gt;SMTP&lt;/strong&gt;&lt;/a&gt;(Simple Mail Transfer Protocol)&lt;br /&gt;
TCP 25 Port. RFC821에 명시된 인터넷 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전자우편&lt;/code&gt;(MIME 데이터 형식)을 위한 프로토콜로 메시지 전달을 위해 Store and Forward 방식을 사용&lt;br /&gt;
암호화 및 인증 기능 없이 사용자의 e-mail을 전송하는 프로토콜&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#snmp&quot;&gt;&lt;strong&gt;SNMP&lt;/strong&gt;&lt;/a&gt;(Simple Network Management Protocol)&lt;br /&gt;
네트워크에 대한 트래픽, 세션 등의 네트워크 상태를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모니터링&lt;/code&gt;하고 정보를 전달할 때 사용되는 프로토콜&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-way-handshaking&quot;&gt;3-Way Handshaking&lt;/h3&gt;
&lt;p&gt;1) 웹브라우저(클라이언트)가 웹 서버에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt; 메시지를 전송&lt;br /&gt;
2) 웹 서버는 웹브라우저에게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt;로 응답&lt;br /&gt;
3) 웹브라우저는 웹 서버에 최종 연결확립 메시지인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt;를 전송해 웹 서버와 연결 확립(ESTABLISHED 상태)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/tcpip/3-way-handshake.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;http&quot;&gt;HTTP&lt;/h3&gt;
&lt;p&gt;Header : Request 시 전달해야 하는 웹브라우저 정보, 요청방식, 파라미터&lt;br /&gt;
Body : Request 할 때는 사용하지 않고 POST 방식의 Request 시 Body에 파라미터 정보를 넣고 전송&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP &lt;span style=&quot;color:blue&quot;&gt;Request&lt;/span&gt; 시 Header 구조
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Request Method&lt;/strong&gt;&lt;br /&gt;
호출되는 메소드. GET/POST/OPTIONS/PUT/DELETE/TRACE/CONNECT&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Accept&lt;/strong&gt;&lt;br /&gt;
웹 브라우저에서 사용 가능한 미디어 타입. text/html..등&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Accept-Language&lt;/strong&gt;&lt;br /&gt;
웹 브라우저가 인식할 수 있는 언어를 의미&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;User-Agent&lt;/strong&gt;&lt;br /&gt;
웹 브라우저 정보 의미&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Accept-Encoding&lt;/strong&gt;&lt;br /&gt;
웹 브라우저에서 제공되는 인코딩 방식&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;br /&gt;
웹 서버의 기본 URL&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Connection&lt;/strong&gt;&lt;br /&gt;
연결 지속(Keep Alive) 및 연결 끊기(Close) 상태 표시&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP &lt;span style=&quot;color:blue&quot;&gt;Response&lt;/span&gt; 시 Header 구조
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Status Code&lt;/strong&gt;&lt;br /&gt;
HTTP 응답코드. 200 : 성공적으로 처리&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;br /&gt;
서버 프로그램 이름과 버전 전송&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;br /&gt;
자원의 만기일자&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Cache Control&lt;/strong&gt;&lt;br /&gt;
캐시 사용 여부. HTTP/1.1&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;br /&gt;
캐시 사용 여부. HTTP/1.0&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Content-Encoding&lt;/strong&gt;&lt;br /&gt;
응답되는 메시지의 인코딩 방식&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Content-Length&lt;/strong&gt;&lt;br /&gt;
바이트 단위로 응답되는 리소스의 크기&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;br /&gt;
연결 유지 시간을 의미&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Connection&lt;/strong&gt;&lt;br /&gt;
Keep-Alive 사용 여부&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Content-Type&lt;/strong&gt;&lt;br /&gt;
응답되는 미디어 타입&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP 요청 방식
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt; 방식&lt;br /&gt;
서버에 전달할 때 데이터를 URL에 포함시켜서 요청&lt;br /&gt;
전송할 수 있는 데이터 양이 제한(2Kbyte or 4Kbyte)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;POST&lt;/strong&gt; 방식&lt;br /&gt;
서버에 전달할 때 데이터를 Request Body에 포함시킴&lt;br /&gt;
데이터 전송량의 제한이 없음&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;쿠키(Cookie)&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;웹브라우저&lt;/code&gt;에서 저장할 수 있는 작은 공간으로 개발자가 프로그램에 필요한 정보를 임시적으로 저장 가능&lt;br /&gt;
쿠키 값은 변조가 가능하기에 보안 상 주의를 요함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;세션(Session)&lt;br /&gt;
클라이언트와 웹 서버 사이의 네트워크 연결이 지속적으로 유지되는 상태&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;smtp&quot;&gt;SMTP&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;구성요소
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;MTA&lt;/strong&gt;(Mail Transfer Agent)&lt;br /&gt;
메일을 전송하는 서버&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;MDA&lt;/strong&gt;(Mail Delivery Agent)&lt;br /&gt;
MTA에게 받은 메일을 사용자에게 전달(수신측에 고용된 우체부)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;MUA&lt;/strong&gt;(Mail User Agent)&lt;br /&gt;
사용자들이 사용하는 클라이언트 어플리케이션&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기본 동작 방식&lt;br /&gt;
1) 송신자가 보낸 전자우편은 전자우편을 관리하는 메일 서버에 전달&lt;br /&gt;
2) 메일 서버는 수신자의 전자우편 주소를 분석하고 최단 경로를 찾아 근접한 메일 서버에게 편지를 전달&lt;br /&gt;
3) 최종 수신자 측 메일 서버에 도착하기까지 연속적으로 전달하는 중계 작업을 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;POP3&lt;/strong&gt;&lt;br /&gt;
TCP 110 Port. 메일서버에 접속하여 저장된 메일을 내려 받는 MDA 프로그램&lt;br /&gt;
메시지를 읽은 후 메일 서버에서 해당 메일을 삭제&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IMAP &amp;amp; IMAP3&lt;/strong&gt;&lt;br /&gt;
TCP 143 Port. 위 POP과 역할은 유사하나 메일을 내려받아도 메일 서버에 원본을 계속 저장한다는 차이점이 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ftp&quot;&gt;FTP&lt;/h3&gt;
&lt;p&gt;해당 컴퓨터에 등록된 사용자만 파일전송이 가능하며, 그 외에는 익명으로 사용&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ftpuser&lt;/code&gt;에 등록된 사용자는 FTP 접근 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;불가&lt;/code&gt;&lt;br /&gt;
제어 접속과 데이터 접속 포트 분리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Active Mode&lt;br /&gt;
1) 클라이언트에서 서버 TCP 21번 포트로 접속 시도&lt;br /&gt;
2) 서버는 TCP 20번 포트로 데이터를 송수신&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Passive Mode&lt;br /&gt;
1) 클라이언트는 서버의 TCP/21번 포트로 접속 후 두 번째 포트를 질의&lt;br /&gt;
2) 서버는 클라이언트에게 데이터 연결을 위한 두 번째 포트(TCP 1024 ~ 65535)을 알림&lt;br /&gt;
3) 클라이언트는 서버가 알려 준 두 번째 포트로 접속&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;snmp&quot;&gt;SNMP&lt;/h3&gt;
&lt;p&gt;운영되는 네트워크의 안정성, 효율성을 높이기 위해 구성/장애/통계/상태 정볼르 실시간으로 수집 및 분석하는 네트워크 관리 시스템&lt;/p&gt;

&lt;p&gt;NMS(Network Management System)는 SNMP 프로토콜을 사용해서 네트워크 정보 수집&lt;br /&gt;
MIB(Management Information Base)는 SNMP에서 모니터링해야 하는 객체 정보를 소유&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SNMP 명령
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt;&lt;br /&gt;
장비의 상태 및 기동시간 등의 관리 정보 읽기&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;GET-NEXT&lt;/strong&gt;&lt;br /&gt;
정보가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;계층적&lt;/code&gt; 구조를 가지므로 관리자가 장비 조회를 해서 해당 트리보다 하위층 정보를 읽기&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;SET&lt;/strong&gt;&lt;br /&gt;
장비 MIB를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조작&lt;/code&gt;하여 장비 제어/관리자는 요청을 보내 초기화 혹은 장비 재구성&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;TRAP&lt;/strong&gt;&lt;br /&gt;
일반적으로 SNMP는 Polling 방식으로 주기적으로 정보 요청과 요청에 대한 정보 응답 방식으로 동작되는데,&lt;br /&gt;
이 때 만약 연결구간이 혼잡하게 될 경우 중요한 관리 정보가 손실되어 그 정보를 인지 못할 수도 있다는 문제점을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보완&lt;/code&gt;하기 위해 TRAP 기술 도입&lt;/p&gt;

        &lt;p&gt;Manager가 요청 않더라도 Agent에 의해 자의적으로 경고, 고장통지 등 미리 설정된 유형의 보고서를 생성/송신&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="네트워크" /><category term="데이터통신" /><summary type="html">TCP/IP Transmission Control Protocol/Internet Protocol</summary></entry><entry><title type="html">[네트워크] TCP/IP 전송 계층</title><link href="https://many258.github.io/study/tcp-ip-transmission/" rel="alternate" type="text/html" title="[네트워크] TCP/IP 전송 계층" /><published>2021-03-11T00:00:00+09:00</published><updated>2021-03-11T18:37:34+09:00</updated><id>https://many258.github.io/study/%7Btcp-ip-transmission%7D</id><content type="html" xml:base="https://many258.github.io/study/tcp-ip-transmission/">&lt;h1 id=&quot;transport-layer&quot;&gt;Transport Layer&lt;/h1&gt;
&lt;p&gt;수신측에 전달되는 데이터에 오류가 없고 데이터의 순서가 그대로 보존되도록 보장하는 &lt;strong&gt;연결 지향 서비스&lt;/strong&gt;의 역할을 하는 &lt;strong&gt;종단 간 서비스&lt;/strong&gt;(End-to-End) 계층&lt;/p&gt;

&lt;p&gt;신뢰성 있는 전송을 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP&lt;/code&gt;와 비신뢰성 전송을 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UDP&lt;/code&gt;가 존재&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Segment&lt;br /&gt;
애플리케이션 계층의 메시지에 TCP 혹은 UDP의 헤더를 붙인 것을 의미.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcptransmission-control-protocol&quot;&gt;TCP(Transmission Control Protocol)&lt;/h2&gt;
&lt;p&gt;클라이언트와 서버 간의 연결 지향, 신뢰성 있는 데이터 전송, 에러 제어, 흐름 제어, 완전이중 방식&lt;br /&gt;
신뢰성있는 데이터 전송을 위해 가상 연결 수행&lt;br /&gt;
송신자가 메시지를 전송하면 수신자는 ACK를 되돌려서 수신 여부를 확인&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;혼잡 제어&lt;/strong&gt;(Congestion Control)&lt;br /&gt;
수신자 동일한 ACK 번호를 반복적으로 전송 =&amp;gt; 데이터를 받지 못함 ==&amp;gt; GO-BACK-N 방법으로 재전송&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;흐름 제어&lt;/strong&gt;(Flow Control)&lt;br /&gt;
수신자가 메시지를 제대로 받지 못하면 송신자는 전송 속도를 늦추어 네트워크 효율성 제어&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;순서 제어&lt;/strong&gt; : Sequence 번호를 가지고 메시지의 순서 파악&lt;/li&gt;
  &lt;li&gt;Checksum : TCP, UDP 모두 존재. 송신 중 메시지의 변조 파악하기 위해 에러 체크&lt;/li&gt;
  &lt;li&gt;Receive Windows&lt;br /&gt;
수신자의 윈도우 크기이자 메모리 버퍼. 
수신자의 버퍼가 비어 있으면 송신자는 해당 버퍼의 크기만큼 데이터를 한꺼번에 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tcp의-상태-전이&quot;&gt;TCP의 상태 전이&lt;/h3&gt;
&lt;p&gt;netstat 명령어로 확인 가능&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt; 클라이언트는 서버에 연결요청 메시지인 SYN 신호를 보내고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN_SEND&lt;/code&gt; 상태 전환&lt;br /&gt;
&lt;strong&gt;2)&lt;/strong&gt; 서버는 기동되면 클라이언트의 연결을 받기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LISTEN&lt;/code&gt; 상태로 클라이언트의 연결 대기&lt;br /&gt;
&lt;strong&gt;3)&lt;/strong&gt; 서버는 클라이언트로부터 SYN 메시지가 수신되면 서버는 클라이언트에게 SYN, ACK를 전송하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN_RECEIVED&lt;/code&gt; 상태 전환&lt;br /&gt;
&lt;strong&gt;4)&lt;/strong&gt; 클라이언트는 ACK를 서버에 전송하고 클라이언트와 서버는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESTABLISHED&lt;/code&gt;(연결 확립) 상태&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/tcpip/tcp-state-machine.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tcp-프로토콜의-header-구조&quot;&gt;TCP 프로토콜의 Header 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;근원지 포트&lt;/strong&gt;(Source Port)&lt;br /&gt;
가상 선로의 송신측 포트(End point of Sender)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;목적지 포트&lt;/strong&gt;(Destination Port)&lt;br /&gt;
가상 선로의 수신측 포트(End point of receiver)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;일련번호&lt;/strong&gt;(Sequence Number)&lt;br /&gt;
송신자가 전송하는 데이터의 일련번호&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;전송확인&lt;/strong&gt;(Piggyback Acknowledgement)&lt;br /&gt;
수신자와 응답하는 받은 데이터의 수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TCP 헤더 길이&lt;/strong&gt;(Header Length)&lt;br /&gt;
TCP 헤더에 몇 개의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;32Bit&lt;/code&gt; 워드가 포함되어 있는가를 나타내는 필드&lt;br /&gt;
옵션 필드가 가변 길이를 갖기 때문에 필요, 이 값을 이용하여 실제 데이터의 시작점을 계산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;URG&lt;/strong&gt;(Urgent)&lt;br /&gt;
긴급 지점이 사용될 때 1로 설정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ACK&lt;/strong&gt;(Acknowledgement)&lt;br /&gt;
전송 확인을 필요로 할 때 설정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EOM&lt;/strong&gt;(End of Message)&lt;br /&gt;
마지막 메시지임을 가리킴&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;재설정&lt;/strong&gt;(RST)&lt;br /&gt;
연결의 재설정. 비정상적인 종료&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;동기화&lt;/strong&gt;(SYN, Synchronization)&lt;br /&gt;
연결 설정 요구&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FIN&lt;/strong&gt;(Finish)&lt;br /&gt;
연결 해제에 사용되며, 송신측에서 더 이상 전송할 데이터가 없음을 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;윈도우 크기&lt;/strong&gt;(Window size)&lt;br /&gt;
수신측에서 수신할 수 있는 최대 Byte 수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;체크썸&lt;/strong&gt;(Checksum)&lt;br /&gt;
전송 데이터에 대한 완벽한 신뢰성을 위한 것으로, 모든 데이터의 합에 대한 ‘1’의 보수로 계산
무결성을 확인하기 위해 CRC(Cyclic Redundancy Check)코드 사용
CRC : 데이터 통신에서 전송 중에 전송 오류가 발생하였는지 확인하기 위해 덧붙인 코드&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;급송 지점&lt;/strong&gt;(Urgent point)&lt;br /&gt;
다음에 이어지는 데이터가 급송되어야 함을 의미. 인터럽트 메시지 대신 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;옵션&lt;/strong&gt;&lt;br /&gt;
전송 셋업 과정의 버퍼 크기에 대한 통신 등 기타 목적에 활용&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;에러-제어&quot;&gt;에러 제어&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FEC&lt;/strong&gt;(Forward Error Correction)&lt;br /&gt;
송신측이 특정한 정보 비트를 함께 전송하여 수신측에서 이 정보 비트로 에러 발생 시 수정하는 방식(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수신측&lt;/code&gt;이 에러 처리)&lt;/p&gt;

    &lt;p&gt;데이터 전송과정에서 발생한 오류를 검출하여 오류를 재전송 요구 없이 수정&lt;br /&gt;
재전송 요구가 없어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;역 채널&lt;/code&gt;이 필요 없고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연속&lt;/code&gt;적인 데이터 전송 가능&lt;br /&gt;
오류 검출 및 수정을 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;잉여비트&lt;/code&gt;들이 추가 전송되므로 전송 효율 감소&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;해밍 코드&lt;/li&gt;
      &lt;li&gt;상승 코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BEC&lt;/strong&gt;(Backward Error Correction)&lt;br /&gt;
수신측이 에러 검출 후 송신측에게 에러가 발생한 데이터 블록을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;재전송&lt;/code&gt; 요청(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;송신측&lt;/code&gt;이 에러 처리, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARQ&lt;/code&gt;:Auto Repeat reQuest)&lt;/p&gt;

    &lt;p&gt;패리티 검사, CRC 등 CheckSum을 이용하여 오류 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;검출&lt;/code&gt; 후, 오류 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어&lt;/code&gt;는 ARQ가 처리&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Stop-And-Wait&lt;/strong&gt;&lt;br /&gt;
하나의 데이터를 송신하고 수신 확인 신호를 받을 때까지 기다린 다음 전송&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Go-Back-N&lt;/strong&gt;&lt;br /&gt;
수신자가 데이터를 수신 받지 못할 경우 마지막으로 수신 받은 데이터 이후의 모든 데이터 재전송
TCP에서 사용하는 방식&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Selective Repeat ARQ&lt;/strong&gt;&lt;br /&gt;
수신받은 데이터 중에서 중간에 빠져있는 것만 재전송&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Adaptive ARQ&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;흐름-제어&quot;&gt;흐름 제어&lt;/h3&gt;
&lt;p&gt;송수신측 사이의 전송 패킷의 양, 속도를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조절&lt;/code&gt;하여 네트워크를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;효율&lt;/code&gt;적으로 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;슬라이딩 윈도우&lt;/strong&gt;(Sliding Window)&lt;br /&gt;
호스트 간에 송수신 혹은 수신할 수 있는 Size 정보를 제공&lt;br /&gt;
&lt;strong&gt;Stop-And-Wait&lt;/strong&gt;의 단점을 보완한 방식으로 수신측의 확인 신호를 받지 않더라도 미리 정해진 프레임의 수만큼 연속적으로 전송&lt;br /&gt;
수신자의 버퍼 크기를 확인함으로서 최대한 전송 효율 극대화&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;혼잡-제어&quot;&gt;혼잡 제어&lt;/h3&gt;
&lt;p&gt;라우터가 패킷을 처리할 수 있는 속도보다 많은 패킷을 수신하는 경우 라우터는 패킷을 손실하게 된다.
송신측에서는 패킷을 재전송하게 되는데, 이러한 과정의 연속으로 데이터의 손실이나 지연이 발생
혼잡 제어는 송신 단말의 전송률을 직접 제어하여 혼잡으로 인해 손실된 데이터를 재전송하기 위함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TCP Slow Start&lt;/strong&gt;&lt;br /&gt;
TCP가 시작될 때 전송속도를 초기값부터 지속적으로 올리는 방법&lt;/p&gt;

    &lt;p&gt;송신측에서 패킷을 전송하는 비율과 수신측에서 수신된 ACK를 통해 Congestion Window(cwnd)를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지수&lt;/code&gt;의 크기로 증가.&lt;br /&gt;
cwnd는 계속적으로 증가하다가 임계값에 이르게 되면 Congestion Avoidance로 동작&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Congestion Avoidance&lt;/strong&gt;&lt;br /&gt;
Duplication ACK 값이 오거나 일정 시간 동안 ACK가 수신되지 않으면 전송속도를 낮춤&lt;br /&gt;
매번 ACK가 수신될 때마다 cwnd를 1/cwnd만큼 증가(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선형적&lt;/code&gt;인 증가)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fast Retransmit&lt;/strong&gt;&lt;br /&gt;
Retransmit Threshold 이상 연속된 Duplicate ACK를 수신하는 경우 TCP는 해당 Segment를 재전송&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fast Recovery&lt;/strong&gt;&lt;br /&gt;
Fast Retransmit한 이후 새로 Slow Start를 통해서 설정된 연결의 안전상태에 도달할 필요없이 Congestion Avoidance 상태에서 전송할 수 있도록 하는 것&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;udpuser-datagram-protocol&quot;&gt;UDP(User Datagram Protocol)&lt;/h2&gt;
&lt;p&gt;비연결성, 비신뢰성(블록 재전송 및 흐름 제어 등이 없음)을 특성으로 패킷을 고속 전달할 수 있는 프로토콜&lt;br /&gt;
비접속형 : 전달되는 패킷에 대한 상태 정보를 유지하지 않음&lt;br /&gt;
간단한 헤더구조(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8Byte&lt;/code&gt;), 블록 단위로 데이터 전송&lt;/p&gt;

&lt;h3 id=&quot;udp-프로토콜의-header-구조&quot;&gt;UDP 프로토콜의 Header 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;근원지 포트&lt;/strong&gt;(Source Port)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;목적지 포트&lt;/strong&gt;(Destination Port)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;수신자의 포트번호 길이&lt;/strong&gt;(Length)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;체크썸&lt;/strong&gt;(Checksum)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;voipvoice-over-ip&quot;&gt;VoIP(Voice Over IP)&lt;/h3&gt;
&lt;p&gt;UDP 프로토콜은 빠르게 데이터를 전송해야 하는 서비스에서 사용하는데 대표적인 활용이 VoIP&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RTP(Real Time Protocol) : 음성 전송&lt;/li&gt;
  &lt;li&gt;RTCP(Real Time Control Protocol) : 에러 처리&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="네트워크" /><category term="데이터통신" /><summary type="html">Transport Layer 수신측에 전달되는 데이터에 오류가 없고 데이터의 순서가 그대로 보존되도록 보장하는 연결 지향 서비스의 역할을 하는 종단 간 서비스(End-to-End) 계층</summary></entry><entry><title type="html">[네트워크] TCP/IP 인터넷, 네트워크 접근 계층</title><link href="https://many258.github.io/study/tcp-ip-internet-network-access/" rel="alternate" type="text/html" title="[네트워크] TCP/IP 인터넷, 네트워크 접근 계층" /><published>2021-03-11T00:00:00+09:00</published><updated>2021-03-11T23:37:34+09:00</updated><id>https://many258.github.io/study/%7Btcp-ip-internet-network-access%7D</id><content type="html" xml:base="https://many258.github.io/study/tcp-ip-internet-network-access/">&lt;h1 id=&quot;인터넷-계층internet-layer&quot;&gt;인터넷 계층(Internet Layer)&lt;/h1&gt;
&lt;p&gt;송신자의 IP주소와 수신자의 IP주소를 읽어서 경로를 결정하거나 전송하는 역할을 수행&lt;br /&gt;
다중 네트워크 링크를 통해 패킷의 발신지-대-목적지 전달에 대한 책임을 가진다.(데이터 링크 층은 노드간 전달 책임, Point-to-Point)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IP, ICMP&lt;/strong&gt;의 TCP/IP 프로토콜 군이 존재하고 멀티캐스팅을 위한 &lt;strong&gt;IGMP&lt;/strong&gt;, 라우팅을 위한 &lt;strong&gt;BGP, OSPF, RIP&lt;/strong&gt; 존재&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;경로설정&lt;/strong&gt;(Routing)&lt;br /&gt;
수신자의 IP주소를 읽어서 어떻게 목적기까지 가는 것이 최적의 경로인지를 판단하는 것. 라우터(Router)의 역할&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Point-To-Point&lt;/strong&gt; 패킷 전달&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;논리 주소&lt;/strong&gt; 지정 : IP주소로 변환하여 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주소 변환&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터그램&lt;/strong&gt; : 기존 패킷에 IP Header를 붙이는 것을 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;라우팅&quot;&gt;라우팅&lt;/h2&gt;
&lt;p&gt;목적지 IP주소를 읽어서 경로를 결정하는 작업.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정적&lt;/code&gt;&lt;/strong&gt; 경로 방법(Static Routing)&lt;br /&gt;
특정 목적지 네트워크로 가는 경로를 관리자가 직접 라우팅 테이블의 경로를 설정하는 방법&lt;br /&gt;
실시간으로 이루어지지 않기에 초기에 관리자가 다양한 라우팅 정보를 분석하여 최적의 경로 설정이 가능&lt;br /&gt;
라우터의 직접적인 처리 부하를 감소시킬 수 있어서 비교적 환경변화가 적은 형태의 네트워크에 적합
    &lt;ul&gt;
      &lt;li&gt;Floating static routing&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동적&lt;/code&gt;&lt;/strong&gt; 경로 방법(Dynamic Routing)&lt;br /&gt;
네트워크 상태를 파악해서 최적의 경로를 결정하는 방법&lt;br /&gt;
실시간으로 이루어지므로 네트워크 환경변화에 능동적인 대처가 가능&lt;br /&gt;
라우팅 알고리즘을 통해 자동으로 경로 설정이 이루어지며,&lt;br /&gt;
수시로 환경이 변화되는 형태의 네트워크에 적합
    &lt;ul&gt;
      &lt;li&gt;Distance Vector routing&lt;/li&gt;
      &lt;li&gt;Linked state routing&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;라우팅-프로토콜&quot;&gt;라우팅 프로토콜&lt;/h3&gt;
&lt;p&gt;인터네트워크를 통해서 데이터를 근원지에서 목적지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전달&lt;/code&gt;하는 기능 수행&lt;br /&gt;
경로 결정에서 최단경로 선정 및 전송 수행, 목적지에 대한 경로 정보를 인접한 라우터들과 교환하기 위한 규약&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IGP&lt;/strong&gt;(Internal Gateway Routing Protocol)&lt;br /&gt;
동일 그룹(기업 또는 ISP) 내에서 라우팅 정보를 교환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EGP&lt;/strong&gt;(Exterior Gateway Routing Protocol)&lt;br /&gt;
다른 그룹과의 라우팅 정보를 교환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Distance Vector routing&lt;/strong&gt;&lt;br /&gt;
최단 경로를 구하는 벨만 포드 알고리즘 기반&lt;br /&gt;
통과해야 하는 라우터의 수가 적은 쪽으로 경로를 결정. 일명 &lt;strong&gt;Hop Count&lt;/strong&gt; 또는 &lt;strong&gt;TTL&lt;/strong&gt;(Time to Live)&lt;br /&gt;
네트워크 변화 발생 시 해당 정보를 인접한 라우터에 정기적으로 전달하고,&lt;br /&gt;
인접 라우터에서는 라우팅 테이블 정보 갱신
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;라우팅 정보&lt;/strong&gt; : 모든 라우터까지의 거리 정보 보관&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;정보 전송 시점&lt;/strong&gt; : 일정주기(30초, 이웃 라우터와 공유)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;대표 프로토콜&lt;/strong&gt; : RIP, IGRP, EIGRP(내부 라우팅), BGP&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;br /&gt;
변화되는 라우팅 정보를 모든 라우터에 주기적으로 갱신(브로드캐스팅)하므로 망 자체 트래픽 유발&lt;br /&gt;
라우팅 정보를 변경하는 문제 발생 시 Routing Loop가 발생할 가능성 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Linked state routing&lt;/strong&gt;&lt;br /&gt;
최소 신상 트리를 구하는 다익스트라 알고리즘 기반&lt;br /&gt;
네트워크 대역폭, 지연정보 등을 종합적으로 고려해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cost&lt;/code&gt;를 산정하고 해당 Link의 Cost에 따라 경로를 결정하는 방법&lt;br /&gt;
네트워크 변화 감지 시 링크 상태 변경 정보를 인접한 라우터에게 즉각 전달하고 이를 저장
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;라우팅 정보&lt;/strong&gt; : 인정 라우터까지의 Link Cost 계산&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;정보 전송 시점&lt;/strong&gt; : 변화 발생 시에만&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;대표 프로토콜&lt;/strong&gt; : OSPF, IS-IS(소규모 네트워크)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;br /&gt;
네트워크 전체 정보 유지를 위한 많은 메모리 소요&lt;br /&gt;
라우터의 CPU 사용량이 많아짐&lt;br /&gt;
라우터간 회선의 대역차이로 동기화 실패할 가능성 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RIP&lt;/strong&gt;(Routing Information Protocol)&lt;br /&gt;
RFC 1058. 대표적인 거리 벡터 라우팅 프로토콜&lt;/p&gt;

    &lt;p&gt;라우터 간 거리 계산을 위한 척도로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;홉수&lt;/code&gt;(Hop Count) 사용&lt;br /&gt;
16Hop 이상이면 패킷을 폐기&lt;br /&gt;
180초 이내에 새로운 라우팅 정보가 수신되지 않으면 해당 경로를 이상 상태로 간주&lt;br /&gt;
수신된 목적지의 거리 값과 현재 거리 값을 비교하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;작은&lt;/code&gt; 것을 기준으로 라우팅 테이블을 변경&lt;/p&gt;

    &lt;p&gt;라우팅 정보 변경 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모든&lt;/code&gt; 망에 적용하므로 큰 규모의 망에는 부적합&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OSPF&lt;/strong&gt;(Open Shortest Path First)&lt;br /&gt;
RFC 1247. IP 라우팅 프로토콜&lt;/p&gt;

    &lt;p&gt;링크에서의 전송 시간을 링크 비용으로 사용하여 각 목적지별 최단 경로를 계산&lt;br /&gt;
네트워크에 변화가 발생했을 때 상대적으로 짧고 간단한 링크 상태 정보 교환&lt;/p&gt;

    &lt;p&gt;Link의 delay, throughput, reliability를 이용하여 기본적인 throughput만 이용하고, Hop수에 대한 제약이 없음&lt;br /&gt;
네트워크를 Area로 구분하여 많은 라우팅 정보의 교환으로 인한 라우터의 성능저하를 예방(대역폭을 절약)&lt;br /&gt;
Link 변화 감지 시 해당 Link에 대한 정보만을 즉시 모든 라우터에 전달하며 Convergence가 매우 빠름&lt;br /&gt;
Supernetting된 형태로 Routing Information을 전달할 수 있어 라우터 메모리 절약, 성능 향상 및 대역폭 절약&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ABR(Area Border Router)&lt;br /&gt;
Area에 백본망을 연결해주는 라우터&lt;/li&gt;
      &lt;li&gt;ASBR(Autonomous System Boundary Router)&lt;br /&gt;
다른 AS(Autonomous System)에 속한 라우터와 경로 정보를 교환&lt;/li&gt;
      &lt;li&gt;IR(Internal Router)&lt;br /&gt;
Area에 접속한 라우터&lt;/li&gt;
      &lt;li&gt;BR(Backbone Router)&lt;br /&gt;
백본망에 접속한 모든 라우터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BGP&lt;/strong&gt;(Border Gateway Protocol)&lt;br /&gt;
AS 상호 간의 routing에 적용되는 라우팅 프로토콜.&lt;br /&gt;
ISP(Internet Service Provider) 사업자들 상호 간에 주로 사용&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;EGP&lt;/strong&gt;라고 하는 Inter-Domain routing Protocol&lt;br /&gt;
인터넷을 AS 상호 간 연결 Path로 이루어진 방향성 그래프의 집단으로 인식&lt;br /&gt;
경로 벡터 라우팅 방법(&lt;strong&gt;path vector routing&lt;/strong&gt;)을 적용하며 경로 벡터 라우팅 테이블을 유지&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Looping Free Routing&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP&lt;/code&gt; 기반 라우팅&lt;br /&gt;
BGP 라우팅 정보는 라우터 간에 179번 포트를 통하여 TCP에 의해 신뢰성 있게 전달&lt;/li&gt;
      &lt;li&gt;라우팅 정보의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;점진적&lt;/code&gt; 갱신&lt;br /&gt;
BGP는 주기적으로 라우팅 정보를 갱신하지 않고, 변화가 있을 때 이웃 라우터에게 갱신 정보를 전달&lt;/li&gt;
      &lt;li&gt;다양한 라우팅 metric 사용&lt;br /&gt;
최상위 경로 선택을 위해 우선순위가 있는 각 metric을 참조&lt;/li&gt;
      &lt;li&gt;Class 없는 주소체계 지원&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CIDR&lt;/code&gt;(Classless Inter-Domain Routing) 지원&lt;/li&gt;
      &lt;li&gt;IBGP(Internal BGP) : 동일한 AS에 속한 BGP 라우터 간의 동작&lt;/li&gt;
      &lt;li&gt;EBGP(External BGP) : 서로 다른 AS에서 동작하는 BGP 프로토콜&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ipinternet-protocol&quot;&gt;IP(Internet Protocol)&lt;/h2&gt;
&lt;p&gt;IP 주소 형태로 송신자와 수신자의 IP를 가지고 있고 IP주소를 읽어서 최적의 경로를 결정할 수 있게 함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주소화&lt;/code&gt;, 데이터그램 포맷, 패킷 핸들링 등을 정의해놓은 인터넷 규약&lt;/li&gt;
  &lt;li&gt;IPv4 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;32bit&lt;/code&gt; 주소체계를 사용. (네트워크 ID + 호스트 ID)&lt;/li&gt;
  &lt;li&gt;IPv6 : IP주소의 부족 문제를 해결하기 위해 주소 비트수를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;128bit&lt;/code&gt;로 확장.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip-header-구조&quot;&gt;IP Header 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Version&lt;/strong&gt; : IPv4 버전&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Header Length&lt;/strong&gt; : Header의 전체 길이&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Type of Service&lt;/strong&gt; : 서비스 유형&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Total Length&lt;/strong&gt; : IP Datagram의 byte 수&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Identification&lt;/strong&gt; : Host에서 보낸 DataGram 식별&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Flags &amp;amp; Offset&lt;/strong&gt;&lt;br /&gt;
IP Datagram 단편화 정보&lt;br /&gt;
네트워크에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTU&lt;/code&gt;(Maximum Transmission Unit)라는 것이 존재하는데, 한 번에 통과할 수 있는 패킷의 최대 크기를 의미한다.&lt;/p&gt;

    &lt;p&gt;즉, MTU 값보다 크면 패킷은 분할(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단편화&lt;/code&gt; : Fragmentation)되고 그 정보를 Flags &amp;amp; Offset이 가지고 있게 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Time to Live&lt;/strong&gt;&lt;br /&gt;
Datagram이 통과할 수 있는 라우터 수(Linux 기본 = 64, Window 기본 = 128)&lt;br /&gt;
IP 패킷이 통과할 수 있는 라우터의 수를 의미. 라우터를 하나 통과 시 1씩 감소하며 0이 될 경우 자동 폐기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Protocol&lt;/strong&gt; : IP헤더 위의 상위 프로토콜 종류. ICMP, TCP, UDP&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Header Checksum&lt;/strong&gt; : IP Header 무결성 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip-주소의-구조&quot;&gt;IP 주소의 구조&lt;/h3&gt;
&lt;p&gt;클래스로 분류되며 클래스는 IP 주소를 분류하는 기준으로 사용.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Class&lt;/td&gt;
      &lt;td&gt;Content&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Class A&lt;/td&gt;
      &lt;td&gt;첫 바이트 7bit가 네트워크 식별자 한 네트워크에 가장 많은 호스트 수용 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Class B&lt;/td&gt;
      &lt;td&gt;14bit의 네트워크 식별자 한 네트워크에 약 2&lt;sup&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;16&lt;/code&gt;&lt;/sup&gt;대의 호스트 수용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Class C&lt;/td&gt;
      &lt;td&gt;세 번째 바이트까지 네트워크 식별자 한 네트워크에 254대까지 수용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Class D&lt;/td&gt;
      &lt;td&gt;멀티캐스트 주소로 사용&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/tcpip/ip-class.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;서브넷팅subnetting&quot;&gt;서브넷팅(Subnetting)&lt;/h3&gt;
&lt;p&gt;주어진 네트워크 주소를 작게 나누어 여러 개의 서브넷으로 구성&lt;br /&gt;
네트워크 식별자 부분을 구분하기 위한 Mask를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서브넷 마스크&lt;/code&gt;라고 함&lt;/p&gt;

&lt;h3 id=&quot;수퍼넷팅supernetting&quot;&gt;수퍼넷팅(Supernetting)&lt;/h3&gt;
&lt;p&gt;ISP(Internet Service Provider) 사업자가 많은 네트워크 망을 효율적을 관리하기 위해서 네트워크를 묶어 관리하는 방법&lt;/p&gt;

&lt;h3 id=&quot;cidrclassless-inter-domain-routing&quot;&gt;CIDR(Classless Inter-Domain Routing)&lt;/h3&gt;
&lt;p&gt;RFC 4632. IPv4의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IP 주소 고갈&lt;/code&gt; 및 라우팅 테이블 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대형화&lt;/code&gt;에 대한 해소책&lt;br /&gt;
기존의 클래스 A, B, C 네트워크 주소의 개념을 무시하고 IP주소와 서브넷 마스크를 이진 표기법으로 표현하여 기존의 고정크기 네트워크를 다양하고 세부적으로 분할한 것&lt;/p&gt;

&lt;h3 id=&quot;vlsmvariable-length-subnet-mask--가변길이-서브넷-마스크&quot;&gt;VLSM(Variable Length Subnet Mask : 가변길이 서브넷 마스크)&lt;/h3&gt;
&lt;p&gt;서브넷팅을 실시한 이후에도 IP 주소가 낭비되는 것을 방지하기 위해서 서브넷 마스크의 길이를 더 확장하여 늘리는 기능&lt;/p&gt;

&lt;h2 id=&quot;icmpinternet-control-message-protocol&quot;&gt;ICMP(Internet Control Message Protocol)&lt;/h2&gt;
&lt;p&gt;TCP/IP &lt;strong&gt;오류 제어&lt;/strong&gt; 프로토콜&lt;br /&gt;
호스트 및 라우터는 다른 호스트나 라우터가 현재 도달 가능한지의 여부를 결정&lt;br /&gt;
라우터는 특정 목적지 네트워크로 후속 IP 데이터그램을 보냈는데, 사용할 수 있는 최적의 경로가 있을 때 근원지 호스트에게 통지&lt;br /&gt;
호스트나 라우터는 그들이 처리하기에 너무 빠른 IP 데이터그램이 도착하면 다른 시스템에게 통보&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;오류 보고 메시지&lt;/strong&gt; : IP 패킷 처리 도중 발견된 문제를 보고&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;질의 메시지&lt;/strong&gt; : 다른 호스트로부터 특정 정보를 획득하기 위해 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;icmp-메시지-구조&quot;&gt;ICMP 메시지 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Type : ICMP 메시지 유형 표시&lt;/li&gt;
  &lt;li&gt;Code : Type과 같이 사용되며 세부적인 유형을 표현&lt;/li&gt;
  &lt;li&gt;Checksum : IP Datagram Checksum&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;icmp-메시지&quot;&gt;ICMP 메시지&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Type&lt;/td&gt;
      &lt;td&gt;Message&lt;/td&gt;
      &lt;td&gt;Content&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Destination Unreachable&lt;/td&gt;
      &lt;td&gt;라우터가 목적지를 찾지 못할 경우 보내는 메시지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Source Quench&lt;/td&gt;
      &lt;td&gt;패킷을 너무 빨리 보내 네트워크에 무리를 주는 호스트를 제지할 때 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Redirection&lt;/td&gt;
      &lt;td&gt;패킷 라우팅 경로를 수정, SMURF 공격에서 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8 or 0&lt;/td&gt;
      &lt;td&gt;Echo Request or Reply&lt;/td&gt;
      &lt;td&gt;Host의 존재를 확인&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;Time Exceeded&lt;/td&gt;
      &lt;td&gt;패킷을 보냈으나 시간이 경과하여 패킷이 삭제되었을 때 보내는 메시지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;Parameter Problem&lt;/td&gt;
      &lt;td&gt;IP 헤더 필드에 잘못된 정보가 있다는 것을 알림&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;13 or 14&lt;/td&gt;
      &lt;td&gt;Timestamp Request and Reply&lt;/td&gt;
      &lt;td&gt;Echo와 비슷하나 시간에 대한 정보 추가&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;데이터-전송-방식&quot;&gt;데이터 전송 방식&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Unicast&lt;br /&gt;
1:1 전송 방식.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Broadcast&lt;br /&gt;
1:N 전송 방식. 동일한 서브넷 상의 모든 수신자에게 전송&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Multicast&lt;br /&gt;
M:N 전송 방식. 하나 이상의 송신자들이 특정 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그룹&lt;/code&gt;의 수신자에게 전송&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IGMP&lt;/code&gt; : 그룹에 등록된 사용자를 관리하는 프로토콜
    &lt;ul&gt;
      &lt;li&gt;IGMP 메시지 구조 (8byte)
        &lt;ul&gt;
          &lt;li&gt;Version : IGMP 프로토콜의 버전&lt;/li&gt;
          &lt;li&gt;Type : 메시지 유형. (1 = 보고, 2 = 질의메시지)&lt;/li&gt;
          &lt;li&gt;Group ID&lt;br /&gt;
보고 메시지의 경우 호스트에서 신규 가입하고자 하는 멀티캐스트 서비스의 group id,&lt;br /&gt;
계속 받아보기를 원하는 멀티캐스트 서비스의 group id 질의 메시지인 경우는 ‘0’&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Anycast&lt;br /&gt;
그룹에 등록된 노드 중에서 최단경로 노드 한 개에만 전송.&lt;br /&gt;
IPv6에서 사용 (Broadcast 대신)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;arpaddress-resolution-protocol&quot;&gt;ARP(Address Resolution Protocol)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;IP주소&lt;/strong&gt;를 물리적 하드웨어 주소인 &lt;strong&gt;MAC 주소&lt;/strong&gt;로 변경하는 프로토콜&lt;br /&gt;
IP 주소와 이에 해당하는 물리적 네트워크 주소 정보는 각 IP 호스트의 &lt;strong&gt;ARP 캐시&lt;/strong&gt;라 불리는 메모리에 테이블 형태로 저장된 후 다음 패킷 전송 시에 다시 사용&lt;br /&gt;
ARP Cache Table : MAC 주소와 IP 주소를 보유하고 있는 매핑 테이블&lt;/p&gt;

&lt;h2 id=&quot;rarpreverse-address-resolution-protocol&quot;&gt;RARP(Reverse Address Resolution Protocol)&lt;/h2&gt;
&lt;p&gt;물리적인 &lt;strong&gt;주소 MAC&lt;/strong&gt;을 기반으로 논리적인 주소 &lt;strong&gt;IP&lt;/strong&gt;를 알아오는 프로토콜&lt;br /&gt;
운영체제도 없는 일종의 더미 터미널 Diskless Host에서 사용하는 것으로 자신의 물리적 주소인 MAC주소를 서버에 전송하고 IP주소를 수신 받아서 기동&lt;/p&gt;

&lt;h1 id=&quot;네트워크-접근-계층&quot;&gt;네트워크 접근 계층&lt;/h1&gt;
&lt;p&gt;논리적 주소인 IP 주소를 물리적 MAC 주소로 변환&lt;br /&gt;
Physical Layer가 이해할 수 있는 헤더를 붙여주는 Layer, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Frame&lt;/code&gt; 단위, MAC Address를 사용하는 계층&lt;/p&gt;

&lt;p&gt;Point-to-Point 간 신뢰성 있는 전송으로 &lt;strong&gt;흐름 제어&lt;/strong&gt; 기능을 담당&lt;br /&gt;
&lt;strong&gt;에러 제어&lt;/strong&gt; : Error Detection, Error Correction&lt;br /&gt;
&lt;strong&gt;MAC&lt;/strong&gt;(Media Access Control) : LAN 카드의 물리적 주소&lt;/p&gt;

&lt;h2 id=&quot;csmacd&quot;&gt;CSMA/CD&lt;/h2&gt;
&lt;p&gt;Carrier Sense Multiple Access/Collision Detection&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유선&lt;/code&gt; LAN에서 메시지를 송수신하기 위한 접근 방법. IEEE 802.3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt; 각 호스트들이 전송매체에 경쟁적으로 데이터를 전송&lt;br /&gt;
&lt;strong&gt;2)&lt;/strong&gt; 프레임을 전송하면서 충돌여부를 검사&lt;br /&gt;
&lt;strong&gt;3)&lt;/strong&gt; 전송 중 충돌이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;감지&lt;/code&gt;되면 패킷의 전송을 즉시 중단&lt;br /&gt;
&lt;strong&gt;4)&lt;/strong&gt; 충돌이 발생한 사실을 모든 스텐이션들이 알 수 있도록 간단한 통보신호 송신&lt;br /&gt;
&lt;strong&gt;5)&lt;/strong&gt; 통보신호에 따라 전송을 조절&lt;/p&gt;

&lt;p&gt;Collision이 일어난 경우 &lt;strong&gt;Back off&lt;/strong&gt; 알고리즘을 이용하여 재전송&lt;br /&gt;
&lt;strong&gt;리피터&lt;/strong&gt;와 &lt;strong&gt;허브&lt;/strong&gt;를 이용하면 Collision이 발생하나 &lt;strong&gt;Switch&lt;/strong&gt;는 Collision을 막을 수 있다&lt;br /&gt;
&lt;strong&gt;Switch&lt;/strong&gt;는 브로드캐스트를 막을 수 없고 &lt;strong&gt;Router&lt;/strong&gt;가 브로드캐스트를 막을 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Non-Persistent&lt;br /&gt;
매채가 사용 중이 아니면 즉시 전송&lt;br /&gt;
매체가 사용 중이면, 확률분포에서 구한 재전송 지연시간만큼 대기
    &lt;ul&gt;
      &lt;li&gt;임의 지연 사용은 충돌 확률을 감소&lt;/li&gt;
      &lt;li&gt;매체가 비었을 때 임의 지연 때문에 데이터 전송이 없는 채널 휴지 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;1-Persistent&lt;br /&gt;
매체가 사용 중이 아니면 즉시 전송&lt;br /&gt;
매체가 사용 중이면 대기 후 채널이 비는 순간 즉시 전송
    &lt;ul&gt;
      &lt;li&gt;채널 휴지 시간을 제거하기 위해 사용&lt;/li&gt;
      &lt;li&gt;임의 지연이 없게 하여 채널 휴지는 거의 없지만 충돌 확률이 높음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;p-Persistent&lt;br /&gt;
매체가 사용 중이 아니라면, 확률 p로 전송하고 (1-p)의 확률료 하나의 시간단위를 지연&lt;br /&gt;
매체가 사용 중이면 기다렸다가 채널이 비는 순간 확률 p로 전송하고 확률 (1-p)로 대기
    &lt;ul&gt;
      &lt;li&gt;위 장단점을 상호보완하기 위해 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;csmaca&quot;&gt;CSMA/CA&lt;/h2&gt;
&lt;p&gt;Carrier Sense Multiple Access/Collision Avoidance&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무선&lt;/code&gt; LAN에서 메시지의 송수신하기 위한 접근 방법&lt;/p&gt;

&lt;p&gt;프레임 전송 이전에 제어 메시지를 이용하여 수신자로부터 간단한 전송 유발&lt;br /&gt;
제어 신호에 대한 응답이 도착하면 프레임 전송&lt;/p&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="네트워크" /><category term="데이터통신" /><summary type="html">인터넷 계층(Internet Layer) 송신자의 IP주소와 수신자의 IP주소를 읽어서 경로를 결정하거나 전송하는 역할을 수행 다중 네트워크 링크를 통해 패킷의 발신지-대-목적지 전달에 대한 책임을 가진다.(데이터 링크 층은 노드간 전달 책임, Point-to-Point)</summary></entry><entry><title type="html">[웹프로그래밍] Ajax</title><link href="https://many258.github.io/study/web-ajax/" rel="alternate" type="text/html" title="[웹프로그래밍] Ajax" /><published>2021-03-10T00:00:00+09:00</published><updated>2021-03-10T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bweb-ajax%7D</id><content type="html" xml:base="https://many258.github.io/study/web-ajax/">&lt;blockquote&gt;
  &lt;p&gt;보통 우리가 생각하는 웹프로그래밍은 클릭과 같은 이벤트를 통해 웹 서버에 요청하고 요청에 대한 응답을 클라이언트에게 보내주어 갱신되는 것이 일반적이다.&lt;/p&gt;

  &lt;p&gt;하지만, 구글 지도와 같은 몇 웹페이지에서는 신기하게도 전체 페이지를 다시 새로고침하지 않고도 지도 정보만 갱신되는 것을 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;ajax&quot;&gt;Ajax&lt;/h1&gt;
&lt;p&gt;(Asynchronous JavaScript and XML, 에이잭스)&lt;br /&gt;
비동기적인 웹 애플리케이션의 제작을 위해 아래와 같은 조합을 이용하는 웹 개발 기법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;표현 정보를 위한 HTML (또는 XHTML) 과 CSS&lt;/li&gt;
  &lt;li&gt;동적인 화면 출력 및 표시 정보와의 상호작용을 위한 DOM, 자바스크립트&lt;/li&gt;
  &lt;li&gt;웹 서버와 비동기적으로 데이터를 교환하고 조작하기 위한 XML, XSLT, XMLHttpRequest&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript의 라이브러리 중 하나이며, JavaScript를 사용한 비동기 통신, 클라이언트와 서버 간에 XML 데이터를 주고받는 기술이다.&lt;/p&gt;

&lt;p&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자바스크립트&lt;/code&gt;를 통해 다양한 형태의 데이터(JSON, XML, CSV)를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버&lt;/code&gt;와 주고받을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;비동기-방식&quot;&gt;비동기 방식&lt;/h2&gt;
&lt;p&gt;웹페이지를 새로고침하지 않고 데이터를 불러오는 방식.&lt;/p&gt;

&lt;p&gt;보통 자주가는 카페를 예로 들어보자면,&lt;br /&gt;
동기 방식의 경우는 손님이 들어올 때마다 주문을 받고 손님은 커피를 받기 전까지 카운터에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기다리는&lt;/code&gt; 상황이고&lt;br /&gt;
비동기 방식은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;진동벨&lt;/code&gt;을 구비해서 손님의 주문을 받음과 동시에 진동벨을 배분하고 일을 하다가 중간에 다른 손님이 오더라도 주문을 받을 수 있는 상황과 유사하다고 할 수 있다.&lt;/p&gt;

&lt;p&gt;위 예시에서 손님이 갑자기 몰려온다고 생각해보자.&lt;br /&gt;
동기 방식에서는 손님이 주문하고 커피를 준비하고 넘겨주어야 다음 손님을 맞을 수 있으므로 시간 낭비가 심하다.&lt;br /&gt;
하지만, 비동기 방식에서는 손님을 기다리게 하고 다른 업무를 할 수 있으니 시간적으로 효율이 좋다.&lt;/p&gt;

&lt;p&gt;즉, 비동기 방식의 &lt;strong&gt;장점&lt;/strong&gt;은&lt;br /&gt;
기존의 변경할 필요가 없는 이미지, 스크립트 등은 남겨두고 필요한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부분만&lt;/code&gt; 갱신해 사용할 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/web/ajax/processing model.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;데이터-전송-방식&quot;&gt;데이터 전송 방식&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt;&lt;br /&gt;
지정한 URL의 데이터를 열람하기 위한 메소드&lt;br /&gt;
사용이 간편하고 전송량이 적으나 사용자정보를 URL에 노출함으로 보안상 취약할 수 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt;&lt;br /&gt;
지정한 URL에 데이터를 생성하기 위한 메소드(수정 및 삭제 작업도 수행 가능)&lt;/li&gt;
  &lt;li&gt;PUT&lt;br /&gt;
지정한 URL의 데이터를 갱신하기 위한 메소드&lt;/li&gt;
  &lt;li&gt;DELETE&lt;br /&gt;
지정한 URL의 데이터를 삭제하기 위한 메소드&lt;/li&gt;
  &lt;li&gt;HEAD&lt;br /&gt;
지정한 URL의 헤더 정보를 요청하는 메소드&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ajax의-장점&quot;&gt;AJAX의 장점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;웹페이지 &lt;strong&gt;속도&lt;/strong&gt; 향상&lt;/li&gt;
  &lt;li&gt;서버 처리를 기다리지 않고, 비동기 요청 가능&lt;/li&gt;
  &lt;li&gt;수신하는 데이터의 양을 줄일 수 있고, 클라이언트에게 처리를 위임할 수도 있다.&lt;/li&gt;
  &lt;li&gt;플러그인 없이도 인터렉티브한 웹페이지 구현이 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ajax의-단점&quot;&gt;AJAX의 단점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Ajax를 쓸 수 없는 브라우저에 대한 문제가 있음&lt;/li&gt;
  &lt;li&gt;HTTP 클라이언트 기능이 한정되어 있음&lt;/li&gt;
  &lt;li&gt;페이지 이동없는 통신으로 인한 보안상의 문제 발생 가능성&lt;/li&gt;
  &lt;li&gt;히스토리 관리가 되지 않음&lt;/li&gt;
  &lt;li&gt;지원하는 Charset이 한정&lt;/li&gt;
  &lt;li&gt;스크립트로 작성되므로 디버깅이 용이하지 않음&lt;/li&gt;
  &lt;li&gt;요청을 남발하면 역으로 서버 부하가 늘 수 있음&lt;/li&gt;
  &lt;li&gt;동일-출처 정책으로 인하여 다른 도메인과는 통신이 불가능(Cross-Domain문제)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ajax-프레임워크&quot;&gt;AJAX 프레임워크&lt;/h2&gt;
&lt;p&gt;Ajax를 이용하여 개발을 손쉽게 할 수 있도록 미리 여러 가지 기능을 포함해 놓은 개발 환경&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JQuery&lt;/li&gt;
  &lt;li&gt;Prototype&lt;/li&gt;
  &lt;li&gt;script.acul.us&lt;/li&gt;
  &lt;li&gt;dojo&lt;/li&gt;
  &lt;li&gt;Google Web Toolkit&lt;/li&gt;
  &lt;li&gt;ASP.NET AJAX&lt;/li&gt;
  &lt;li&gt;YUI&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ajax-예제&quot;&gt;AJAX 예제&lt;/h2&gt;
&lt;h3 id=&quot;javascript에서-ajax&quot;&gt;JavaScript에서 Ajax&lt;/h3&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;XMLHttpRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;XMLHttpRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ActiveXObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Microsoft.XMLHTTP&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onreadystatechange&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;readyState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;//통신 성공시 구현부분&lt;/span&gt;

         &lt;span class=&quot;c1&quot;&gt;//readState : Ajax 통신의 진행중인 상태 표시&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 0 : 초기화되지 않은 상태(open 메소드가 호출되지 않은 상태)&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 1 : open 메소드가 호출된 상태(send메소드는 호출되지 않은 상태)&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 2 : 송신완료, 요청을 시작한 상태(요청은 하지 않았지만 데이터가 아직 오지 않은 상태)&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 3 : 수신 중인 상태(데이터를 받고 있는 상태)&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 4 : 수신 완료(데이터를 모두 받은 상태)&lt;/span&gt;

         &lt;span class=&quot;c1&quot;&gt;//status : 데이터 수신의 성공 여부를 판단해주는 속성값&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 0 : 로컬로 접근 성공을 의미&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 200 : 해당 URL로 접근 성공한 상태&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 403 : 접근이 거부됨.&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 404 : 해당 URL이 없음&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 500 : 서버오류&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;exam.xml&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JavaScript에서 Ajax는 텍스트/XML 타입으로만 데이터를 가져올 수 있기 때문에 JSON/CSV 형식으로 데이터를 받기 위해서는 따로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파싱&lt;/code&gt;(Parsing)하는 코드 작업이 필요.&lt;/p&gt;

&lt;h3 id=&quot;jquery에서-ajax&quot;&gt;JQuery에서 Ajax&lt;/h3&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;script&lt;/span&gt;  &lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;http://code.jquery.com/jquery-latest.min.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/script&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//request 보낼 서버의 경로&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 메소드(get, post, put 등)&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;yoo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//보낼 데이터&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;datatype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//서버로부터 정상적으로 응답이 왔을 때 실행&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//서버로부터 응답이 정상적으로 처리되지 못햇을 때 실행&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;또는&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//request 보낼 서버의 경로&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 메소드(get, post, put 등)&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;yoo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//보낼 데이터&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;datatype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// HTTP 요청이 성공하면 요청한 데이터가 done 메소드로 전달&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;xhr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;errorThrown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// HTTP 요청이 실패하면 오류와 상태에 대한 정보가 fail 메소드로 전달&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;always&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;xhr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// HTTP 요청이 성공, 실패에 상관없이 언제나 alway 메서드 실행&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="AJAX" /><summary type="html">보통 우리가 생각하는 웹프로그래밍은 클릭과 같은 이벤트를 통해 웹 서버에 요청하고 요청에 대한 응답을 클라이언트에게 보내주어 갱신되는 것이 일반적이다. 하지만, 구글 지도와 같은 몇 웹페이지에서는 신기하게도 전체 페이지를 다시 새로고침하지 않고도 지도 정보만 갱신되는 것을 볼 수 있다.</summary></entry><entry><title type="html">[네트워크] 네트워크 개요 및 일반</title><link href="https://many258.github.io/study/network-base/" rel="alternate" type="text/html" title="[네트워크] 네트워크 개요 및 일반" /><published>2021-03-10T00:00:00+09:00</published><updated>2021-03-10T15:37:34+09:00</updated><id>https://many258.github.io/study/%7Bnetwork-base%7D</id><content type="html" xml:base="https://many258.github.io/study/network-base/">&lt;h1 id=&quot;네트워크&quot;&gt;네트워크&lt;/h1&gt;
&lt;p&gt;송신자의 메시지를 수신자에게 &lt;strong&gt;전달&lt;/strong&gt;하는 과정으로 한 지점에서 원하는 다른 지점까지 의미 있는 &lt;strong&gt;정보&lt;/strong&gt;를 보다 정확하고 빠르게 상대방이 이해할 수 있도록 전송하는 것을 의미&lt;/p&gt;

&lt;h1 id=&quot;프로토콜&quot;&gt;프로토콜&lt;/h1&gt;
&lt;p&gt;송신자와 수신자가 통신이라는 것을 하려면 서로 메시지의 포맷, 언제 데이터를 보낼 것인지, 한 번 전송하고 한 번 응답받는 형태로 할 것인지에 관한 것을 서로 약속해야 한다.
이 때, 이러한 약속이 &lt;strong&gt;프로토콜&lt;/strong&gt;을 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;네트워크의-분류&quot;&gt;네트워크의 분류&lt;/h2&gt;
&lt;h3 id=&quot;거리에-따른-네트워크-유형&quot;&gt;거리에 따른 네트워크 유형&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PAN&lt;/strong&gt;(Personal Area Network)&lt;br /&gt;
3M 이내의 인접 지역 간의 통신 방법&lt;br /&gt;
짧은 거리로 인하여 유선보다는 무선의 WPAN이 많이 활용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LAN&lt;/strong&gt;(Local Area Network)&lt;br /&gt;
근거리 영역의 네트워크로 동일한 지역 내 고속의 전용 회선으로 연결하여 구성하는 통신망&lt;br /&gt;
Client/Server와 peer-to-peer 모델&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;WAN&lt;/strong&gt;(Wide Area Network)&lt;br /&gt;
광대역 네트워크망으로 서로 관련이 있는 LAN 간의 상호 연결망&lt;br /&gt;
LAN에 비해 선로 에러율이 높고, 전송 지연이 크다&lt;br /&gt;
두 목적지 사이를 최단경로로 연결시켜 주는 라우팅 알고리즘 필요&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MAN&lt;/strong&gt;(Metropolitan Area Network)&lt;br /&gt;
LAN과 WAN의 중간 형태의 네트워크로 데이터, 음성, 영상 등을 지원하기 위해 개발&lt;br /&gt;
DQDB(Distributed Queue Dual Bus)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-전송-방식&quot;&gt;데이터 전송 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;단방향(Simplex)&lt;/li&gt;
  &lt;li&gt;반이중(Half Duplex)&lt;/li&gt;
  &lt;li&gt;전이중(Full Duplex)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;회선교환circuit-switching&quot;&gt;회선교환(Circuit Switching)&lt;/h2&gt;
&lt;p&gt;교환기를 통해 통신 회선을 설정하여 직접 데이터를 교환하는 방식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;전송 전에 회선이 전용선으로 설정 : 동일한 경로(독점)&lt;/li&gt;
      &lt;li&gt;데이터 전송이 없더라도 회선 해제 요청이 없으면 계속 접속 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유지&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;전송 시작 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;후&lt;/code&gt; 오버헤드가 없음&lt;/li&gt;
      &lt;li&gt;Point-to-Point 전송 구조&lt;/li&gt;
      &lt;li&gt;전송된 데이터의 에러 제어나 흐름 제어는 사용자에 의해 수행되어야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;대용량의 데이터를 고속으로 전송할 때 좋으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;고정&lt;/code&gt;적인 대역폭 사용&lt;/li&gt;
      &lt;li&gt;접속에는 긴 시간이 소요되나 그 후 접속이 항상 유지되어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전송 지연&lt;/code&gt;이 없고, 데이터 전송률이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;일정&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;아날로그나 디지털 데이터로 직접 전달&lt;/li&gt;
      &lt;li&gt;연속적인 전송에 적합(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실시간&lt;/code&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;회선 이용률 면에서 비효율적&lt;/li&gt;
      &lt;li&gt;연결된 두 장치는 반드시 같은 전송률과 같은 기종 사이에서만 송수신이 가능&lt;/li&gt;
      &lt;li&gt;속도나 코드의 변환이 불가능 : 교환망 내에서의 에러 제어 기능이 어려움&lt;/li&gt;
      &lt;li&gt;실시간 전송보다 에러없는 데이터 전송이 요구되는 구조에서는 부적합&lt;/li&gt;
      &lt;li&gt;통신 비용 고가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;패킷교환packet-switching&quot;&gt;패킷교환(Packet Switching)&lt;/h2&gt;
&lt;p&gt;송신측에서 메시지를 일정한 크기의 패킷으로 분해/전송, 수신측에서 원래의 데이터로 조립&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;패킷 다중화, 논리 채널, 경로 선택 제어, 순서 제어, 트래픽 제어, 오류 제어&lt;/li&gt;
      &lt;li&gt;수신된 패킷의 저장기능(대기 큐)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;순서 제어&lt;/strong&gt; 기능 : 목적지에서 수신된 패킷의 순서를 재정렬&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;트래픽 제어&lt;/strong&gt; : 흐름 제어, 혼잡 제어, 교착상태&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;경로 배정 요소&lt;/strong&gt; : 성능 기준, 결정 시간, 결정 장소, 네트워크 정보&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;회선 이용률이 높고, 속도 변환, 프로토콜 변환 가능, 음성 통화&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;고신뢰성&lt;/strong&gt; : 상황에 따라 교환기 및 회선 등의 장애가 발생하더라도 패킷의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우회전송&lt;/code&gt;이 가능하므로 전송의 신뢰성 보장&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;고품질&lt;/strong&gt; : 디지털 전송이므로, 인접 간에 또는 단말기와 교환기 간에 전송, 오류 검사를 실시하여 오류 발생 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;재전송&lt;/code&gt; 가능&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;고효율&lt;/strong&gt; : 다중화를 사용하므로 전송로 사용 및 효율이 좋다&lt;/li&gt;
      &lt;li&gt;이 기종 단말장치 간 통신 : 전송 속도, 전송 제어 절차가 다르더라도 교환망이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;변환 처리&lt;/code&gt;를 제공하므로 통신 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;각 교환기의 경로에서 다소 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연&lt;/code&gt;이 발생&lt;/li&gt;
      &lt;li&gt;이러한 지연은 가변적임. 전송량이 증가함에 따라 지연이 더욱 심할 수 있음&lt;/li&gt;
      &lt;li&gt;패킷별 헤더 추가로 인한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오버헤드&lt;/code&gt; 발생 가능성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;패킷교환-방식의-종류&quot;&gt;패킷교환 방식의 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;가상회선&lt;/strong&gt;(Virtual Circuit)
    &lt;ul&gt;
      &lt;li&gt;패킷을 전송하기 전에 논리적인 연결을 먼저 수행 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연결형&lt;/code&gt; 서비스&lt;/li&gt;
      &lt;li&gt;호출 요구를 하고 호출 수신 패킷을 주고받아서 연결하는 방식(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X.21&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;회선교환처럼 사용하지만 교환기에 패킷이 일시적으로 저장되며 일정한 전송률 보장 불가&lt;/li&gt;
      &lt;li&gt;비교적 긴 메시지의 전송 시 더 효과적&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터그램&lt;/strong&gt;(Datagram)
    &lt;ul&gt;
      &lt;li&gt;각 전송 패킷을 미리 정해진 경로 없이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;독립적&lt;/code&gt;으로 처리하여 교환하는 방식&lt;/li&gt;
      &lt;li&gt;같은 목적지의 패킷도 같은 경로를 거치지 않고 서로 다른 경로를 통해서 목적지에 도달&lt;/li&gt;
      &lt;li&gt;망의 한 부분이 혼잡할 때 패킷에 다른 경로를 지정하여 배정 가능, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;융통성&lt;/code&gt; 있는 경로를 설정&lt;/li&gt;
      &lt;li&gt;특정 교환기의 고장 시 모든 패킷을 잃어버리는 가상회선 방식과는 달리, 그 경로를 피해서 전송할 수 있음 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;신뢰성&lt;/code&gt; 보장&lt;/li&gt;
      &lt;li&gt;짧은 메시지의 패킷들을 전송할 때 효과적, 재정렬 기능 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;네트워크-토폴로지network-topology&quot;&gt;네트워크 토폴로지(Network Topology)&lt;/h2&gt;
&lt;p&gt;컴퓨터 네트워크의 요소들(링크, 노드)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/base/NetworkTopologies.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;계층형&lt;/strong&gt;(트리형)
    &lt;ul&gt;
      &lt;li&gt;Tree 구조, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최상위&lt;/code&gt;에 있는 노드가 네트워크 제어&lt;/li&gt;
      &lt;li&gt;통제 및 유지 보수 용이&lt;/li&gt;
      &lt;li&gt;단말기의 추가나 제거 및 에러 발생 시 발견이 쉬움&lt;/li&gt;
      &lt;li&gt;병목 현상 발생 가능, 중앙 노드 장애 발생 시 전체 통신망 마비&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수평형&lt;/strong&gt;(버스형)
    &lt;ul&gt;
      &lt;li&gt;중앙 통신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;회선&lt;/code&gt; 하나에 여러 대의 노드를 연결하는 방식&lt;/li&gt;
      &lt;li&gt;근거리 통신망에서 볼 수 있는 일반적인 형태&lt;/li&gt;
      &lt;li&gt;하나의 컴퓨터가 다운되어도 나머지 컴퓨터에는 지장이 없음&lt;/li&gt;
      &lt;li&gt;DTE 추가 삭제가 용이&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위&lt;/code&gt; 제어가 어려움&lt;/li&gt;
      &lt;li&gt;통신 회선의 길이에 제한, 충돌이 자주 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성형&lt;/strong&gt;(스타형)
    &lt;ul&gt;
      &lt;li&gt;중앙에 있는 컴퓨터를 중심으로 터미널이 연결된 중앙 집중식 형태&lt;/li&gt;
      &lt;li&gt;유지보수 및 관리가 용이, 단말기 고장 시 발견이 용이&lt;/li&gt;
      &lt;li&gt;중앙 컴퓨터 고장 시 전체 네트워크 마비&lt;/li&gt;
      &lt;li&gt;통신망 제어가 복잡&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;원형&lt;/strong&gt;(링형)
    &lt;ul&gt;
      &lt;li&gt;인접해 있는 노드들을 연결하는 단방향 전송 형태&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;매채 엑세스&lt;/code&gt; 방식&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;토큰 링&lt;/code&gt; 이용, 동축/광섬유 케이블 이용&lt;/li&gt;
      &lt;li&gt;전송 매체와 DTE 고장 시 발견이 용이&lt;/li&gt;
      &lt;li&gt;단말기 추가 및 삭제가 어려움&lt;/li&gt;
      &lt;li&gt;전송 지연 발생 시 DTE 간의 순차적 전송때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중계기&lt;/code&gt; 기능이 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;망형&lt;/strong&gt;(메쉬형)
    &lt;ul&gt;
      &lt;li&gt;모든 노드들이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상호&lt;/code&gt; 연결&lt;/li&gt;
      &lt;li&gt;통신 회선 장애 시 다른 경로로 데이터 전송이 가능&lt;/li&gt;
      &lt;li&gt;DTE 고장과 병목 현상에 대해 면역성이 있음&lt;/li&gt;
      &lt;li&gt;가장 많은 통신 선로가 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;osi-7계층&quot;&gt;OSI 7계층&lt;/h2&gt;
&lt;p&gt;Open System Interconnection 7-layer&lt;br /&gt;
개방형 시스템 네트워크의 효율적인 이용을 위하여 모든 데이터 통신 기준으로 계층을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분할&lt;/code&gt;하고, 각 계층 간의 필요한 프로토콜을 규정한다.&lt;/p&gt;

&lt;p&gt;정보가 전달되는 Framework를 제공하며, 네트워크 형태에 차이가 발생해도 데이터 통신을 지원&lt;/p&gt;

&lt;h3 id=&quot;osi-7계층-구조&quot;&gt;OSI 7계층 구조&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;OSI 7계층&lt;/td&gt;
      &lt;td&gt;주요 내용&lt;/td&gt;
      &lt;td&gt;주요 프로토콜(매체)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7. Application&lt;/td&gt;
      &lt;td&gt;사용자 소프트웨어를 네트워크에 접근 가능하도록 함.&lt;br /&gt;사용자에게 최종 서비스를 제공&lt;/td&gt;
      &lt;td&gt;FTP, SNMP, HTTP, Mail, Telnet 등&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6. Presentation&lt;/td&gt;
      &lt;td&gt;포맷 기능, 압축, 암호화&lt;br /&gt;텍스트 및 그래픽 정보를 컴퓨터가 이해할 수 있는 16진수 데이터로 변환&lt;/td&gt;
      &lt;td&gt;압축, 암호, 코드 변환  GIF, ASCII, EBCDIC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5. Session&lt;/td&gt;
      &lt;td&gt;세션 연결 및 동기화 수행, 통신 방식 결정&lt;br /&gt;가상 연결을 제공하여 Login/Logout 수행&lt;/td&gt;
      &lt;td&gt;반이중, 전이중, 완전이중 결정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4. Transport&lt;/td&gt;
      &lt;td&gt;가상연결, 에러 제어, 데이터 흐름 제어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Segment&lt;/code&gt; 단위&lt;br /&gt;두 개의 종단 간 End-To-End 데이터 흐름이 가능하도록 논리적 주소 연결&lt;br /&gt;신뢰도, 품질보증, 오류탐지 및 교정 기능 제공  다중화(Multiplexing) 발생&lt;/td&gt;
      &lt;td&gt;TCP, UDP&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3. Network&lt;/td&gt;
      &lt;td&gt;경로선택, 라우팅 수행, 논리적 주소 연결(IP)&lt;br /&gt;데이터 흐름 조절, 주소 지정 메커니즘 구현  네트워크에서 노드에 전송되는 패킷 흐름을 통제하고, 상태메시지가 네트워크상에서 어떻게 노드로 전송되는 가를 정의, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Datagram&lt;/code&gt;(Packet) 단위&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2. Data Link&lt;/td&gt;
      &lt;td&gt;물리주소 결정, 에러 제어, 흐름 제어, 데이터 전송&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Frame&lt;/code&gt; 단위, 전송 오류를 처리하는 최초의 계층&lt;/td&gt;
      &lt;td&gt;흐름제어, 오류제어(ARQ)  브리지, PPTP, L2TP, HDLC  Frame Relay&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1. Physical&lt;/td&gt;
      &lt;td&gt;전기적, 기계적 연결 정의, 실제 Data Bit 전송&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bit&lt;/code&gt; 단위, 전기적 신호, 전압구성, 케이블, 인터페이스 등을 구성&lt;br /&gt;Data Rates, Line noise Control, 동기화 기능 수행&lt;/td&gt;
      &lt;td&gt;매체: 동축케이블, 광섬유, Twisted Pair Cable&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;End-to-End&lt;/strong&gt; : 7 ~ 4계층, 송수신자 간의 에러 제어&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Point-to-Point&lt;/strong&gt; : 4 ~ 1계층, 각 구간에 대해 에러 제어&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;osi-계층별-하드웨어-장비&quot;&gt;OSI 계층별 하드웨어 장비&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Physical
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Cable&lt;/strong&gt;&lt;br /&gt;
Twisted Pair Cable, Coaxial, Fiber-Optic Cable&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Repeater&lt;/strong&gt;&lt;br /&gt;
네트워크 구간 케이블의 전기적 신호를 재생하고 증폭하는 장치
디지털 신호를 제공, 아날로그 신호 증폭 시 잡음과 왜곡까지 증폭&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data Link
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Bridge&lt;/strong&gt;&lt;br /&gt;
서로 다른 LAN Segment를 연결, 관리자에게 MAC 주소 기반 필터링 제공하여 더 나은 대역폭 사용과 트래픽을 통제
리피터와 같이 데이터 신호를 증폭하지만 MAC 기반에서 동작&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Switch&lt;/strong&gt;&lt;br /&gt;
목적지의 MAC 주소를 알고 있는 지정된 포트로 데이터를 전송
Repeater와 Bridge의 기능을 결합
네트워크의 속도 및 효율적 운영, Data Link 계층에서도 작동&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Network
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Router&lt;/strong&gt;&lt;br /&gt;
패킷을 받아 경로를 설정하고 패킷을 전달
Bridge는 MAC 주소를 참조하지만, Router는 네트워크 주소를 참조하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;경로&lt;/code&gt;를 설정
패킷 헤더 정보에서 IP 주소를 확인하여 목적지 네트워크로만 전달하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Broadcasting&lt;/code&gt;을 차단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Application
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Gateway&lt;/strong&gt;&lt;br /&gt;
서로 다른 네트워크망과의 연결(PSTN, Internet, Wireless Network 등)
패킷 헤더의 주소 및 포트 외 거의 모든 정보를 참조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-전송-방식-1&quot;&gt;데이터 전송 방식&lt;/h3&gt;
&lt;h4 id=&quot;직렬-전송serial-transmission&quot;&gt;직렬 전송(Serial Transmission)&lt;/h4&gt;
&lt;p&gt;한 문자의 각 비트 열을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나의&lt;/code&gt; 전송 선로를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;순차적&lt;/code&gt;으로 전송하는 방식(모뎀)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시프트 레지스터를 이용하여 병렬을 직렬화한 후 송신&lt;/li&gt;
  &lt;li&gt;동기 전송 방식의 요구&lt;/li&gt;
  &lt;li&gt;전송 에러가 적고, 장거리에 적합&lt;/li&gt;
  &lt;li&gt;통신 회선 설치 비용이 저렴&lt;/li&gt;
  &lt;li&gt;전송 속도가 느림&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;병렬-전송parallel-transmission&quot;&gt;병렬 전송(Parallel Transmission)&lt;/h4&gt;
&lt;p&gt;한 문자를 이루는 각 비트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;각각의&lt;/code&gt; 전송로를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;한꺼번에&lt;/code&gt; 전송되는 방식(프린터)
블록 버퍼를 이용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;송수신 문자 간격을 식별하는 스트로브 신호와 BUSY 신호로 다음 문자의 송신 시기 결정&lt;/li&gt;
  &lt;li&gt;단위 시간에 다량의 데이터를 빠른 속도로 전송&lt;/li&gt;
  &lt;li&gt;전송 길이가 길어지면 에러 발생 가능성 농후&lt;/li&gt;
  &lt;li&gt;통신 회선 설치 비용이 커짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;동기-방식synchronous-method&quot;&gt;동기 방식(Synchronous Method)&lt;/h4&gt;
&lt;p&gt;전송할 데이터를 여러 블록으로 나누어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블록&lt;/code&gt; 단위로 전송하는 방식
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 정보&lt;/code&gt;를 데이터의 앞뒤에 붙여 프레임을 구성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;전송 단위&lt;/strong&gt; : 프레임, 문자 중심 / 비트 중심&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;에러 검출&lt;/strong&gt; : CRC&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오버헤드&lt;/strong&gt; : 프레임당 고정된 크기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 속도&lt;/strong&gt; : 고속&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 효율&lt;/strong&gt; : 높다(휴지 간격 없음, 채널 할당 시간 공백 없음)&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;원거리 전송에 이용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;에러 발생 확률이 높다&lt;/li&gt;
      &lt;li&gt;고가(별도의 하드웨어 장치가 필요)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;비동기-방식asynchronous-method&quot;&gt;비동기 방식(Asynchronous Method)&lt;/h4&gt;
&lt;p&gt;한 번에 한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;문자씩&lt;/code&gt; 전송하는 방식(한 문자 전송 시마다 동기화하는 방식)&lt;br /&gt;
start-stop 비트를 사용, 패리티 비트, 정지 비트 ‘1’ 시작비트 ‘0’&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;전송 단위&lt;/strong&gt; : 문자 단위의 비트 블록&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;에러 검출&lt;/strong&gt; : 패리티 비트&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오버헤드&lt;/strong&gt; : 문자당 고정된 크기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 속도&lt;/strong&gt; : 저속&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 효율&lt;/strong&gt; : 낮음&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;동기화가 단순하며 저렴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;문자당 2~3비트의 오버헤드가 발생&lt;/li&gt;
      &lt;li&gt;프레임 에러가 발생할 가능성이 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="데이터통신" /><category term="네트워크" /><summary type="html">네트워크 송신자의 메시지를 수신자에게 전달하는 과정으로 한 지점에서 원하는 다른 지점까지 의미 있는 정보를 보다 정확하고 빠르게 상대방이 이해할 수 있도록 전송하는 것을 의미</summary></entry><entry><title type="html">[데이터베이스/DB] 트랜잭션(Transaction)과 병행제어 및 회복</title><link href="https://many258.github.io/study/database-transaction/" rel="alternate" type="text/html" title="[데이터베이스/DB] 트랜잭션(Transaction)과 병행제어 및 회복" /><published>2021-03-09T00:00:00+09:00</published><updated>2021-03-09T14:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-transaction%7D</id><content type="html" xml:base="https://many258.github.io/study/database-transaction/">&lt;h1 id=&quot;트랜잭션&quot;&gt;트랜잭션&lt;/h1&gt;
&lt;p&gt;데이터베이스의 상태를 하나의 상태에서 또 다른 일관된 상태로 변화시켜주는 일련의 논리적인 연산 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;집합&lt;/code&gt;&lt;br /&gt;
한번에 모두 소행되어야하는 연산들의 집합, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나의 작업&lt;/code&gt;을 처리하기위한 작업 단위&lt;br /&gt;
하나의 트랜잭션은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완료&lt;/code&gt;(Commit)되거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복귀&lt;/code&gt;(Rollback)되어야 한다&lt;/p&gt;

&lt;h2 id=&quot;트랜잭션의-성질&quot;&gt;트랜잭션의 성질&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Atomicity&lt;/strong&gt;(원자성)&lt;br /&gt;
트랜잭션이라는 것은 연산의 집단을 의미하지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;논리적&lt;/code&gt;으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나&lt;/code&gt;의 의미
연산들은 모두 수행되거나 모두 수행되지 않아야한다(= 일부의 완료는 존재하지 않는다)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Consistency&lt;/strong&gt;(일관성)&lt;br /&gt;
고정 요소는 트랜잭션 실행 전과 후가 같아야 한다는 성질
트랜잭션이 실행되고 나서도 데이터베이스의 상태는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무결성&lt;/code&gt;이 유지되고 모순되지 말아야 된다는 성질&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Isolation&lt;/strong&gt;(독립성,격리성)&lt;br /&gt;
트랜잭션이 실행되는 중간에는 다른 트랜잭션 연산이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;침범&lt;/code&gt;하지 못하는 성질
같은 자원에 대해 여러 개의 트랜잭션이 동시에 사용할 수 없다는 성질&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Durability&lt;/strong&gt;(영속성,지속성)&lt;br /&gt;
트랜잭션에 의해서 변화된 상태는 계속해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유지&lt;/code&gt;될 수 있어야 한다는 성질&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;트랜잭션의-상태&quot;&gt;트랜잭션의 상태&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;활동(Active)&lt;br /&gt;
트랜잭션이 실행 중인 상태&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;부분 완료(Partially Committed)&lt;br /&gt;
트랜잭션이 마지막 연산을 끝내고 데이터베이스에 실행 결과를 적용하기 직전의 상태&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;완료(Committed)&lt;br /&gt;
트랜잭션이 연산을 완료하고 연산의 결과를 데이터베이스에 적용한 상태&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실패(Failed)&lt;br /&gt;
트랜잭션이 실행 중 어떤 오류에 의해서 더 이상 진행될 수 없는 상태&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;철회(Aborted)&lt;br /&gt;
트랜잭션 실행이 실패하여 복귀된 상태&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;병행제어&quot;&gt;병행제어&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다중&lt;/code&gt; 프로그램의 이점을 활용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동시&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;여러&lt;/code&gt; 개의 트랜잭션을 병행수행할 때,&lt;br /&gt;
동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것을 의미.&lt;/p&gt;

&lt;h2 id=&quot;목적&quot;&gt;목적&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터베이스의 공유를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최대화&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;시스템의 활용도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최대화&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;데이터베이스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;일관성&lt;/code&gt; 유지&lt;/li&gt;
  &lt;li&gt;사용자에 대한 응답시간 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소화&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;제약없는-병행-처리concurrency-processing-시-문제점&quot;&gt;제약없는 병행 처리(Concurrency Processing) 시 문제점&lt;/h2&gt;
&lt;p&gt;병행제어 기법에 의한 제어 없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용할 경우 다음과 같은 문제점이 발생&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;분실된 갱신(Lost Update)&lt;br /&gt;
두 개의 트랜잭션이 같은 데이터에 대해서 동시에 갱신 작업을 하면 하나의 갱신 작업이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분실&lt;/code&gt;되는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모순성(Inconsistency, 불일치)&lt;br /&gt;
한 개의 트랜잭션 작업이 갱신 작업을 하고 있는 상태에서 또 하나의 트랜잭션이 같은 작업 구역에 침범하여 작업하게 되면, 트랜잭션이 모두 끝나게 되더라도 그 데이터에 대한 결과는 사용자가 원하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결과&lt;/code&gt;와 일치하지 않는 상태가 되어 데이터베이스의 일관성을 해치는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;연쇄 복귀(CasCading Rollback)&lt;br /&gt;
다른 트랜잭션이 처리하는 과정에서 실패하게 되면 두 개의 트랜잭션 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복귀&lt;/code&gt;되는 현상&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비완료 의존성(Uncommitted Dependency)&lt;br /&gt;
한 개의 트랜잭션이 수행과정에서 실패하였을 때, 이 트랜잭션이 회복되기 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전&lt;/code&gt;에 다른 트랜잭션이 이 트랜잭션의 수행 결과를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;참조&lt;/code&gt;하는 현상&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;병행제어-기법의-종류&quot;&gt;병행제어 기법의 종류&lt;/h2&gt;
&lt;h3 id=&quot;로킹&quot;&gt;로킹&lt;/h3&gt;
&lt;p&gt;자원 이용에 대하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상호배제&lt;/code&gt; 기능을 이용하는 기법&lt;/p&gt;

&lt;p&gt;직렬성을 보장하기 위해 하나의 트랜잭션이 어떤 데이터에 대해서 액세스하는 동안 또 다른 트랜잭션이 이 데이터에 대해 액세스하기 위해서는 로크를 소유하고 있어야만 가능하도록 하는 방법.&lt;br /&gt;
언제 로크를 소유하고 해제하는가 하는 로킹 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;규칙&lt;/code&gt;을 정해놓고 해결.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로킹 기법
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;공유 잠금(Shared Lock)&lt;br /&gt;
잠금 걸린 데이터에 대해 읽기 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가능&lt;/code&gt;, 쓰기 불가능&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;베타 잠금(Exclusive Lock)&lt;br /&gt;
잠금 걸린 데이터에 대해 읽기, 쓰기 불가능&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;로킹단위(Locking Granularity)&lt;br /&gt;
병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기&lt;br /&gt;
주요 단위로는 DB, DBSPACE, 테이블, 페이지 등
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;로킹 단위가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;작다&lt;/code&gt;&lt;br /&gt;
데이터의 공유도와 병행성이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;증가&lt;/code&gt;하나 로크의 수가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;많아&lt;/code&gt; 병행 제어 기법이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복잡&lt;/code&gt;하고 관리가 어렵다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;로킹 단위가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;크다&lt;/code&gt;&lt;br /&gt;
데이터의 공유도와 병행성 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;감소&lt;/code&gt;하고 로크의 수가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;적어&lt;/code&gt; 병행 제어 기법이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;간단&lt;/code&gt;하고 관리가 쉽다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2단계 로킹 규약(Two-Phase Locking Protocol)&lt;br /&gt;
트랜잭션 스케쥴의 직렬성을 보장하는 대표적인 기법
    &lt;ul&gt;
      &lt;li&gt;요청단계(Growing Phase) = 확장 단계&lt;br /&gt;
로크를 얻는 과정에서는 어떠한 로크도 반납될 수 없다는 것을 나타내는 단계(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;잠금만&lt;/code&gt; 수행)&lt;/li&gt;
      &lt;li&gt;반납단계(Shrinking Phase) = 축소 단계&lt;br /&gt;
트랜잭션이 완료되는 시점에서 데이터에 대한 로크를 반납하는 과정에서는 어떠한 로크도 획득할 수 없는 단계(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;해제만&lt;/code&gt; 수행)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;타임스탬프&quot;&gt;타임스탬프&lt;/h3&gt;
&lt;p&gt;시스템에 진입하는 트랜잭션 순서대로 타임스탬프를 지정하여 동시성을 제어하는 기법&lt;/p&gt;

&lt;h3 id=&quot;검증-기법&quot;&gt;검증 기법&lt;/h3&gt;
&lt;p&gt;= 최적 병행수행, 확인 기법, 낙관적 기법&lt;/p&gt;

&lt;p&gt;읽기 단계, 검증 단계, 기록 단계를 이용하여 직렬성을 보장하는 기법&lt;/p&gt;

&lt;h3 id=&quot;다중버전-기법&quot;&gt;다중버전 기법&lt;/h3&gt;
&lt;p&gt;= 다중 버전 타임 스탬프 기법&lt;/p&gt;

&lt;p&gt;갱신 연산 때마다 새로운 버전을 만들어 병렬수행을 제어하는 기법&lt;/p&gt;

&lt;h1 id=&quot;회복recovery&quot;&gt;회복(Recovery)&lt;/h1&gt;
&lt;p&gt;어떤 외부적인 장애 요인이나 내부적인 장애 요인에 의해서 데이터베이스의 상태가 일관성 유지에 제약이 걸렸을 때, 장애 이전의 일관된 상태가 되도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복원&lt;/code&gt;하는 일&lt;/p&gt;

&lt;h2 id=&quot;장애failure의-유형&quot;&gt;장애(Failure)의 유형&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;실행 장애&lt;/li&gt;
  &lt;li&gt;트랜잭션 장애&lt;/li&gt;
  &lt;li&gt;시스템 장애&lt;br /&gt;
H/W 시스템 자체에서 발생할 수 잇는 장애&lt;/li&gt;
  &lt;li&gt;미디어 장애&lt;br /&gt;
디스크 자체의 손상으로 발생할 수 있는 장애&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;undo&quot;&gt;UNDO&lt;/h2&gt;
&lt;p&gt;변경된 데이터를 취소하여 원래의 내용으로 복원시키는 연산&lt;/p&gt;

&lt;p&gt;주로 트랜잭션이 실행 중인 상태에서 실행이 실패하였을 경우 원래의 내용으로 복원하는 경우에 사용&lt;/p&gt;

&lt;h2 id=&quot;redo&quot;&gt;REDO&lt;/h2&gt;
&lt;p&gt;이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 것을 의미&lt;/p&gt;

&lt;p&gt;주로 데이터베이스의 내용이 손상되었을 때, Backup 본으로 회복한 다음 Backup 본에 있는 데이터 이후는 로그에 갱신되어 있는 데이터를 데이터베이스에 적용하는데 사용&lt;/p&gt;

&lt;h2 id=&quot;회복-기법&quot;&gt;회복 기법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;로그 기반 회복 기법&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;즉시 갱신&lt;/strong&gt;&lt;br /&gt;
트랜잭션이 수행중인 상태에서도 그 결과를 즉시 데이터베이스에 반영&lt;br /&gt;
커밋 발생 이전의 갱신은 원자성이 보장되지 않는 미완료 갱신이므로 장애 발생 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNDO&lt;/code&gt; 연산 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;필요&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;지연 회복 기법&lt;/strong&gt;&lt;br /&gt;
트랜잭션의 갱신 결과를 로그에 기록하여 두었다가 트랜잭션의 연산이 완료되면 한번에 데이터베이스에 반영
처리 도중 장애가 생기더라도 데이터베이스에 반영되지 않았으므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNDO&lt;/code&gt; 연산이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;불필요&lt;/code&gt; (REDO 연산 수행)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;검사점(CheckPoint) 회복 기법&lt;/strong&gt; 
장애 발생 시 검사점 이전에 처리된 트랜잭션은 회복에서 제외하고 검사점 이후에 처리된 트랜잭션은 회복작업을 수행&lt;br /&gt;
장애 발생 시점 이전에 Commit이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완료&lt;/code&gt;된 경우 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNDO&lt;/code&gt; 수행&lt;br /&gt;
장애 발생 시점 이전에 Commit을 못한 경우 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REDO&lt;/code&gt; 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;그림자페이징 기법&lt;/strong&gt;&lt;br /&gt;
로그를 이용하지 않으며 트랜잭션이 실행되는 메모리상의 현 페이지 테이블(Current Page Table)과 하드디스크의 그림자페이지 테이블(Shadow Page Table) 사용&lt;/p&gt;

    &lt;p&gt;트랜잭션 시작지점에서 현 페이지 테이블과 동일한 그림자페이지 테이블 사용&lt;br /&gt;
트랜잭션이 성공으로 완료될 경우, 그림자페이지 테이블 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삭제&lt;/code&gt;&lt;br /&gt;
트랜잭션이 실패할 경우, 그림자페이지 테이블을 현 페이지 테이블로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;교체&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;미디어 회복 기법&lt;/strong&gt;&lt;br /&gt;
디스크와 같은 비휘발성 저장 장치가 손상되는 장애 발생을 대비한 회복 기법&lt;/p&gt;

    &lt;p&gt;데이터베이스의 내용을 백업/미러링/RAID 등을 통해 별도의 물리적 저장장치에 덤프&lt;br /&gt;
미디어 장애 시 가장 최근 덤프로 복구하고 로그 파일을 참조해 덤프 이후의 작업을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REDO&lt;/code&gt; 수행 (UNDO는 수행하지 않음)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ARIES 회복 기법&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;REDO 중 역사 반복(Repeating history)&lt;br /&gt;
붕괴가 발생했을 때의 데이터베이스 상태를 복구하기 위하여 붕괴 발생 이전에 수행했던 모든 연산을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다시&lt;/code&gt; 한번 수행.&lt;br /&gt;
붕괴가 발생했을 때 완료되지 않은 상태였던 (진행 트랜잭션)은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNDO&lt;/code&gt; 된다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;UNDO 중 로깅(Logging)&lt;br /&gt;
UNDO를 할 때에도 로깅을 함으로써 회복을 수행하는 도중에 실패하여 회복을 다시 시작할 때에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이미&lt;/code&gt; 완료된 UNDO 연산은 반복하지 않는다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;주요 3단계
        &lt;ul&gt;
          &lt;li&gt;분석(Analysis)단계: 붕괴가 발생한 시점에 버퍼에 있는 수정된 페이지와 진행 트랜잭션을 파악, REDO가 시작되어야 하는 로그의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;위치&lt;/code&gt;를 결정&lt;/li&gt;
          &lt;li&gt;REDO 단계: 분석 단계에서 결정한 REDO 시작 위치의 로그로부터 로그가 끝날 때 까지 REDO를 수행, REDO 된 로그 레코드의 리스트를 관리하여 불필요한 REDO 연산이 수행되지 않도록 한다.&lt;/li&gt;
          &lt;li&gt;UNDO 단계: 로그를 역순으로 읽으면서 미완료된 트랜잭션의 연산을 UNDO 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;구성 요소
        &lt;ul&gt;
          &lt;li&gt;WAL(Write Ahead Logging)&lt;br /&gt;
DB 변경 사항에 대한 전체 로깅&lt;/li&gt;
          &lt;li&gt;LSN(Log Sequence Number)&lt;br /&gt;
모든 로그에 대한 고유 순서 번호&lt;/li&gt;
          &lt;li&gt;Repeating History&lt;br /&gt;
장애 시 이전의 데이터베이스 수행 기록을 모두 추적하여 REDO&lt;/li&gt;
          &lt;li&gt;Logging Changes&lt;br /&gt;
UNDO 완료된 트랙잭션을 기록하여 UNDO 반복 수행 회피&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">트랜잭션 데이터베이스의 상태를 하나의 상태에서 또 다른 일관된 상태로 변화시켜주는 일련의 논리적인 연산 집합 한번에 모두 소행되어야하는 연산들의 집합, 하나의 작업을 처리하기위한 작업 단위 하나의 트랜잭션은 완료(Commit)되거나 복귀(Rollback)되어야 한다</summary></entry><entry><title type="html">[운영체제/OS] RAID</title><link href="https://many258.github.io/study/os-raid/" rel="alternate" type="text/html" title="[운영체제/OS] RAID" /><published>2021-03-09T00:00:00+09:00</published><updated>2021-03-09T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bos-raid%7D</id><content type="html" xml:base="https://many258.github.io/study/os-raid/">&lt;h1 id=&quot;raid&quot;&gt;RAID&lt;/h1&gt;
&lt;p&gt;Redundant Array of Independent/Inexpensive Disks : 복수 배열 독립 디스크&lt;br /&gt;
여러 대의 물리적 디스크를 하나의 논리적 디스크로 인식시키는 기술&lt;br /&gt;
여러 개의 하드 디스크에 일부 중복된 데이터를 나눠서 저장하는 기술 = 디스크 어레이&lt;/p&gt;

&lt;p&gt;데이터를 나누는 다양한 방법이 존재하며, 이 방법들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;레벨&lt;/code&gt;이라 하는데, 레벨에 따라 저장장치의 신뢰성을 높이거나 전체적인 성능을 향상시키는 등의 다양한 목적을 만족시킬 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;raid의-사용-목적&quot;&gt;RAID의 사용 목적&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;무정지 구현(가용성)&lt;/li&gt;
  &lt;li&gt;성능 향상&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주의)&lt;/strong&gt; 데이터의 무결성, 안전, 백업에 대한 목적은 아니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;raid-0&quot;&gt;RAID 0&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스트라이핑&lt;/code&gt; Striping&lt;/p&gt;

&lt;p&gt;일련의 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나의 논리적 디스크&lt;/code&gt; 배열에 일정한 크기로 나누어서 분산 저장하는 기법&lt;br /&gt;
사용자와 시스템 데이터는 하나의 논리 디스크상에 저장되어 있는 것으로 인식하며 디스크는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스트립&lt;/code&gt;(Strip)이라는 일정한 크기의 섹터 또는 물리적 블록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단위&lt;/code&gt;로 나누어 연속적인 배열 구성요소와 대응되도록 순환할당된다.&lt;br /&gt;
이와 같이 하나의 스트립들과 각 배열의 구성요소가 대응하는 논리적으로 연속적인 스트립의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;집합&lt;/code&gt;을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스트라이프&lt;/code&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;RAID 0 방식은 데이터를 입출력할 때, RAID 컨트롤러에서 여러 개의 하드 디스크로 나눠서 쓰고 읽어 들이므로 중요하지 않은 데이터에 대한 빠른 데이터 입출력 성능이 요구되는 동영상 편집 등에 적합&lt;/p&gt;

&lt;p&gt;데이터를 중복해서 기록하지 않으므로 장애발생에 대비한 여분의 저장 공간을 가지고 있지 않다. 즉, 어느 한 드라이브에서 장애가 발생하면 데이터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;손실&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/150px-RAID_0.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-1&quot;&gt;RAID 1&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;미러링&lt;/code&gt; Mirroring + 스트라이핑 Striping&lt;/p&gt;

&lt;p&gt;RAID 0 과 같이 데이터 스트라이핑을 사용하면서 배열 내의 모든 디스크가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동일&lt;/code&gt;한 데이터를 가지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;미러 디스크&lt;/code&gt;를 가진다.
각 논리적 스트립은 두 개의 별도 디스크에 대응되므로 미러링이라고도 하는데, 중복 저장된 데이터를 가진 적어도 두 개의 드라이브로 구성&lt;/p&gt;

&lt;p&gt;멤버 디스크 중 하나만 살아남으면 데이터는 보존되며 복원도 1:1복사로 매우 간단하기 때문에 서버에서 끊김없이 지속적으로 서비스를 제공하기 위해 사용&lt;/p&gt;

&lt;p&gt;읽기 요구는 요구 데이터를 가지고 있는 두 개의 디스크 중 어떤 디스크에서도 서비스를 받을 수 있기 때문에 성능이 향상될 수 있으나,
데이터를 분할 저장하지 않기 때문에 두 스트립이 모두 갱신되어야 하며 쓰기 요구는 단일 디스크 드라이브의 경우와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/150px-RAID_1.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-2&quot;&gt;RAID 2&lt;/h2&gt;
&lt;p&gt;스트라이핑 + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;허밍 코드&lt;/code&gt; Hamming Code&lt;/p&gt;

&lt;p&gt;디스크들 간에 데이터 스트라이핑을 사용하며 오류 검출 능력이 없는 드라이브를 위해 허밍 코드 기법을 사용한다.(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안전성&lt;/code&gt; 확보)&lt;br /&gt;
몇몇 디스크들은 오류를 감지하고 수정하는 데 사용되는 오류정정코드(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECC&lt;/code&gt;, Error Correcting Code)정보를 저장&lt;/p&gt;

&lt;p&gt;허밍 오류정정코드는 패리티 비트를 사용해 디스크로부터 전송된 데이터에 오류가 있는지 검사 및 정정&lt;/p&gt;

&lt;p&gt;실시간 오류수정이 가능하다는 장점이 있지만, 현재의 SCSI 드라이브들이 자체 오류 검출 능력을 갖고 있기 때문에 실제 잘 쓰이지 않음.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/350px-RAID2_arch.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-3&quot;&gt;RAID 3&lt;/h2&gt;
&lt;p&gt;RAID 0과 같이 스트라이브를 사용하며, 오류 검출과 수정을 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;별도의 드라이브&lt;/code&gt; 한 개를 패리티 드라이브로 사용&lt;br /&gt;
각각의 데이터 디스크에 데이터를 비트 단위로 스트라이핑하여 기록&lt;/p&gt;

&lt;p&gt;대형 레코드가 많이 사용되는 단일 사용자 시스템과 다량의 데이터 전송이 요구되는 작업에 적합&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/300px-RAID_3.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-4&quot;&gt;RAID 4&lt;/h2&gt;
&lt;p&gt;데이터 분산 저장을 위해 스트라이핑과 패리티 드라이브를 사용한다는 점에서 RAID 3과 유사하지만, 각 드라이브에 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블록 단위&lt;/code&gt;로 분산 저장한다는 점에서 다름&lt;/p&gt;

&lt;p&gt;쓰기 요청이 있을 때마다 사용자 데이터와 함께 패리티 정보를 갱신해야 하기 때문에 추가시간이 소요되므로 크기가 작은 입출력이 요청될 때 쓰기 성능 저하(입출력의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;병목현상&lt;/code&gt; 유발)&lt;br /&gt;
데이터 읽기 요청은 RAID 0과 비슷한 성능을 가짐&lt;/p&gt;

&lt;p&gt;여러 드라이브 중에서 한 대의 드라이브만이 여분의 패리티 정보를 기록하는데 사용되기 때문에 용량당 비용은 높지않아 저렴한 가격으로 장애 복구 능력이 요구되거나 빠른 판독속도가 필요한 경우에 사용&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/300px-RAID_4.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-5&quot;&gt;RAID 5&lt;/h2&gt;
&lt;p&gt;RAID 4 구성과 유사하며 별도의 패리티 드라이브 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모든&lt;/code&gt; 드라이브에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;패리티&lt;/code&gt; 정보를 나누어 저장. (디스크 병목현상 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;해결&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;다중 프로세스 시스템에서와 같이 작고 잦은 데이터 기록이 있을 경우 더 빠르지만, 읽기 요청의 경우 각 드라이브에서 패리티 정보를 건너뛰어야 하기 때문에 RAID 4보다 속도가 느리다.&lt;/p&gt;

&lt;p&gt;최소한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt;대, 일반적으로 5대 이상의 드라이브가 필요. N개의 디스크를 사용하면 (N-1)배의 저장 공간을 사용 가능하다.&lt;/p&gt;

&lt;p&gt;데이터는 각 데이터 영역에 블록 단위로 스트라이핑하여 저장된다.&lt;br /&gt;
병렬 입출력이 가능하기 때문에 기록과 읽기가 동시에 가능하며 데이터 입출력 선능이 아주 빠르면서도 안전성 또한 높은 편으로 파일 서버 등의 입출력이 빈번한 업무에 적합하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/300px-RAID_5.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-6&quot;&gt;RAID 6&lt;/h2&gt;
&lt;p&gt;RAID 5와 원리는 같으며, 서로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다른 방식&lt;/code&gt;의 패리티 2개를 동시에 사용한다.&lt;br /&gt;
성능과 용량을 희생해서 가용성을 높인 셈.&lt;/p&gt;

&lt;p&gt;N개의 디스크를 사용하면 (N-2)배의 저장 공간을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/300px-RAID_6.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;nested-raid&quot;&gt;Nested RAID&lt;/h2&gt;
&lt;p&gt;레이드 볼륨의 멤버로 다른 레이드 볼륨을 사용하는 형태.&lt;br /&gt;
멤버 디스크를 묶는 배열을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하위&lt;/code&gt; 배열, 하위 배열을 묶는 배열을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상위&lt;/code&gt; 배열이라고 한다.
표기 방법은 m(하위 배열)n(상위 배열)이며 m=0이면 뒤에 +를 붙인다.&lt;/p&gt;

&lt;h3 id=&quot;raid-01&quot;&gt;RAID 0+1&lt;/h3&gt;
&lt;p&gt;RAID 0으로 스트라이핑 된 볼륨을 RAID 1로 미러링. (적어도 4개의 디스크 필요)&lt;/p&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="OS" /><summary type="html">RAID Redundant Array of Independent/Inexpensive Disks : 복수 배열 독립 디스크 여러 대의 물리적 디스크를 하나의 논리적 디스크로 인식시키는 기술 여러 개의 하드 디스크에 일부 중복된 데이터를 나눠서 저장하는 기술 = 디스크 어레이</summary></entry></feed>