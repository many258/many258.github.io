<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://many258.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://many258.github.io/" rel="alternate" type="text/html" /><updated>2021-03-24T16:16:17+09:00</updated><id>https://many258.github.io/feed.xml</id><title type="html">My LifeChronicle</title><subtitle>Be a Imagineer.</subtitle><author><name>SG Yoo.</name></author><entry><title type="html">[소프트웨어 공학] 비용 산정 방법론</title><link href="https://many258.github.io/study/software-engineering-cost-model/" rel="alternate" type="text/html" title="[소프트웨어 공학] 비용 산정 방법론" /><published>2021-03-24T00:00:00+09:00</published><updated>2021-03-24T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-cost-model%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-cost-model/">&lt;h1 id=&quot;소프트웨어-개발비용-산정기법&quot;&gt;소프트웨어 개발비용 산정기법&lt;/h1&gt;

&lt;h2 id=&quot;상향식&quot;&gt;상향식&lt;/h2&gt;
&lt;p&gt;단계별로 측정한 결과들을 모아서 총비용을 측정하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LOC 기법 (원시 코드 라인 수 : Line Of Code)&lt;br /&gt;
프로젝트의 각 기능별 라인 수를 측정(&lt;strong&gt;비관치, 기대치, 낙관치&lt;/strong&gt;)하여 비용을 산정하는 방법
    &lt;ul&gt;
      &lt;li&gt;비관치 : 기능을 코딩할 때, 가장 많이 측정된 라인 수&lt;/li&gt;
      &lt;li&gt;기대치 : 기능을 코딩할 때, 제시한 측정된 라인 수의 평균&lt;/li&gt;
      &lt;li&gt;낙관치 : 기능을 코딩할 때, 가장 적게 측정된 라인 수&lt;/li&gt;
      &lt;li&gt;예측치 : $\frac{(비관치 + 4 \cdot 기대치 + 낙관치)}{6}$&lt;/li&gt;
      &lt;li&gt;평방 편차 : $({\frac{(비관치-낙관치)}6})^2$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개발 단계별 인월 수 방법&lt;br /&gt;
LOC 기법을 보완하기 위한 방법으로, 각 기능을 구현시키는데 필요한 노력을 생명주기의 각 단계별로 산정&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;수학적-산정-기법&quot;&gt;수학적 산정 기법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Walston Felix 모형&lt;/strong&gt;&lt;br /&gt;
60여 개 개발 업체의 다양한 규모의 프로젝트 비용 측정 자료를 모아 통계적으로 분석한 &lt;strong&gt;공식&lt;/strong&gt;으로 개발 비용을 측정하는 방법&lt;br /&gt;
인월 수를 계산하는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KDSI&lt;/code&gt;(원시코드에서 주석라인, 라이브러리 루틴, 공백을 제외한 실제 수행 코드 라인 수)를 사용한다
    &lt;ul&gt;
      &lt;li&gt;COCOMO 비용 산정 공식의 모체이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;COCOMO&lt;/strong&gt;(COnstructive COst MOdel)&lt;br /&gt;
Boehm이 제시한 원시 프로그램의 규모에 의한 비용 예측 모형
변화 모형과 규모 유형이 존재한다
    &lt;ul&gt;
      &lt;li&gt;변화 모형
        &lt;ul&gt;
          &lt;li&gt;Basic : S/W 크기 + 개발 유형&lt;/li&gt;
          &lt;li&gt;Intermediate : Basic Model + 가중치&lt;/li&gt;
          &lt;li&gt;Detailed : Intermediate Model + 시스템 세분화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;규모 모형
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;Organic&lt;/strong&gt;(유기형)
            &lt;blockquote&gt;
              &lt;p&gt;인월(MM) = $2.4 \times [KDSI]^{1.05}$&lt;br /&gt;
개발기간(TDEV) = $2.5 \times [KDSI]^{0.38}$&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Semi-detached&lt;/strong&gt;(준 분리형)
            &lt;blockquote&gt;
              &lt;p&gt;인월(MM) = $3.0 \times [KDSI]^{1.12}$&lt;br /&gt;
개발기간(TDEV) = $2.5 \times [KDSI]^{0.35}$&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Embedded&lt;/strong&gt;(내재형)
            &lt;blockquote&gt;
              &lt;p&gt;인월(MM) = $3.6 \times [KDSI]^{1.20}$&lt;br /&gt;
개발기간(TDEV) = $2.5 \times [KDSI]^{0.32}$&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PUTNAM&lt;/strong&gt;&lt;br /&gt;
시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 한다&lt;br /&gt;
개발 기간이 연장될수록 프로젝트 적용 인원의 노력이 감소하므로 &lt;strong&gt;대형 프로젝트&lt;/strong&gt;의 노력 분포 산정으로 적당&lt;br /&gt;
Putnam 모형을 기초로 해서 만든 자동화 추정 도구는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SLIM&lt;/code&gt;이다&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;MM = $\frac{DSI^3}{[개발 기술 지수]^3 \times [개발 기간]^4\frac{3}{4}}$&lt;br /&gt;
LOC =  $[개발 기술 지수] \times[총인월]^{\frac{1}{3}} \times [개발 기간]^{\frac{3}{4}}$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Albrecht&lt;/strong&gt; 모형(&lt;strong&gt;기능점수, FP&lt;/strong&gt;)&lt;br /&gt;
프로젝트를 기능 별로 &lt;strong&gt;분해&lt;/strong&gt;하고 경험을 바탕으로 단순/보통/복잡한 정도에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가중치&lt;/code&gt;를 부여&lt;br /&gt;
요인별 가중치를 합산하여 총 기능점수 산출&lt;br /&gt;
총 기능점수와 영향도를 이용하여 실질 기능 점수를 구한 후 최종 비용 산정&lt;br /&gt;
FP 모형을 기초로 하여 개발된 자동화 도구는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESTIMACS&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;실질 기능 점수(FP) = $총기능점수 \times [0.65+ (0.1 \times 총영향도)]$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;하향식&quot;&gt;하향식&lt;/h2&gt;
&lt;p&gt;프로젝트의 총비용을 측정한 후 단계별로 비용을 세분화하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전문가 감정 기법
    &lt;ul&gt;
      &lt;li&gt;조직 내 경험이 많은 두명 이상의 전문가에게 비용산정 의뢰&lt;/li&gt;
      &lt;li&gt;의뢰자로부터 신뢰를 얻을 수 있다&lt;/li&gt;
      &lt;li&gt;새로운 프로젝트와 유사한 프로젝트에 대한 경험이 없을 수 있고 개인직이고 주관적일 가능성이 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;델파이 기법
    &lt;ul&gt;
      &lt;li&gt;많은 전문가의 의견을 종합 후 산정하는 방법으로 전문가 감정 기법의 단점을 보완&lt;/li&gt;
      &lt;li&gt;전문가들의 의견을 중재하는 중재자가 반드시 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">소프트웨어 개발비용 산정기법</summary></entry><entry><title type="html">[소프트웨어공학] 소프트웨어 설계</title><link href="https://many258.github.io/study/software-engineering-sw-design/" rel="alternate" type="text/html" title="[소프트웨어공학] 소프트웨어 설계" /><published>2021-03-23T00:00:00+09:00</published><updated>2021-03-23T23:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-sw-design%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-sw-design/">&lt;h1 id=&quot;설계의-기본-개념&quot;&gt;설계의 기본 개념&lt;/h1&gt;
&lt;h2 id=&quot;소프트웨어-설계-절차&quot;&gt;소프트웨어 설계 절차&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DFD, DD 분석&lt;/li&gt;
  &lt;li&gt;외부 설계&lt;br /&gt;
파일 설계, 입출력 설계 등 S/W의 내적인 기능보다는 외부적은 특성을 설계&lt;/li&gt;
  &lt;li&gt;내부 설계(기본설계)&lt;br /&gt;
S/W의 내부 설계이며 주로 모듈의 기능을 정의하거나 모듈 간의 관계를 정의하는 설계&lt;/li&gt;
  &lt;li&gt;내부 설계(상세설계)&lt;br /&gt;
모듈 내부의 알고리즘을 정의&lt;/li&gt;
  &lt;li&gt;설계 명세서&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;설계-모형&quot;&gt;설계 모형&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;문서량 기준
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;데이터(Data) 설계&lt;br /&gt;
요구분석의 자료 사전(DD, 메타 데이터)을 분석&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;구조(Architectural) 설계&lt;br /&gt;
구조도 작성(외부 설계)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;관계(Interface) 설계&lt;br /&gt;
모듈 간의 관계를 표현(기본 설계)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;절차(Procedure) 설계&lt;br /&gt;
PDL로 알고리즘을 작성(상세 설계)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;노력 기준
    &lt;ul&gt;
      &lt;li&gt;절차 설계&lt;/li&gt;
      &lt;li&gt;관계 설계&lt;/li&gt;
      &lt;li&gt;구조 설계&lt;/li&gt;
      &lt;li&gt;데이터 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;설계의-종류&quot;&gt;설계의 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;상위 설계(High-Level Design) : 아키텍처/예비 설계, 하위 설계를 위한 바탕
    &lt;ul&gt;
      &lt;li&gt;구조 설계&lt;/li&gt;
      &lt;li&gt;DB 설계&lt;/li&gt;
      &lt;li&gt;인터페이스 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하위 설계(Low-Level Design) : 시스템 수준에서의 소프트웨어 구성 컴포넌트 간의 관계
    &lt;ul&gt;
      &lt;li&gt;컴포넌트 설계&lt;/li&gt;
      &lt;li&gt;자료구조 설계&lt;/li&gt;
      &lt;li&gt;알고리즘 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구조적-설계의-원칙&quot;&gt;구조적 설계의 원칙&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;모듈화(Modularization)&lt;/strong&gt;&lt;br /&gt;
단일 기능을 갖출 수 있도록 부분적으로 묶어서 처리하는 기술&lt;br /&gt;
단위 프로그램, 함수, 서브 프로그램을 작성하기 위한 설계 기법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;추상화(Abstraction)&lt;/strong&gt;&lt;br /&gt;
세부적은 설계를 배제하고 전체 흐름과 구조를 알아볼 수 있도록 개관적인 설계부터 점차 세부적으로 진행하는 설계 기법
    &lt;ul&gt;
      &lt;li&gt;기능 추상화 : 수행의 흐름만을 정의&lt;/li&gt;
      &lt;li&gt;제어 추상화 : 선택, 반복, 분기 등의 설계를 추상화&lt;/li&gt;
      &lt;li&gt;자료 추상화 : 변수 및 레코드 등을 추상화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구조화(Structured)&lt;/strong&gt;&lt;br /&gt;
모듈을 수행하기 위한 위치나 시기를 전체 구조에 적절하게 배치시키는 설계 기법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;정보 은닉(Information Hiding)&lt;/strong&gt;&lt;br /&gt;
모듈 간의 관계성을 최소화시키는 설계 기법.(S/W 변경 용이)&lt;br /&gt;
설계상의 결정 사항들이 각 모듈 안에 숨겨져 있어 다른 모듈이 접근하거나 변경을 못한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;분할과 정복&lt;/strong&gt;&lt;br /&gt;
Bottom-Up 방식으로 작은 시스템을 개발하고, 이를 합쳐 큰 시스템을 만든다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단계적 분해&lt;/strong&gt;&lt;br /&gt;
하향식 설계에서 사용. 문제를 상위 수준에서 점증적으로 더 구체적인 하위 수준으로 분할하는 기법
    &lt;ul&gt;
      &lt;li&gt;문제를 하위 수준의 독립된 단위로 나눈다&lt;/li&gt;
      &lt;li&gt;구분된 문제의 자세한 내용은 가능한 뒤로 미룬다&lt;/li&gt;
      &lt;li&gt;점증적으로 구체화 작업을 계속한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;좋은-설계&quot;&gt;좋은 설계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;요구사항을 모두 표현(완전성)&lt;/li&gt;
  &lt;li&gt;유지보수하기 쉽고(변경이 용이) 가독성이 좋고 객관성 있게 작성&lt;/li&gt;
  &lt;li&gt;구현 관점에서 데이터/기능/행위 영역을 설명하는 완전한 그림을 제공&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모듈적이어야 하며, 두 모듈 간의 상호 의존도는 약하게 해야 한다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모듈화&quot;&gt;모듈화&lt;/h1&gt;
&lt;h2 id=&quot;모듈의-특징&quot;&gt;모듈의 특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;구현, 컴파일, 설계는 독립적으로 수행, 실행은 종속적으로 수행&lt;/li&gt;
  &lt;li&gt;다른 모듈을 호출할 수도, 호출당할 수 있다&lt;/li&gt;
  &lt;li&gt;모듈 호출 시 매개변수를 전달하거나 전달받을 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;모듈화의-장점&quot;&gt;모듈화의 장점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;단위 프로그램을 독립적으로 설계할 수 있기 때문에 설계가 용이&lt;/li&gt;
  &lt;li&gt;모듈만을 구분하면 되므로 프로그램의 복잡도를 감소&lt;/li&gt;
  &lt;li&gt;다른 모듈에 영향을 주지 않을 수 있으므로 수정이 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;공유도--제어도&quot;&gt;공유도 / 제어도&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;공유도(Fan-in)
얼마나 많은 모듈이 주어진 모듈을 호출하는가를 나타내는 척도.&lt;/li&gt;
  &lt;li&gt;제어도(Fan-out)
주어진 모듈이 호출하는 모듈의 개수&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모듈의-응집력cohesion&quot;&gt;모듈의 응집력(Cohesion)&lt;/h1&gt;
&lt;p&gt;모듈 안의 요소들이 서로 관련되어 있는 정도로 강할수록 좋은 설계(좋은 설계 순서)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;기능적(Functional)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부가 하나의 단일 기능으로 존재하는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;순차적(Sequential)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 이전의 명령어로부터 나온 출력 결과를 그 다음 명령어의 입력자료로 사용하는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;교환적(Communication)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 작업 대상이 같은 기능끼리 존재하는 경우나 동일한 입력과 출력을 사용하는 작업들이 모인 경우&lt;br /&gt;
예시) 하나의 파일을 대상으로 갱신 작업을 하는 루틴끼리 묶인 루틴&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;절차적(Procedural)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 수행 시기에 순위가 있는 기능끼리 존재하는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;시간적(Temporal)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 시간상으로 수행 시기가 같은 기능끼리 존재&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;논리적(Logical)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 같은 범주에 속하는 기능끼리 묶은 모듈.&lt;br /&gt;
유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 하나의 모듈로 형성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;우연적(Coincidental)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 뚜렷한 관계없이 묶인 경우&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모듈의-결합도coupling&quot;&gt;모듈의 결합도(Coupling)&lt;/h1&gt;
&lt;p&gt;두 모듈 간의 관계성(상호 의존성)의 척도로, 약할수록 좋은 설계(좋은 설계 순서)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;자료(Data)&lt;/strong&gt; 결합도&lt;br /&gt;
두 모듈 간의 인터페이스가 자료 요소만으로 구성된 결합도&lt;br /&gt;
Call By Value 기법으로 결합된 모듈&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구조(Stamp)&lt;/strong&gt; 결합도&lt;br /&gt;
두 모듈 간의 인터페이스로 배열이나 레코드같은 자료 구조가 전달&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제어(Control)&lt;/strong&gt; 결합도&lt;br /&gt;
호출 모듈에서 전달된 자료에 의해서 운용되는 피 호출 모듈의 관계(종속적인 관계)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;외부(Extern)&lt;/strong&gt; 결합도&lt;br /&gt;
외부 변수에 의해 영향을 받는 두 모듈이 결합된 관계. 전역 변수 관련&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;공통(Common)&lt;/strong&gt; 결합도&lt;br /&gt;
공유되는 공통 데이터 영역을 여러 모듈이 사용하는 모듈 관계.&lt;br /&gt;
Call By Referrence, 메모리 번지의 공유&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;내용(Content)&lt;/strong&gt; 결합도&lt;br /&gt;
모듈이 다른 모듈 내부 기능 및 그 내부 자료를 참조하는 형태의 결합&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;구조적-설계-표기법&quot;&gt;구조적 설계 표기법&lt;/h1&gt;
&lt;h2 id=&quot;n-snassi-schneiderman-chart&quot;&gt;N-S(Nassi-Schneiderman) Chart&lt;/h2&gt;
&lt;p&gt;IBM사에 의해 개발되었으며 입출력 자료와 소프트웨어 모듈들 사이의 관계를 표현하는 뛰어난 능력을 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;고려사항
    &lt;ul&gt;
      &lt;li&gt;도표는 항상 직사각형&lt;/li&gt;
      &lt;li&gt;도표의 제어 흐름은 맨 위에서 시작&lt;/li&gt;
      &lt;li&gt;제어 흐름은 위에서 아래로 흐른다(하향식)&lt;/li&gt;
      &lt;li&gt;수평으로 그어진 줄은 모두 평행이 되어야 한다&lt;/li&gt;
      &lt;li&gt;사각형 안의 내용이 수행된 후에는 아래 방향으로 빠져나온다&lt;/li&gt;
      &lt;li&gt;사각형에 빈 공간이 있을 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/sw-engineering/n-s-chart.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;논리적 기술에 중점을 둔 도형을 이용한 표현 방법&lt;/li&gt;
      &lt;li&gt;연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현&lt;/li&gt;
      &lt;li&gt;임의의 제어 이동이 어렵다&lt;/li&gt;
      &lt;li&gt;상자 도표라고도 하며 프로그램으로 구현이 쉽다&lt;/li&gt;
      &lt;li&gt;조건이 복합된 곳의 처리를 시각적으로 명확히 식별하는데 적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hipohierarchy-plus-input-process-output&quot;&gt;HIPO(Hierarchy plus Input Process Output)&lt;/h2&gt;
&lt;p&gt;IBM에서 개발한 방법으로 프로그램을 기능 위주로 문서화하는 하향식 설계 기법.&lt;/p&gt;

&lt;p&gt;입력/처리/출력으로 구성되어 시각적으로 알아보기 쉽게 표현할 수 있으며 구조화된 방법으로 구현될 수 있도록 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;도식 목차(가시적 도표, Visual Table of Contents)&lt;br /&gt;
전체적인 흐름과 구조를 나타내는 도표&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;총괄 도표(총체적 도표, Overview Diagram)&lt;br /&gt;
입력/처리/출력 등의 기능을 명확히 표현한 도표(&lt;strong&gt;사용자관점&lt;/strong&gt;)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;상세 도표(세부적 도표, Detail Diagram)&lt;br /&gt;
총괄 도표의 일부 기능을 구체적으로 표현한 모듈 도표(&lt;strong&gt;개발자관점&lt;/strong&gt;)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;분석 및 설계 도구로 사용&lt;/li&gt;
      &lt;li&gt;하향식(Top-Down) 개발에 적당&lt;/li&gt;
      &lt;li&gt;수정 및 유지보수가 용이&lt;/li&gt;
      &lt;li&gt;소규모 프로젝트에 적합&lt;/li&gt;
      &lt;li&gt;기능과 자료의 관계를 동시에 표현할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;설계-방법론&quot;&gt;설계 방법론&lt;/h1&gt;
&lt;h2 id=&quot;구조적-설계-방법론&quot;&gt;구조적 설계 방법론&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기본구조
    &lt;ul&gt;
      &lt;li&gt;순차(Sequence) 구조&lt;/li&gt;
      &lt;li&gt;선택(Condition) 구조&lt;/li&gt;
      &lt;li&gt;반복(Repetition) 구조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;단일 입출력으로 처리&lt;/li&gt;
      &lt;li&gt;실행 효율성을 중시할 때 한정된 범위 내에서 GOTO문을 사용&lt;/li&gt;
      &lt;li&gt;프로그램의 이해가 쉽고 유지보수와 검증이 용이&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자료-흐름-중심-설계-방법론&quot;&gt;자료 흐름 중심 설계 방법론&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;자료 흐름 설계 과정
    &lt;ul&gt;
      &lt;li&gt;정보 &lt;strong&gt;흐름의 유형&lt;/strong&gt;을 설정&lt;/li&gt;
      &lt;li&gt;흐름의 &lt;strong&gt;경계&lt;/strong&gt;(Flow Boundaries)를 표시&lt;/li&gt;
      &lt;li&gt;자료 흐름도를 프로그램 구조로 &lt;strong&gt;사상&lt;/strong&gt; → &lt;strong&gt;변환 사상&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;제어 계층을 분해&lt;/strong&gt;시켜서 정의&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;경험적 방법&lt;/strong&gt;을 구체화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;변환 사상(Transform Mapping)&lt;/strong&gt;&lt;br /&gt;
변환 흐름에 특성을 갖는 &lt;strong&gt;DFD(Data Flow Diagram)&lt;/strong&gt; 을 전체 혹은 일부를 분할해서 &lt;strong&gt;구조도&lt;/strong&gt;로 변화하는 작업&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자료-구조-중심-설계-방법론&quot;&gt;자료 구조 중심 설계 방법론&lt;/h2&gt;
&lt;p&gt;입출력 자료의 구조 파악으로 소프트웨어 구조를 추출&lt;/p&gt;

&lt;h3 id=&quot;dssd-방법론-warnier-orr-기법&quot;&gt;DSSD 방법론 (Warnier-Orr 기법)&lt;/h3&gt;
&lt;p&gt;Warnier가 개발한 LCP(Logical of Program)를 Orr와 공동으로 개발한 자료 구조 지향 설계 방법으로 출력 자료를 중심으로 입력 자료를 설계하고 제어 구조도 설계하는 방법&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;출력 자료 정의 : 출력할 자료를 파악하여 배열&lt;/li&gt;
  &lt;li&gt;논리적 레코드 정의 : 출력할 레코드의 구조를 정의&lt;/li&gt;
  &lt;li&gt;사건 분석 : 출력할 레코드 항목을 기준으로 입력 항목을 정의&lt;/li&gt;
  &lt;li&gt;물리적 레코드 정의 : 입력할 레코드의 구조를 정의&lt;/li&gt;
  &lt;li&gt;논리적 절차 정의 : 입력/처리/출력 모듈로 구분하여 Warnier-Orr 도표를 그림&lt;/li&gt;
  &lt;li&gt;물리적 절차 정의 : 명시된 도표를 보고 알고리즘 기술&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;jsd-방법론-jackson-기법&quot;&gt;JSD 방법론 (Jackson 기법)&lt;/h3&gt;
&lt;p&gt;프로그램의 입력과 출력 자료의 구조를 대응시켜서 설계하는 자료 구조 지향 설계 방법론으로 자료 구조를 정의하면서 제어 구조를 유도하는 방식&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;자료 구조 정의&lt;br /&gt;
입출력 구조를 정의하여 일치되지 않는 부분을 처리 루틴으로 모듈화하고 일치하는 부분은 입력과 출력 루틴으로 모듈화&lt;/li&gt;
  &lt;li&gt;구조도 작성&lt;br /&gt;
입력/처리/출력으로 분류하여 잭슨 표기법으로 구조도를 세분화하여 작성&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;연산 목록 작성&lt;br /&gt;
  구조도를 보고 필요한 제어 구조 명시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;구조문 작성&lt;br /&gt;
  명시된 제어 구조를 보고 알고리즘 기술&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;소프트웨어-설계-solid-원칙&quot;&gt;소프트웨어 설계 SOLID 원칙&lt;/h1&gt;
&lt;h2 id=&quot;single-responsibility-priciple단일-책임-원칙--srp&quot;&gt;Single Responsibility Priciple(단일 책임 원칙 : SRP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;소프트웨어의 설계 부품은 반드시 한 개의 책임을 가져야 한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;책임 대신 기능이라 해석해도 무방하다.&lt;/p&gt;

&lt;h2 id=&quot;open-closed-principle개방-폐쇠-원칙--ocp&quot;&gt;Open-Closed Principle(개방 폐쇠 원칙 : OCP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;한 번 설계가 되고 단위 테스트가 완료된 객체는 향후 외부에 변경 사항이 발생하더라도 객체 자체는 변경되지 않아야 한다는 것을 의미&lt;/p&gt;

&lt;h2 id=&quot;liskov-substitution-principle리스코프-치환-원칙--lsp&quot;&gt;Liskov Substitution Principle(리스코프 치환 원칙 : LSP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;자식 클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MIT 컴퓨터 사이언스 교수인 리스코프가 제안한 설계 원칙으로 상속관계에 있는 두 객체에 있어서 부모 클래스의 인스턴스가 사용된 자리에 자식 클래스의 인스턴스를 넣어도 &lt;strong&gt;코드의 맥락이 변하지 않아야&lt;/strong&gt; 한다는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;자식 클래스가 부모 클래스를 대체하기 위해서는 부모의 기능에 대해 오버라이드되지 않도록 하면 된다. 즉, 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않과 &lt;strong&gt;확장만 수행&lt;/strong&gt;하도록 해야 LSP를 만족하게 된다.&lt;/p&gt;

&lt;p&gt;LSP의 만족 여부는 [자식 클래스 &lt;strong&gt;is a kind of&lt;/strong&gt; 부모 클래스]의 참/거짓으로 간단히 파악이 가능&lt;/p&gt;

&lt;h2 id=&quot;interface-segregation-principle인터페이스-분리-원칙--isp&quot;&gt;Interface Segregation Principle(인터페이스 분리 원칙 : ISP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;객체 자신이 사용하지 않을 인터페이스는 구현하면 안된다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 자신이 &lt;strong&gt;사용하지 않는 기능에는 영향을 받지 말아야 한다&lt;/strong&gt;는 것을 의미한다&lt;/p&gt;

&lt;p&gt;가능한 경우라면, 범용 인터페이스를 구현하는 것보다 객체에 &lt;strong&gt;특화된 인터페이스를 분리&lt;/strong&gt;해내어 구현한다.&lt;/p&gt;

&lt;h2 id=&quot;dependency-inversion-principle의존-역전-원칙--dip&quot;&gt;Dependency Inversion Principle(의존 역전 원칙 : DIP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;의존 관계를 맺을 때, 변화하기 쉬운 것(구체화)보다 변화하기 어려운 것(추상화)에 의존해야 한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;구체적인 클래스보다 &lt;strong&gt;추상성이 높은 인터페이스나 추상클래스와 관계&lt;/strong&gt;를 맺는다는 것을 의미. 일반적으로 Interface를 활용 시 이 원칙을 준수할 수 있다.&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">설계의 기본 개념 소프트웨어 설계 절차 DFD, DD 분석 외부 설계 파일 설계, 입출력 설계 등 S/W의 내적인 기능보다는 외부적은 특성을 설계 내부 설계(기본설계) S/W의 내부 설계이며 주로 모듈의 기능을 정의하거나 모듈 간의 관계를 정의하는 설계 내부 설계(상세설계) 모듈 내부의 알고리즘을 정의 설계 명세서 설계 모형 문서량 기준 데이터(Data) 설계 요구분석의 자료 사전(DD, 메타 데이터)을 분석</summary></entry><entry><title type="html">[데이터보안] 재해복구시스템(DRS:Disater Recovery System)</title><link href="https://many258.github.io/study/disaster-recovery-system/" rel="alternate" type="text/html" title="[데이터보안] 재해복구시스템(DRS:Disater Recovery System)" /><published>2021-03-22T00:00:00+09:00</published><updated>2021-03-22T20:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdisaster-recovery-system%7D</id><content type="html" xml:base="https://many258.github.io/study/disaster-recovery-system/">&lt;h1 id=&quot;재해복구시스템drs--disaster-recovery-system&quot;&gt;재해복구시스템(DRS : Disaster Recovery System)&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/DRS/disaster-recovery-system-intro.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;천재지변이나 해킹 등 각종 재난/재해로 인해 IT 인프라에 장애가 발생하여 제 기능을 수행하지 못하게 되었을 경우, 서비스 연속성을 보장하기 위해 이를 대체하거나 복구하여 제 기능을 수행할 수 있도록 하는 시스템&lt;/p&gt;

&lt;p&gt;재해복구 대책에 대한 법적인 규제 추세(금융감독원 권고안 발표)이다&lt;/p&gt;

&lt;h2 id=&quot;구성-요소&quot;&gt;구성 요소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;BIA(Business Impact Analysis)&lt;br /&gt;
재해가 비지니스에 영향을 미치는 정도를 분석하는 작업&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DOMAIN&lt;br /&gt;
영향도 별 그룹화(복구 우선순위 별 그룹화)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RTO(Recovery Time Object)&lt;br /&gt;
재해 상황에서 서비스가 복구되어야 할 최대 시간&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RPO(Recovery Point Objective)&lt;br /&gt;
재해 상황에서 수용할 수 있는 최대 허용 데이터 손실&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DR 센터 선정&lt;br /&gt;
주 센터와 복구 센터 위치 선정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;백업 방안&lt;br /&gt;
Hot Standby, DB Shadowing, 원격 백업, OS 백업, 단순백업&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;운영 방안&lt;br /&gt;
조직체계, 평상시/재해시 운영절차, 모의 훈련 절차&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기술적-요소&quot;&gt;기술적 요소&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/images/security/DRS/disaster-recovery-system.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;HA&lt;/strong&gt;(&lt;strong&gt;고가용성&lt;/strong&gt; : High Availability)&lt;br /&gt;
서버와 네트워크 등의 정보 시스템이 지속적으로 정상 운영이 가능한 성질&lt;br /&gt;
2개의 서버 중 1대의 서버에서 장애가 발생하면 다른 서버가 대처&lt;br /&gt;
레이드(RAID) 방식과 샌(SAN) 방식을 주로 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;결함 허용&lt;/strong&gt;(FT)&lt;br /&gt;
시스템을 구성하는 푸품의 일부에서 결함(Fault) 또는 고장(Failure)이 발생하여도 정상적 혹은 부분적으로 기능을 수행할 수 있는 시스템&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SAN&lt;/strong&gt;(Storage Area Network)&lt;br /&gt;
대량의 데이터를 집중시켜 보관하고 이를 구성하는 장비들을 이용, 공유하여 사용할 수 있도록 하는 기술.&lt;br /&gt;
다만, 별도의 Fibre Channel 네트워크를 구성해야 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IP-SAN&lt;/strong&gt;&lt;br /&gt;
기존의 TCP/IP 망을 그대로 이용하여 별도의 Fibre Channel 네트워크를 구성해야하는 기존 SAN의 단점을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보완&lt;/code&gt;, 속도는 크게 떨어지지 않는 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fibre Channel&lt;/strong&gt;(파이버 채널 : FC)&lt;br /&gt;
주로 스토리지 네트워킹에 쓰이는 기가 비트 속도의 네트워크 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;WDM&lt;/strong&gt;(파장 분할 다중화 :Wavelength Division Multiplexing)&lt;br /&gt;
한 가닥의 광섬유에 여러 채널을 통해 파장을 동시에 전송하는 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DWDM&lt;/strong&gt;(Dense WDM)&lt;br /&gt;
일정 파장 대역에 걸쳐  수십, 수백개의 파장의 광 신호를 동시에 변조시켜서 하나의 광섬유를 통해 전송하는 WDM의 발전된 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CWDM&lt;/strong&gt;(Coarse WDM)&lt;br /&gt;
DWDM과 유사하나, 파장 간격이 보다 넓고(~10nm 이상) 광증폭기를 잘 사용하지 않는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단거리&lt;/code&gt; 전송에 주로 사용&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;재해복구-구축-절차&quot;&gt;재해복구 구축 절차&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;업무 영향 분석&lt;br /&gt;
&lt;strong&gt;BIA, DOMAIN, RTO, RPO&lt;/strong&gt; 등의 적용과정&lt;br /&gt;
재해로 인한 핵심 프로그램 들의 가동 중단 시 파급영향 분석 및 그에 따른 복구 우선순위를 설정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;재해복구 전략 수립&lt;br /&gt;
대상 별 복구 전략, 복구 솔루션 선전 및 재해복구센터 선정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;시스템 구축 및 복구 계획 수립&lt;br /&gt;
재해복구 시스템 구축 및 업무와 전산시스템의 복구를 위한 상세 계획 수립&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;운영 및 모의 훈련&lt;br /&gt;
수립된 계획의 주기적 테스트를 통한 미비점 파악 및 보완&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;계획-수립-시-고려사항&quot;&gt;계획 수립 시 고려사항&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RSO&lt;/strong&gt;(복구 목표 대상/범위 : Recovery Scope Objective)&lt;br /&gt;
정보의 중요성과 복구 우선순위 지정의 기본 지표가 된다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RTO&lt;/strong&gt;(복구 목표 시간 : Recovery Time Objective)&lt;br /&gt;
시스템 복구까지 허용할 수 있는 최대 시간&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RPO&lt;/strong&gt;(복구 목표 지점 : Recovery Point Objective)&lt;br /&gt;
목표 복구 시점, 데이터 손실을 시간으로 환산한 개념&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RCO&lt;/strong&gt;(통신 복구 목표 : Recovery Communications Objective)&lt;br /&gt;
네트워크 복구 수준&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BCO&lt;/strong&gt;(목표 백업 센터 : Backup Center Objective)&lt;br /&gt;
백업 센터 구축 및 관리 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구축-형태&quot;&gt;구축 형태&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;독자구축&lt;/strong&gt;&lt;br /&gt;
단일 기관 전용의 DRS를 독자적으로 구축&lt;br /&gt;
보안 유지 및 복구의 신뢰성이 가장 높음&lt;br /&gt;
구축 및 유지비용이 가장 많이 소요&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;공동구축&lt;/strong&gt;&lt;br /&gt;
두 개 이상의 기관이 DRS를 공동으로 구축 및 이용&lt;br /&gt;
비교적 적은 구축 및 유지비용&lt;br /&gt;
보안 및 운용 측면에서 고려할 사항이 많고, 광역재해 발생 시 공동이용기관간의 동시 재해복구 불가&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;상호구축&lt;/strong&gt;&lt;br /&gt;
단일 기관의 여러 개 사이트 또는 두 개 이상 기관의 사이트 상호간 DRS의 역할을 수행&lt;br /&gt;
가장 적은 구축 및 유지 비용&lt;br /&gt;
상호 기관 작업에 종속&lt;br /&gt;
서로 다른 기관간의 보안성 및 재해복구에 대한 신뢰성이 낮음&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;외부위탁&lt;/strong&gt;&lt;br /&gt;
재해 복구 전문 서비스 업체에 위탁하여 운영&lt;br /&gt;
전문기술 지원 가능&lt;br /&gt;
정보 유출, 보안 및 신뢰성 문제&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시스템-구성요소-별-복제방식&quot;&gt;시스템 구성요소 별 복제방식&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;H/W (Disk) 복제&lt;/strong&gt;&lt;br /&gt;
디스크 간 복제&lt;br /&gt;
안정성/고성능, 높은비용&lt;br /&gt;
Shadow Copy, True Copy&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;S/W (OS) 복제&lt;/strong&gt;&lt;br /&gt;
OS 수준 솔루션&lt;br /&gt;
안정성/효율성, 비교적 낮은 비용&lt;br /&gt;
Shareplex, Oracle Golden Gate&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;S/W (DBMS) 복제&lt;/strong&gt;&lt;br /&gt;
DBMS 기능 기용&lt;br /&gt;
안정성/효율성, 비교적 낮은 비용&lt;br /&gt;
Orcle RAC&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-동기화-기법&quot;&gt;데이터 동기화 기법&lt;/h2&gt;
&lt;h3 id=&quot;스토리지-데이터-복제-방식&quot;&gt;스토리지 데이터 복제 방식&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Active-Active 스토리지 방식&lt;/strong&gt;&lt;br /&gt;
동기방식으로 스토리지 1, 2가 하나의 저장공간으로 ㄷ오작하며 웹서버1(Active), 웹서버2(Active)가 각각 로컬 스토리지에 Write/Read가 가능&lt;/p&gt;

&lt;p&gt;구성 시 CWDM/DWDM으로 구현, 지연시간에 따라 센터간 50KM이내 권장&lt;/p&gt;

&lt;h3 id=&quot;스토리지-데이터-동기-복제-기법&quot;&gt;스토리지 데이터 동기 복제 기법&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;실시간 동기 방식&lt;/strong&gt;(Synchronous Data Replication)&lt;br /&gt;
서버가 로컬 스토리지에 저장 시 원격 스토리지에도 저장 후 응답을 받고 나서 서버에게 최종 응답을 전달 - Zero RPO, 거리 제약(50Km ~ 300Km)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동기 복제&lt;/code&gt; : SCSI(FC)는 한 번 동작이 메시지를 2차례를 주고 받는다.
즉, 50KM 거리에서 SCSI 한 번 동작 시 1ms 지연 발생&lt;/p&gt;

&lt;h3 id=&quot;스토리지-데이터-비동기-복제-기법&quot;&gt;스토리지 데이터 비동기 복제 기법&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;비동기 방식&lt;/strong&gt;(Asynchronous Data Replication)&lt;br /&gt;
서버가 로컬 스토리지에 저장 이후 리모트 스토리지에 저장 - 거리 제약 없음&lt;/p&gt;

&lt;h2 id=&quot;수준별-유형&quot;&gt;수준별 유형&lt;/h2&gt;
&lt;h3 id=&quot;미러사이트mirror-site&quot;&gt;미러사이트(Mirror Site)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주 센터와 동일한 수준의 정보기술자원을 원격지에 구축, Active Active 상태로 실시간 동시 서비스 제공&lt;/li&gt;
  &lt;li&gt;복구소요시간(RTO) : 즉시&lt;/li&gt;
  &lt;li&gt;데이터 최신성, 높은 안정성, 신속한 업무 재개&lt;/li&gt;
  &lt;li&gt;높은 초기투자비용, 높은 유지보수 비용, 데이터 업데이트가 많은 경우 과부하 야기&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;핫사이트hot-site&quot;&gt;핫사이트(Hot Site)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주센터와 동일한 수준의 정보기술자원을 원격지에 구축 후 Active Stanby 상태로 유지&lt;/li&gt;
  &lt;li&gt;재해 발생 시 Active 상태로 전환&lt;/li&gt;
  &lt;li&gt;데이터는 동기적 또는 비동기적 방식으로 실시간 미러링을 통하여 최신상태 유지&lt;/li&gt;
  &lt;li&gt;복구소요시간(RTO) : 수 시간 이내&lt;/li&gt;
  &lt;li&gt;데이터 최신성, 높은 안정성, 신속한 업무 재개, 데이터 업데이트가 많은 경우 적합&lt;/li&gt;
  &lt;li&gt;높은 초기투자비용, 높은 유지보수비용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;웜사이트warm-site&quot;&gt;웜사이트(Warm Site)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;중요성이 높은 정보기술자원만 부분적으로 재해복수센터에 보유&lt;/li&gt;
  &lt;li&gt;데이터는 주기적으로 백업&lt;/li&gt;
  &lt;li&gt;복구소요시간(RTO) : 일 단위 ~ 주 단위&lt;/li&gt;
  &lt;li&gt;구축 및 유지비용이 핫사이트에 비해 저렴&lt;/li&gt;
  &lt;li&gt;데이터 손실 다소 발생, 초기복구수준이 부분적, 복구소요시간이 길다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;콜드사이트cold-site&quot;&gt;콜드사이트(Cold Site)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터만 원격지에 보관하고 이의 서비스를 위한 정보자원은 확보하지 않거나 장소 등 최소한으로 확보&lt;/li&gt;
  &lt;li&gt;재해 발생 시 데이터를 근간으로 필요한 정보자원을 조달하여 정보시스템의 복구 개시&lt;/li&gt;
  &lt;li&gt;데이터는 주기적으로 원격지에 백업&lt;/li&gt;
  &lt;li&gt;복구소요시간(RTO) : 주 단위 ~ 달 단위&lt;/li&gt;
  &lt;li&gt;구축 및 유지비용이 가장 저렴&lt;/li&gt;
  &lt;li&gt;데이터 손실 발생, 복구에 매우 긴 시간 소요, 복구 신뢰성이 낮다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;drs-도입-효과&quot;&gt;DRS 도입 효과&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;재무적 관점&lt;/strong&gt;&lt;br /&gt;
ROI, TCO&lt;br /&gt;
서비스 연속성을 통한 투자 대비 효과&lt;br /&gt;
비용 증가 대비 가시성 효과 증대&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;고객 관점&lt;/strong&gt;&lt;br /&gt;
위험 대비 체계적 고품질 서비스&lt;br /&gt;
서비스 안정화로 고객 만족&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로세스 관점&lt;/strong&gt;&lt;br /&gt;
서비스 안정성 기반 생산성 증대&lt;br /&gt;
체계적 관리로 업무 효율성 향상&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;bcpbusiness-continuous-planning과의-비교&quot;&gt;BCP(Business Continuous Planning)과의 비교&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;구분&lt;/th&gt;
      &lt;th&gt;DRS&lt;/th&gt;
      &lt;th&gt;BCP&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;적용시점&lt;/td&gt;
      &lt;td&gt;재해 사후&lt;/td&gt;
      &lt;td&gt;재해 사전/후(평시, 비상시 연속)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;목적&lt;/td&gt;
      &lt;td&gt;정보시스템 인프라와 사업 운영에 필수적인 정보자산의 복구를 촉직하기 위한 상세한 절차를 제공&lt;/td&gt;
      &lt;td&gt;심각한 중단 상황에서 복구가 진행되는 동안에 필수적인 사업을 유지하기 위한 절차를 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;범위&lt;/td&gt;
      &lt;td&gt;IT서비스 중심. BIA에 따른 RTO, RPO를 고려한 서버, 스토리지, 네트워크 구축&lt;/td&gt;
      &lt;td&gt;실제의 업무 프로세스와 업무 프로세스를 지원하기 위한 IT 영역에 집중&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;실행 주체&lt;/td&gt;
      &lt;td&gt;정보시스템 부서가 절차중심으로 수행&lt;/td&gt;
      &lt;td&gt;각 비지니스 부서가 계획중심으로 수행&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;대상&lt;/td&gt;
      &lt;td&gt;IT운영팀을 중심으로 운영시설을 사업단위 중심으로 수행&lt;/td&gt;
      &lt;td&gt;업무는 물론 사람, 물리적 사무공간, 중요 문서등을 포함하여 사전에 준비하기 어려운 수많은 항목이 대상&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;구축 결과물&lt;/td&gt;
      &lt;td&gt;DRP(Disaster Recovery Plan)과 사전 계획 문서&lt;/td&gt;
      &lt;td&gt;재해복구계획, 업무복구계획, 대체프로세스계획, 업무비상계획&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;레퍼런스&quot;&gt;레퍼런스&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.skby.net/drs-disaster-recovery-system/&quot;&gt;도리의 디지털 라이프&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.naver.com/seilius/130189038043&quot;&gt;바보상자의 개발 블로그&lt;/a&gt;&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="데이터 보안" /><summary type="html">재해복구시스템(DRS : Disaster Recovery System)</summary></entry><entry><title type="html">[프로그래밍] 함수형 프로그래밍</title><link href="https://many258.github.io/study/functional-programming/" rel="alternate" type="text/html" title="[프로그래밍] 함수형 프로그래밍" /><published>2021-03-22T00:00:00+09:00</published><updated>2021-03-23T22:37:34+09:00</updated><id>https://many258.github.io/study/%7Bfunctional-programming%7D</id><content type="html" xml:base="https://many258.github.io/study/functional-programming/">&lt;h1 id=&quot;함수형-프로그래밍&quot;&gt;함수형 프로그래밍&lt;/h1&gt;
&lt;p&gt;함수의 동작에 의한 변수의 부수적인 값 변경을 원천 배제함으로써 오류를 방지하는 패러다임&lt;/p&gt;

&lt;p&gt;함수 내부에 상태가 존재하지 않으며, 함수의 출력 값은 항상 함수의 입력 값의 영향만 받는다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;높은 표현력을 통해 불필요한 코드를 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;함수형 프로그래밍의 언어군은 프로그래밍 언어론의 최신 연구 결과를 반영하고 있다&lt;/li&gt;
  &lt;li&gt;불변성(Immutability)으로 인해 다양한 최적화 및 검증이 용이&lt;/li&gt;
  &lt;li&gt;이전에 계산한 함수의 값을 캐싱해 두었다가 필요할 때 다시 사용하는 메모이제이션이 가능&lt;/li&gt;
  &lt;li&gt;함수형 프로그래밍 언어에서는 변경 가능한 상태를 원천적으로 배제하기 때문에 멀티프로세서, 멀티스레드 환경에서 동작하는 동시성 프로그램을 개발할 때 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대표 함수형 프로그래밍 언어 : &lt;strong&gt;Scala, LISP, Haskell, F#, Erlang&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;일급-객체&quot;&gt;일급 객체&lt;/h2&gt;
&lt;p&gt;다음 조건을 만족하면 일급 객체라고 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;변수나 데이터에 할당할 수 있어야 한다&lt;/li&gt;
  &lt;li&gt;객체의 인자로 넘길 수 있어야 한다&lt;/li&gt;
  &lt;li&gt;객체의 리턴값으로 리턴할 수 있어야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, 객체처럼 동작할 수 있는 함수를 지칭한다&lt;/p&gt;

&lt;h2 id=&quot;순수-함수&quot;&gt;순수 함수&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;항상 같은 인풋에는 항상 같은 아웃풋(멱등성, 참조 투명성)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;외부의 인자를 변화시키지 않고 최대한 지역변수만을 사용해서 구현되는 함수&lt;/p&gt;

&lt;h2 id=&quot;고차-함수--고계-함수&quot;&gt;고차 함수 = 고계 함수&lt;/h2&gt;
&lt;p&gt;함수를 값이라 생각하고 &lt;strong&gt;함수를 인자값&lt;/strong&gt;으로 넣어주는 형태&lt;/p&gt;

&lt;p&gt;인자로 다른 함수를 받아 결과값을 내보내는 함수를 의미&lt;/p&gt;

&lt;h2 id=&quot;커링&quot;&gt;커링&lt;/h2&gt;
&lt;p&gt;여러 인자를 받는 함수에 &lt;strong&gt;일부 인자만&lt;/strong&gt; 넣어서 나머지 인자를 받는 다른 함수를 만들어낼 수 있는 함수형 프로그래밍 기법을 의미&lt;/p&gt;

&lt;h2 id=&quot;함수-합성&quot;&gt;함수 합성&lt;/h2&gt;
&lt;p&gt;함수형 프로그래밍을 위한 라이브러리들에는 컬렉션 내 요소들을 다양하게, 연속적으로 처리할 수 있는 많은 도구&lt;/p&gt;

&lt;p&gt;새로운 함수를 생성하거나 어떤 계산을 수행하기 위해 &lt;strong&gt;둘 이상의 함수를 결합&lt;/strong&gt;하는 프로세스이다&lt;/p&gt;

&lt;h2 id=&quot;재귀와-꼬리-재귀-최적화&quot;&gt;재귀와 꼬리 재귀 최적화&lt;/h2&gt;

&lt;h2 id=&quot;모나드monad&quot;&gt;모나드(Monad)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;모나드는 값을 캡슐화하고, 추가 기능을 더해 새로운 타입을 생성하는 구조체&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모나드는 하나의 타입이며 인자를 Type 타입으로 받아 값을 캡슐화하여 값을 가공할 수 있는 추가기능 오퍼레이터를 사용할 수 있는 Functor를 사용하여 최종적으로 이러한 프로세스를 구현하는 구조를 새롭게 생성하는 특징을 가지고 있다.&lt;/p&gt;

&lt;p&gt;다음 세 가지를 충족하면 모나드라 할 수 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;타입을 인자로 받는 타입&lt;/li&gt;
  &lt;li&gt;unit(return) 오퍼레이터가 있어야 한다&lt;/li&gt;
  &lt;li&gt;bind 오퍼레이터가 있어야 한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;모나드가 필요한 이유 ? &lt;br /&gt;
비동기 연산 처리, NULL 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;br /&gt;
컬렉션의 원소를 순회하는 방법의 의미보다&lt;br /&gt;
&lt;strong&gt;T 타입의 Functor를 R 타입의 Functor로 바꾸는 기능&lt;/strong&gt;이라고 생각하는 중요!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;flatMap&lt;/strong&gt;&lt;br /&gt;
위 맵의 역할을 하지만 캡슐화가 된 자료구조를 Serialize했다고 생각하면 편하다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.function.Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;함수를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;인자를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;받는&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;메소드만&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;가진다&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;인자&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;가짐&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;전달인자인&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;함수&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f는&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;값을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;받아&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;값을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환하는&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;함수&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor는&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map함수를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;거쳐&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입의&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;map메소드로 값을 변경하는 것 뿐인데 왜 Functor를 사용할까?&lt;br /&gt;
=&amp;gt; Functor를 이용하면 &lt;strong&gt;일반적으로 모델링할 수 없는 상황을 모델링 할 수 있다&lt;/strong&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;타입안정성을 유지하면서 NULL을 인코딩하는 방법&lt;/li&gt;
  &lt;li&gt;아직 값을 가지고 있지 않아도 동일하게 map 메소드를 적용할 수 있음
(문법적으로나 의미적으로 완전 동일)&lt;/li&gt;
  &lt;li&gt;비동기 로직을 동기 로직을 구현하는 것과 동일한 형태로 구현하면서도, 함수의 합성 및 완전한 Non-Blocking Pipeline을 구현 가능&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Functor의 문제점&lt;br /&gt;
=&amp;gt; Functor가 Functor안에 감싸져 있으면, 함수의 합성과 체이닝을 저해하므로 제 기능을 하지 못하게 될 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Monad = Functor + flatMap&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;{&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;지연-연산lazy-evaluation&quot;&gt;지연 연산(Lazy Evaluation)&lt;/h2&gt;
&lt;p&gt;어떤 값이 실제로 쓰이기 전까지 그 값의 계산을 최대한 연기하는 것을 의미.&lt;/p&gt;

&lt;p&gt;값을 미리 계산하여 저장하지 않기때문에 공간을 절약할 수 있고 값이 꼭 필요할 때만 계산하기 때문에 프로그램 성능에도 긍정적인 영향을 준다.&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="Programming" /><summary type="html">함수형 프로그래밍 함수의 동작에 의한 변수의 부수적인 값 변경을 원천 배제함으로써 오류를 방지하는 패러다임</summary></entry><entry><title type="html">[알고리즘/데이터보안] 블록체인(Block-Chain)</title><link href="https://many258.github.io/study/block-chain/" rel="alternate" type="text/html" title="[알고리즘/데이터보안] 블록체인(Block-Chain)" /><published>2021-03-21T00:00:00+09:00</published><updated>2021-03-22T15:37:34+09:00</updated><id>https://many258.github.io/study/%7Bblock-chain%7D</id><content type="html" xml:base="https://many258.github.io/study/block-chain/">&lt;h1 id=&quot;블록-체인&quot;&gt;블록 체인&lt;/h1&gt;
&lt;p&gt;관리 대상 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블록&lt;/code&gt;이라고 하는 소규모 데이터들이 P2P방식을 기반으로 모여 이룬 체인 연결고리 분산 데이터 저장 환경&lt;/p&gt;

&lt;p&gt;즉, 네트워크에 중앙 서버가 아닌 참여하는 모든 사용자가 모든 거래 내역 등을 공동으로 기록, 관리하여 데이터를 분산, 저장하는 기술을 의미&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/block-chain.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;
&lt;p&gt;편집이 불가능하고 추가 작업(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APPEND&lt;/code&gt;)만 가능한 데이터베이스&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;탈중앙화&lt;/code&gt;(Decentralization) 데이터베이스의 복제본을 모두가 소유하고 있기 때문에 개인의 위조를 방지할 수 있다&lt;/p&gt;

&lt;h2 id=&quot;블록의-구성&quot;&gt;블록의 구성&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/block-chain-element.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; width=&quot;120%&quot; height=&quot;120%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;블록 헤더&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;블록의 정체성
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;비전&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;이전블록의 해시&lt;/strong&gt; : 현재 블록이 이전 블록과 연결되어 있음을 의미&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;타임스탬프&lt;/strong&gt; : 채굴 경쟁과 직접적 연관이 있는 부분&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;난이도 목표&lt;/strong&gt; : 채굴 경쟁과 직접적 연관이 있는 부분&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;논스&lt;/strong&gt;: 채굴 경쟁과 직접적 연관이 있는 부분&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;머클루트&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;거래 카운터&lt;/strong&gt; : 거래의 개수&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;거래&lt;/strong&gt; : 블록에 기록된 거래 내역&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해시&quot;&gt;해시&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/hash-algorithm.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;단방향 암호화, 결정론적&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;임의의 길이를 갖는 문자열을 입력받아 &lt;strong&gt;고정된 길이&lt;/strong&gt;의 해시 값을 출력하는 함수를 해시 함수라 하는데 이 함수로 인해서 출력된 값을 해쉬 값이라 부른다. 이 때 해쉬 값으로부터 기존 메시지를 역산할 수는 없는 성질을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단방향성&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;또한, 메시지가 다르면 비슷하다 할지라도 해시값도 다르다는 특징이 있는데 해당 특징으로 인해 해시 함수를 무결성을 확인하기 위한 방안으로 사용하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결정론적&lt;/code&gt;이다라는 의미는 해시 알고리즘은 특정 입력 대해 항상 같은 해시 값을 반환한다는 것을 뜻한다.&lt;/p&gt;

&lt;p&gt;일반적인 해싱 알고리즘은 MD4, MD5, SHA, RIPEMD, WHIRLPOOL, TIGER가 있다.&lt;/p&gt;

&lt;p&gt;이전 블록 해쉬 + 데이터 =&amp;gt; 자기 자신만의 블록 해쉬 값
이렇게 해쉬 값을 가지고 블록을 연결시킨다는 의미에서 체인이라는 단어를 사용하는 것이다.&lt;/p&gt;

&lt;p&gt;데이터가 조금이라도 변경된다면 해쉬값도 변경되고 그 이후 블록에도 영향을 미치기 때문에 올바른 체인을 생성할 수 없게 된다.&lt;/p&gt;

&lt;p&gt;블록체인을 사용하는 모든 사용자들이 같은 체인을 가지고 있으며, 각자의 체인을 비교함으로서 같은 체인인지 검증이 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;머클-루트merkle-root&quot;&gt;머클 루트(Merkle Root)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/merkle-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이진트리라는 이름으로도 알려져 있으며,&lt;/p&gt;

&lt;p&gt;두 개씩 거래를 묶은 다음 해싱 알고리즘을 통해 해시 값으로 나타내고 또 그렇게 묶은 값들을 다시 두 개씩 묶어서 다시 해싱하여 수 백개의 거래 값들을 가장 꼭대기에 위치한 하나의 데이터로 만들어준다.&lt;/p&gt;

&lt;p&gt;이렇게 이진트리 방식으로 구성하게되면 거래량이 기하급수적으로 늘어나도 특정 거래를 찾는 경로는 단순하다는 이점이 있다. 그렇기에 거래 내역을 위조하려는 시도가 있어도 머클트리의 경로를 따라가면 해시값이 다른 것이 나오게 되어 거래의 위변조도 쉽고 빠르게 알 수 있게 되고 이를 방지할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;종류&quot;&gt;종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;퍼블릭 블록체인&lt;/strong&gt;(Public BlockChain)&lt;br /&gt;
개방형 블록체인으로 누구나 트랜잭션을 생성할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프라이빗 블록체인&lt;/strong&gt;(Private BlockChain)&lt;br /&gt;
폐쇠형 블록체인으로 주로 기업에서 사용하기에 엔터프라이즈 블록체인(Enterprise BlockChain)이라고도 한다.서비스 제공자의 승인을 받아야만 참여가 가능한 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;콘소시엄 블록체인&lt;/strong&gt;(Consortium BloackChain)&lt;br /&gt;
프라이빗 블록체인을 확장한 방식으로 여러 기업또는 기관이 공동으로 참여한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;작업증명pow--proof-of-work&quot;&gt;작업증명(PoW : Proof of Work)&lt;/h2&gt;
&lt;p&gt;모든 블록(노드)가 포함된 거래 내역이 악의적인 공격자에 의해 변조되지 않은 올바른 블록체인을 공유하는 있다는 것을 입증하기 위해 P2P 네트워크, 공개키-개인키 암호, 공유된 데이터베이스에 정보를 저장하고 검증하는 방법을 관리하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;합의 알고리즘&lt;/code&gt;(Consensus Mechanism)이라는 것을 활용하는데 여러 종류 중에서도 비트코인의 경우 PoW(작업증명 : Proof of Work)라는 합의 알고리즘을 사용한다.&lt;/p&gt;

&lt;p&gt;블록체인은 이와 같은 요소 기술들을 결합해 네트워크 상에서 투명성을 확보하며 데이터의 위조/변조 방지 및 보안성을 강화한 기술이다&lt;/p&gt;

&lt;h2 id=&quot;마이닝mining&quot;&gt;마이닝(Mining)&lt;/h2&gt;
&lt;p&gt;PoW란 컴퓨팅 파워를 이용해 블록의 해쉬 값을 추적하여 블록체인 네트워크에 새로운 블록을 추가하는 방식의 알고리즘이다&lt;/p&gt;

&lt;p&gt;위 과정이 채굴(Mining)에 해당한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/dodge-mining.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비트코인의 경우 
채굴자가 네트워크에 새로운 블록들을 추가할 때 마다 받을 수 있으며
새로운 블록들을 추가하기 위해서는 네트워크의 질문에 원하는 답을 찾아서 논스 값을 변경해야 한다.&lt;/p&gt;

&lt;p&gt;논스(Nonce)는 채굴자가 변경할 수 있는 유일한 값이며 Nonce 값을 변경할 때 마다 해쉬 값이 달라지는데, 채굴자는 그중에서도 현재 난이도에 맞춰서 네트워크가 던지는 질문에 적절한 값을 가지는 해쉬를 만들어내야 한다.&lt;/p&gt;

&lt;h2 id=&quot;활용&quot;&gt;활용&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;암호화폐 거래&lt;/li&gt;
  &lt;li&gt;ICO(Initial Coin Offering)&lt;/li&gt;
  &lt;li&gt;NFT(Non-Fungible Token)&lt;/li&gt;
  &lt;li&gt;DEX(Decebtrakuzed Exchange)&lt;/li&gt;
  &lt;li&gt;스마트 컨트랙트(Smart Contract)
    &lt;blockquote&gt;
      &lt;p&gt;사전에 정해진 임의의 규칙에 따라 디지털 자산을 자동적으로 이전하는 시스템 - Vitalik Buter&lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;블록체인이 지니고 있는 탈중앙화를 기반으로 금융거래, 부동산 계약, 공증 등 다양한 형태의 계약을 체결하고 이행하는 것. (블록체인 2.0)&lt;/li&gt;
      &lt;li&gt;다른사람들과의 교류와 코드로 소통이 가능하며 또한 공유 네트워크에 업로드할 수 있다&lt;/li&gt;
      &lt;li&gt;수정은 불가하나 공유/검증/실행은 가능하다&lt;/li&gt;
      &lt;li&gt;원하는 소스를 다 활용할 수 없음(블록체인 네트워크 위에서만 실행 가능)&lt;/li&gt;
      &lt;li&gt;신뢰 기반이 아닌 특수한 네트워크, 환경을 요구&lt;/li&gt;
      &lt;li&gt;스마트 컨트랙 지원 암호화폐&lt;br /&gt;
이더리움, Kusama, Polkadot, Cardano, Cosmos&lt;/li&gt;
      &lt;li&gt;개발자들은 이더리움 상에서 스마트 컨트랙트를 활용하여 암호화폐 지갑, 금융 애플리케이션, 마켓, 게임과 같이 새로운 종류의 탈중앙화된 애플리케이션(DApps)을 개발할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;단점&quot;&gt;단점&lt;/h2&gt;
&lt;p&gt;블록체인 네트워크는 그 특성상 노드의 신뢰를 기반으로 하기 때문에, 신뢰가 무너지는 순간 블록체인 역시 급격하게 무너질 수 있다는 치명적인 맹점이 있다.&lt;/p&gt;

&lt;p&gt;또한 참여하는 노드 수(분산되어 데이터를 저장되는 주체의 수)가 매우 적을 경우에 외부 공격자와 침입에 취약하다&lt;/p&gt;

&lt;p&gt;탈중앙화, 보안성, 확장성의 문제로 이 세 가지 문제 중 어떠한 두 가지는 만족시킬 수 있지만, 남은 한 가지는 만족시킬 수 없는 트릴레마의 문제가 있으며 이 문제를 보완하기 위해 사이드체인, 샤딩, 인터체인, 라이트닝 네트워크, 플라즈마 기술이 있다.&lt;/p&gt;

&lt;h1 id=&quot;레퍼런스&quot;&gt;레퍼런스&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.banksalad.com/contents/%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%98%EB%8A%94-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC-Merkle-Trees-%EB%9E%80-ilULl&quot;&gt;블록체인-개념-완벽-정리(뱅크샐러드)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://brownbears.tistory.com/372&quot;&gt;머클트리란? - 불곰님 티스토리 블로그&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kiri.or.kr/pdf/%EC%97%B0%EA%B5%AC%EC%9E%90%EB%A3%8C/%EC%97%B0%EA%B5%AC%EB%B3%B4%EA%B3%A0%EC%84%9C/nre2018-24_02.pdf&quot;&gt;블록체인의 이해&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Ca7Meu4z-F4&quot;&gt;노마드 코더 유튜브&lt;/a&gt;&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="Algorithm" /><category term="데이터 보안" /><summary type="html">블록 체인 관리 대상 데이터를 블록이라고 하는 소규모 데이터들이 P2P방식을 기반으로 모여 이룬 체인 연결고리 분산 데이터 저장 환경</summary></entry><entry><title type="html">[배민커넥트] 도보로 시작하기 및 주의사항과 소소한팁</title><link href="https://many258.github.io/life/baemin-connect/" rel="alternate" type="text/html" title="[배민커넥트] 도보로 시작하기 및 주의사항과 소소한팁" /><published>2021-03-20T00:00:00+09:00</published><updated>2021-03-20T20:37:34+09:00</updated><id>https://many258.github.io/life/%7Bbaemin-connect%7D</id><content type="html" xml:base="https://many258.github.io/life/baemin-connect/">&lt;h1 id=&quot;개요&quot;&gt;개요&lt;/h1&gt;
&lt;p&gt;몸이 굳어있던 추운 계절이 지나고 나들이나 운동을 하기 좋은 계절이 오고 있습니다.&lt;br /&gt;
하지만 코로나의 영향으로 아직까지는 헬스장을 가는게 꺼려지는 것은 제 주관적이지만 솔직히 말해서 사실입니다.&lt;/p&gt;

&lt;p&gt;이 때, 배민커넥트를 시작하기에 최적의 시기라고 생각합니다.&lt;/p&gt;

&lt;p&gt;필자는 걷는 것을 좋아해서 작년 여름에 주변 지인의 추천으로 배민 커넥트에 입문하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/life/baemin-connect_feature.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간단히 말해, 내가 원하는 시간에 운동과 동시에 부수입을 얻을 수 있다는 것이 배민커넥트의 최대 장점이라 할 수 있겠습니다&lt;/p&gt;

&lt;p&gt;마지막 이유로 현재 진행중인 친구초대 이벤트를 후술하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;도보로-시작하기&quot;&gt;도보로 시작하기&lt;/h1&gt;

&lt;p&gt;다른 수단들과 비교하여 별다른 준비 없이 핸드폰, 보온가방, 튼튼한 두 다리만 있다면 가능하지만, 만약 ‘나는 수입이 목적이에요~’라는 사람이 있다면 권유는 드리지 않습니다.&lt;/p&gt;

&lt;p&gt;커넥트의 장점은 내가 &lt;strong&gt;원하는 시간&lt;/strong&gt;에 할 수 있다는 것이지, 수입을 목적으로 하기엔 어려운 면이 있습니다. 아무래도 당일 &lt;strong&gt;주문의 양&lt;/strong&gt;에 따라 그 날 수입이 들쑥날쑥하고 한 건당 &lt;strong&gt;시간 소요가 크기 때문에&lt;/strong&gt; 안타깝게도 어떤 날은 최저시급으로 계산한 것 보다 적게 지급받을 수도 있습니다.&lt;/p&gt;

&lt;p&gt;가방과 보조장비들은 우아한스토어에서 구매(가방만 구매시 26,400원)를 하시거나 중고 마켓을 이용하는 것도 방법 중 하나입니다.&lt;/p&gt;

&lt;p&gt;또한 매주 배송할 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;20시간&lt;/code&gt;으로 제한되어 있으며 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수요일&lt;/code&gt;에 초기화되며 가장 중요한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정산&lt;/code&gt;은 별다른 공지가 없으면 매주 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;금요일&lt;/code&gt;에 진행됩니다. 정산의 경우 한 건 이상을 배달을 수행하였다면, 약 3천원 정도의 &lt;strong&gt;산재보험료&lt;/strong&gt;가 부과된다는 점 알고 계시기 바랍니다.&lt;/p&gt;

&lt;p&gt;마지막으로 산업안전보건법에 따라 &lt;strong&gt;PC&lt;/strong&gt;에서 &lt;strong&gt;2시간&lt;/strong&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안전보건교육&lt;/code&gt; 이수 후에 첫 배달을 시작할 수 있습니다.&lt;/p&gt;

&lt;p&gt;무엇보다도 뚜벅이 커넥터일지라도 &lt;strong&gt;안전&lt;/strong&gt;이 &lt;strong&gt;최우선&lt;/strong&gt;으로 중요합니다!&lt;/p&gt;

&lt;h2 id=&quot;배송-과정&quot;&gt;배송 과정&lt;/h2&gt;
&lt;p&gt;처음 시도하는 입장에서 까다로울 것 같지만 한 두번 해보게 되면 전혀 어렵지않습니다.&lt;/p&gt;

&lt;p&gt;주문을 받는 시스템으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;일반 배차&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AI배차&lt;/code&gt;가 있으며&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일반 배차&lt;/strong&gt;의 경우 실시간으로 주문(콜)이 올라오며 커넥터가 이 콜을 직접 선택하는 방식이고&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AI배차&lt;/strong&gt;의 경우 AI가 경로를 파악하며 고객에게 예정 시간에 배달이 가능한지 등을 종합적으로 고려해서 특정 배달 주문을 수행하기에 가장 적합한 위치의 커넥터에게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선적&lt;/code&gt;으로 콜을 보내는 방식입니다. 이 때, 약 30초간 선택할 수 있는 시간이 주어지고 시간이 초과될 때까지 결정을 못했다면 다른 커넥터/라이더에게 주문이 넘어갑니다.&lt;/p&gt;

&lt;p&gt;필자는 다른 커넥터/라이더들과 경쟁으로 인해 빨리빨리 콜을 잡아햐하는 일반배차보다 품목을 세부적으로 꼼꼼히 확인할 수 있는 &lt;strong&gt;AI배차&lt;/strong&gt;를 더 추천하는 바입니다.&lt;/p&gt;

&lt;p&gt;실제 배송 과정은 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;신규배달&lt;/code&gt; 알림이 도착한다(AI배차로 선택한 경우)&lt;/li&gt;
  &lt;li&gt;알림을 눌러 배송가능한 품목들인지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;확인&lt;/code&gt;을 한다&lt;/li&gt;
  &lt;li&gt;가능할 것 같다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;승낙&lt;/code&gt;을 누르고 다음 단계로, 어려울 것 같다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;거절&lt;/code&gt;을 누르고 1단계로 다시 돌아가 알림올 때까지 기다린다.&lt;/li&gt;
  &lt;li&gt;매장까지 이동하고 매장에 도착했다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;매장도착&lt;/code&gt; 버튼을 누른다&lt;/li&gt;
  &lt;li&gt;음식/물품이 완료될 때 까지 기다리고 주문번호 확인 후 받았으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;픽업완료&lt;/code&gt;를 누른다&lt;/li&gt;
  &lt;li&gt;고객에게 이동한 후 음식/물품을 건내주고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전달완료&lt;/code&gt;를 누른다&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;embed-responsive embed-responsive-16by9&quot;&gt;
  &lt;iframe class=&quot;embed-responsive-item&quot; width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/r3PXvZ6CxUI&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;

&lt;p class=&quot;align-center&quot;&gt;&lt;br /&gt;&lt;br /&gt;
자세한 사항은 &lt;a href=&quot;http://www.baeminriders.kr/connect/&quot;&gt;배민커넥트 홈페이지&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;주의-사항&quot;&gt;주의 사항&lt;/h2&gt;
&lt;h3 id=&quot;핸드폰은-생명이나-다름-없다&quot;&gt;핸드폰은 생명이나 다름 없다&lt;/h3&gt;
&lt;p&gt;핸드폰이 방전되었다면 사실상 할 수 있는 것이 없습니다.&lt;/p&gt;

&lt;p&gt;가능하다면 필히 &lt;strong&gt;보조배터리&lt;/strong&gt;를 소지하고 다니고 만약 고장이 난 경우,
주변 사람들의 도움을 받아 배달의 민족 고객센터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1600-9880&lt;/code&gt;으로 
연락 후 조치를 취하는 것이 가장 현명한 방법이라 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;모든-항목을-꼼꼼히-검토한다-욕심은-금물&quot;&gt;모든 항목을 꼼꼼히 검토한다. 욕심은 금물&lt;/h3&gt;
&lt;p&gt;배송 중에는 단지 힘들다고 또는 거리가 멀다고 중간에 그만두거나 배송 &lt;strong&gt;취소하기가 상당히 어렵습니다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;그래서, 항!상! 품목을 확인하고 내가 배송을 갈 수 있는 것인지 아닌지 판단하고 행동하는 것이 중요합니다. 자유에는 책임이 따른다는 명언이 생각나네요&lt;/p&gt;

&lt;p&gt;또한 &lt;strong&gt;고객요청사항&lt;/strong&gt; 중에 특히나 벨을 울리지 말아달라는 요청도 많으니 이 점 확실하게 유의해주셔야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;면국물-요리는-자신이-있을-때-잡자&quot;&gt;면/국물 요리는 자신이 있을 때 잡자&lt;/h3&gt;
&lt;p&gt;면/국물 요리는 특히 시간이 생명이라는 거 잘 알고 계실거라 생각됩니다.&lt;/p&gt;

&lt;p&gt;도보커넥터들은 보통 다른 운송수단보다 상대적으로 시간이 더 소요되기 때문에 보온/보냉가방을 사용하고 있고 거리가 가까운 경우가 아니라면 다른 커넥터/라이더 분께 양보해드리는 게 더 좋을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;현금카드-결제는-미리-확인하자&quot;&gt;현금/카드 결제는 미리 확인하자&lt;/h3&gt;
&lt;p&gt;비마트의 경우에는 무조건 선결제로 이뤄지지만 일반 매장일 경우 현금이나 카드로 결제를 신청하는 분들이 꽤 있으십니다.&lt;/p&gt;

&lt;p&gt;그러므로, 배송수락 전 잔돈이 있는지 확인하는 것을 습관화합시다.&lt;/p&gt;

&lt;h3 id=&quot;손님에게-직접-건네주지-않는-한-사진을-꼭-찍어두자&quot;&gt;손님에게 직접 건네주지 않는 한 사진을 꼭 찍어두자&lt;/h3&gt;
&lt;p&gt;코로나로 인해 직접 대면하여 음식/물건을 전달하는 것보다 ‘집 앞에 놓아주세요’라고 요청하는 고객님들이 부쩍 늘었습니다.&lt;/p&gt;

&lt;p&gt;어플 기능 중에 고객에게 사진 전송하는 기능이 있는데 실제로 고객님이 사용하는 어플에 푸쉬알림으로 전해지게 됩니다.
혹여나 음식이나 물건을 전달받았음에도 불구하고 받지 못했다고 클레임을 진행하는 고객이 있을 수도 있으니(한번도 만나보지 못했지만..) 배송업무를 끝내고 증거(?)로 남겨두는 목적입니다.&lt;/p&gt;

&lt;h2 id=&quot;미세한-팁들&quot;&gt;미세한 팁들&lt;/h2&gt;
&lt;h3 id=&quot;거점을-정하자&quot;&gt;거점을 정하자&lt;/h3&gt;
&lt;p&gt;배민커넥트 카카오톡 플러스친구에서는 주마다 어느 지역에 배달이 많았는지 분포도로 알려주고 있습니다.&lt;/p&gt;

&lt;p&gt;이를 참고하여 어느 지점을 타겟팅을 할 것인지 &lt;strong&gt;개방화장실&lt;/strong&gt;의 위치정도는 미리 파악해두는 것이 도움이 될 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;점심시간과-저녁시간이-피크타임&quot;&gt;점심시간과 저녁시간이 피크타임&lt;/h3&gt;
&lt;p&gt;가능하면 시간대를 12시 ~ 2시, 6시 ~ 8시로 움직이는 것을 추천합니다.&lt;/p&gt;

&lt;p&gt;이 때가 가장 주문이 많은 편이며 각종 프로모션으로 배송비도 또한 많이 오르는 편입니다.&lt;/p&gt;

&lt;h3 id=&quot;휴식할-곳을-미리-파악하자&quot;&gt;휴식할 곳을 미리 파악하자&lt;/h3&gt;
&lt;p&gt;뚜벅이 커넥터들은 항상 다리가 아픕니다.&lt;/p&gt;

&lt;p&gt;배송이 끝난 후 남는 시간에 미리미리 휴식할 장소(특히 공원 벤치)을 찾아 체력을 비축해두는 것을 추천합니다.&lt;/p&gt;

&lt;h3 id=&quot;만보기-어플을-이용하자&quot;&gt;만보기 어플을 이용하자&lt;/h3&gt;
&lt;p&gt;우리의 목표는 운동과 부수입이라는 두 마리 토끼를 잡는 것입니다.&lt;/p&gt;

&lt;p&gt;이 만보기나 헬스케어 어플은 운동을 시각화해줌으로써 목표를 달성하면 하루의 보람을 느끼게 해주기도 하고 다음 날에도 계속 커넥트를 할 수 있게 끔 추진력과 원동력을 만들어 주기에 많은 도움을 줍니다.&lt;/p&gt;

&lt;h3 id=&quot;웨어러블-장비를-마련하자&quot;&gt;웨어러블 장비를 마련하자&lt;/h3&gt;
&lt;p&gt;이건 진짜 알려주기 싫을 정도로 꿀정보라고 할 수 있는데 필자는 현재 미밴드를 착용하면서 커넥트를 하고 있습니다.&lt;/p&gt;

&lt;p&gt;미밴드 뿐만 아니라 다른 스마트워치에도 대부분 존재하는 기능 중에 따로 지정한 어플에서 푸쉬알림이 오면 진동으로 알려주는 시스템이 있는데, 이 때, 핸드폰을 굳이 보고있지 않아도 알림이 오면 손목에서 진동으로 자칫 못보고 넘어갈 수 있는 알림을 알려주니까 확인하기 편해서 강력히 추천드립니다.&lt;/p&gt;

&lt;h1 id=&quot;마치며&quot;&gt;마치며..&lt;/h1&gt;
&lt;p&gt;앞서 말씀드린 것처럼 배민에서는 친구초대 이벤트를 현재 진행중입니다.&lt;/p&gt;

&lt;p&gt;기존 이벤트의 경우 추천인 코드를 입력한 사람이 배송임무를 진행할 경우, 추천받은 사람과 추천한 사람 모두 1만원을 제공하였으나 금일부로(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3월20일&lt;/code&gt;) 2만원으로 인상되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/life/baemin-connect.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에 한시적으로 진행하므로 이 기회에 지인과 함께 하시거나 저의 추천인코드(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BC642005&lt;/code&gt;)와 한 번 도전해보시는 것도 좋은 선택이라 생각됩니다.&lt;/p&gt;

&lt;p&gt;포스팅을 하는 지금 당장 생각나는 내용들은 이것으로 마무리하겠습니다.&lt;br /&gt;
블로그를 운영하지 얼마 지나지 않았고 글을 쓰는 재주도 없는 터라 많은 도움이 되셨는지는 모르겠습니다.&lt;/p&gt;

&lt;p&gt;그 밖에도 궁금하신 내용이나 질문들은 제가 경험한 선에서 답해드릴 수 있으니 좌측이나 우측에 있는 &lt;strong&gt;카카오톡 오픈톡방&lt;/strong&gt; 링크로 문의부탁드리겠습니다.&lt;/p&gt;

&lt;p&gt;감사합니다 XD&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="life" /><category term="배민커넥트" /><summary type="html">개요 몸이 굳어있던 추운 계절이 지나고 나들이나 운동을 하기 좋은 계절이 오고 있습니다. 하지만 코로나의 영향으로 아직까지는 헬스장을 가는게 꺼려지는 것은 제 주관적이지만 솔직히 말해서 사실입니다.</summary></entry><entry><title type="html">[알고리즘] 최소신장트리(MST)와 그래프의 순회(Graph Traversal)</title><link href="https://many258.github.io/study/algorithm-MST-graph-traversal/" rel="alternate" type="text/html" title="[알고리즘] 최소신장트리(MST)와 그래프의 순회(Graph Traversal)" /><published>2021-03-19T00:00:00+09:00</published><updated>2021-03-19T22:37:34+09:00</updated><id>https://many258.github.io/study/%7Balgorithm-MST-graph-traversal%7D</id><content type="html" xml:base="https://many258.github.io/study/algorithm-MST-graph-traversal/">&lt;h1 id=&quot;신장-트리spanning-tree&quot;&gt;신장 트리(Spanning Tree)&lt;/h1&gt;
&lt;p&gt;그래프 내의 모든 정점을 포함하는 트리&lt;br /&gt;
최소 연결 부분 그래프.&lt;/p&gt;

&lt;p&gt;N개의 정점을 가지는 그래프의 최소 간선의 수는 N-1개이며, N-1개의 간선으로 연결되어 있으면 필연적으로 트리 형태가 이루어지고 이것이 바로 Spanning Tree라 할 수 있다.&lt;/p&gt;

&lt;p&gt;하나의 그래프에는 많은 신장 트리가 존재할 수 있으며, 트리의 특수한 형태이므로 모든 정점들이 연결되어 있어야 하고 사이클을 &lt;strong&gt;포함해서는 안된다&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;최소-신장트리mst--minimum-spanning-tree&quot;&gt;최소 신장트리(MST : Minimum Spanning Tree)&lt;/h2&gt;
&lt;p&gt;가능한 신장트리에서 간선의 가중치 합이 최소인 신장트리를 의미&lt;/p&gt;

&lt;p&gt;최소 비용 신장 트리를 구하는 방법들은 모두 &lt;strong&gt;탐욕 알고리즘&lt;/strong&gt;(Greedy Algorithm)으로 구현&lt;/p&gt;

&lt;p&gt;** 탐욕 알고리즘 : 각 단계에서 최선의 선택이 최종 단계에서도 최선의 결과를 나타낼 것이라고 생각하는 알고리즘&lt;/p&gt;

&lt;h2 id=&quot;크루스칼-알고리즘kruskals-algorithm&quot;&gt;크루스칼 알고리즘(Kruskal’s Algorithm)&lt;/h2&gt;
&lt;p&gt;간선 위주의 알고리즘.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;모든 간선들의 가중치를 오름차순으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정렬&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;가중치가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소&lt;/code&gt;인 간선을 선택&lt;/li&gt;
  &lt;li&gt;위에서 선택한 간선이 연결하려는 2개의 노드가 서로 연결되지 않은 상태라면, 2개의 노드를 서로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연결&lt;/code&gt;(이 때, &lt;strong&gt;사이클이 발생하지 않도록 주의&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;최소신장트리가 만들어지기 전까지 2~3 과정 반복 수행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그래프 내 간선의 개수가 적은 &lt;strong&gt;희소 그래프&lt;/strong&gt;의 경우 크루스칼 알고리즘에 적합하다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/algorithm/graph/KruskalAlg.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프림-알고리즘prims-algorithm&quot;&gt;프림 알고리즘(Prim’s Algorithm)&lt;/h2&gt;
&lt;p&gt;정점 위주의 알고리즘&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;임의의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정점&lt;/code&gt;을 선택&lt;/li&gt;
  &lt;li&gt;정점에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인접&lt;/code&gt;한 간선 중 가중치가 최소인 간선으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연결&lt;/code&gt;된 정점을 선택&lt;/li&gt;
  &lt;li&gt;위 정점에서 다시 최소 간선으로 연결된 정점을 선택&lt;/li&gt;
  &lt;li&gt;최소신장트리가 만들어지기 전까지 2-3 과정 반복 수행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그래프 내 간선의 개수가 많은 &lt;strong&gt;밀집 그래프&lt;/strong&gt;의 경우 프림 알고리즘이 적합하다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/algorithm/graph/PrimAlg.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;그래프의-순회graph-traversal&quot;&gt;그래프의 순회(Graph Traversal)&lt;/h1&gt;
&lt;p&gt;하나의 정점에서 시작하여 그래프에 있는 모든 정점을 한번씩 방문하는 것을 그래프 순회 또는 탐색이라 한다&lt;/p&gt;

&lt;h2 id=&quot;dfs깊이-우선-탐색--depth-first-search&quot;&gt;&lt;strong&gt;DFS&lt;/strong&gt;(깊이 우선 탐색 : Depth-First Search)&lt;/h2&gt;
&lt;p&gt;아직 방문하지 않은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자식&lt;/code&gt; 노드를 우선적으로 탐색&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;정점 i를 방문한다.&lt;/li&gt;
  &lt;li&gt;정점 i에 인접한 정점 중에서 아직 방문하지 않은 정점이 있으면 이 정점을 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STACK&lt;/code&gt;에 저장한다&lt;/li&gt;
  &lt;li&gt;스택에서 정점을 삭제하여 새로운 i를 설정하고 다시 1단계부터 수행&lt;/li&gt;
  &lt;li&gt;스택이 공백이 되면 연산을 종료&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/algorithm/graph/DFS.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;특징&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;현 경로상의 노드만을 기억하면 되므로 저장 공간의 수요가 비교적 적지만, 한 경로가 무한히 깊을 경우 &lt;strong&gt;오버플로우&lt;/strong&gt;가 발생할 수 있다.&lt;br /&gt;
이를 방지하기 위해, 깊이에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제한&lt;/code&gt;을 두고 구현이 필요하다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;목표에 &lt;strong&gt;도달하지 못할 가능성이 존재&lt;/strong&gt;하며, 도달할지라도 해당 경로가 &lt;strong&gt;최단 경로라고 보장할 수 없다&lt;/strong&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bfs너비-우선-탐색--breadth-first-search&quot;&gt;&lt;strong&gt;BFS&lt;/strong&gt;(너비 우선 탐색 : Breadth-First Search)&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;형제&lt;/code&gt; 노드를 우선적으로 탐색하는 기법&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;임의의 시작 노드를 정해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QUEUE&lt;/code&gt;에 넣는다&lt;/li&gt;
  &lt;li&gt;Dequeue연산을 통해 큐에서 노드를 가져와 현재 노드로 정한다&lt;/li&gt;
  &lt;li&gt;현재 노드의 인접 노드 목록을 순회하면서 방문하지 않은 노드가 있는지 확인한다&lt;/li&gt;
  &lt;li&gt;방문하지 않은 노드가 있다면 그 노드를 큐에 넣고 방문한다.&lt;/li&gt;
  &lt;li&gt;큐가 공백이 될 때까지 2~4과정을 반복 수행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/algorithm/graph/BFS.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;특징&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;큐에 다음에 탐색할 정점들을 저장해야 하므로 &lt;strong&gt;저장공간이 많이 필요&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;단순 검색속도가 DFS보다 빠르다&lt;/li&gt;
      &lt;li&gt;최단 경로를 보장함과 동시에 &lt;strong&gt;반드시 찾을 수 있다&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="Algorithm" /><category term="컴퓨터일반" /><category term="Programming" /><summary type="html">신장 트리(Spanning Tree) 그래프 내의 모든 정점을 포함하는 트리 최소 연결 부분 그래프.</summary></entry><entry><title type="html">[자료구조] 트리의 종류 및 특징</title><link href="https://many258.github.io/study/data-structure-tree-type/" rel="alternate" type="text/html" title="[자료구조] 트리의 종류 및 특징" /><published>2021-03-19T00:00:00+09:00</published><updated>2021-03-19T20:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdata-structure-tree-type%7D</id><content type="html" xml:base="https://many258.github.io/study/data-structure-tree-type/">&lt;h1 id=&quot;트리의-종류&quot;&gt;트리의 종류&lt;/h1&gt;
&lt;h2 id=&quot;이진-트리binary-tree&quot;&gt;이진 트리(Binary Tree)&lt;/h2&gt;
&lt;p&gt;기본적으로 자식노드를 최대 2개 가지는 트리를 의미&lt;/p&gt;

&lt;h3 id=&quot;완전-이진-트리complete-binary-tree&quot;&gt;완전 이진 트리(Complete Binary Tree)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;왼쪽&lt;/code&gt; 자식노드부터 채워지며 마지막 레벨을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제외&lt;/code&gt;하고는 모든 자식노드가 채워져있는 트리&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/complete-binary-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;힙heap&quot;&gt;힙(Heap)&lt;/h4&gt;
&lt;p&gt;부모 자식 노드 간의 대소 관계는 정의되어 있으나 형제간의 대소관계는 정의되어 있지 않은 완전 이진트리 자료구조를 의미&lt;/p&gt;

&lt;p&gt;힙에는 두가지 종류가 있으며, 부모노드의 키값이 자식노드의 키값보다 항상 큰 힙을 ‘최대 힙’, 부모노드의 키값이 자식노드의 키값보다 항상 작은 힙을 ‘최소 힙’이라고 명명한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/heap.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;포화-이진-트리perfect-binary-tree&quot;&gt;포화 이진 트리(Perfect Binary Tree)&lt;/h3&gt;
&lt;p&gt;모든 노드가 0 or 2개의 자식노드를 가지며 모든 리프노드가 똑같은 레벨에 있는 경우의 트리&lt;/p&gt;

&lt;p&gt;레벨의 수를 N이라 가정할 때, 2&lt;sup&gt;n&lt;/sup&gt;-1 개의 노드를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/perfect-binary-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;정-이진-트리full-binary-tree&quot;&gt;정 이진 트리(Full Binary Tree)&lt;/h3&gt;
&lt;p&gt;모든 노드가 0 or 2개의 자식노드를 가지는 트리를 의미&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/full-binary-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;편향-이진-트리skewed-binary-tree&quot;&gt;편향 이진 트리(Skewed Binary Tree)&lt;/h3&gt;
&lt;p&gt;노드들이 전부 한 방향으로 편향된 트리를 의미&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/skewed-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;이진-탐색-트리bst--binary-search-tree&quot;&gt;이진 탐색 트리(BST : Binary Search Tree)&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이진트리&lt;/code&gt;의 구조와 자료의 검색/삭제/삽입에 효율적이게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정렬&lt;/code&gt;의 개념이 추가된 형태&lt;/p&gt;

&lt;p&gt;기본적인 특징은 이진 트리와 같지만 하나 다른 점은 자기 왼쪽에는 자신보다 값이 작은 노드가, 오른쪽에는 자신보다 값이 큰 노드가 존재해야 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;중회 순회(Inorder) 시 순차적으로 데이터가 정렬된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자가-균형-이진-탐색-트리self-balancing-binary-search-tree&quot;&gt;자가 균형 이진 탐색 트리(Self-Balancing Binary Search Tree)&lt;/h2&gt;
&lt;p&gt;이진 탐색트리는 저장과 검색에 평균 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logN&lt;/code&gt;시간이 소요되지만 편향으로 구성되어있거나 균형이 무너지면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;에 근접한 시간이 소요될 수 있다.&lt;/p&gt;

&lt;p&gt;그래서, 고안해낸 것이 균형잡힌 이진탐색트리이다. 대표적으로 AVL트리와 레드블랙트리가 있으며 최악의 경우에도 이진트리의 균형이 잘 맞도록 유지한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AVL트리는 더욱 엄격한 균형을 이루고 있기 때문에 Red-Black 트리보다 더 빠른 검색을 제공&lt;/li&gt;
  &lt;li&gt;Red-Black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어지지 않기 때문에 AVL트리보다 빠르게 삽입/제거 작업을 수행&lt;/li&gt;
  &lt;li&gt;AVL트리는 각 노드에 대해 BF를 저장하므로 노드 당 int 저장이 필요
Red-Black 트리는 노드당 1bit의 정보만 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;avl-트리&quot;&gt;AVL 트리&lt;/h3&gt;
&lt;p&gt;스스로 균형을 잡는 이진 탐색 트리&lt;/p&gt;

&lt;p&gt;검색/삽입/삭제 평균과 최악의 경우 O(log N)의 시간복잡도를 가지며,&lt;br /&gt;
노드가 삽입 또는 삭제될 때 회전을 통해 트리를 재구성하여 높이 균형 성질을 유지시킨다&lt;/p&gt;

&lt;p&gt;균형인수(BF : Balance Factor)를 구성하며 왼쪽과 오른쪽 서브트리의 높이 차를 나타낸다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BF = hL - hR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;값이 -1, 0, 1일 때만 균형있는 트리라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/AVL_Tree.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;레드블랙-트리rb-tree--red-black-tree&quot;&gt;레드블랙 트리(RB Tree : Red-Black Tree)&lt;/h3&gt;
&lt;p&gt;레드-블랙 트리는 자료의 삽입과 삭제, 검색에서 최악의 경우에도 일정한 실행 시간을 보장한다.&lt;br /&gt;
이는 실시간 처리와 같은 실행 시간이 중요한 경우에 유용하며 일정한 실행 시간을 보장하는 다른 자료구조(대표적으로 STL의 Map)를 만드는 데에도 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/red-black-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RB Tree는 다음과 같은 특성을 가진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;각 모든 노드는 레드 or 블랙 색상을 갖는다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Root Property&lt;br /&gt;
트리의 루트는 항상 블랙이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;External Property&lt;br /&gt;
모든 리프 노드(NIL)들은 블랙이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Internal Property&lt;br /&gt;
노드가 레드이면 그 노드의 자식은 반드시 블랙이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Depth Property&lt;br /&gt;
특정 노드에서 아래에 있는 모든 NULL 노드까지의 경로에서 만나는 블랙 색상의 노드의 수가 동일하다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;다원-탐색-트리-mst--m-way-search-tree&quot;&gt;다원 탐색 트리 (MST : M-way Search Tree)&lt;/h2&gt;
&lt;p&gt;균형을 유지한다는 점에서 균형 이진 트리와 유사하지만 트리의 각 &lt;strong&gt;노드가 여러 개의 자료&lt;/strong&gt;를 가질 수 있고, &lt;strong&gt;하위 트리의 수&lt;/strong&gt;를 임의로 설정 가능하다는 차이점이 존재한다.&lt;/p&gt;

&lt;p&gt;MST는 한개의 노드에 여러개의 키가 있을 수 있다. 자식 노드에도 여러 개의 키가 들어갈 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;각 노드는 0에서 최대 M개의 서브 트리를 가진다&lt;/li&gt;
      &lt;li&gt;K개의 서브 트리를 가지는 노드는 (K-1)개의 자료를 가진다(단, K&amp;lt;=M)&lt;/li&gt;
      &lt;li&gt;각 노드 안에서 자료들은 검색 키에 의해 정렬&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;b-트리b-tree&quot;&gt;B-트리(B Tree)&lt;/h3&gt;
&lt;p&gt;M원 탐색 트리의 차수가 많아져서 트리의 높이도 증가하면 점점 비효율적으로 변하게 된다. 그래서 B-트리를 고안해 규칙이 있는 MST를 구상했다.&lt;/p&gt;

&lt;p&gt;대량의 데이터를 처리해야 하는 검색 구조 주로 데이터베이스, 파일시스템에서 인덱스 저장 방법으로 사용하는 자료구조이다.&lt;/p&gt;

&lt;p&gt;노드 내 데이터 수가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;개라면 자식 노드의 수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(N+1)&lt;/code&gt;이며, 노드의 데이터는 항상 정렬된 상태여야 한다.&lt;/p&gt;

&lt;p&gt;노드 내 최대 데이터 수에 따라 2차 B-Tree(2개), 3차 B-Tree(3개), …라 명명&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/b-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;특징&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;루트 노드의 자식 수는 2 이상이어야 한다&lt;/li&gt;
      &lt;li&gt;모든 단말노드는 같은 레벨을 가진다&lt;/li&gt;
      &lt;li&gt;Internal 노드는 ⌈M/2⌉이상 M이하의 자식을 갖는다.&lt;/li&gt;
      &lt;li&gt;각 노드의 원소 수는 최소[M/2-1]개 이상 최대[M-1]개를 가진다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;b트리b-plus-tree&quot;&gt;B+트리(B Plus Tree)&lt;/h3&gt;
&lt;p&gt;B-트리는 특성상 순회 작업이 상당히 난감하다. B+ 트리는 색인구조에서 순차접근에 대한 문제의 해결책으로 제시되었다.&lt;/p&gt;

&lt;p&gt;B트리의 특징을 가지고 있지만 모든 키 값들이 Leaf 노드에 정렬되어 있는 트리 구조.&lt;/p&gt;

&lt;p&gt;Leaf 노드들은 연결 리스트 형태로 서로 연결되어 있고 이를 순차집합(sequence set)이라고 하며 오름차순으로 정렬이 되어 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;B+ 트리의 비단말 노드(not leaf)들은 데이터의 빠른 접근을 위한 인덱스 역할 수행(Index Set)&lt;/li&gt;
  &lt;li&gt;오직 리프노드에만 데이터 저장 가능하고 리프 노드에 모든 데이터가 있기 때문에 키 중복이 있다&lt;/li&gt;
  &lt;li&gt;리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용 가능&lt;/li&gt;
  &lt;li&gt;하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.&lt;/li&gt;
  &lt;li&gt;B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/B-plus-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;b트리b-star-tree&quot;&gt;B*트리(B Star Tree)&lt;/h3&gt;
&lt;p&gt;삽입 또는 삭제 작업 수행 시 발생하는 노드 분리를 줄이기 위해 노드의 약 2/3 이상이 채워지는 B트리.&lt;/p&gt;

&lt;p&gt;노드가 꽉 차면 분리하지 않고 키와 포인터를 재배치하여 다른 형제 노드로 옮김&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리프를 제외한 모든 노드는 m개의 서브트리 이상을 가질 수 없다&lt;/li&gt;
  &lt;li&gt;루트와 리프를 제외한 모든 노드는 적어도 [(2m-2)/3]+1개의 서브트리를 갖는다&lt;/li&gt;
  &lt;li&gt;루트는 리프가 아닌 이상 최소 2개, 적어도 2[(2m-2)/3]+1개의 서브트리를 갖는다.&lt;/li&gt;
  &lt;li&gt;모든 단말노드는 같은 레벨을 가진다&lt;/li&gt;
  &lt;li&gt;각 리프노드는 최소[(2m-2)/3]개, 최대 m-1개의 키 값을 갖는다&lt;/li&gt;
  &lt;li&gt;노드에 저장되는 자료가 넘치는 경우(Overflow), 일단 형제 노드들로 재분배하는 과정 수행. 모든 형제 노드들이 가득 찬 경우에만 B-트리의 분할 연산을 수행(보조 연산 최소화)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;트라이trie&quot;&gt;트라이(Trie)&lt;/h2&gt;
&lt;p&gt;문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조
주로 검색어 자동완성, 사전찾기, 문자열 검사에서 사용&lt;/p&gt;

&lt;p&gt;원하는 원소를 찾을 때, 원소의 길이가 L일 경우 O(L)의 시간복잡도를 가진다.&lt;/p&gt;

&lt;p&gt;빠르게 탐색이 가능하다는 장점이 있으나 각 노드에서 자식들에 대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;포인터&lt;/code&gt;들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;배열&lt;/code&gt;로 모두 저장하고 있다는 점에서 저장공간의 크기(공간복잡도)가 크다는 단점을 지니고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/trie.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="자료구조" /><category term="컴퓨터일반" /><category term="Programming" /><summary type="html">트리의 종류 이진 트리(Binary Tree) 기본적으로 자식노드를 최대 2개 가지는 트리를 의미</summary></entry><entry><title type="html">[데이터베이스] SQL</title><link href="https://many258.github.io/study/database-sql/" rel="alternate" type="text/html" title="[데이터베이스] SQL" /><published>2021-03-17T00:00:00+09:00</published><updated>2021-03-17T16:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-sql%7D</id><content type="html" xml:base="https://many258.github.io/study/database-sql/">&lt;h1 id=&quot;sqlstructured-query-language&quot;&gt;SQL(Structured Query Language)&lt;/h1&gt;
&lt;p&gt;ANSI, ISO에서 선정한 관계 데이터베이스 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;표준&lt;/code&gt; 언어&lt;br /&gt;
관계 대수와 관계 해석을 기초로 한 혼합 언어&lt;br /&gt;
데이터 정의, 조작, 제어 기능을 모두 갖추고 있다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비절차식&lt;/code&gt; 언어이며 대화식 질의어로 사용 가능&lt;br /&gt;
다른 프로그램 언어(COBOL, PL/1, C, Pascal)에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삽입된 형태&lt;/code&gt;로 사용 가능&lt;/p&gt;

&lt;h2 id=&quot;sql에서-사용하는-테이블&quot;&gt;SQL에서 사용하는 테이블&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기본 테이블&lt;br /&gt;
DDL에 의해 만들어지는 테이블로 독립적으로 존재하며 테이블명을 기록하게 되어 있다&lt;/li&gt;
  &lt;li&gt;뷰 테이블&lt;br /&gt;
역시 DDL에 의해 만들어지며 기본 테이블에서 유도되어 만들어지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가상&lt;/code&gt; 테이블&lt;/li&gt;
  &lt;li&gt;임시 테이블&lt;br /&gt;
질의 처리과정에서 DML에 의해 만들어지는 테이블로 임시적으로 만들어지는 테이블&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sql에서-사용하는-자료형의-종류&quot;&gt;SQL에서 사용하는 자료형의 종류&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;타입명&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BIT(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비트열&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;고정길이로 Bit단위로 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;VARBIT(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비트열&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;가변길이로 Bit단위로 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CHAR(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;문자열&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;고정 길이로 N개 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;VARCHAR(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;문자열&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;가변 길이로 N개 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SMALLINT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정수형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2바이트 고정 소수점 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;INT or INTEGER&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정수형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4바이트 고정 소수점 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FLOAT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;실수형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4바이트 부동 소수점 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DOUBLE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;실수형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8바이트 부동 소수점 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DECIMAL(i,j)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10진형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;i는 10진수의 개수, j는 소수점 이하 자리수&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;GRAPHIC(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;그래픽형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;그림 형태의 내용을 기억시킬 기억 장소 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;LOGICAL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;논리형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TRUE, FALSE를 기억시킬 기억 장소&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DATE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;날짜형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;YY-MM-DD 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TIME&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;시간형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;HH:MM:SS 형식&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;sql-명령어의-분류&quot;&gt;SQL 명령어의 분류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;데이터 정의어&lt;/strong&gt;(DDL : Data Definition Language)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#create&quot;&gt;CREATE&lt;/a&gt; : 테이블/인덱스/뷰의 생성&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#alter&quot;&gt;ALTER&lt;/a&gt; : 테이블의 변경&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#drop&quot;&gt;DROP&lt;/a&gt; : 테이블/인덱스/뷰의 제거&lt;/li&gt;
      &lt;li&gt;TRUNCATE : 테이블 초기화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 조작어&lt;/strong&gt;(DML : Data Manipulation Language)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#select&quot;&gt;SELECT&lt;/a&gt; : 데이터 검색&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#update&quot;&gt;UPDATE&lt;/a&gt; : 데이터 갱신&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#insert&quot;&gt;INSERT&lt;/a&gt; : 데이터 삽입&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#delete&quot;&gt;DELETE&lt;/a&gt; : 데이터 삭제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 제어어&lt;/strong&gt;(DCL : Data Control Language)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#grant&quot;&gt;GRANT&lt;/a&gt; : 사용자에게 권한 부여&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#revoke&quot;&gt;REVOKE&lt;/a&gt; : 사용자의 권한 해제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;트랜잭션 제어어&lt;/strong&gt;(TCL : Transaction Control Language)
    &lt;ul&gt;
      &lt;li&gt;COMMIT : 데이터를 데이터베이스에 저장하고 트랜잭션을 성공적으로 종료&lt;/li&gt;
      &lt;li&gt;ROLLBACK : 데이터의 변경사항을 취소하고 원상태로 복귀한 후 트랜잭션 종료&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-정의어&quot;&gt;데이터 정의어&lt;/h2&gt;
&lt;h3 id=&quot;create&quot;&gt;CREATE&lt;/h3&gt;
&lt;p&gt;테이블, 뷰, 인덱스 등을 생성할 때 사용&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테이블 생성 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{속성의&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;멤버&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;정의&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;UNIQUE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;FOREIGN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;REFERENCES&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;기본테이블&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;RESTRICT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;RESTRICT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CHECK&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;NOT NULL&lt;/strong&gt; : 널 값을 허용하지 않을 때 지정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PRIMARY KEY&lt;/strong&gt; : 기본키를 구성하는 속성을 지정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FOREIGN KEY&lt;/strong&gt; : 외래키로 어떤 릴레이션의 기본키를 참조하는지를 지정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RESTRICT&lt;/strong&gt; : 동작이 취소(제한)됨&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CASCADE&lt;/strong&gt; : 연속으로 같은 동작을 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SET NULL&lt;/strong&gt; : 모두 NULL로 바꿔주는 동작 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SET DEFAULT&lt;/strong&gt; : 주어진 초기 값으로 설정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CHECK&lt;/strong&gt; : 속성의 제약조건 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;뷰 생성 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VIEW&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;뷰이름&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;인덱스 생성 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;UNIQUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;색인명&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ASC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DESC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CLUSTER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;UNIQUE&lt;/strong&gt; : 색인화되어야 할 하나의 필드나 필드 조합이 중복되어서 같은 값이 나타나지 않게 하고자 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ASC/DESC&lt;/strong&gt; : 명시하지 않으면 오름차순(ASC)으로 자동설정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CLUSTER&lt;/strong&gt; : 색인 값과 물리적인 실제 데이터를 일치시킬 때 사용하는 옵션으로 하나의 테이블에서 한번빡에 생성할 수 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;alter&quot;&gt;ALTER&lt;/h3&gt;
&lt;p&gt;생성된 기본 테이블이나 도메인의 정의를 변경하고자 할 때 사용하는 명령어&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ADD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;MODIFY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;변경하고자&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;하는&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;ADD : 테이블에 속성 추가&lt;/li&gt;
  &lt;li&gt;ALTER : 도메인 정의 변경&lt;/li&gt;
  &lt;li&gt;DROP : 테이블에서 속성이나 제약조건 삭제&lt;/li&gt;
  &lt;li&gt;MODIFY : 속성의 데이터 유형, 제약조건에 대한 변경
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;MODIFY COLUMN 시 고려사항&lt;/p&gt;

        &lt;p&gt;해당 컬럼의 크기를 늘릴 수는 있지만 줄이지는 못한다. 이는 기존의 데이터가 훼손될 수 있기 때문이다.&lt;/p&gt;

        &lt;p&gt;해당 컬럼이 NULL 값만 가지고 있거나 테이블에 아무 행도 없으면 컬럼의 폭을 줄일 수 있다.&lt;/p&gt;

        &lt;p&gt;해당 컬럼이 NULL 값만을 가지고 있으면 데이터 유형을 변경할 수 있다.&lt;/p&gt;

        &lt;p&gt;해당 컬럼의 DEFAULT 값을 바꾸면 변경 작업 이후 발생하는 행 삽입에만 영향을 미치게 된다.&lt;/p&gt;

        &lt;p&gt;해당 컬럼에 NULL 값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;drop&quot;&gt;DROP&lt;/h3&gt;
&lt;p&gt;테이블, 뷰, 인덱스의 정의를 제거&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이름&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASCADE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;RESTRICT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VIEW&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;뷰&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이름&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASCADE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;RESTRICT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;인덱스&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이름&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;데이터-조작어&quot;&gt;데이터 조작어&lt;/h2&gt;
&lt;h3 id=&quot;select&quot;&gt;SELECT&lt;/h3&gt;
&lt;p&gt;테이블이나 뷰에 접근해서 원하는 튜플이나 속성을 검색하는 명령어&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SUM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;AVG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;MIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;리스트&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BETWEEN&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;도메인값&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;집합형태&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;LIKE&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'문자'&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;HAVING&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ASC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DESC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ALL(*)&lt;/strong&gt; : 하나의 테이블에 있는 모든 속성 출력&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DISTINCT&lt;/strong&gt; : 중복을 제거하는 옵션&lt;/li&gt;
  &lt;li&gt;집계함수
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;COUNT&lt;/strong&gt; : 해당 열이 있는 총 튜플의 개수&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SUM&lt;/strong&gt; : 해당 열에 있는 데이터의 합&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;AVG&lt;/strong&gt; : 해당 열에 있는 데이터들의 평균&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;MAX&lt;/strong&gt; : 해당 열에 있는 데이터 중 최대값&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;MIN&lt;/strong&gt; : 해당 열에 있는 데이터 중 최소값&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BETWEEN&lt;/strong&gt; : 값1과 값2 사이에 해당하는 조건&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IS (NOT) NULL&lt;/strong&gt; : 값이 NULL일 경우(아닐 경우) 조건&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IN&lt;/strong&gt; : 연산자는 조건의 범위를 지정하는 데 사용된다. 값은 콤마( , )로 구분하여 괄호 내에 묶으며, 이 값 중에서 하나 이상과 일치하면 조건에 맞는 것으로 평가&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LIKE&lt;/strong&gt; : 문자열 연산으로 사용되며 부분적으로 일치하는 값을 검색(숫자로 되어있는 필드는 사용 불가)
    &lt;ul&gt;
      &lt;li&gt;‘_‘(하이픈) : 한 문자의 대표 문자&lt;/li&gt;
      &lt;li&gt;’%’(퍼센트) : 모든 문자의 대표 문자&lt;/li&gt;
      &lt;li&gt;예시)&lt;br /&gt;
‘유__’ : 문자 ‘유’로 시작하는 3글자 검색&lt;br /&gt;
‘유%’ : 문자 ‘유’로 시작되는 모든 문자열 검색&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GROUP BY&lt;/strong&gt; : 그룹 지정, 조건식으로 HAVING 문법 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ORDER BY&lt;/strong&gt; : 정렬 검색, [ASC: 오름차순 / DESC : 내림차순]&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;insert&quot;&gt;INSERT&lt;/h3&gt;
&lt;p&gt;원하는 테이블에 원하는 튜플을 삽입시키는 연산&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;삽입시킬&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성들&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;삽입시킬&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성에&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;삽입될&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;실제&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값들&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;update&quot;&gt;UPDATE&lt;/h3&gt;
&lt;p&gt;테이블에서 원하는 속성값을 변경시키는 연산&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;값&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;delete&quot;&gt;DELETE&lt;/h3&gt;
&lt;p&gt;원하는 테이블에서 원하는 레코드를 삭제시키는 연산&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;데이터-제어어&quot;&gt;데이터 제어어&lt;/h2&gt;
&lt;h3 id=&quot;grant&quot;&gt;GRANT&lt;/h3&gt;
&lt;p&gt;사용자에 따라서 접근할 수 있는 DB데이터와 사용할 수 있는 기능을 제한&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;권한&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIVILEGES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;데이터베이스&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;TO&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'아이디'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'호스트'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDENTIFIED&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'비밀번호'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WITH&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;OPTION&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;FLUSH&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIVILEGES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;WITH GRANT OPTION&lt;/strong&gt; : 권한을 할당받은 유저가 GRANT 명령어도 사용할 수 있는 권한을 가지게 된다. 권한의 해제는 REVOKE GRANT OPTION 명령어를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;revoke&quot;&gt;REVOKE&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;REVOKE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;권한&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;데이터베이스&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;사용자&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">SQL(Structured Query Language) ANSI, ISO에서 선정한 관계 데이터베이스 표준 언어 관계 대수와 관계 해석을 기초로 한 혼합 언어 데이터 정의, 조작, 제어 기능을 모두 갖추고 있다. 비절차식 언어이며 대화식 질의어로 사용 가능 다른 프로그램 언어(COBOL, PL/1, C, Pascal)에 삽입된 형태로 사용 가능</summary></entry><entry><title type="html">[자료구조] 자료구조 기본</title><link href="https://many258.github.io/study/datastructure/" rel="alternate" type="text/html" title="[자료구조] 자료구조 기본" /><published>2021-03-17T00:00:00+09:00</published><updated>2021-03-17T20:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatastructure%7D</id><content type="html" xml:base="https://many258.github.io/study/datastructure/">&lt;h1 id=&quot;자료구조data-structure&quot;&gt;자료구조(Data Structure)&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;문제 해결에 있어 가장 효율적으로 자료를 조직하고 구조화하며, 자료를 표현하고 연산하는 일련의 활동을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;자료구조의-분류&quot;&gt;자료구조의 분류&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;선형구조(Linear)
    &lt;ul&gt;
      &lt;li&gt;스택(Stack)&lt;/li&gt;
      &lt;li&gt;큐(Queue)&lt;/li&gt;
      &lt;li&gt;데크(Deque)&lt;/li&gt;
      &lt;li&gt;배열(Array)&lt;/li&gt;
      &lt;li&gt;연결리스트(Linked list)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비선형구조(Non-Linear)
    &lt;ul&gt;
      &lt;li&gt;트리(Tree)&lt;/li&gt;
      &lt;li&gt;그래프(Graph)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;자료의-표현&quot;&gt;자료의 표현&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;외부 표현
    &lt;ul&gt;
      &lt;li&gt;BCD 코드 : 6비트, 64가지 표현, 소문자는 표현 불가&lt;/li&gt;
      &lt;li&gt;ASCII 코드 : 7비트, PC와 데이터 통신에서 주로 사용&lt;/li&gt;
      &lt;li&gt;EBCDIC 코드 : 8비트, 대형 컴퓨터에서 주로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 표현
    &lt;ul&gt;
      &lt;li&gt;수치 표현 : 컴퓨터 내부에 크기를 표현하기 위한 방법&lt;/li&gt;
      &lt;li&gt;포인터 표현 : 컴퓨터 내부에서 주소를 표현하기 위한 방법&lt;/li&gt;
      &lt;li&gt;논리 표현 : 긍정과 부정의 개념을 컴퓨터 내부에 표현하기 위한 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예외 표현 : 10진수 표현, 에러 검출, 데이터 송수신 등 용도로 사용
    &lt;ul&gt;
      &lt;li&gt;그레이 코드&lt;/li&gt;
      &lt;li&gt;3초과 코드&lt;/li&gt;
      &lt;li&gt;패리티 코드&lt;/li&gt;
      &lt;li&gt;해밍 코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;음수 표현 방식
컴퓨터 내의 연산 시 감산기(뺄셈)을 따로 만들지 않고 가산기(덧셈)만을 이용하여 덧셈과 뺄셈을 수행하기 위해 숫자자료는 보수 표현을 사용한다
    &lt;ul&gt;
      &lt;li&gt;부호화 절대치 : 첫 번째 비트가 0이면 양수이고 1이면 음수를 사용하는 방식
        &lt;ul&gt;
          &lt;li&gt;수의 표현 범위 : -(2&lt;sup&gt;n-1&lt;/sup&gt;-1) ~ 2&lt;sup&gt;n-1&lt;/sup&gt;-1&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;부호화된 1의 보수 : 양수의 1의 보수값을 음수로 사용
        &lt;ul&gt;
          &lt;li&gt;수의 표현 범위 : -(2&lt;sup&gt;n-1&lt;/sup&gt;-1) ~ 2&lt;sup&gt;n-1&lt;/sup&gt;-1&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;부호화된 2의 보수 : 양수의 2의 보수값을 음수로 사용
        &lt;ul&gt;
          &lt;li&gt;수의 표현 범위 : -(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;&lt;sup&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n-1&lt;/code&gt;&lt;/sup&gt;) ~ 2&lt;sup&gt;n-1&lt;/sup&gt;-1&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;선형-구조&quot;&gt;선형 구조&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;데이터를 저장시키는데 있어 데이터와 데이터를 1:1 대응 구조로 관계 맺어 저장시키는 형태의 구조를 의미&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;스택stack&quot;&gt;스택(Stack)&lt;/h3&gt;
&lt;p&gt;처음 입력시킨 자료는 맨 마지막에 출력되고 맨 마지막에 입력시킨 자료는 맨 처음에 출력되는 LIFO(Last in First Out)구조&lt;/p&gt;

&lt;p&gt;한쪽에서만 입출력하는 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스택의 응용 분야
    &lt;ul&gt;
      &lt;li&gt;함수 호출이나 서브 프로그램 호출 시 복귀를 지정할 때&lt;/li&gt;
      &lt;li&gt;인터럽트 분기 시 복귀 주소를 저장할 때&lt;/li&gt;
      &lt;li&gt;되부름 시 복귀 주소를 저장할 때&lt;/li&gt;
      &lt;li&gt;수식을 연산할 때&lt;/li&gt;
      &lt;li&gt;수식의 후위 표기법 변환&lt;/li&gt;
      &lt;li&gt;0주소 명령어 형식의 자료 저장소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;삽입-알고리즘-push&quot;&gt;삽입 알고리즘 (PUSH)&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF TOP &amp;gt;= M Overflow
TOP ← TOP + 1
STACK(TOP) ← X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TOP 포인터가 전체 크기 M보다 크거나 같으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오버플로&lt;/code&gt;가 발생하고 그렇지 않으면 TOP 포인터 값을 하나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;증가&lt;/code&gt;시켜 원하는 자료 X를 스택의 TOP포인터 위치에 삽입&lt;/p&gt;

&lt;h4 id=&quot;삭제-알고리즘-pop&quot;&gt;삭제 알고리즘 (POP)&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF TOP = 0 Underflow
X ← STACK(TOP)
TOP ← Top - 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;TOP 포인터가 0과 같으면 스택에 데이터가 없는 것이므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;언더플로&lt;/code&gt;가 발생하고 그렇지 않으면 스택에서 TOP 포인터 위치와 값을 X에 넣어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삭제&lt;/code&gt;시켜주고 TOP 포인터 값을 하나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;감소&lt;/code&gt;시킨다.&lt;/p&gt;

&lt;h3 id=&quot;큐queue&quot;&gt;큐(QUEUE)&lt;/h3&gt;
&lt;p&gt;먼저 입력된 자료가 먼저 출력되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIFO&lt;/code&gt;(First In First Out) 구조 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FCFS&lt;/code&gt;(First Come First Serve) 구조라 불린다.&lt;/p&gt;

&lt;p&gt;한쪽 방향에서는 입력만 하고, 다른 한쪽 방향에서는 출력만 이루어진다.&lt;/p&gt;

&lt;p&gt;삽입(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rear&lt;/code&gt; or Tail)과 삭제(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Front&lt;/code&gt; or Head) 포인터 두 개를 두고 운용한다.&lt;br /&gt;
삽입 시 Rear 값을 &lt;strong&gt;증가&lt;/strong&gt; 시키고 삭제 시 Front를 &lt;strong&gt;감소&lt;/strong&gt;시킨다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;큐의 응용 분야
    &lt;ul&gt;
      &lt;li&gt;스풀 운용 처리에 사용&lt;/li&gt;
      &lt;li&gt;운영체제의 스케줄링 작업에 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;삽입-알고리즘enqueue&quot;&gt;삽입 알고리즘(Enqueue)&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF rear &amp;gt;= M overflow
QUEUE(rear) ← X
rear ← rear + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Rear 포인터가 큐의 전체 크기 M보다 크거나 같으면 &lt;strong&gt;오버플로&lt;/strong&gt;가 발생하고 그렇지 않으면 큐에서 Rear 포인터가 가리키는 위치에 X라는 자료를 삽입하고 삽입 포인터 Rear를 하나 &lt;strong&gt;증가&lt;/strong&gt;시킨다.&lt;/p&gt;

&lt;h4 id=&quot;삭제-알고리즘dequeue&quot;&gt;삭제 알고리즘(Dequeue)&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF front = rear underflow
X ← QUEUE(front)
front ← front + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;삭제 표인터 Front와 삽입 포인터 Rear가 같으면 데이터가 없는 &lt;strong&gt;언더플로&lt;/strong&gt;가 발생하고 그렇지 않으면 큐에서 Front 포인터가 가리키는 위치의 값을 X에 치환하고 삭제 포인터 Front를 하나 &lt;strong&gt;증가&lt;/strong&gt;시킨다.&lt;/p&gt;

&lt;h3 id=&quot;데크deque&quot;&gt;데크(Deque)&lt;/h3&gt;
&lt;p&gt;포인터를 두 개 두고 운영(Left, Right)&lt;br /&gt;
양쪽끝에서 입출력이 일어나는 구조&lt;/p&gt;

&lt;p&gt;입력 제한 데크는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스크롤&lt;/code&gt;(Scroll), 출력 제한 데크는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;셀프&lt;/code&gt;(Shelf)&lt;/p&gt;

&lt;h3 id=&quot;환형-큐circular-queue&quot;&gt;환형 큐(Circular Queue)&lt;/h3&gt;
&lt;p&gt;선형 큐는 front가 증가하여 Size 에 도달했을때 다시 빈 공간을 활용할 수 없다는 단점이 있는데,&lt;br /&gt;
이 점을 보완하여, 원형 큐를 사용하면 원형으로 배열 요소를 접근하게 하여 빈 공간에 다시 재할당이 가능해진다&lt;/p&gt;

&lt;p&gt;큐가 가득 찬 경우와 큐가 비어있는 경우를 구분이 불가능한 단점&lt;br /&gt;
=&amp;gt; 배열을 가득 채우지 않고 배열의 길이 N일 경우 N-1개 채워졌을 때 이것을 가득 찬 것으로 가정하여 해결&lt;/p&gt;

&lt;h4 id=&quot;환형-큐의-상태-알고리즘&quot;&gt;환형 큐의 상태 알고리즘&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Empty
IF QUEUE → Rear == QUEUE → Front
  EMPTY

// Full
IF (QUEUE → Rear + 1) % QUEUE_SIZE == QUEUE → Front
  FULL

// EnQueue
IF FULL(QUEUE) Overflow
QUEUE → Rear = (QUEUE → Rear + 1) % QUEUE_SIZE
QUEUE → Data[QUEUE → Rear] = X

// DeQueue  
IF EMPTY(QUEUE) Underflow
QUEUE → Front = (QUEUE → Front + 1) % QUEUE_SIZE
X = QUEUE → Data[QUEUE → Front]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;배열array&quot;&gt;배열(Array)&lt;/h3&gt;
&lt;p&gt;같은 크기의 기억 장소를 연속된 공간에 모아 놓고 원하는 데이터를 기록하거나 액세스하는 것을 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특징&lt;br /&gt;
엑세스 속도가 빠르다&lt;br /&gt;
삽입, 삭제가 어렵고 메모리에 종속적이다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;연결리스트linked-list&quot;&gt;연결리스트(Linked List)&lt;/h3&gt;
&lt;p&gt;자료를 구성할 때 포인터 자료를 포함해서 하나의 자료를 구성하는 형태로, 이 포인터를 이용해 현 자료와 관계있는 자료를 연결하는 형식으로 구성하여 저장&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특징&lt;br /&gt;
액세스 속도가 느리다&lt;br /&gt;
중간에 단절되면 다음 노드를 찾기 어렵다&lt;br /&gt;
메모리에 대해 독립적이며 삽입, 삭제가 간편하다&lt;br /&gt;
메모리 단편화를 방지하여 기억 장소를 절약할 수 있다&lt;br /&gt;
포인터를 위한 추가 공간이 별도로 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;비선형-구조&quot;&gt;비선형 구조&lt;/h2&gt;
&lt;p&gt;자료가 있을 때, 이 자료와 관계를 맺고 있는 다른 자료가 여러 개 존재하는 경우 이러한 관계성(1:N, N:M)을 표현하기 위한 구조&lt;/p&gt;

&lt;h3 id=&quot;트리tree&quot;&gt;트리(Tree)&lt;/h3&gt;
&lt;p&gt;노드와 선분으로 되어 있고 정점 사이에 사이클이 형성되지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 구조&lt;/p&gt;

&lt;p&gt;여기서는 트리의 용어와 종류만 간단하게 언급하고 다음 장에서 부가 설명을 할 계획&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;용어
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;근노드&lt;/strong&gt;(Root Node) : 트리의 뿌리가 되는 노드&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;단노드&lt;/strong&gt;(Terminal Node, Leaf) : 노드의 차수가 0인 노드 또는 자식이 없는 노드를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;간노드&lt;/strong&gt;(Nonterminal Node) : 노드의 차수가 0이 아닌 노드 또는 자식을 가지고 있는 노드를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;차수&lt;/strong&gt;(Degree) : 각 노드의 가지 수, 또는 각 노드가 가지고 있는 자식 노드의 수를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;트리의 차수&lt;/strong&gt;(Tree Degree) : 트리 전체에서 노드의 차수가 가장 큰 것을 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;레벨&lt;/strong&gt;(Level) : 근 노드를 1레벨로 하여 차례로 2, 3 레벨로 증가하여 표시&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;깊이&lt;/strong&gt;(Depth) : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;높이&lt;/strong&gt;(Height) : 트리의 총 레벨을 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;자노드&lt;/strong&gt;(Child Node) : 각 노드에 연결되어 있는 다음 레벨의 노드를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;부노드&lt;/strong&gt;(Parent Node) : 각 노드의 바로 상위 레벨에 있는 노드를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;제노드&lt;/strong&gt;(Sibling Node) : 같은 부노드에 연결되어 있는 노드를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;숲&lt;/strong&gt;(Forest) : 트리가 모여서 이루어진 집합&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;서브 트리&lt;/strong&gt;(Sub Tree) : 임의의 노드를 제거했을 때 생길 수 있는 트리의 집합을 의미&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트리의 운행(Tree Traversal)
    &lt;ul&gt;
      &lt;li&gt;중위 운행(Inorder Traversal) : &amp;lt;좌, 근, 우&amp;gt; 순서로 운행&lt;/li&gt;
      &lt;li&gt;전위 운행(Preorder Traversal) : &amp;lt;근, 좌, 우&amp;gt; 순서로 운행&lt;/li&gt;
      &lt;li&gt;후위 운행(Postorder Traversal) : &amp;lt;좌, 우, 근&amp;gt; 순서로 운행&lt;/li&gt;
      &lt;li&gt;레벨 순서 순회(Level-order Traversal) = 너비 우선 순회(Breadth-First Traversal) : 노드를 레벨 순서로 방문하는 순회 방법&lt;/li&gt;
      &lt;li&gt;위 3가지는 스택을 활용하여 구현이 가능하며, 레벨 순서 순회는 큐를 활용하여 구현이 가능하다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;이진 트리&lt;/li&gt;
      &lt;li&gt;이진 탐색 트리(AVL)&lt;/li&gt;
      &lt;li&gt;레드 블랙 트리&lt;/li&gt;
      &lt;li&gt;스레드 이진 트리&lt;/li&gt;
      &lt;li&gt;B-트리, B+트리&lt;/li&gt;
      &lt;li&gt;이집 힙&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;그래프graph&quot;&gt;그래프(Graph)&lt;/h3&gt;
&lt;p&gt;트리보다 더 일반적인 자료 구조이며, 그래프는 트리를 포함한다. 일반적으로 정점과 선분으로 되어있으면서 사이클이 형성되는 경우를 트리와 구별하여 그래프라 지칭&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;용어
    &lt;ul&gt;
      &lt;li&gt;그래프의 표시 : G = (V, E) {V: 정점들의 집합, E: 간선의 집합}&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;정점&lt;/strong&gt;(Vertex) : 표현하고자 하는 대상 자료의 집합&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;간선&lt;/strong&gt;(Edge) : 정점 사이에 관계&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;경로&lt;/strong&gt;(Path) : 임의의 정점과 정점을 연결하는 경로&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;사이클&lt;/strong&gt;(Cycle) : 경로의 길이가 2이상인 경로에서 종착점과 시작점이 같은 경로&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;차수&lt;/strong&gt;(Degree) : 임의의 정점에 연결되어 있는 가지 수, 간선의 수
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;진입 차수&lt;/strong&gt;(In-Degree) : 정점으로 들어오는 간선의 수&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;진출 차수&lt;/strong&gt;(Out-Degree) : 정점에서 나가는 간선의 수&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;임의의 두 노드가 하나의 간선으로 연결돼 있을 경우, 이 노드들은 서로 &lt;strong&gt;인접&lt;/strong&gt;(Adjacent)해 있으며, 간선은 두 노드에 &lt;strong&gt;부속&lt;/strong&gt;(Incident)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;그래프의-종류&quot;&gt;그래프의 종류&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;비방향성 그래프(Undirected Graph)&lt;br /&gt;
간선 사이에 방향이 표시되지 않은 그래프. G(A, B)로 표현&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;방향성 그래프(Directed Graph)&lt;br /&gt;
간선 사이에 방향이 표시되어 있는 그래프. G&amp;lt;A, B&amp;gt;로 표현&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;완전 그래프(Complete Graph)&lt;br /&gt;
그래프를 구성한 모든 정점에서 자기 자신을 제외한 모든 정점에 대하여 간선이 있는 경우를 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;레이블 그래프(Labeled Graph)&lt;br /&gt;
그래프에서 간선에 실수 레이블을 붙여 표시하는 그래프&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;그래프의-표현&quot;&gt;그래프의 표현&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;인접 행렬&lt;/li&gt;
  &lt;li&gt;인접 리스트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/graph-expression.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="자료구조" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">자료구조(Data Structure) 문제 해결에 있어 가장 효율적으로 자료를 조직하고 구조화하며, 자료를 표현하고 연산하는 일련의 활동을 의미한다.</summary></entry></feed>