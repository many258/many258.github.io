<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://many258.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://many258.github.io//" rel="alternate" type="text/html" /><updated>2021-01-26T21:04:05+09:00</updated><id>https://many258.github.io//feed.xml</id><title type="html">My expression</title><subtitle>My expression</subtitle><author><name>SG Yoo.</name><email>many258@naver.com</email></author><entry><title type="html">[(구)정처기/컴퓨터일반] (3) 운영체제 자주 틀리는 내용 정리</title><link href="https://many258.github.io//study/operating-system/" rel="alternate" type="text/html" title="[(구)정처기/컴퓨터일반] (3) 운영체제 자주 틀리는 내용 정리" /><published>2021-01-26T00:00:00+09:00</published><updated>2021-01-26T20:17:34+09:00</updated><id>https://many258.github.io//study/%7Boperating-system%7D</id><content type="html" xml:base="https://many258.github.io//study/operating-system/">&lt;p class=&quot;notice--warning&quot;&gt;&lt;span style=&quot;color:red;font-weight:bold;&quot;&gt;주의)&lt;/span&gt;
해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다.
수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;어셈블리어의-장점&quot;&gt;어셈블리어의 장점&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;어셈블리어로 작성한 원시 프로그램을 기계어로 번역&lt;/li&gt;
  &lt;li&gt;기계어보다 쉽고, 이해하기가 쉽다&lt;/li&gt;
  &lt;li&gt;프로그램의 주소가 기호 번지이다&lt;/li&gt;
  &lt;li&gt;프로그램에 데이터를 사용하기 쉽다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;매크로-프로세서의-기능&quot;&gt;매크로 프로세서의 기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;매크로 정의 인식 : 매크로를 정의한 부분의 시작과 종료 파악&lt;/li&gt;
  &lt;li&gt;매크로 정의 저장 : 매크로 호출 시 확장하기 위해 저장&lt;/li&gt;
  &lt;li&gt;매크로 호출 인식 : 확장하기 위한 준비가 되어 있는 지 확인&lt;/li&gt;
  &lt;li&gt;매크로 확장 및 인수 : 원시 프로그램 위치에 저장된 내용과 인수를 치환&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;로더의-종류&quot;&gt;로더의 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;절대 로더 : 로더의 역할 축소, 한 번 지정한 주기억 장소의 변경이 어려움
    &lt;ul&gt;
      &lt;li&gt;할당, 연결 ⇒ 프로그래머&lt;/li&gt;
      &lt;li&gt;재배치 ⇒ 번역 프로그램&lt;/li&gt;
      &lt;li&gt;적재 ⇒ 로더&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;직접 연결 로더 : 일반적인 로더 형태, 로더가 모두 수행&lt;/li&gt;
  &lt;li&gt;동적 로더 : CPU가 현재 사용중인 부분만 적재, 미사용 중인 것은 보조기억장치에 보관(Load-on-call)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;운영체제의-구성&quot;&gt;운영체제의 구성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;제어프로그램
    &lt;ul&gt;
      &lt;li&gt;감시 프로그램(Supervisor P) : 일명 모니터, 지시/감독&lt;/li&gt;
      &lt;li&gt;데이터 관리 프로그램(Data Management P) : 주기억 장치, 보조기억 장치 간 작업&lt;/li&gt;
      &lt;li&gt;작업 제어 프로그램(Job Control P) : 스케쥴 및 시스템 지원 할당 등을 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;처리 프로그램
    &lt;ul&gt;
      &lt;li&gt;언어 번역 프로그램 : 목적 프로그램으로 번역해주는 프로그램&lt;/li&gt;
      &lt;li&gt;서비스 프로그램 : 모듈이나 프로그램을 사용자가 사용할 수 있도록 제공&lt;/li&gt;
      &lt;li&gt;문제 프로그램 : 사용자의 응용 처리를 위해 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;운영체제의-발달-과정&quot;&gt;운영체제의 발달 과정&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;시분할 처리 : 전문적인 처리기가 존재 하지 않음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스풀-vs-버퍼링&quot;&gt;스풀 vs 버퍼링&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;스풀(Spool) : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그램&lt;/code&gt;과 I/O 장치와의 속도 차를 극복하기 위해, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HDD&lt;/code&gt;가 중재&lt;/li&gt;
  &lt;li&gt;버퍼링(buffering) : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CPU&lt;/code&gt;와 I/O 장치와의 속도 차를 극복하기 위해, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주기억&lt;/code&gt; 장치가 중재&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;pcbprocess-control-block--프로세스-생성-정보-없음&quot;&gt;PCB(Process Control Block) ⇒ 프로세스 생성 정보 없음&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;식별자, 현재 상태, PC, 우선순위, CPU 레지스터 정보, 계정 정보, 기억 장치 관련 정보&lt;/li&gt;
  &lt;li&gt;CPU의 각종 레지스터 상태를 가리키는 포인터, 입출력 정보&lt;/li&gt;
  &lt;li&gt;적재된 기억 장치 부분을 가리키는 포인터, 할당된 자원을 가리키는 포인터&lt;/li&gt;
  &lt;li&gt;부모/자식 프로세스를 가리키는 포인터&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인터럽트-종류&quot;&gt;인터럽트 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SVC(SuperVisor Call) : 감시 프로그램 호출 시 발생&lt;br /&gt;
입출력 수행 루틴 호출 / 기억 장치 할당 루틴 / 오퍼레이터와의 대화&lt;/li&gt;
  &lt;li&gt;입출력(I/O) : 하드웨어적 인터럽트&lt;br /&gt;
입출력 채널 확인, 준비, 할당, 완료, 프로세스 전이(실행 ⇒ 대기)&lt;/li&gt;
  &lt;li&gt;외부(External) : 운영체제 소속이 아닌 외적인 요인으로부터 발생&lt;br /&gt;
인터럽트 시계에 의해 프로세스가 시간 할당량이 종료된 경우,&lt;br /&gt;
웹 서버나 프린터 서버를 운영하고 있는 상태에서 외부로부터 인터럽트 처리 신호 올 때&lt;/li&gt;
  &lt;li&gt;재시작 : 운영체제를 메모리에 다시 상주시킬 때&lt;/li&gt;
  &lt;li&gt;프로그램 검사 : 명령어를 수행하는 과정에서 부분적으로 발생되는 문제&lt;/li&gt;
  &lt;li&gt;기계 검사 : 시스템의 기계 고장&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cpu-스케줄링&quot;&gt;CPU 스케줄링&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;HRN(Highest Response-ratio Next) 스케줄링 기법
    &lt;blockquote&gt;
      &lt;p&gt;(대기 시간 + 서비스 시간) / 서비스 시간&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;세마포어의-특징&quot;&gt;세마포어의 특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;상호배제의 원리 보장&lt;/li&gt;
  &lt;li&gt;소프트웨어나 하드웨어로 구현 가능&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt; 조작 : Wake-Up = Up = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Signal&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; 조작 : Sleep = Down = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Wait&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;교착-상태-해결-방안&quot;&gt;교착 상태 해결 방안&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;예방(Prevention)&lt;br /&gt;
상호배제 부정, 대기 제거, 선점 인정, 선형 대기 상태로 변경 ⇒ 효율적이지 못함&lt;/li&gt;
  &lt;li&gt;회피(Avoidance)&lt;br /&gt;
안정상태를 유지할 수 있는 프로세스의 자원 요구만 할당, 은행원 알고리즘&lt;/li&gt;
  &lt;li&gt;회복(Recovery)&lt;br /&gt;
선점 / 복귀 / 제거 / 사용자의 조치&lt;/li&gt;
  &lt;li&gt;발견(Detection)&lt;br /&gt;
자원 할당 그래프는 시스템이 중단된 이유가 교착상태인가를 발견하는 기법&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;주기억-장치-재사용-기술&quot;&gt;주기억 장치 재사용 기술&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;통합(Coalescing) : 인접한 공백들을 더 큰 하나의 공백으로 만드는 과정&lt;/li&gt;
  &lt;li&gt;집약(Compaction, 압축) : 서로 떨어져 있는 여러 개의 낭비 공간을 모아 하나의 공간으로&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;캐시-기억-장치&quot;&gt;캐시 기억 장치&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주기억 장치 ↔ CPU 간 속도 차이 극복, 버퍼의 기능 수행&lt;/li&gt;
  &lt;li&gt;분리 캐시 : 캐시 접근 시 충돌을 방지하기 위해 코드와 데이터를 분리해서 기억&lt;/li&gt;
  &lt;li&gt;쓰기 접근 빈도가 높다 == 캐싱-일관성 문제가 발생할 확률 높음 == 성능 저하&lt;/li&gt;
  &lt;li&gt;사상 방법
    &lt;ul&gt;
      &lt;li&gt;직접 사상&lt;/li&gt;
      &lt;li&gt;전체 연합 사상
        &lt;ul&gt;
          &lt;li&gt;블록 중 아무 곳이나 하나 정해서 기억&lt;/li&gt;
          &lt;li&gt;메모리 워드의 번지 + 데이터 함께 저장, RR 방식으로 교체&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;세트 연합 사상&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;페이지-교체-알고리즘&quot;&gt;페이지 교체 알고리즘&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;NUR(Not Used Recently)
    &lt;ul&gt;
      &lt;li&gt;참조비트, 변형비트 ⇒ ‘1’ 최근 / ‘0’ 예전&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파일의-구조&quot;&gt;파일의 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;직접 파일(Direct Access File)
    &lt;ul&gt;
      &lt;li&gt;해싱 사상 함수에 의해 물리적인 주소로 변환하여 데이터를 기록 / 검색&lt;/li&gt;
      &lt;li&gt;한 번 파일을 개방하면 읽거나 쓰기를 자유롭게&lt;/li&gt;
      &lt;li&gt;평균 접근 시간 내 접근&lt;/li&gt;
      &lt;li&gt;디스크 기억 장치에 많이 이용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파일-시스템의-기능&quot;&gt;파일 시스템의 기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;파일 저장 / 공유 / 생성 / 변경 / 제거 / 응용 처리&lt;/li&gt;
  &lt;li&gt;백업, 복구, 여러 종류의 접근 제어 방법 제공, 파일 간 정보 전송&lt;/li&gt;
  &lt;li&gt;기호형 이름을 사용 ⇒ 자신의 파일을 참조할 수 있도록 장치 독립성을 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;디렉터리&quot;&gt;디렉터리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;비순환(주기) 그래프 디렉터리
    &lt;ul&gt;
      &lt;li&gt;트리구조와 유사, 사이클 불허&lt;/li&gt;
      &lt;li&gt;하나의 파일을 여러 사용자가 공유하기 때문에 삭제 시 문제점 발생&lt;/li&gt;
      &lt;li&gt;융통성이 있으며 기억 공간을 절약할 수 있으나 복잡&lt;/li&gt;
      &lt;li&gt;하나의 파일이 다수의 이름으로 존재&lt;/li&gt;
      &lt;li&gt;공유하고 있는 파일 제거 시 Dangling Pointer 발생 가능&lt;/li&gt;
      &lt;li&gt;Unix 운영체제에서 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;보안-유지-방식&quot;&gt;보안 유지 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;외부 보안 : 천재지변으로부터 컴퓨터를 보호&lt;/li&gt;
  &lt;li&gt;내부 보안 : 운영체제/하드웨어 내장, 프로그램의 신뢰성 있는 운영/무결성 보장&lt;/li&gt;
  &lt;li&gt;사용자 인터페이스 보안 : 인증, 패스워드&lt;/li&gt;
  &lt;li&gt;암호화
    &lt;ul&gt;
      &lt;li&gt;비밀키 = 공통키 = 대칭키 = 관용키 = 단일키 = Private Key System
        &lt;ul&gt;
          &lt;li&gt;암호화 키 = 복호화 키&lt;/li&gt;
          &lt;li&gt;DES, 평문을 암호화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;공개키 = 비대칭키
        &lt;ul&gt;
          &lt;li&gt;암호화 키(공개) != 복호화 키(보호)&lt;/li&gt;
          &lt;li&gt;키 분배가 간단, 암호화 과정 복잡, 속도가 느림&lt;/li&gt;
          &lt;li&gt;RSA, PGP&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;flynn&quot;&gt;Flynn&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SISD : 개인 컴퓨터, Pipeline 기법&lt;/li&gt;
  &lt;li&gt;MISD : 실제 없음&lt;/li&gt;
  &lt;li&gt;SIMD : 대형 컴퓨터, Array Processor&lt;/li&gt;
  &lt;li&gt;MIMD : 분산/병렬 컴퓨터
    &lt;ul&gt;
      &lt;li&gt;교환형 다중 처리기 : 크로스바 교환 행렬(버스의 수 만큼 메모리 증가)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-시스템의-결함&quot;&gt;분산 시스템의 결함&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;링크 결함, 사이트 결함, 메시지의 분실&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-처리-시스템의-계층-구조&quot;&gt;분산 처리 시스템의 계층 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;하드웨어 ⇒ 기억 장치 ⇒ 프로세스 ⇒ 파일 시스템 ⇒ 사용자 응용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unix-기본-구성&quot;&gt;UNIX 기본 구성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;쉘
    &lt;ul&gt;
      &lt;li&gt;명령의 입력을 받아 시스템 기능을 수행하는 명령 해석기&lt;/li&gt;
      &lt;li&gt;사용자 시스템 간 인터페이스 담당, 여러 가지 내장 명령어 보유&lt;/li&gt;
      &lt;li&gt;파이프라인 기능, 입출력 방향 지정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unix-특징&quot;&gt;UNIX 특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Pipe : 먼저 입력된 데이터를 먼저 처리하는 선형 구조(FIFO) 형태로 통신 경로 확보&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unix-파일-시스템&quot;&gt;UNIX 파일 시스템&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;부트 블록&lt;/li&gt;
  &lt;li&gt;실린더 블록&lt;/li&gt;
  &lt;li&gt;i-Node 테이블
    &lt;ul&gt;
      &lt;li&gt;사용자 ID, 그룹 ID, 보호모드, 블록 주소&lt;/li&gt;
      &lt;li&gt;처음 생성 시기, 마지막 사용 시기, 최종 수정 시기&lt;/li&gt;
      &lt;li&gt;파일 링크 수, 파일 속성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일 테이블 블록&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unix-주요-명령어&quot;&gt;UNIX 주요 명령어&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Mount : 파일 시스템에 새로운 파일 시스템을 서브 디렉터리에 연결할 때 사용&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.</summary></entry><entry><title type="html">[(구)정처기/컴퓨터일반] (2) 전자계산기 자주 틀리는 내용 정리</title><link href="https://many258.github.io//study/electronic-calculator/" rel="alternate" type="text/html" title="[(구)정처기/컴퓨터일반] (2) 전자계산기 자주 틀리는 내용 정리" /><published>2021-01-26T00:00:00+09:00</published><updated>2021-01-26T12:17:34+09:00</updated><id>https://many258.github.io//study/%7Belectronic-calculator%7D</id><content type="html" xml:base="https://many258.github.io//study/electronic-calculator/">&lt;p class=&quot;notice--warning&quot;&gt;&lt;span style=&quot;color:red;font-weight:bold;&quot;&gt;주의)&lt;/span&gt;
해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다.
수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;불-대수-기본-정리&quot;&gt;불 대수 기본 정리&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A + A = A&lt;/td&gt;
      &lt;td&gt;A · A = A&lt;/td&gt;
      &lt;td&gt;A · 0 = 0&lt;/td&gt;
      &lt;td&gt;A + 0 = A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A + 1 = 1&lt;/td&gt;
      &lt;td&gt;A · 1 = A&lt;/td&gt;
      &lt;td&gt;0 + 0 = 0&lt;/td&gt;
      &lt;td&gt;0 · 0 = 0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1 + 0 = 1&lt;/td&gt;
      &lt;td&gt;1 · 0 = 0&lt;/td&gt;
      &lt;td&gt;1 + 1 = 1&lt;/td&gt;
      &lt;td&gt;1 · 1 = 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A + A·B = A&lt;/td&gt;
      &lt;td&gt;A·(A + B) = A&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;논리게이트&quot;&gt;논리게이트&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Exclusive OR : A, B 입력 ⇒ 서로 다를 때 1출력, 같을 때 0 출력&lt;/li&gt;
  &lt;li&gt;Exclusive NOT OR : A,B 입력 값 ⇒ 서로 같을 때 1, 다를 때 0 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;조합-논리-회로&quot;&gt;조합 논리 회로&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;반가산기(Half Adder) : AND(1) + XOR(1)
    &lt;blockquote&gt;
      &lt;p&gt;S : A ⊕ B / C : A·B&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;반감산기(Half Subtracter) : NOT(1) + AND(1) + XOR(1)
    &lt;blockquote&gt;
      &lt;p&gt;D : X ⊕ Y / B : X’ · Y&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;전가산기(Full Adder) : Half Adder(2) + OR(1)
    &lt;blockquote&gt;
      &lt;p&gt;S : A ⊕ B ⊕ C / C : (A ⊕ B) · C + A · B = A · B + B · C + A · C&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;전감산기(Full Subtracter) : Half Subtracter(2) + OR(1)
    &lt;blockquote&gt;
      &lt;p&gt;D = X ⊕ Y ⊕ B / B = (X ⊕ Y)’·B + X’ · Y&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;병렬 가산기 :&lt;br /&gt;
반가산기(2n-1)개 + OR(n-1)개 / 전가산기(n개)를 여러 개 사용&lt;/li&gt;
  &lt;li&gt;디코더 = 해독기&lt;br /&gt;
N개의 입력 ⇒ 2&lt;sup&gt;n&lt;/sup&gt;개의 출력&lt;/li&gt;
  &lt;li&gt;인코더&lt;br /&gt;
2&lt;sup&gt;n&lt;/sup&gt;개의 입력 ⇒ n개의 출력&lt;/li&gt;
  &lt;li&gt;멀티플렉서 == 선택기&lt;br /&gt;
2&lt;sup&gt;n&lt;/sup&gt;개의 입력선 + n개의 선택선 ⇒ 하나의 출력&lt;/li&gt;
  &lt;li&gt;디멀티플렉서&lt;br /&gt;
하나의 입력 정보 + n개의 선택선 ⇒ 2&lt;sup&gt;n&lt;/sup&gt; 개의 출력&lt;/li&gt;
  &lt;li&gt;비교기 : Exclusive NOR(n개) 연결&lt;/li&gt;
  &lt;li&gt;3-상태 버퍼&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;순서-논리-회로&quot;&gt;순서 논리 회로&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;플립플롭 : 현 상태값에 관계 없이 입력 값을 다음 상태로 전달하는 특징이 있음&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;RS플립플롭 : S, R 단자가 모두 1인 경우 ⇒ 불허용&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;JK 플립플롭 : S, R 단자가 모두 1인 경우 ⇒ 반전(토글)&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;D 플립플롭 : 배타적인 경우만 이용, D 입력(1) ⇒ 출력(1)&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;T 플립플롭 : 토글 기능만 작동&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;마스터 슬래이브 플립플롭 : Race 현상 해결하기 위해&lt;/li&gt;
  &lt;li&gt;카운터&lt;/li&gt;
  &lt;li&gt;레지스터&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;자료의-외부-표현&quot;&gt;자료의 외부 표현&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;BCD : Zone(2Bit) + Digit(4Bit) ⇒ 6Bit&lt;/li&gt;
  &lt;li&gt;EBCDIC : Zone(4Bit) + Digit(4Bit) ⇒ 8Bit&lt;/li&gt;
  &lt;li&gt;ASCII : Zone(3Bit) + Digit(4Bit) ⇒ 7Bit + Parity(1Bit)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;고정-소수점-수에서-음수-표현-방식에-따른-특징&quot;&gt;고정 소수점 수에서 음수 표현 방식에 따른 특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;수의 표현 범위
    &lt;ul&gt;
      &lt;li&gt;부호와 절대치 : -(2^(n-1)-1) ~ 2^(n-1)-1&lt;/li&gt;
      &lt;li&gt;1의 보수 : -(2^(n-1)-1)~2^(n-1)-1&lt;/li&gt;
      &lt;li&gt;2의 보수 : -2^(n-1) ~ 2^(n-1)-1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;부동-소수점&quot;&gt;부동 소수점&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;부호(1), 지수(8), 가수(23)&lt;/li&gt;
  &lt;li&gt;나눗셈 과정 :
    &lt;ul&gt;
      &lt;li&gt;0인지 조사 ⇒&lt;/li&gt;
      &lt;li&gt;부호 결정 ⇒&lt;/li&gt;
      &lt;li&gt;피젯수를 위치 조정 ⇒&lt;/li&gt;
      &lt;li&gt;지수 뺄셈 ⇒&lt;/li&gt;
      &lt;li&gt;가수 나눗셈 ⇒&lt;/li&gt;
      &lt;li&gt;결과의 정규화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메가플롭스(MFLOPS) : 1초간에 실행되는 부동 소수점 연산의 수를 100만 단위로 표현&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;10진-표현&quot;&gt;10진 표현&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;언팩 10진 표현 :  연산 불가, 입출력 작업 시&lt;br /&gt;
부호는 맨 마지막 바이트의 존 부분에 표현(+:C(1100), -:D(1101))&lt;/li&gt;
  &lt;li&gt;팩 10진 표현 :&lt;br /&gt;
연산 가능, 부호는 맨 마지막 4비트(+:C(1100), -:D(1101))&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;코드의-분류&quot;&gt;코드의 분류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;가중치 코드 : 자리 값을 가지고 있는 코드
    &lt;ul&gt;
      &lt;li&gt;8421, 2421, 7421, 5421, 5111, Biquinary, Ring Counter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비가중치 코드 : 자리 값이 없는 코드
    &lt;ul&gt;
      &lt;li&gt;3초과 코드, 그레이 코드, 2-out-of-5 코드, 3-out-of-5 코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자기 보수 코드 : 코드의 1의 보수 == 10진수의 9의 보수&lt;/li&gt;
  &lt;li&gt;3초과 코드, 2421, 5211, 5111, 8421&lt;/li&gt;
  &lt;li&gt;에러 검출 코드
    &lt;ul&gt;
      &lt;li&gt;패리티, 해밍, 2-out-of-5 코드, 3-out-of-5 코드, Biquinary, Ring Counter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Gray 코드 : 기계적인 동작을 제어하는데 적당&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;수치적-연산&quot;&gt;수치적 연산&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;산술 시프트&lt;/li&gt;
  &lt;li&gt;우측 산술 시프트
    &lt;blockquote&gt;
      &lt;p&gt;부호와 절대치 표현 ⇒ 부호 비트 고정
1의 보수 ⇒ 음수일 경우 1 패딩
2의 보수 ⇒ 음수일 경우 1 패딩&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;좌측 산술 시프트
    &lt;blockquote&gt;
      &lt;p&gt;부호와 절대치 표현 ⇒ 부호 비트 고정
1의 보수 ⇒ 부호 비트 고정, 음수일 경우 1패딩
2의 보수 ⇒ 부호 비트 고정&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;명령어의-구조&quot;&gt;명령어의 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;연산자 = Op-Code : Op-Code (n)Bit ⇒ 명령어 생성 개수 = 2^n&lt;/li&gt;
  &lt;li&gt;모드 : 직접 주소 / 간접 주소&lt;/li&gt;
  &lt;li&gt;주소 : 메모리 용량이 2^n ⇒ Operand (n)Bit&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;연산자operation-op-code의-기능&quot;&gt;연산자(Operation, Op-Code)의 기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;함수 연산 기능, 제어 기능, 전달 기능, 입출력 기능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;명령어-세트의-효율성을-향상시키기-위한-고려사항&quot;&gt;명령어 세트의 효율성을 향상시키기 위한 고려사항&lt;/h3&gt;
&lt;p&gt;기억 공간, 사용 빈도, 주기억 장치의 밴드폭 사용, 주소 지정 방식
함수 연산 기능 대 기타 연산 기능의 비율&lt;/p&gt;

&lt;h3 id=&quot;명령어-설계-과정-고려사항&quot;&gt;명령어 설계 과정 고려사항&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;연산자의 수, 종류 / 주소 지정 방식 / 데이터 구조 / 워드 크기&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;명령어의-종류&quot;&gt;명령어의 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 처리 명령어&lt;br /&gt;
ADD / SUB / MUL / DIV
INC / DEC
AND / OR / XOR / COMPLEMENT / CLEAR
산술, 논리 SHIFT / ROTATE&lt;/li&gt;
  &lt;li&gt;데이터 전송 명령어&lt;br /&gt;
LOAD / STORE / MOVE / PUSH / POP / INPUT / OUTPUT&lt;/li&gt;
  &lt;li&gt;데이터 제어 명령어&lt;br /&gt;
JUMP / SMA / SZC / SKIP / SZA / ISZ / RETI / CALL / RETURN / HALT&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;명령어-메모리-참조-형식&quot;&gt;명령어 메모리 참조 형식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;레지스터 참조 명령(RRI : Register Reference Instruction)&lt;/li&gt;
  &lt;li&gt;메모리 참조 명령(MRI : Memory Reference Instruction)&lt;/li&gt;
  &lt;li&gt;입출력 명령(IOI : Input Output Instruction)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;주소-지정-방식&quot;&gt;주소 지정 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;즉시 주소(Immediate Address) :&lt;br /&gt;
주소 부분에 실제 데이터가 들어있는 방식&lt;/li&gt;
  &lt;li&gt;직접 주소(Direct Address) :&lt;br /&gt;
주소 부분에 실제 데이터가 들어있는 유효주소가 있음&lt;/li&gt;
  &lt;li&gt;계산에 의한 주소(Calculate Address)&lt;/li&gt;
  &lt;li&gt;인덱스 주소 지정(Index Register Address) :&lt;br /&gt;
인덱스 레지스터, 배열 엑세스 방식&lt;/li&gt;
  &lt;li&gt;상대 주소 지정(Relative Address) :&lt;br /&gt;
PC, 데이터 영역의 배치와 Program 배치 유사, 분기 명령&lt;/li&gt;
  &lt;li&gt;기준 주소 지정(Base Register Address) :&lt;br /&gt;
베이스 레지스터, 프로그램 재배치, 다중 프로그래밍 기법에서 주로 사용&lt;/li&gt;
  &lt;li&gt;간접 주소(Indirect Address)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cpu의-구분&quot;&gt;CPU의 구분&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;스택 구조 CPU : 0 주소 명령어 형식, Postfix 표기법&lt;/li&gt;
  &lt;li&gt;단일 누산기 구조 CPU : 1주소 명령어 형식, Infix 표기법&lt;/li&gt;
  &lt;li&gt;범용 레지스터 구조 CPU : 2주소 명령어 형식, Prefix 표기법&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로세서의-종류&quot;&gt;프로세서의 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CISC(Complex Instruction Set Computer)&lt;br /&gt;
초창기 컴퓨터, 마이크로 프로그램 제어 방식 사용&lt;br /&gt;
메모리 참조 연산&lt;/li&gt;
  &lt;li&gt;RISC(Reduced Instruction Set Computer)&lt;br /&gt;
하드 와이어드 제어 방식&lt;br /&gt;
중요 명령어 ROM에 저장&lt;br /&gt;
명령어 길이 고정, 명령어의 개수 적음&lt;br /&gt;
레지스터 참조 연산&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;레지스터&quot;&gt;레지스터&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;AR(Address Register) : 기억용량과 관련, 주기억장치 / 워드 길이&lt;/li&gt;
  &lt;li&gt;PC(Program Counter)&lt;/li&gt;
  &lt;li&gt;MAR(Memory Address Register)&lt;/li&gt;
  &lt;li&gt;DR(Data Register) : 기억 장치의 워드 크기와 관련&lt;/li&gt;
  &lt;li&gt;MBR(Memory Buffer Register)&lt;/li&gt;
  &lt;li&gt;Status Register : 프로그램 제어를 위한 상태 정보를 기억&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;명령어-수행-순서&quot;&gt;명령어 수행 순서&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;명령어 인출 ⇒ 명령어 해독 ⇒ 오퍼랜드 인출 ⇒ 실행 ⇒ 인터럽트 조사&lt;br /&gt;
Instruction Fetch ⇒ Instruction Decoder ⇒ Operand Fetch ⇒ Exe ⇒ Interrupt Search&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;마이크로-오퍼레이션&quot;&gt;마이크로 오퍼레이션&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;하나의 클록 펄스 동안 실행되는 기본 동작을 의미&lt;/li&gt;
  &lt;li&gt;CPU에 있는 레지스터와 플래그의 상태 변환을 일으키게 하는 동작&lt;/li&gt;
  &lt;li&gt;CPU에서 발생시키는 제어 신호에 따라 마이크로 오퍼레이션이 순서적 실행&lt;/li&gt;
  &lt;li&gt;동기 고정식 마이크로오퍼레이션
    &lt;ul&gt;
      &lt;li&gt;마이크로 사이클 타임이 가장 긴 것 == 클록 주기&lt;/li&gt;
      &lt;li&gt;수행 시간이 차이가 날 때 CPU의 시간 낭비, 구현 간단&lt;/li&gt;
      &lt;li&gt;여러 종류의 MO 수행 시 CPU 사이클 타임이 실제적인 오퍼레이션 시간보다 김&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;클럭-사이클-시간&quot;&gt;클럭 사이클 시간&lt;/h3&gt;
&lt;p&gt;조합 논리 회로 : 세그먼트 중 가장 긴 것 + 가장 짧은 것&lt;/p&gt;

&lt;h3 id=&quot;메이져-상태&quot;&gt;메이져 상태&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;인출 주기&lt;/li&gt;
  &lt;li&gt;간접 주기&lt;/li&gt;
  &lt;li&gt;실행 주기
    &lt;ul&gt;
      &lt;li&gt;ADD&lt;/li&gt;
      &lt;li&gt;AND&lt;/li&gt;
      &lt;li&gt;LOAD&lt;/li&gt;
      &lt;li&gt;STORE&lt;/li&gt;
      &lt;li&gt;BUN(JUMP)&lt;/li&gt;
      &lt;li&gt;BSA(Branch and Save Return Address)&lt;/li&gt;
      &lt;li&gt;ISZ(Increment and Skip if Zero) : 프로그램의 수행 순서를 조건에 따라 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인터럽트 주기&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-장치&quot;&gt;제어 장치&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;제어 메모리 : 액세스 타임이 빠른 ROM으로 만들어진다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;cpu의-제어-데이터&quot;&gt;CPU의 제어 데이터&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;제어 데이터&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;인출&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;간접&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;실행&lt;/th&gt;
      &lt;th&gt;인터럽트&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;메이저 상태를 변화시키는 데이터&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;명령어&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;직/간접 주로 방식을 판별하는 비트&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;인터럽트 요청 신호&lt;/td&gt;
      &lt;td&gt;없음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CPU의 제어점을 제어하는 데이터&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;명령어&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;명령어의 연산자 부분&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;명령어의 연산자 부분&lt;/td&gt;
      &lt;td&gt;기종에 따라 다름&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;명령 수행 순서를 결정하는 제어 데이터&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;명령어&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;기억 장치에서 읽어낸 실제 데이터 주소&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PC&lt;/td&gt;
      &lt;td&gt;기종에 따라 다름&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;마이크로-프로그램&quot;&gt;마이크로 프로그램&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;일련의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 워드&lt;/code&gt;가 특수한 기억 장치 속에 저장되어 기계어 명령어들이 적절히 수행되도록 각종 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 신호를 발생&lt;/code&gt;시키는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그램&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;제어-장치의-구현-방법&quot;&gt;제어 장치의 구현 방법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;고정 배선식 제어 방식(Hard Wired)&lt;br /&gt;
하드웨어적, 속도 빠름, 변경 불가, 회로 복잡, 변경이 어려움&lt;/li&gt;
  &lt;li&gt;마이크로프로그램 제어 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제어-메모리에서-번지-결정-방법&quot;&gt;제어 메모리에서 번지 결정 방법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;순차 수행 : 제어 주소 레지스터의 내용을 +1 결정&lt;/li&gt;
  &lt;li&gt;무조건 분기 : 마이크로 명령어 상에 있는 분기 주소에 나타난 다음 명령어 수행&lt;/li&gt;
  &lt;li&gt;조건 분기 : 상태 플래그의 내용에 따라&lt;/li&gt;
  &lt;li&gt;서브 루틴 : 독립된 서브 마이크로프로그램 호출하여 수행&lt;/li&gt;
  &lt;li&gt;매크로 : 반복되는 부분을 매크로로 정의하고 직접 제어 메모리로 매핑&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;주기억-장치&quot;&gt;주기억 장치&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DRAM&lt;br /&gt;
재충전 시간이 필요하므로 사이클 시간 &amp;gt; 접근 시간&lt;/li&gt;
  &lt;li&gt;DRO(파괴성 판독 : Destructive Read Out)
    &lt;ul&gt;
      &lt;li&gt;메모리에서 데이터를 읽어내면서 원래의 데이터를 소거하는 판독 방법으로 메모리에서 정보를 보존하려면 읽어낸 뒤 즉시 재기입하여하 하기 때문에&lt;/li&gt;
      &lt;li&gt;사이클 타임 &amp;gt; 접근 시간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SSD(Solid State Drive) : 메모리 반도체를 사용하는 대용량 저장 장치
    &lt;ul&gt;
      &lt;li&gt;SLC / MLC / TLC(속도 빠름/수명 길다 ↔ 속도 느림/수명 짧음)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CPLD(Complex Programmable Logic Device)
    &lt;ul&gt;
      &lt;li&gt;LAB, PIA로 구성되어 규칙적이고 빠른 타이밍이 필요하거나 어드레스 디코더 같은 간단한 로직 구현에 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;보조-기억-장치&quot;&gt;보조 기억 장치&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;자기 디스크
    &lt;ul&gt;
      &lt;li&gt;등선 속도(CLV : Constant Linear Velocity)
        &lt;ul&gt;
          &lt;li&gt;디스크의 안쪽, 바깥쪽 회전 속도가 일정하지 않음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;등각 속도(CAV : Constant Angular Velocity)
        &lt;ul&gt;
          &lt;li&gt;외부 면의 저장 밀도가 떨어져 공간 낭비 유발, 접근 속도 빠름&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;블루레이&lt;br /&gt;
405nm 파장의 청자색 레이저 사용, DVD보다 많이 저장 가능&lt;br /&gt;
한 면에 최대 27GB, 듀얼 50GB, MPEG-2 압축 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;캐시메모리&quot;&gt;캐시메모리&lt;/h3&gt;
&lt;p&gt;캐시 메모리 평균 액세스 시간 = 히트 시간 + 미스도 + 미스 패널티&lt;br /&gt;
캐시 블록 번호 = 주기억 장치 블록 번호(= 번지 / 블록 크기) MOD 캐시 전체의 블록 수&lt;br /&gt;
캐시 메모리에 데이터 저장 시 주기억 장치와의 관계&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Write Through : 캐시에 저장이 일어날 때 캐시와 주기억 장치를 동시에 갱신&lt;/li&gt;
  &lt;li&gt;Write Back : 캐시의 내용만 갱신이 일어나다가 블록이 캐시에서 제거될 때, 주기억에 복사해서 갱신&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;연관-기억-장치associative-memory&quot;&gt;연관 기억 장치(Associative Memory)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;기억된 정보의 일부분을 이용하여 원하는 정보를 검색 ⇒ 주소가 필요 없음&lt;/li&gt;
  &lt;li&gt;신속한 검색, 병렬판독회로 내장(가격이 비싸다)&lt;/li&gt;
  &lt;li&gt;작은 용량의 IC메모리를 사용하여 캐시 메모리나 가상 메모리의 주소 탐색에 주로 이용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;가상-기억-장치&quot;&gt;가상 기억 장치&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;실제 페이지의 개수 = 주기억 장치 용량 / 하나의 페이지 크기&lt;/li&gt;
  &lt;li&gt;가상 페이지의 개수 = 가상 주소(nBit ⇒ 2^n) / 하나의 페이지 크기&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메모리-인터리빙&quot;&gt;메모리 인터리빙&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;독립된 메모리를 2개 이상 나누어 연결하고 CPU에서 각각 독립된 메모리를 번갈아가면서 연속적으로 액세스가 이루어지도록 구현하는 방법&lt;/li&gt;
  &lt;li&gt;CPU의 처리속도에 비해 사이클 타임이 오래 걸리지만, 접근하는 시간은 효율적&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기억-장치--입출력-장치&quot;&gt;기억 장치 / 입출력 장치&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;동작 속도 / 정보 단위 / 동작의 자율성 / 에러율&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;입출력-제어기의-역할&quot;&gt;입출력 제어기의 역할&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 버퍼링 / 제어 신호의 논리적, 물리적 변환&lt;/li&gt;
  &lt;li&gt;통신 회선 확보 / 상태 정보 저장 / 주기억 장치 접근 / 데이터 교환&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;고립형-입출력-포트io-mapped-io-port&quot;&gt;고립형 입출력 포트(I/O Mapped I/O Port)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;입출력 포트와 메모리 주소가 독립적인 상태&lt;/li&gt;
  &lt;li&gt;마이크로프로세서는 뚜렷한 입출력 명령을 가짐
각 명령은 인터페이스 레지스터의 주소를 가짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;메모리-맵-입출력-포트memory-mapped-io-port&quot;&gt;메모리 맵 입출력 포트(Memory Mapped I/O Port)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;입출력 포트와 메모리 주소가 종속적인 상태&lt;/li&gt;
  &lt;li&gt;마이크로프로세서가 인터페이스 레지스터를 메모리 시스템의 한 부분으로 인식&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dmadirect-memory-access&quot;&gt;DMA(Direct Memory Access)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;단어 계수기는 입출력이 일어날 때마다 하나씩 감소하여 0이 되면 인터럽트를 요청하여 블록에 대한 입출력이 완료되었음을 CPU에게 알림&lt;/li&gt;
  &lt;li&gt;구성요소
    &lt;ul&gt;
      &lt;li&gt;인터페이스 회로 :  CPU ↔ 입출력 장치 통신&lt;/li&gt;
      &lt;li&gt;번지 레지스터 :  기억 장치와 위치 지정을 위한 번지를 기억&lt;/li&gt;
      &lt;li&gt;워드카운터 레지스터 : 전송되어야 할 워드의 수 표시&lt;/li&gt;
      &lt;li&gt;제어 레지스터 : 전송 방식을 결정&lt;/li&gt;
      &lt;li&gt;데이터 버스 버퍼, 주소 버스 버퍼&lt;/li&gt;
      &lt;li&gt;Data Buffer Register / F Flip-Flop / Status Register / Address Register / Word Counter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;사이클-스틸&quot;&gt;사이클 스틸&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CPU 상태를 보존할 필요가 없음&lt;/li&gt;
  &lt;li&gt;CPU가 잠시 쉴 수 있음&lt;/li&gt;
  &lt;li&gt;아무 사이클이나 상관없이 훔치는 것이 가능&lt;/li&gt;
  &lt;li&gt;DMA의 우선순위는 메모리 참조의 경우 CPU장치보다 상대적으로 높음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;채널&quot;&gt;채널&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Interlock Channel : 하나 이상의 입출력 요청이 들어올 경우 이를 적절히 수행&lt;/li&gt;
  &lt;li&gt;Crossbar Channel : 여러 개의 채널 제어기 중 아무거나 사용해서 입출력할 수 있는 방식&lt;/li&gt;
  &lt;li&gt;버스트 모드 : 하나의 I/O 장치가 데이터 전송을 하고 있는 동안 채널의 기능을 완전히 독점하여 대량의 데이터를 고속으로 전송&lt;/li&gt;
  &lt;li&gt;멀티플렉서 모드 : 여러 개의 I/O 장치가 채널의 기능을 공유하여 시간 분할 형식으로 데이터를 전송하는 형태, 저속의 I/O 장치 여러 개를 연결하는 방식&lt;/li&gt;
  &lt;li&gt;입출력 수행 중 어떤 에러 조건에서 CPU에 인터럽트를 걸 수 있음&lt;/li&gt;
  &lt;li&gt;구성요소
    &lt;ul&gt;
      &lt;li&gt;채널 명령어(CCW : Channel Command Word) : 주기억 장치에 있는 하나의 블록 입출력 정보를 가지고 있는 명령어
        &lt;ul&gt;
          &lt;li&gt;Operation Code : I/O 여부 / 분기 / 입출력 장치 제어 / 채널 동작 정보&lt;/li&gt;
          &lt;li&gt;블록 주소 : 블록의 첫 번째 시작 주소&lt;/li&gt;
          &lt;li&gt;블록의 단어수 : 입출력하고자 하는 블록 워드의 개수&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;다음 채널 명령의 주소 : PC가 없으므로 다음에 수행해야 할 명령어 있음&lt;/li&gt;
      &lt;li&gt;채널 주소 단어(CAW : Channel Address Word) : 채널 명령어의 시작 주소를 기억&lt;/li&gt;
      &lt;li&gt;채널 상태 단어(CSW : Channel Status Word) : 채널 정보, I/O 장치 정보 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인터럽트-종류&quot;&gt;인터럽트 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;페이지 폴트 / 캐시 미스 인터럽트&lt;/li&gt;
  &lt;li&gt;외부 인터럽트 : 타이머 인터럽트나 조작원의 의도적 동작인 입출력 인터럽트&lt;/li&gt;
  &lt;li&gt;내부 인터럽트 : 0으로 나누기 / 불법적인 명령어 사용 / 오버, 언더 플로우
    &lt;ul&gt;
      &lt;li&gt;트랩 : 어떤 프로세스가 특정 시스템 기능을 사용하려고 할 때 OS에게 요청&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;I/O 인터럽트 : 의도적으로 인터럽트 발생 가능&lt;/li&gt;
  &lt;li&gt;SVC(Super Visor Call) : 사용자가 프로그램을 이용하여 직접 인터럽트를 호출&lt;/li&gt;
  &lt;li&gt;차단 불가능 인터럽트(NMI : Non-Maskable Interrupt)
    &lt;ul&gt;
      &lt;li&gt;인터럽트 마스크에 영향을 받지 않는 우선순위가 가장 높은 인터럽트&lt;/li&gt;
      &lt;li&gt;정전, 심각한 하드웨어 이상 인터럽트에 해당&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인터럽트-발생-시-cpu의-처리-사항&quot;&gt;인터럽트 발생 시 CPU의 처리 사항&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;PC&lt;/li&gt;
  &lt;li&gt;프로그램에서 사용한 모든 레지스터의 내용&lt;/li&gt;
  &lt;li&gt;플래그 상태 조건 내용&lt;/li&gt;
  &lt;li&gt;스택의 내용 / 메모리 0번지의 내용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인터럽트-우선순위-부여-방식&quot;&gt;인터럽트 우선순위 부여 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;폴링 = 프로그램에 의한 I/O 제어 방식
    &lt;ul&gt;
      &lt;li&gt;CPU와 I/O 장치 사이의 데이터 전달이 프로그램에 의해서 제어되는 방법&lt;/li&gt;
      &lt;li&gt;프로그램에서 D와 B 상태를 검사하여 데이터를 전송&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인터럽트 요청 체인 방식&lt;/li&gt;
  &lt;li&gt;인터럽트 우선순위 체인 방식&lt;/li&gt;
  &lt;li&gt;병렬 우선순위 부여 방식
    &lt;ul&gt;
      &lt;li&gt;처리 중인 인터럽트보다 우선순위가 낮은 것을 비활성화시키는 마스크 레지스터&lt;/li&gt;
      &lt;li&gt;인터럽트 처리 루틴 없이 인터럽트 취급 루틴 시작&lt;/li&gt;
      &lt;li&gt;CPU에 있는 인터럽트 레지스터의 각 비트는 요청 회선과 연결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인터럽트-작동-순서&quot;&gt;인터럽트 작동 순서&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;인터럽트 요청 ⇒ 현 상태 보존 ⇒ 인터럽트 판별 ⇒ 인터럽트 취급 ⇒ 원 상태 복귀&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;병렬-컴퓨터-구조&quot;&gt;병렬 컴퓨터 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;파이프라인 클록 타임
    &lt;blockquote&gt;
      &lt;p&gt;T = (k + (N -1)) (k:파이프라인 단계 수, N : 수행할 명령어의 개수)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;상호연결-구조&quot;&gt;상호연결 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;다중 처리기
    &lt;ul&gt;
      &lt;li&gt;Bus, 크로스바 스위치, 다단 상호 연결망(오메가 스위치)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다중 컴퓨터
    &lt;ul&gt;
      &lt;li&gt;Bus, 그리드, 하이퍼큐브&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;시스톨릭-배열systolic-array&quot;&gt;시스톨릭 배열(Systolic Array)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파이프라인 어레이 구조&lt;/code&gt;의 새로운 범주로서 지역적으로 연결된 프로세서들이 규칙적으로 데이터를 계산하고 시스템을 통해 데이터를 전달하는 프로세서 네트워크&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;벡터 처리기&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MISD&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;파일-보호-기법&quot;&gt;파일 보호 기법&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;파일 명명, 접근 제어, 암호화&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;보안-유지-방식&quot;&gt;보안 유지 방식&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부인 방지(Non-repudiation)&lt;/code&gt; : 데이터를 송수신한 자가 송수신 사실을 부인할 수 없도록 송수신 증거를 제공하는 것, 공개키 암호 방식 이용&lt;/p&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.</summary></entry><entry><title type="html">[(구)정처기/컴퓨터일반] (1) 데이터베이스 자주 틀리는 내용 정리</title><link href="https://many258.github.io//study/database/" rel="alternate" type="text/html" title="[(구)정처기/컴퓨터일반] (1) 데이터베이스 자주 틀리는 내용 정리" /><published>2021-01-25T00:00:00+09:00</published><updated>2021-01-25T20:47:34+09:00</updated><id>https://many258.github.io//study/%7Bdatabase%7D</id><content type="html" xml:base="https://many258.github.io//study/database/">&lt;p class=&quot;notice--warning&quot;&gt;&lt;span style=&quot;color:red;font-weight:bold;&quot;&gt;주의)&lt;/span&gt;
해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다.
수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;데이터-모델의-구성요소&quot;&gt;데이터 모델의 구성요소&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구조(Structure)&lt;/code&gt; : 개념적 / 논리적 구성 형태&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연산(Operation)&lt;/code&gt; : 개체 인스턴스의 삽입, 삭제, 검색, 갱신 처리 방법&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제약사항(Constraint)&lt;/code&gt; : 개체 인스턴스의 허용 기준&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;e-r-관계-모델&quot;&gt;E-R 관계 모델&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;원 : 속성 / 사각형 : 객체 / 마름모 : 관계&lt;/li&gt;
  &lt;li&gt;개념적 설계에서 주로 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;논리적-데이터-모델&quot;&gt;논리적 데이터 모델&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;개념적 구조 ⇒ 논리적 구조&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;네트워크-데이터-모델&quot;&gt;네트워크 데이터 모델&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;오너-멤버 관계, 그래프 구조 형태&lt;/li&gt;
  &lt;li&gt;연계성이 매우 우월, CODASYL / DBTG&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;관계-대수&quot;&gt;관계 대수&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;릴레이션으로부터 필요한 릴레이션을 만들어내는 연산자의 집합&lt;/li&gt;
  &lt;li&gt;릴레이션 조작을 위한 연산&lt;/li&gt;
  &lt;li&gt;원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적인 방법&lt;/li&gt;
  &lt;li&gt;합집합 / 교집합 / 차집합 / 곱집합 / 설렉션 / 프로젝션 / 조인 / 디비젼&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;관계-해석&quot;&gt;관계 해석&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;수학의 프레디킷 해석에 기반&lt;/li&gt;
  &lt;li&gt;질의하는 형식, 구하고자 하는 정보가 무엇이라는 것만 명시하는 비절차적 형태&lt;/li&gt;
  &lt;li&gt;튜플 관계 해석 / 도메인 관계 해석&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;트랜잭션&quot;&gt;트랜잭션&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Atomicity(원자성)
— 일부의 완료는 부재(모두 반영하거나 전혀 반영하지 않는 성질)&lt;/li&gt;
  &lt;li&gt;Consistency(일관성)
—실행 전과 후가 같아야 한다는 성질, 무결성 유지&lt;/li&gt;
  &lt;li&gt;Isolation(독립성, 격리성)
— 실행되는 중간에 다른 트랜잭션 연산이 침범하지 못하는 성질&lt;/li&gt;
  &lt;li&gt;Durability(지속성, 계속성, 영속성)
— 변화된 상태는 계속해서 유지될 수 있어야 한다는 성질&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;병행-제어-기법&quot;&gt;병행 제어 기법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;로킹(Locking) : 자원 이용에 대하여 상호배제 기능을 이용하는 기법&lt;/li&gt;
  &lt;li&gt;타임스탬프 순서(Timestamp Ordering) : 진입하는 트랜잭션 순서대로 타임스탬프를 지정하여 동시성을 제어하는 기법&lt;/li&gt;
  &lt;li&gt;검증 기법(Validation, 낙관적 기법) : 읽기 단계, 검증 단계, 기록 단계를 이용하여 직렬성 보장하는 기법, 사본에만 갱신 결과를 반영하다 최종적으로 검증과정을 통해 DB반영&lt;/li&gt;
  &lt;li&gt;다중버전 기법(Multi Version) : 각 트랜잭션은 순서적으로 부여된 버전을 이용&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.</summary></entry><entry><title type="html">Jekyll로 개인 블로그 시작해보기</title><link href="https://many258.github.io//life/start-wtih-jekyll/" rel="alternate" type="text/html" title="Jekyll로 개인 블로그 시작해보기" /><published>2021-01-21T00:00:00+09:00</published><updated>2021-01-21T00:00:00+09:00</updated><id>https://many258.github.io//life/%7Bstart-wtih-jekyll%7D</id><content type="html" xml:base="https://many258.github.io//life/start-wtih-jekyll/">&lt;h3 id=&quot;임시-테스트-문서입니다&quot;&gt;임시 테스트 문서입니다.&lt;/h3&gt;
&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;수정 작업 필요&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="life" /><category term="Blog" /><summary type="html">임시 테스트 문서입니다. 수정 작업 필요</summary></entry></feed>