var store = [{
        "title": "[(구)정처기/컴퓨터일반] (1) 데이터베이스 자주 틀리는 내용 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.     데이터 모델의 구성요소     구조(Structure) : 개념적 / 논리적 구성 형태   연산(Operation) : 개체 인스턴스의 삽입, 삭제, 검색, 갱신 처리 방법   제약사항(Constraint) : 개체 인스턴스의 허용 기준   E-R 관계 모델     원 : 속성 / 사각형 : 객체 / 마름모 : 관계   개념적 설계에서 주로 사용   논리적 데이터 모델     개념적 구조 ⇒ 논리적 구조   네트워크 데이터 모델     오너-멤버 관계, 그래프 구조 형태   연계성이 매우 우월, CODASYL / DBTG   관계 대수     릴레이션으로부터 필요한 릴레이션을 만들어내는 연산자의 집합   릴레이션 조작을 위한 연산   원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적인 방법   합집합 / 교집합 / 차집합 / 곱집합 / 설렉션 / 프로젝션 / 조인 / 디비젼   관계 해석     수학의 프레디킷 해석에 기반   질의하는 형식, 구하고자 하는 정보가 무엇이라는 것만 명시하는 비절차적 형태   튜플 관계 해석 / 도메인 관계 해석   트랜잭션     Atomicity(원자성) — 일부의 완료는 부재(모두 반영하거나 전혀 반영하지 않는 성질)   Consistency(일관성) —실행 전과 후가 같아야 한다는 성질, 무결성 유지   Isolation(독립성, 격리성) — 실행되는 중간에 다른 트랜잭션 연산이 침범하지 못하는 성질   Durability(지속성, 계속성, 영속성) — 변화된 상태는 계속해서 유지될 수 있어야 한다는 성질   병행 제어 기법     로킹(Locking) : 자원 이용에 대하여 상호배제 기능을 이용하는 기법   타임스탬프 순서(Timestamp Ordering) : 진입하는 트랜잭션 순서대로 타임스탬프를 지정하여 동시성을 제어하는 기법   검증 기법(Validation, 낙관적 기법) : 읽기 단계, 검증 단계, 기록 단계를 이용하여 직렬성 보장하는 기법, 사본에만 갱신 결과를 반영하다 최종적으로 검증과정을 통해 DB반영   다중버전 기법(Multi Version) : 각 트랜잭션은 순서적으로 부여된 버전을 이용  ","categories": ["study"],
        "tags": ["(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database/",
        "teaser": null
      },{
        "title": "[(구)정처기/컴퓨터일반] (2) 전자계산기 자주 틀리는 내용 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.     불 대수 기본 정리                  A + A = A       A · A = A       A · 0 = 0       A + 0 = A                 A + 1 = 1       A · 1 = A       0 + 0 = 0       0 · 0 = 0                 1 + 0 = 1       1 · 0 = 0       1 + 1 = 1       1 · 1 = 1                 A + A·B = A       A·(A + B) = A                           논리게이트     Exclusive OR : A, B 입력 ⇒ 서로 다를 때 1출력, 같을 때 0 출력   Exclusive NOT OR : A,B 입력 값 ⇒ 서로 같을 때 1, 다를 때 0 출력   조합 논리 회로     반가산기(Half Adder) : AND(1) + XOR(1)            S : A ⊕ B / C : A·B            반감산기(Half Subtracter) : NOT(1) + AND(1) + XOR(1)            D : X ⊕ Y / B : X’ · Y            전가산기(Full Adder) : Half Adder(2) + OR(1)            S : A ⊕ B ⊕ C / C : (A ⊕ B) · C + A · B = A · B + B · C + A · C            전감산기(Full Subtracter) : Half Subtracter(2) + OR(1)            D = X ⊕ Y ⊕ B / B = (X ⊕ Y)’·B + X’ · Y            병렬 가산기 :  반가산기(2n-1)개 + OR(n-1)개 / 전가산기(n개)를 여러 개 사용   디코더 = 해독기  N개의 입력 ⇒ 2n개의 출력   인코더  2n개의 입력 ⇒ n개의 출력   멀티플렉서 == 선택기  2n개의 입력선 + n개의 선택선 ⇒ 하나의 출력   디멀티플렉서  하나의 입력 정보 + n개의 선택선 ⇒ 2n 개의 출력   비교기 : Exclusive NOR(n개) 연결   3-상태 버퍼   순서 논리 회로          플립플롭 : 현 상태값에 관계 없이 입력 값을 다음 상태로 전달하는 특징이 있음              RS플립플롭 : S, R 단자가 모두 1인 경우 ⇒ 불허용                   JK 플립플롭 : S, R 단자가 모두 1인 경우 ⇒ 반전(토글)                   D 플립플롭 : 배타적인 경우만 이용, D 입력(1) ⇒ 출력(1)                   T 플립플롭 : 토글 기능만 작동            마스터 슬래이브 플립플롭 : Race 현상 해결하기 위해   카운터   레지스터   자료의 외부 표현     BCD : Zone(2Bit) + Digit(4Bit) ⇒ 6Bit   EBCDIC : Zone(4Bit) + Digit(4Bit) ⇒ 8Bit   ASCII : Zone(3Bit) + Digit(4Bit) ⇒ 7Bit + Parity(1Bit)   고정 소수점 수에서 음수 표현 방식에 따른 특징     수의 표현 범위            부호와 절대치 : -(2^(n-1)-1) ~ 2^(n-1)-1       1의 보수 : -(2^(n-1)-1)~2^(n-1)-1       2의 보수 : -2^(n-1) ~ 2^(n-1)-1           부동 소수점     부호(1), 지수(8), 가수(23)   나눗셈 과정 :            0인지 조사 ⇒       부호 결정 ⇒       피젯수를 위치 조정 ⇒       지수 뺄셈 ⇒       가수 나눗셈 ⇒       결과의 정규화           메가플롭스(MFLOPS) : 1초간에 실행되는 부동 소수점 연산의 수를 100만 단위로 표현   10진 표현     언팩 10진 표현 :  연산 불가, 입출력 작업 시  부호는 맨 마지막 바이트의 존 부분에 표현(+:C(1100), -:D(1101))   팩 10진 표현 :  연산 가능, 부호는 맨 마지막 4비트(+:C(1100), -:D(1101))   코드의 분류     가중치 코드 : 자리 값을 가지고 있는 코드            8421, 2421, 7421, 5421, 5111, Biquinary, Ring Counter           비가중치 코드 : 자리 값이 없는 코드            3초과 코드, 그레이 코드, 2-out-of-5 코드, 3-out-of-5 코드           자기 보수 코드 : 코드의 1의 보수 == 10진수의 9의 보수   3초과 코드, 2421, 5211, 5111, 8421   에러 검출 코드            패리티, 해밍, 2-out-of-5 코드, 3-out-of-5 코드, Biquinary, Ring Counter           Gray 코드 : 기계적인 동작을 제어하는데 적당   수치적 연산     산술 시프트   우측 산술 시프트            부호와 절대치 표현 ⇒ 부호 비트 고정 1의 보수 ⇒ 음수일 경우 1 패딩 2의 보수 ⇒ 음수일 경우 1 패딩            좌측 산술 시프트            부호와 절대치 표현 ⇒ 부호 비트 고정 1의 보수 ⇒ 부호 비트 고정, 음수일 경우 1패딩 2의 보수 ⇒ 부호 비트 고정            명령어의 구조     연산자 = Op-Code : Op-Code (n)Bit ⇒ 명령어 생성 개수 = 2^n   모드 : 직접 주소 / 간접 주소   주소 : 메모리 용량이 2^n ⇒ Operand (n)Bit   연산자(Operation, Op-Code)의 기능     함수 연산 기능, 제어 기능, 전달 기능, 입출력 기능   명령어 세트의 효율성을 향상시키기 위한 고려사항  기억 공간, 사용 빈도, 주기억 장치의 밴드폭 사용, 주소 지정 방식 함수 연산 기능 대 기타 연산 기능의 비율   명령어 설계 과정 고려사항     연산자의 수, 종류 / 주소 지정 방식 / 데이터 구조 / 워드 크기   명령어의 종류     데이터 처리 명령어  ADD / SUB / MUL / DIV INC / DEC AND / OR / XOR / COMPLEMENT / CLEAR 산술, 논리 SHIFT / ROTATE   데이터 전송 명령어  LOAD / STORE / MOVE / PUSH / POP / INPUT / OUTPUT   데이터 제어 명령어  JUMP / SMA / SZC / SKIP / SZA / ISZ / RETI / CALL / RETURN / HALT   명령어 메모리 참조 형식     레지스터 참조 명령(RRI : Register Reference Instruction)   메모리 참조 명령(MRI : Memory Reference Instruction)   입출력 명령(IOI : Input Output Instruction)   주소 지정 방식     즉시 주소(Immediate Address) :  주소 부분에 실제 데이터가 들어있는 방식   직접 주소(Direct Address) :  주소 부분에 실제 데이터가 들어있는 유효주소가 있음   계산에 의한 주소(Calculate Address)   인덱스 주소 지정(Index Register Address) :  인덱스 레지스터, 배열 엑세스 방식   상대 주소 지정(Relative Address) :  PC, 데이터 영역의 배치와 Program 배치 유사, 분기 명령   기준 주소 지정(Base Register Address) :  베이스 레지스터, 프로그램 재배치, 다중 프로그래밍 기법에서 주로 사용   간접 주소(Indirect Address)   CPU의 구분     스택 구조 CPU : 0 주소 명령어 형식, Postfix 표기법   단일 누산기 구조 CPU : 1주소 명령어 형식, Infix 표기법   범용 레지스터 구조 CPU : 2주소 명령어 형식, Prefix 표기법   프로세서의 종류     CISC(Complex Instruction Set Computer)  초창기 컴퓨터, 마이크로 프로그램 제어 방식 사용  메모리 참조 연산   RISC(Reduced Instruction Set Computer)  하드 와이어드 제어 방식  중요 명령어 ROM에 저장  명령어 길이 고정, 명령어의 개수 적음  레지스터 참조 연산   레지스터     AR(Address Register) : 기억용량과 관련, 주기억장치 / 워드 길이   PC(Program Counter)   MAR(Memory Address Register)   DR(Data Register) : 기억 장치의 워드 크기와 관련   MBR(Memory Buffer Register)   Status Register : 프로그램 제어를 위한 상태 정보를 기억   명령어 수행 순서     명령어 인출 ⇒ 명령어 해독 ⇒ 오퍼랜드 인출 ⇒ 실행 ⇒ 인터럽트 조사  Instruction Fetch ⇒ Instruction Decoder ⇒ Operand Fetch ⇒ Exe ⇒ Interrupt Search    마이크로 오퍼레이션     하나의 클록 펄스 동안 실행되는 기본 동작을 의미   CPU에 있는 레지스터와 플래그의 상태 변환을 일으키게 하는 동작   CPU에서 발생시키는 제어 신호에 따라 마이크로 오퍼레이션이 순서적 실행   동기 고정식 마이크로오퍼레이션            마이크로 사이클 타임이 가장 긴 것 == 클록 주기       수행 시간이 차이가 날 때 CPU의 시간 낭비, 구현 간단       여러 종류의 MO 수행 시 CPU 사이클 타임이 실제적인 오퍼레이션 시간보다 김           클럭 사이클 시간  조합 논리 회로 : 세그먼트 중 가장 긴 것 + 가장 짧은 것   메이져 상태     인출 주기   간접 주기   실행 주기            ADD       AND       LOAD       STORE       BUN(JUMP)       BSA(Branch and Save Return Address)       ISZ(Increment and Skip if Zero) : 프로그램의 수행 순서를 조건에 따라 결정           인터럽트 주기   제어 장치     제어 메모리 : 액세스 타임이 빠른 ROM으로 만들어진다    CPU의 제어 데이터                  제어 데이터       인출       간접       실행       인터럽트                       메이저 상태를 변화시키는 데이터       명령어       직/간접 주로 방식을 판별하는 비트       인터럽트 요청 신호       없음                 CPU의 제어점을 제어하는 데이터       명령어       명령어의 연산자 부분       명령어의 연산자 부분       기종에 따라 다름                 명령 수행 순서를 결정하는 제어 데이터       명령어       기억 장치에서 읽어낸 실제 데이터 주소       PC       기종에 따라 다름           마이크로 프로그램     일련의 제어 워드가 특수한 기억 장치 속에 저장되어 기계어 명령어들이 적절히 수행되도록 각종 제어 신호를 발생시키는 프로그램    제어 장치의 구현 방법     고정 배선식 제어 방식(Hard Wired)  하드웨어적, 속도 빠름, 변경 불가, 회로 복잡, 변경이 어려움   마이크로프로그램 제어 방식   제어 메모리에서 번지 결정 방법     순차 수행 : 제어 주소 레지스터의 내용을 +1 결정   무조건 분기 : 마이크로 명령어 상에 있는 분기 주소에 나타난 다음 명령어 수행   조건 분기 : 상태 플래그의 내용에 따라   서브 루틴 : 독립된 서브 마이크로프로그램 호출하여 수행   매크로 : 반복되는 부분을 매크로로 정의하고 직접 제어 메모리로 매핑   주기억 장치     DRAM  재충전 시간이 필요하므로 사이클 시간 &gt; 접근 시간   DRO(파괴성 판독 : Destructive Read Out)            메모리에서 데이터를 읽어내면서 원래의 데이터를 소거하는 판독 방법으로 메모리에서 정보를 보존하려면 읽어낸 뒤 즉시 재기입하여하 하기 때문에       사이클 타임 &gt; 접근 시간           SSD(Solid State Drive) : 메모리 반도체를 사용하는 대용량 저장 장치            SLC / MLC / TLC(속도 빠름/수명 길다 ↔ 속도 느림/수명 짧음)           CPLD(Complex Programmable Logic Device)            LAB, PIA로 구성되어 규칙적이고 빠른 타이밍이 필요하거나 어드레스 디코더 같은 간단한 로직 구현에 사용           보조 기억 장치     자기 디스크            등선 속도(CLV : Constant Linear Velocity)                    디스크의 안쪽, 바깥쪽 회전 속도가 일정하지 않음                       등각 속도(CAV : Constant Angular Velocity)                    외부 면의 저장 밀도가 떨어져 공간 낭비 유발, 접근 속도 빠름                           블루레이  405nm 파장의 청자색 레이저 사용, DVD보다 많이 저장 가능  한 면에 최대 27GB, 듀얼 50GB, MPEG-2 압축 방식   캐시메모리  캐시 메모리 평균 액세스 시간 = 히트 시간 + 미스도 + 미스 패널티  캐시 블록 번호 = 주기억 장치 블록 번호(= 번지 / 블록 크기) MOD 캐시 전체의 블록 수  캐시 메모리에 데이터 저장 시 주기억 장치와의 관계     Write Through : 캐시에 저장이 일어날 때 캐시와 주기억 장치를 동시에 갱신   Write Back : 캐시의 내용만 갱신이 일어나다가 블록이 캐시에서 제거될 때, 주기억에 복사해서 갱신   연관 기억 장치(Associative Memory)     기억된 정보의 일부분을 이용하여 원하는 정보를 검색 ⇒ 주소가 필요 없음   신속한 검색, 병렬판독회로 내장(가격이 비싸다)   작은 용량의 IC메모리를 사용하여 캐시 메모리나 가상 메모리의 주소 탐색에 주로 이용   가상 기억 장치     실제 페이지의 개수 = 주기억 장치 용량 / 하나의 페이지 크기   가상 페이지의 개수 = 가상 주소(nBit ⇒ 2^n) / 하나의 페이지 크기   메모리 인터리빙     독립된 메모리를 2개 이상 나누어 연결하고 CPU에서 각각 독립된 메모리를 번갈아가면서 연속적으로 액세스가 이루어지도록 구현하는 방법   CPU의 처리속도에 비해 사이클 타임이 오래 걸리지만, 접근하는 시간은 효율적   기억 장치 / 입출력 장치     동작 속도 / 정보 단위 / 동작의 자율성 / 에러율    입출력 제어기의 역할     데이터 버퍼링 / 제어 신호의 논리적, 물리적 변환   통신 회선 확보 / 상태 정보 저장 / 주기억 장치 접근 / 데이터 교환   고립형 입출력 포트(I/O Mapped I/O Port)     입출력 포트와 메모리 주소가 독립적인 상태   마이크로프로세서는 뚜렷한 입출력 명령을 가짐 각 명령은 인터페이스 레지스터의 주소를 가짐   메모리 맵 입출력 포트(Memory Mapped I/O Port)     입출력 포트와 메모리 주소가 종속적인 상태   마이크로프로세서가 인터페이스 레지스터를 메모리 시스템의 한 부분으로 인식   DMA(Direct Memory Access)     단어 계수기는 입출력이 일어날 때마다 하나씩 감소하여 0이 되면 인터럽트를 요청하여 블록에 대한 입출력이 완료되었음을 CPU에게 알림   구성요소            인터페이스 회로 :  CPU ↔ 입출력 장치 통신       번지 레지스터 :  기억 장치와 위치 지정을 위한 번지를 기억       워드카운터 레지스터 : 전송되어야 할 워드의 수 표시       제어 레지스터 : 전송 방식을 결정       데이터 버스 버퍼, 주소 버스 버퍼       Data Buffer Register / F Flip-Flop / Status Register / Address Register / Word Counter           사이클 스틸     CPU 상태를 보존할 필요가 없음   CPU가 잠시 쉴 수 있음   아무 사이클이나 상관없이 훔치는 것이 가능   DMA의 우선순위는 메모리 참조의 경우 CPU장치보다 상대적으로 높음   채널     Interlock Channel : 하나 이상의 입출력 요청이 들어올 경우 이를 적절히 수행   Crossbar Channel : 여러 개의 채널 제어기 중 아무거나 사용해서 입출력할 수 있는 방식   버스트 모드 : 하나의 I/O 장치가 데이터 전송을 하고 있는 동안 채널의 기능을 완전히 독점하여 대량의 데이터를 고속으로 전송   멀티플렉서 모드 : 여러 개의 I/O 장치가 채널의 기능을 공유하여 시간 분할 형식으로 데이터를 전송하는 형태, 저속의 I/O 장치 여러 개를 연결하는 방식   입출력 수행 중 어떤 에러 조건에서 CPU에 인터럽트를 걸 수 있음   구성요소            채널 명령어(CCW : Channel Command Word) : 주기억 장치에 있는 하나의 블록 입출력 정보를 가지고 있는 명령어                    Operation Code : I/O 여부 / 분기 / 입출력 장치 제어 / 채널 동작 정보           블록 주소 : 블록의 첫 번째 시작 주소           블록의 단어수 : 입출력하고자 하는 블록 워드의 개수                       다음 채널 명령의 주소 : PC가 없으므로 다음에 수행해야 할 명령어 있음       채널 주소 단어(CAW : Channel Address Word) : 채널 명령어의 시작 주소를 기억       채널 상태 단어(CSW : Channel Status Word) : 채널 정보, I/O 장치 정보 레지스터           인터럽트 종류     페이지 폴트 / 캐시 미스 인터럽트   외부 인터럽트 : 타이머 인터럽트나 조작원의 의도적 동작인 입출력 인터럽트   내부 인터럽트 : 0으로 나누기 / 불법적인 명령어 사용 / 오버, 언더 플로우            트랩 : 어떤 프로세스가 특정 시스템 기능을 사용하려고 할 때 OS에게 요청           I/O 인터럽트 : 의도적으로 인터럽트 발생 가능   SVC(Super Visor Call) : 사용자가 프로그램을 이용하여 직접 인터럽트를 호출   차단 불가능 인터럽트(NMI : Non-Maskable Interrupt)            인터럽트 마스크에 영향을 받지 않는 우선순위가 가장 높은 인터럽트       정전, 심각한 하드웨어 이상 인터럽트에 해당           인터럽트 발생 시 CPU의 처리 사항     PC   프로그램에서 사용한 모든 레지스터의 내용   플래그 상태 조건 내용   스택의 내용 / 메모리 0번지의 내용   인터럽트 우선순위 부여 방식     폴링 = 프로그램에 의한 I/O 제어 방식            CPU와 I/O 장치 사이의 데이터 전달이 프로그램에 의해서 제어되는 방법       프로그램에서 D와 B 상태를 검사하여 데이터를 전송           인터럽트 요청 체인 방식   인터럽트 우선순위 체인 방식   병렬 우선순위 부여 방식            처리 중인 인터럽트보다 우선순위가 낮은 것을 비활성화시키는 마스크 레지스터       인터럽트 처리 루틴 없이 인터럽트 취급 루틴 시작       CPU에 있는 인터럽트 레지스터의 각 비트는 요청 회선과 연결           인터럽트 작동 순서     인터럽트 요청 ⇒ 현 상태 보존 ⇒ 인터럽트 판별 ⇒ 인터럽트 취급 ⇒ 원 상태 복귀    병렬 컴퓨터 구조     파이프라인 클록 타임            T = (k + (N -1)) (k:파이프라인 단계 수, N : 수행할 명령어의 개수)            상호연결 구조     다중 처리기            Bus, 크로스바 스위치, 다단 상호 연결망(오메가 스위치)           다중 컴퓨터            Bus, 그리드, 하이퍼큐브           시스톨릭 배열(Systolic Array)  파이프라인 어레이 구조의 새로운 범주로서 지역적으로 연결된 프로세서들이 규칙적으로 데이터를 계산하고 시스템을 통해 데이터를 전달하는 프로세서 네트워크  벡터 처리기, MISD   파일 보호 기법     파일 명명, 접근 제어, 암호화    보안 유지 방식  부인 방지(Non-repudiation) : 데이터를 송수신한 자가 송수신 사실을 부인할 수 없도록 송수신 증거를 제공하는 것, 공개키 암호 방식 이용   ","categories": ["study"],
        "tags": ["(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/electronic-calculator/",
        "teaser": null
      },{
        "title": "[(구)정처기/컴퓨터일반] (3) 운영체제 자주 틀리는 내용 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.     어셈블리어의 장점     어셈블리어로 작성한 원시 프로그램을 기계어로 번역   기계어보다 쉽고, 이해하기가 쉽다   프로그램의 주소가 기호 번지이다   프로그램에 데이터를 사용하기 쉽다   매크로 프로세서의 기능     매크로 정의 인식 : 매크로를 정의한 부분의 시작과 종료 파악   매크로 정의 저장 : 매크로 호출 시 확장하기 위해 저장   매크로 호출 인식 : 확장하기 위한 준비가 되어 있는 지 확인   매크로 확장 및 인수 : 원시 프로그램 위치에 저장된 내용과 인수를 치환   로더의 종류     절대 로더 : 로더의 역할 축소, 한 번 지정한 주기억 장소의 변경이 어려움            할당, 연결 ⇒ 프로그래머       재배치 ⇒ 번역 프로그램       적재 ⇒ 로더           직접 연결 로더 : 일반적인 로더 형태, 로더가 모두 수행   동적 로더 : CPU가 현재 사용중인 부분만 적재, 미사용 중인 것은 보조기억장치에 보관(Load-on-call)   운영체제의 구성     제어프로그램            감시 프로그램(Supervisor P) : 일명 모니터, 지시/감독       데이터 관리 프로그램(Data Management P) : 주기억 장치, 보조기억 장치 간 작업       작업 제어 프로그램(Job Control P) : 스케쥴 및 시스템 지원 할당 등을 관리           처리 프로그램            언어 번역 프로그램 : 목적 프로그램으로 번역해주는 프로그램       서비스 프로그램 : 모듈이나 프로그램을 사용자가 사용할 수 있도록 제공       문제 프로그램 : 사용자의 응용 처리를 위해 사용           운영체제의 발달 과정     시분할 처리 : 전문적인 처리기가 존재 하지 않음   스풀 vs 버퍼링     스풀(Spool) : 프로그램과 I/O 장치와의 속도 차를 극복하기 위해, HDD가 중재   버퍼링(buffering) : CPU와 I/O 장치와의 속도 차를 극복하기 위해, 주기억 장치가 중재   PCB(Process Control Block) ⇒ 프로세스 생성 정보 없음     식별자, 현재 상태, PC, 우선순위, CPU 레지스터 정보, 계정 정보, 기억 장치 관련 정보   CPU의 각종 레지스터 상태를 가리키는 포인터, 입출력 정보   적재된 기억 장치 부분을 가리키는 포인터, 할당된 자원을 가리키는 포인터   부모/자식 프로세스를 가리키는 포인터   인터럽트 종류     SVC(SuperVisor Call) : 감시 프로그램 호출 시 발생  입출력 수행 루틴 호출 / 기억 장치 할당 루틴 / 오퍼레이터와의 대화   입출력(I/O) : 하드웨어적 인터럽트  입출력 채널 확인, 준비, 할당, 완료, 프로세스 전이(실행 ⇒ 대기)   외부(External) : 운영체제 소속이 아닌 외적인 요인으로부터 발생  인터럽트 시계에 의해 프로세스가 시간 할당량이 종료된 경우,  웹 서버나 프린터 서버를 운영하고 있는 상태에서 외부로부터 인터럽트 처리 신호 올 때   재시작 : 운영체제를 메모리에 다시 상주시킬 때   프로그램 검사 : 명령어를 수행하는 과정에서 부분적으로 발생되는 문제   기계 검사 : 시스템의 기계 고장   CPU 스케줄링     HRN(Highest Response-ratio Next) 스케줄링 기법            (대기 시간 + 서비스 시간) / 서비스 시간            세마포어의 특징     상호배제의 원리 보장   소프트웨어나 하드웨어로 구현 가능   V 조작 : Wake-Up = Up = Signal   P 조작 : Sleep = Down = Wait   교착 상태 해결 방안     예방(Prevention)  상호배제 부정, 대기 제거, 선점 인정, 선형 대기 상태로 변경 ⇒ 효율적이지 못함   회피(Avoidance)  안정상태를 유지할 수 있는 프로세스의 자원 요구만 할당, 은행원 알고리즘   회복(Recovery)  선점 / 복귀 / 제거 / 사용자의 조치   발견(Detection)  자원 할당 그래프는 시스템이 중단된 이유가 교착상태인가를 발견하는 기법   주기억 장치 재사용 기술     통합(Coalescing) : 인접한 공백들을 더 큰 하나의 공백으로 만드는 과정   집약(Compaction, 압축) : 서로 떨어져 있는 여러 개의 낭비 공간을 모아 하나의 공간으로   캐시 기억 장치     주기억 장치 ↔ CPU 간 속도 차이 극복, 버퍼의 기능 수행   분리 캐시 : 캐시 접근 시 충돌을 방지하기 위해 코드와 데이터를 분리해서 기억   쓰기 접근 빈도가 높다 == 캐싱-일관성 문제가 발생할 확률 높음 == 성능 저하   사상 방법            직접 사상       전체 연합 사상                    블록 중 아무 곳이나 하나 정해서 기억           메모리 워드의 번지 + 데이터 함께 저장, RR 방식으로 교체                       세트 연합 사상           페이지 교체 알고리즘     NUR(Not Used Recently)            참조비트, 변형비트 ⇒ ‘1’ 최근 / ‘0’ 예전           파일의 구조     직접 파일(Direct Access File)            해싱 사상 함수에 의해 물리적인 주소로 변환하여 데이터를 기록 / 검색       한 번 파일을 개방하면 읽거나 쓰기를 자유롭게       평균 접근 시간 내 접근       디스크 기억 장치에 많이 이용           파일 시스템의 기능     파일 저장 / 공유 / 생성 / 변경 / 제거 / 응용 처리   백업, 복구, 여러 종류의 접근 제어 방법 제공, 파일 간 정보 전송   기호형 이름을 사용 ⇒ 자신의 파일을 참조할 수 있도록 장치 독립성을 제공   디렉터리     비순환(주기) 그래프 디렉터리            트리구조와 유사, 사이클 불허       하나의 파일을 여러 사용자가 공유하기 때문에 삭제 시 문제점 발생       융통성이 있으며 기억 공간을 절약할 수 있으나 복잡       하나의 파일이 다수의 이름으로 존재       공유하고 있는 파일 제거 시 Dangling Pointer 발생 가능       Unix 운영체제에서 사용           보안 유지 방식     외부 보안 : 천재지변으로부터 컴퓨터를 보호   내부 보안 : 운영체제/하드웨어 내장, 프로그램의 신뢰성 있는 운영/무결성 보장   사용자 인터페이스 보안 : 인증, 패스워드   암호화            비밀키 = 공통키 = 대칭키 = 관용키 = 단일키 = Private Key System                    암호화 키 = 복호화 키           DES, 평문을 암호화                       공개키 = 비대칭키                    암호화 키(공개) != 복호화 키(보호)           키 분배가 간단, 암호화 과정 복잡, 속도가 느림           RSA, PGP                           Flynn     SISD : 개인 컴퓨터, Pipeline 기법   MISD : 실제 없음   SIMD : 대형 컴퓨터, Array Processor   MIMD : 분산/병렬 컴퓨터            교환형 다중 처리기 : 크로스바 교환 행렬(버스의 수 만큼 메모리 증가)           분산 시스템의 결함     링크 결함, 사이트 결함, 메시지의 분실   분산 처리 시스템의 계층 구조     하드웨어 ⇒ 기억 장치 ⇒ 프로세스 ⇒ 파일 시스템 ⇒ 사용자 응용   UNIX 기본 구성     쉘            명령의 입력을 받아 시스템 기능을 수행하는 명령 해석기       사용자 시스템 간 인터페이스 담당, 여러 가지 내장 명령어 보유       파이프라인 기능, 입출력 방향 지정           UNIX 특징     Pipe : 먼저 입력된 데이터를 먼저 처리하는 선형 구조(FIFO) 형태로 통신 경로 확보   UNIX 파일 시스템     부트 블록   실린더 블록   i-Node 테이블            사용자 ID, 그룹 ID, 보호모드, 블록 주소       처음 생성 시기, 마지막 사용 시기, 최종 수정 시기       파일 링크 수, 파일 속성           파일 테이블 블록   UNIX 주요 명령어     Mount : 파일 시스템에 새로운 파일 시스템을 서브 디렉터리에 연결할 때 사용  ","categories": ["study"],
        "tags": ["(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/operating-system/",
        "teaser": null
      },{
        "title": "[(구)정처기/컴퓨터일반] (4) 소프트웨어 공학 자주 틀리는 내용 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.     소프트웨어 생명주기     나선형 모델            계획 수립(Planning) → 위험 분석(Risk analysis) → 개발(Engineering) → 고객 평가(Customer evaluation)            프로젝트 계획 단계의 특징     정의 단계의 시작 단계   개발 비용을 추정   유지보수 비용은 개발이 모두 끝난 뒤 책정   계획 단계에서 프로젝트 관리자의 임무는 매우 중요   소프트웨어 범위 결정 사항     기능, 성능, 제약 조건, 개발 인원, 일정 계획   위험성을 최소화 목적   소프트웨어 비용 측정 4가지 원칙     소프트웨어 비용 측정을 최대한 지연   분해 기술(단계별, 인월별 분해) 이용   실험적 비용 측정 모델을 이용   자동화 도구 이용   비용 측정 방법론     COCOMO(COnstructive COst MOdel)            Boehm, 상향식, 수학적 산정 기법       변화 모형(Basic, Intermediate, Detailed)       규모 모형(Organic, Semi-detached, Embedded)           Putnam 모형            시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력분포도 곡선       기초로 만든 자동화 도구 SLIM       대형 프로젝트의 노력 분포 산정에 용이           CPM(Critical Path Method)     병행 작업이 가능하도록 계획   비용측정은 하지 않음   이전 작업이 모두 완료되지 않으면 다음 작업으로 진행 불가   정확한 일정 예측은 불가능   위험 관리 절차     위험 식별 : 위험 요소가 될 사항   위험 분석 및 평가 : 위험의 비중과 영향력 파악   위험 관리 계획 : 위험 예방, 대안 준비, 문서화   위험 감시 및 조치 : 위험 관찰, 모니터링   위험표 포함 사항     위험 발생 확률   위험의 내용 및 종류   위험에 따르는 영향력   위험 발생 시간 X   자료 흐름도     프로세스 : 원 / 데이터 흐름 : 화살표 / 데이터 저장 : 실선 2줄 / 입출력 : 사각형   소단위 명세서     설계 단계에서 사용하는 구조적인 언어 사용 가능   서술 문장, 의사결정 나무, 의사 결정표, 표, 그래프 등   소프트웨어 설계 모형     문서량 기준 : 데이터(DD, 메타데이터) ⇒ 구조(구조도) ⇒ 관계 ⇒ 절차(PDL 알고리즘)   노력 기준 : 절차 ⇒ 관계 ⇒ 구조 ⇒ 데이터   HIPO(Hierarchy plus Input Process Output)     하향식 설계 기법, IBM에서 개발한 프로그램을 기능 위주로 문서화   입력/처리/출력 구성, 소규모 프로젝트에 적합   도식 목차(가시적 도표, Visual Table of Contents) : 전체적인 흐름과 구조   총괄 도표(총체적 도표, Overview Diagram) : 입력, 처리, 출력 등의 기능 명확히 표현   상세 도표(세부적 도표, Detail Diagram) : 총괄 도표의 일부 기능을 구체적으로 표현   자료 흐름 설계 과정     정보 흐름의 유형을 설정   흐름의 경계를 표시   자료 흐름도를 프로그램 구조로 사상 ⇒ 변환 사상(Transform Mapping)   제어 계층을 분해시켜서 정의   경험적 방법으로 구체화   결합도(약 → 강)     데이터 결합도(Data Coupling)   구조 결합도(Stamp Coupling) : 두 모듈이 매개 변수로 자료를 전달할 때, 자료 구조 형태   제어 결합도(Control Coupling)   외부 결합도(Extern Coupling)   공통 결합도(Common Coupling) : 두 모듈이 동일한 전역 데이터를 접근   내용 결합도(Content Coupling) : 하나의 모듈이 직접적으로 다른 모듈의 내용 참조   응집도(약 → 강)     우연적 응집도(Coincidental Cohesion)   논리적 응집도(Logical Cohesion)   시기적 응집도(Temporal Cohesion)   절차적 응집도(Procedural Cohesion)   통신적 응집도(Communication Cohesion)   순차적 응집도(Sequential Cohesion)   기능적 응집도(Functional Cohesion)   객체지향 분석 순서     객체 모델링 : 객체의 속성, 연산을 식별   동적 모델링 : 객체 모형들의 행위, 상태, 조건을 파악   기능 모델링 :  입출력 결정 ⇒ 자료 흐름도 ⇒ 기능의 내용 상세 기술 ⇒ 제약사항 결정 / 최소화   객체지향 기술     다형성 : 동일한 메소드를 다양한 방법으로 사용할 수 있는 능력   객체 분석     형식적인 전략으로 기술   모델링 구성 요소인 클래스, 객체, 속성, 연산들을 표현해서 문제를 모형화   E-R 다이어그램 적합, 개념적으로 파악   객체 설계     구체적인 절차, 객체의 속성과 자료 구조를 표현   서브 클래스와 메시지 특성을 세분화하여 세부사항을 정제화   사용자 중심, 대화식 프로그램의 개발에 적합  cf) 객체 구현 : 객체의 정의   객체지향 기법 vs 구조적 프로그래밍 기법     추상적 자료형  vs 절대적 자료형   객체 사용 vs 함수 사용   메시지를 통해 객체 호출 vs 매개 변수를 통해 함수 호출   전역 변수에 영향 없음 vs 전역 변수에 영향 받음   화이트 박스 검사 방법     기초 경로 검사(Basic Path Testing)            가능한 경로를 어느 정도 통과하는지의 적용 범위성 측정       복잡도(Cyclomatic Complexity)       V - E + R = 2 (V : 노드의 수, E : 간선의 수, R : 영역의 수)       화살표로 둘러싸인 면의 수 + 1           블랙 박스 검사 방법     균등 분할(Equivalence Partitioning) : 정상 데이터 / 비정상 데이터   한계값 분석(Boundary Value Analysis) : 범위 한계 위주   원인-결과 그래프(Cause-Effect Graphing) : 임의의 자료 입력 ⇒ 정상 출력 확인   오류 예측(Error Guessing) : 데이터 확인 방법, 위 3가지 이외 오류 검사   비교 검사 : 하나의 프로그램을 여러 컴퓨터에서 테스트   소프트웨어 검사 단계     단위 검사(Class) ⇒ 통합 검사 ⇒ 검증 검사 ⇒ 시스템 검사   cf) 개발 순서 : 시스템 공학 ⇒ 요구 분석 ⇒ 설계 ⇒ 코딩(구현)   통합 검사     하향식(Top Down) 통합 검사 : 가짜 모듈이 필요(Stub), 회귀 검사, 프로그램 전체 실행   상향식(Bottom Up) 통합 검사 : Cluster, Driver, 중요한 모듈 우선 검사 가능   클러스터 결함 ⇒ 드라이버 작성 ⇒ 클러스터 검사 ⇒ 드라이버 제거 후 상위 결합   유지보수 비용 측정     BL방법 : M = P + K * e^(c-d) (M:인원/월, P : 비용, K : 상수, c : 복잡도, d : SW지식)   유지보수 작업의 종류     하자보수(=수리보수, Corrective M) : 잠재적인 오류 수정   기능 개선(=완전보수, Perfective M) : 기능의 수정, 추가, 전반적인 기능 개선 ⇒ 비용 많음   환경 적응(=적응보수, Adaptive M) : 환경 변화에 대응하여   예비 조치(=예방보수, Preventive M) : 미리 예측하여 준비   품질 목표 항목     정확성(Correctness) : 요구사항 충족시키는 정도   신뢰성(Reliability) : 요구된 기능을 오류없이 수행하는 시스템 능력 정도   효율성(Efficiency) : 최소한의 처리 시간과 기억 장소를 소유하여 요구된 기능 수행   유연성(Flexibility) : 새로운 요구사항에 접하여 쉽게 수정될 수 있는 능력   OMA(Object Management Architecture) 레퍼런스 모델     객체 간의 관계를 표현하는 표준 참조 모델   Object Service, Common Facilities, Domain Interface, Application Interface   소프트웨어 재공학(Reengineering)     개조(Restructuring) : SW 기능을 변경하지 않으면서 SW 형태에 맞게 수정   같은 추상적인 수준에서 하나의 표현을 다른 형태로 바꾸는 작업   분석(Analysis) : 기존 SW의 명세서를 확인하여 SW 동작을 이해, 재공학 대상 선정   재개발(Redevelopment) : 기존의 SW 삭제 ⇒ 새롭게 개발   소프트웨어 재사용 단위     명령어, 모듈, 요구분석서, 설계, 코딩 ⇒ 개발 비용은 변하면 안됨  ","categories": ["study"],
        "tags": ["(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/software-engineering/",
        "teaser": null
      },{
        "title": "[(구)정처기/컴퓨터일반] (5) 데이터통신 자주 틀리는 내용 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.     네트워크 서비스     여러 개의 컴퓨터를 연결하여 각각에 연결된 컴퓨터의 하드웨어 자원과 소프트웨어 자원을 공유, 데이터나 파일을 공유   데이터 통신 시스템의 발전     SAGE : 미국의 군사용 방공 시스템, 최초의 데이터 통신 시스템   SABRE : 항공기 좌석 예약 시스템, 상업용   ARPANET : 최초의 유선 패킷 시스템, 인터넷 기술의 모체   ALOHA : 최초의 무선(라디오) 패킷 네트워크 시스템, CSMA, CSMA/CD의 모체   CTSS : 최초의 학내 시스템, 시분할 기술 최초 사용   SNA(System Network Architecture) : 네트워크의 표준화를 제시한 최초의 네트워크 시스템   데이터 통신 시스템     데이터 전송계            단말장치(DTE : Data Terminal Equipment)                    데이터 전송 회선                       신호변환기(DCE) / 통신회선       통신 제어 장치(CCU:Communication Control Unit) : 오류/동기/흐름/응답 제어           데이터 처리계            컴퓨터                    하드웨어 / 소프트웨어                           DTE ⇒ DCE ⇒ 통신망 ⇒ DCE ⇒ DTE ⇒ CCU ⇒ HOST Com   데이터 통신 시스템의 구성 요소     통신 시스템의 3대 구성 요소 : 단말 장치, 통신 제어 장치, 전송 장치   전송 시스템의 3대 구성 요소 : 단말 장치, 통신 제어 장치, 데이터 전송 회선   베어러 속도 = 반송 속도     데이터 신호에 동기 신호와 상태 신호를 합한 속도   디지털 vs 아날로그 신호     디지털 : 많은 대역폭이 필요, 전송 거리가 짧아 증폭기 사용, LSI/VLSI 기술 진보   모뎀의 분류     동기 방식            비동기식 모뎀 방식 : ASK, FSK       동기식 모뎀 방식 : PSK, QAM           FSK(Frequency Shift Keying: 주파수 편이 변조)  Non-coherent 방식 : 다양한 주파수와 진폭, 다양한 모양의 위상, 비동기와 유사   QAM(Quadrature Amplitude Modulation : 진폭 위상 변조, 직교 위상 변조)  Coherent 방식 : 단일 주파수, 같은 모양의 위상, 동기와 유사  2차원 벡터 공간에서 신호를 사용할 수 있음   DSU(Digital Service Unit)     신호 변환 방식            단극 RZ(Return to Zero)       양극 NRZ(Non Return to Zero)                    NRZ-L(Level) : ‘1’ : 양극 / ‘0’ : 음극           NRZ-M(Mark=’1’) : ‘1’ : 비트 간격의 중간에서 천이 / ‘0’ : 천이 없음           NRZ-S(Space=’0’) : ‘1’ : 천이 없음 / ‘0’ : 비트 간격의 중간에서 천이           NRZ-I(Inversion) : ‘0, 1 ⇒ 1’ : Interval 중간에서 변화                       바이폴라(Bipolar)                    AMI(교호 반전 부호), 3원 부호, ISDN 신호 방식, 동기화 어려움           ‘1’ : 양극과 음극 교대로 변환, ‘0’ : Zero                       맨체스터(Manchester)                    하나의 펄스폭을 2개로 나누어 ‘1’, ‘0’을 반대로 구성하여 사용           CSMA/CD LAN에서의 전송부호로 사용, 동기화 가능                           CODEC     양자화 잡음(PCM 극 장치) : 실수형의 표본 값 ⇒  정수 반올림, 이 때 발생하는 오차   부호화 : 인접 부호 간 1비트만 변화하는 그레이코드 주로 사용            원천 부호화: 제한된 대역폭에서 고속 전송                    DM(Delta Modulation), PCM(Pulse Code Modulation) 허프만 코딩, LPC(Linear Predictive Coding), PNM                        채널 부호화 : 에러 검출 및 정정을 위한 비트를 추가하여 전송       파형 부호화 : 디지털 부호를 전송 회선에 적합한 파형으로 변환하는 방식                    PCM, DPCM, ADPCM, DM                            ISI(InterSymbol Interference)  PCM에서 수신된 신호 파형이 일그러져서 각 비트에 할당된 슬롯 타임을 벗어나 인접 슬롯 타임에 영향을 주는 현상, 이러한 현상으로 신호 파형이 중첩되게 된다 중첩되는 모양을 오실로스코프로보면 사람의 눈을 닮아 아이 패턴이라 함   Optimum Sampling Time : 아이 패턴이 열린 최대 높이가 최적의 샘플링   Sensitivity to Timing Error : 아이 패턴의 기울기를 통해 시간 오차에 대한 민감도 평가   Noise Margin : 아이 패턴이 눈을 뜬 상하의 높이 만큼   Maximum Distortion : 아이 패턴의 맨 위와 맨 아래의 파형들의 진동폭은 신호가 샘플링되는 순간 왜곡되는 최대값   비동기식 전송     간헐적, 독립적, 문자 단위 전송   휴지 시간 존재, 저속 전송, 버퍼를 적게 사용   대화용 전송에 적당, ASK/FSK   일반적으로 패리티 비트 추가 전송     동기식 전송       블록 단위 전송, 파일 전송 적합   PSK, QAM   RS-232C     핀4(RTS-송신 요청) : 송신할 데이터가 있음을 DTE에서 DCE로 전달   핀5(CTS-송신 준비 완료) : DCE에서 DTE로 신호 전달, ON/OFF   핀8(DCD-수신선 신호 감지) : DCE가 선로쪽으로부터 감시할 수 있는 크기의 신호를 수신하고 있음을 DTE에게 통보   데이터 전송 프레임     문자 지향 프레임 = BSC 프레임 구조            BASIC, 반이중 방식만 사용       같은 전송 회선만 가능 (종속적)       동기/비동기 전송 방식 사용       SYN(7) / SYN(7) / SOH(7) /Heading / STX(7) / TEXT / ETX(7) / BCC(7)           비트 지향 프레임            동기식 전송       Flag(8) / Address(8bit ~ 8Byte) / Control(8/16) / Info / FCS(16/32) / FLAG(8)       Control                    I Frame : 첫 번째 비트가 0, 순수한 정보, 피기백킹           S Frame : 상위 두 비트 10, 감시, 감독           U Frame : 상위 두 비트 11, 초기 설정 및 링크 확립과 해제                            NRM(표준 응답 모드 : Normal Response Mode, UNC)  반이중 통신, 주 스테이션이 링크 제어               ARM(비동기 응답 모드 : Asynchronous Response Mode, UAC)  전이중 통신, 주 스테이션이 링크 제어               ABM(비동기 균형 모드 : Asynchronous Balance Mode, BAC)               전이중 통신, 주 스테이션과 부 스테이션 구분이 없음               링형, 망형 구조               X.25링크에서 LAPB와 동일               SIM(Set Initial Mode) : 설정 초기화                                                   오류 제어     순방향 오류 수정(FEC : Forward Error Correction) :            해밍코드                    해밍 거리 : 같은 비트 수를 갖는 이진 부호 사이에 대응되는 비트 값이 일치되지 않는 것의 개수                        상승코드           역방향 오류 수정(BEC : Backward Error Correction) : 역 채널 필요 ⇒ 재전송            CRC, 패리티 비트, 블록 합       ARQ                    Stop-And-Wait : BASIC 전송 절차           Go-Back-N :                            오류가 발생한 프레임부터 다시 전송, 중복 전송 문제 발생               HDLC, SDLC                                   Selective-Repeat :                            오류가 발생한 프레임만 재전송, 별도의 버퍼가 필요               HDLC                                   Dynamically                           오류 검출 방식     군 계수 검사 방식   패리티 방식 : 짝수 개의 비트가 오류가 발생할 경우 검출률이 낮아짐            수직 중복 검사(VRC : Vertical Redundancy Check)       세로 중복 검사(LRC : Longitudinal Redundancy Check)       순환 중복 방식(CRC : Cyclic Redundancy Check = 집단, 군집 오류 검출)                    다항식을 계산, 오류를 수정할 수는 없음(재전송 요청)           동기식 전송에 적합                           검사 합(Check Sum)   해밍 코드   상승 코드  여러 개의 비트 오류가 있더라도 한계값/순차적 디코딩을 이용하여 모두 수정   정 마크 방식 : 전송 비트수에 1의 개수와 0의 개수를 고정적으로 정하여 전달            2 out-of 5 : 5개의 비트 전송 ⇒ 1의 비트 2개, 0의 비트 3개           다중화기     주파수 분할 다중화(FDM : Frequency Division Multiplexing)            전송 매체의 유효 대역폭이 클 때 사용       아날로그 신호, 비용 저렴, 기술이 간단       비동기식 전송, 멀티 포인트 방식에 적합       모뎀의 역할을 겸하므로 별도의 모뎀이 필요하지 않음       전송지연 없이 실시간 전송이 가능       보호대역 때문에 대역폭이 낭비       TV, 라디오와 같은 공중파, CATV, ADSL           시간 분할 다중화(TDM : Time Division Multiplexing)            전송 매체의 유효 전송률이 클 때 사용       디지털 신호, 비용/기술 복잡       전송지연 없이 실시간 전송이 가능       별도의 모뎀 필요, 대역폭이 낭비되지 않음       STDM(동기식 시분할 다중화 : Synchronous TDM)       ATDM(비동기식/통계적 시분할 다중화 : Asynchronous TDM)                    흐름 제어, 에러 제어 및 자체 진단 기능 ⇒ 지능 다중화기           헤더 정보를 필요로 하며, STDM에 비해 시간 슬롯 당 정보 전송률 증가                           코드 분할 다중화(CDM : Code Division Multiplexing)            확산 대역 방식, 전송 용량/품질 증가       보안성 보장, 전송지연이 감소, 이동통신에 사용           다중화의 발전 기술     OFDM(Orthogonal Frequency Division Multiplexing : 직교 주파수 분할)            분할된 반송파 사이의 주파수 간격을 최소화하기 위해 직교 다중화           DSSD(Direct Sequence Spread Spectrum)            고정된 하나의 채널을 이용하여 전송하는 방식       디지털 데이터를 넓은 대역으로 분산하여 전송하는 방식           FHSS(Frequency Hopping Spread Spectrum)            23개의 채널을 이용하여 데이터를 전송하는 방식       송수신측에서 주파수의 위치를 변화시키면서 통신하는 방식           블루투스     RF &amp; Baseband - 물리 계층 : 통신 장비   Link Manager - 링크 계층 : 연결 보안 설정   HCI Bottom - 네트워크 계층   HCI Top - 전송 계층 : 통신 기기와 통신 기기 제어기 사이에 연결   L2CAP - 세션 계층 : 통신 기기 프로토콜과 통신 기기 제어기 프로토콜 사이를 중재   RFCOMM - 통신 기기 간의 논리적 접속 제어   Application   집중화기     여러 개의 채널을 몇 개의 소수 회선으로 공유화시키는 장치   구조 복잡, 불규칙 전송에 사용   입출력 각각의 채널 대역폭이 다르다   전용 회선     직통 회선 / 분기 회선 / 직선 분기 회선    교환 회선     회선 교환 방식 : 관리 제어 신호, 주소 제어 신호, 호 정보 제어 신호, 감시 제어 신호            SLIP : 교환기 사이에 클록 주파수의 차이로 데이터의 손실이 발생 (DCS 설치 필)       공간 분할 교환 방식                    단일 / 다단 교환 방식                       시간 분할 교환 방식                    TDM 버스 교환 방식 ⇒ 동기식           시간 슬롯 상호 교환 방식 ⇒ 대부분 사용, 전 2중 동작을 위해 한 쌍의 슬롯           시간 다중화 방식 : TSI 장치 문제점(크기가 커지면 지연이 커짐) 해결                           축적 교환 방식            메시지 교환 방식       패킷 교환 방식                    가상 회선 패킷 교환 방식           데이터 그램 패킷 교환 방식                           교환 기술의 성능 비교 요소     전파 지연 / 전송 시간 / 노드 지연 시간 / 데이터 처리율   경로 선택     비적응적 방법 : 정적, 수동적인 방법            고정 경로 선택(=착국 부호 방식, Fixed Routing)  상대방에 미리 붙여둔 번호를 해석해서 진행 경로 선정       범람 경로 선택(Flooding Routing)           적응적 방법 : 능동적            국부적 경로 선택(Isolated Routing) : 독립적인 판단에 의해 결정       분산 경로 선택(Distribute Routing) : 자신을 중심으로 연결되어 있는 모든 경로 정보 분석       집중 경로 선택(Centralized Routing) : 전체 네트워크 경로 흐름 파악/제어하는 RCC(Routing Control Center)의 정보로 경로를 선택           경로 선택 프로토콜     RIP(Routing Information Protocol) : 평면적인 구조, 인접해있는 게이트웨이 정보 취득   OSPF(Open Shortest Path Fast) : 계층적인 구조, 링크상태 알고리즘 사용   BGP(Border Gateway Protocol) : 두 개 이상의 AS(자율적으로 사용하는 라우터 집합)로 사용되는 프로토콜, 관리자에 의해 독자적인 경로 설정이 필요할 때 사용   IGRP(Internet Gateway Routing Protocol) : BGP를 보완, 중간 규모 네트워크   RTP(Reliable Transport Protocol) : EIGRP(IGRP 개선) 패킷의 송수신을 위해 사용   트래픽 제어     흐름 제어            슬라이딩 윈도(Sliding Window)  송신측에서는 수신측으로부터 전송할 프레임의 개수 미리 지정받음  수신측에서 전송할 프레임의 개수를 다시 지정 시 전송 가능  X.25 패킷 레벨의 프로토콜에서도 사용           혼잡 제어   교착 상태 회피   LAN(Local Area Network)     어떤 종류의 시스템 기기와도 연결이 가능   오류 발생률 낮고 전송 지연을 최소화할 수 있음   공유 매체 사용 ⇒ 경로 선택 없이 매체에 연결된 모든 장치로 데이터 전송 가능   재배치, 확장성 우수   광대역 전송 매체의 사용으로 고속 통신이 가능   DCF(CSMA/CA방식) : IEEE 802.11의 기본적인 매체 접근 방식   ISDN(Integrated Service Digital Network)     하나의 통신망으로 통폐합 ⇒ 확장성, 재배치 우수   모든 통신 선로와 교환기를 디지털화   복수 통신 가능, 중복 투자 회피(경제적)   기존 전화망 ⇒ 디지털 교환기와 연결하여 기본 서비스 제공(2B+D)   규모가 큰 사용자와 기업은 광케이블 설치하여 1차군 서비스(23B/30B+D) 제공   회선 교환 방식, 패킷 교환 방식   64kbps 1회선 교환 서비스가 기본   접속점(기준점, 분계점)            타인의 전산망 기기와 접속되는 경우에 그 설치와 보전에 관한 책임의 한계를 명확하게 구분하기 위한 접속점       U(User) / T(Terminal) / S(System) / R(Rate)           ATM(Asynchronous Transfer Mode : 비동기 전송 방식)     일정한 크기(쉘)로 구분하여 순서대로 전송하는 자료의 전송 방식 ⇒ 송수신 처리 간단   오버헤드가 줄어 고속 전송 가능, 멀티미디어 서비스 적합   비동기식 다중화 방식 사용   양 끝단 간 오류와 흐름을 제어 ⇒ 어떤 종류의 서비스라도 제공 가능   물리 계층 : 셀의 속도 조정, 셀의 경계 식별, 비트 타이밍   ATM 계층 : 일반 흐름 제어, 셀 헤더 생성 및 추출, 셀 교환, 셀 다중화 및 역다중화   ATM 적용 계층(AAL) : 수렴과 셀 분할 조립   상위 계층 : 서비스별 상위 계층 기능   LAN 계층     물리 계층 + 데이터 링크 계층    X.25 계층     물리 계층 + 프레임 계층 + 패킷 계층    TCP/IP(인터네트워킹) 계층     링크 계층 + 인터넷 계층 + 전송 계층 + 응용 계층    PPP(Point to Point Protocol)     전화선과 모뎀을 이용하여 인터넷에 접속하기 위한 프레임 프로토콜   SLIP 개선 ⇒ 에러 검출 기능, 복구 기능 추가, 문자 위주 프레임   IETF 표준 프로토콜, 다중 프로토콜 지원   오류 검출만 제공, 재전송을 통한 오류 복구와 흐름 제어 기능 제공하지 않음   비동기식 링크도 지원해야 하므로 프레임은 반드시 바이트의 정수배   Protocol Field            PAP(Password Authentication Protocol)  초기 접속 시 ID/Password를 미리 입력해 놓으면 자동으로 접속  2-Way 방식       CHAP(Challenge Handshake Authentication Protocol)  매번 접속 시 3단계 핸드쉐이크 인증을 행하는 방법, 안전           IP 계층의 주요 기능     패킷을 절단(단편화), 재조립   비연결성 네트워크 프로토콜   주소 지정, 논리적으로 관리   수명 시간 관리, 오류 제어, 흐름 제어   네트워크 계층 프로토콜     ARP(Address Resolution Protocol)   RARP(Reverse Address Resolution Protocol)   ICMP(Internet Control Message Protocol)   IGMP(Internet Group Management Protocol)   DNS(Domain Name System)   DHCP(Dynamic Host Configuration Protocol)   전송 계층 프로토콜     RTP(Real Time Transport Protocol)            실시간으로 음성이나 동화상을 송수신하기 위한 통신 규약       UDP / 응용프로그램 사이       Version(V)       Padding(P) : 추가적인 데이터들이 포함되어 있는지를 표시       Extension(X) : 고정 헤드와 페이로드 사이에 확장 헤드가 있는지 여부 표시       Marker(M) : 패킷 스트림에서 프레임 간의 경계에 존재하는 특별한 경우       PT(Payload Type) : 데이터가 어떤 형식인지를 결정       Sequence Number       TimeStamp : 첫 번째 바이트의 샘플링 시점           RTCP(RTP Control Protocol)            RTP를 제어하기 위한 프로토콜           국제 표준화 단체의 기술     ISO : HDLC   IETF : PPP   IEEE : LLC   ITU : LAPB, CCITT, PSDN, PSTN, IDSN   서브넷 마스크     네트워크 논리적인 분할, 네트워크 ID와 호스트 ID 구별   네트워크의 부하 감소   A Class : 1 + Network Address(7) / Host Address(24)   B Class : 10 + Network Address(14) / Host Address (16)   C Class : 110 + Network Address(21) / Host Address (8)   D Class : 1110 + Multicast Address   E Class : 1111 + Test Address  ","categories": ["study"],
        "tags": ["(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/data-communication/",
        "teaser": null
      },{
        "title": "[토익/TOEIC] 문법 실전 압축",
        "excerpt":"주어      There is/are/remain/exist 뒤에는 명사 주어   가짜주어 it ⇒ (for+명사) to부정사 / that절   (빈칸) that S + (should)+동사원형            Insist / order / suggest / ask / request / demand            It is (빈칸) that S + (should) 동사원형            Important / vital / imperative / necessary / essential / advised            명령문 ⇒ (Please) + 동사원형으로 시작   보어      주격보어 자리 =&gt; 형용사(상태/설명), 명사(동격)   주격보어를 가지는 동사 : ~가 되다/유지되다/지속되다/감각 동사            Become / come / grow / go / get / turn / stay / remain / seem / prove  감각동사 : feel / taste / smell / look / sound            목적격 보어 Keep / Consider / Find + O + O.C(형용사)     make / leave   Call / consider / elect / make + O + O.C(명사/ 목적어와 동격)   Describe / regard A(O) as B(O.C)   동사   조동사     Cannot help V-ing  = cannot but V·R  = cannot help/choose but V·R  = have no choice but to V·R = ‘~하지 않을 수 없다’   Cannot ~ too = ‘아무리 ~해도 지나치지 않다   Had better + V·R = may as well + V·R = ‘~하는 것이 낫다’   May well + V·R ‘~하는 것도 당연하다’   Might as well A(V·R) as B(V·R) ‘B할 바엔 A하는 것이 낫다’   Be going to V·R / be about to V·R   Be willing to V·R   사역 동사  Have/make + O + O.C ⇒ 동사원형(능동’~하게하다’) / p.p(수동’~되게하다’)  Get + O + O.C ⇒ to부정사(능동) / p.p(수동)  Help + (O) + 동사원형 or To부정사(의미차이 없음)  Let + O + 동사원형 or Be p.p(수동)   자동사 vs 타동사     자동사(Intransitive Verb : vi) =&gt; 목적어 X =&gt; 수동태 X   자동사 : last / expire / function /  proceed / rise / work / fall / exist / participate   혼용(자/타) : decline - vi. 감소하다 / vt. 거절하다   자동사 + 전치사                                                                          Account for       agree (to/with/on)       apologize for       apply (for / to)       benefit from                 belong to       care for       comply with       consent (to/with/on)       contend with                 contribute to       cooperate with       cope with       deal with       depend on                 differ from       engage in       Arrive (at/in)       interfere with       listen to                 look after       look into       look at       look over       look for                 object to       participate in       react to       refer to       rely on                 reply to       respond to       speak to       specialize in       talk (about/to)                 wait for       proceed (with, to)       dispose of       deal with                   타동사(Transitive Verb : vt) =&gt; 명사구(목적어)     Access =&gt; n. 접근(~to), v. 접근하다(타)                                                                          accompany       announce       answer       approach       approve                 attend       await       contract       discuss       email                 emphasize       explain       interview       leave       marry                 mention       oppose       reach       resemble       raise                 organize       establish       conduct       address                   동사는 주어에 수일치     불가산명사 / 고유 명사 ⇒ 단수 취급   one / each / every + 단수명사 ⇒ 단수 취급   each of the / neither of the / the number of / one of the + 복수 명사 + 단수 동사   a couple of / a number of / a variety of + 복수 명사 + 복수 동사   4형식 동사 =&gt; 목적어 2개     offer(*offer to : 제안하다) / award / forward / grant / give / pay / send / refund            ※ 수동태 형식일 때 뒤에 목적어가 남을 수 있음.           3형식 동사 : announce / describe / explain / mention / say / suggest + (to + 명사) + O   4형식 동사 : advise / assure / notify / convince / inform / remind / tell + O + O(that)   5형식 동사, O + O.C(to V)                                                                          allow       permit       ask       require       encourage                 expect       advise       tell       force       order                 want       elect       deem       show                      ※ Ask / expect / want / would like + to V (3형식)   ※ Tell A about B(3형식)   수동태   4형식 동사의 수동태 뒤 ⇒ 목적어 : (S + V + I.O + D.O)  advise / assure / convince / inform / notify / remind / tell ⇒ S + be P.P + that     ※ (Notify / inform / remind) A of B : A에게 B를 알리다   5형식 동사의 수동태 뒤 ⇒ 목적 보어 (S + V + O + O.C)     consider / call / make / leave / keep / find / appoint / name   be encouraged to / be asked to / be expected to / be told to / be required to   Expect + to v (3형식)   사람의 감정 ⇒ 수동태                                                                          Encourage       distract       amaze       depress       excite                 exhaust       tire       please(with)       amuse(at)       satisfy(with)                 interest(in)       fascinate(with)       excite(by)       disappoint(at)       discourage(by)                 depress(by)       frustrate(with)       shock(at)       surprise(at)                   수동태 + 전치사     For            known / renowned / used            With            satisfied / pleased / associated / concerned / equipped / faced / covered            To            dedicated / devoted / committed / exposed / related / assigned            To -V            allowed / permitted / asked / requested / invited / required / advised / prompted / reminded / warned / encouraged / intended / prepared / supposed / scheduled / excited / pleased / entitled / prepared / pleased  be entitled to (V / 명사)            In            interested / engaged / involved / absorbed / included            Etc            based on / divided into            목적어   가목적어는 5형식 구문에서 사용 가능     Make it possible to v   (for + 명사) 의미상 주어 + to v   (to + 명사) + that절   목적어가 있으면 능동태, 없으면 수동태     자동사는 목적어가 없어도 항상 능동태   attend + O : ~에 참석하다 / attend to ~ : ~을 처리하다, 시중들다   시제   과거 시제 ⇒ 과거에 이미 끝난 동작 or 상태     Ago, yesterday, last   Once / recently   과거 완료 시제     By the time + S + 과거시제, S + 과거완료(had p.p)   before/after 접속사 구문에서는 과거시제를 사용하기도 함   현재 시제     반복(usually, always, often, everyday) / 습관적 / 일반적 사실 / 규칙 / 규정 ⇒ 현재 시제   cf) have always p.p : 항상 예전부터 ~ 해왔다   가까운 미래를 대신할 수 있음            come/go/depart/leave/arrive/expire/end/conclude/complete/start/finish            현재 진행     가까운 미래 ⇒ 이미 예정된 일   Now / right now / currently   현재 완료 시제     have p.p ~ before   have + once/recently + p.p   have + p.p + since 과거   for/in/(over the last/past) + 기간, ~ have p.p   in the last/past + 기간(과거 ~ 동안) + have p.p   미래 시제     be to 명사적 용법, 미래 시제(~할 것이다/~할 의무이다 = is due to v)   next / in / shortly / soon / upcoming   미래 완료 시제     will have p.p 과거(시작) ⇒ 현재 ⇒ 미래(완성)   by the time S + V, S + V(미래/미래완료)   준동사(To부정사, 동명사)   To부정사를 목적어로 취하는 동사                                                                          determine       offer       aim       refuse       fail                 promise       hesitate       intend       (dis)agree       try                 want       hope       wish       expect       decide                 choose       plan       prepare       intend       ask                 need                                           To부정사를 목적 보어(5형식 구조)로 취하는 동사     advise / ask / invite / allow / persuade / force / encourage / require / request / expect / enable    To부정사와 함께 쓰이는 명사/형용사     명사 + To v (~ 할)            ability/authority/plan/promise/right/time/authorization/opportunity/permission/way + to do            형용사 + to            be + (able / about / hesitate / likely / ready / willing / liable / eager / difficult / delighted) +to            To부정사는 목적(~하기 위해서)/이유(~하기 때문에)/결과(~해서)를 의미할 수 있다     by ~ing : ~ 함으로써   in order to / so as to / in order that: ~ 하기 위해서   be (happy / glad / pleased) to ⇒ 이유(~하기 때문에)   Only to V : (그러나) 결국 ~하다   동명사   전치사 + 동명사 + 관사 + 명사  전치사 + 동명사/과거분사 + 명사 ⇒ 해석(동명사 : 명사하는 것 / 과거분사 : ~된 명사)   동명사를 목적어로 취하는 동사 - MEGA P(F)AS(C) ID     Suggest / consider / postpone / avoid / recommend / deny / finish / quit / discontinue / give up / keep / enjoy / include / mind    동명사 관용구     have difficulty / trouble / a problem (in) ~ing/with 명사   be busy/used to ~ing(~하는데 익숙하다)   cf) be used to v : ~하기 위해 사용되다   (Cannot help) /keep (on) / feel like / go / on / upon(~하자마자)   upon (전치사) + 명사+목X / 동명사+목O   it is no use v-ing / be capable of v-ing / be worth v-ing / feel like v-ing /   spend (시간/돈) v- ing / prevent A from B v-ing   전치사(To) + 동명사     be (committed / dedicated / devoted / opposed / related / used / accustomed)   object / contribute / look forward / lead   To부정사 또는 동명사를 목적어로 취하는 동사     continue / begin / hate / love / prefer / start (의미에 차이가 없음)   forget / remember / regret + to부정사 : 앞으로~할 / ing : 과거에 이미 ~한   주의) begin + 명사목적어   준동사(분사)   현재분사(~하는/하면서, ~ing) / 과거분사(~되는/되면서, p.p)     when/while/after/before/until/if + ~ing   접속사 + S + V ⇒ 주어 제거, 동사원형 + ~ing(being은 생략) ⇒ 접속사 + ing/p.p   with + 명사 + 분사(현재:~가 ~한 상태로/과거 : ~가 ~된 상태로)   with + 명사 + 형용사(~가 ~한 상태로)   혼동하기 쉬운 표현                  Leading hotel       일류 호텔       Prefered option       선호되는 선택권                 Opening statement       개회사       Proposed change       제안된 변경 사항                 Promising opportunity       유망한 기회       Experienced professional       숙련된 전문가                 Existing manual       기존 설명서       Detailed description       자세한 설명                 Lasting effect       지속적인 영향       Attached file       첨부된 파일                 Improving market       발전하는 시장       Limited budget       제한된 예산                 Missing information       누락된 정보       Damaged appliance       손상된 기기           명사   품사가 혼동되는 단어     visit : v. 방문하다 n. 방문   timely/orderly/friendly ⇒ 형용사   potential/advance   가산 명사 / 불가산 명사     가산 명사 : detail / suggestion / request / profit / increase / bonus / price / discount / rate / fund / refund / reservation / approach / permit / plan / account   불가산 명사 : approval / satisfaction / advice / confirmation / housing / baggage / luggage / information / equipment / construction / furniture / appreciation / participation / access / permission / planning / Merchandise   사람 / 사물 / 추상 명사                  critique       평론       criticism       비평                 critic       비평가       facilitator       조력자                 facilitation       촉진       architect       건축가                 authority       권위자       authorization       권한 부여                 architecture       건축       beneficiary       수혜자                 benefit       이익       coordinator       조정자                 correspondent       통신원       correspondence       연락                 coordination       조정       relative       친척                 relation       관계                           비슷한 의미를 가지는 단어 주의                  utilization       활용       utility       효용                                 process       과정, 절차       processing       가공,처리                                 cover       표지       coverage       범위                                 alternative       대안       alternation       교체       alteration       수정                 indicator       지표       indication       암시                                 initiation       시작,개시       initiative       주도, 계획                                 as one’s own initiative       ~의 주도로                                           복합 명사                  customs office       세관       savings account       저축계좌                 registration process       등록절차       registration fee       등록비                 registration office       등록사무소       safety precautions       안전 예방책                 safety regulations       안전 규정       benefits package       복리후생제도                 awards ceremony       시상식       confirmation number       예약 확인 번호                 manufacturing process       제조 과정       feasibility study       타당성 조사                 earnings growth       수익 성장       office supplies       사무용품                 living expenses       생활비       sales quota       판매 할당량                 reference letter       추천서       travel arrangements       출장 준비                 Performance appraisals/evaluations       업무 수행 평가                                 Customer service representative       고객 서비스 상담원                           대명사   지시대명사     That ⇒ 단수명사, those ⇒ 복수명사   Those (who + be) : ~하는 사람들   부정대명사 / 부정형용사     Other ⇒ 가산 명사 복수/불가산(혼자 쓰일 순 없음), another ⇒ 가산 명사 단수 앞   Another + 시간/거리/무게단위   The others : (대명사) 나머지들   Any other : 가산 명사 단/복수, 불가산   Other + 복수명사 == others   소유대명사     one’s own ⇒ 명사 수식(소유격)   one’s own + 명사 : ~ 자신의 (것) = 명사 of one’s own   on one’s own = by oneself : 스스로   재귀대명사     재귀대명사는 목적어 자리에 올 수 있다 (주어 == 목적어)   재귀대명사 강조 : 주어/목적어 뒤(생략 가능)   재귀대명사 관용어구            For oneself : 혼자힘으로       Of itself / in itself : 본질적으로       Pay for itself : 본전을 찾다       Have + O + to oneself : O를 주어가 차지하다       Help oneself to + 명사 : (음식을)맘껏 먹다/(사물을)맘껏 사용하다           형용사   다른 의미를 가지는 형용사                  Distinguishable       구별할 수 있는       Distinguished       유명한                 Advisable       권할 만한       Advisory       자문의, 경고                 Argumentative       시비를 거는       Arguable       주장할 수 있는                 Comparable       필적할 만한       Comparative       비교의                 Confident       확신하는       Confidential       비밀의, 신임하는                 Dependent       의존적인       Dependable       믿을 수 있는                 Considerate       사려 깊은       Considerable       상당한                 Enviable       부러운       Envious       선망하는                 Favorable       호의적인       Favorite       가장 좋아하는                 Informative       유익한       Informed       정통한, 알고 있는                 Momentous       중대한       Momentary       순간적인                 Reliable       믿을 수 있는       Reliant       의지하는                 Seasonal       계절적인       Seasoned       경험이 많은                 Successful       성공한, 성공의       Successive       연속의                 Understanding       이해심 있는       Understandable       이해할 만한                 Profitable       유리한       Proficient       능숙한                 Respectable       존경할 만한       Respective       각자의                 Careful       세심한, 조심스러운       Caring       보살피는                 Managerial       경영의       Manageable       관리할 수 있는                 Persuasive       설득력있는       Persuaded       확신하고 있는                 Prospective       장래의       Prosperous       번영하는           Be + 형용사     Be about to -v   Be available to -v   Be capable of v -ing   Be eligible for   Be responsible for   Be likely to -v   Be willing to -v   Be skilled in/at   명사의 수에 수량 형용사 일치     (Each / every / one / a single) + 가산 단수 명사 / each of the + 복수 명사(~중에 각각)   [some/most/any/rest/분수 + (of the)]/all (of) the/ + 가산 명사 복수 / 불가산 명사   another/each/few/little/most/many/much/some + (명사)   Other ⇒ 가산 명사 복수 / 불가산   A (wide/large/diverse) variety of = various   (Either/one) of the + 가산 복수 + 단수 동사   (few/most) of the + 명사   A few (조금의), few(거의 없는) ⇒ 가산 복수 명사   A little (조금의), little(거의 없는) ⇒ 불가산명사   Some/Any/Every/No + body/one/thing + 단수 명사   All / most / any / some / half / a lot(lots) / part / the rest / the bulk / percent / 분수  ⇒ of + (단수 명사 + 단수 동사) / (복수 명사 + 복수 동사)   형용사 + that     be aware that / be confident that / be (happy/glad) that / be optimistic that /   be positive that / be (confident/convinced/sure) that / be (afraid/sorry) that   (형용사 / 부사) + 형용사 + 명사     해석으로 접근!   수식받는 품사(형용사/명사)를 확인한다.   부사   동사를 수식하는 부사     Work cooperatively / rise significantly   Almost/nearly + everybody/everything/nobody/nothing/anybody/anything   비슷한 부사 어휘                  High       높게       Highly       대단히                 Even       심지어 ~조차       Evenly       고르게                 Right       바로 (부사)       Largely       주로                 Late       늦게       Lately       최근에                 Most       가장       Mostly       일반적으로, 주로                 Otherwise S + V       그렇지 않다면(접속부사)       Otherwise + V       달리(부사)           숫자를 수식하는 부사     거의/대략 ⇒ nearly/approximately/roughly/about/almost/around   At least/just/more than/only/over/up to   강조 부사     so/very/too/quite + 형용사/부사   *quite + 관사 + 형용사 + 명사   much too(부)/too much(형/부) + 명사/동사 수식   부사 + 동명사(동사의 성질이 있음)     관사X, 형용사X   소유격(~이/가, 의미상주어) + 동명사   동명사 + 목적어   동명사처럼 보이는 명사            clothing/funding/heating/housing/planning/processing/seating/spending/staffing           접속부사     접속 부사 != 접속사   S + V. 접속부사, S + V   S + V + 접속사 + 접속부사, S + V   양보 : however / nevertheless / nonetheless / still   결과 : accordingly / consequently / hence / therefore / thus / as a consequence / finally / as a result   부가 : besides / furthermore / moreover / above all / in addition   추가 설명 : indeed / in fact   대조 : contrarily / in contrast   순서 : then / thereafter   가령 : otherwise   시점/사건 연결 : (in the)meantime, meanwhile   기타 : alternatively / afterward(s) / as usual(=as always) / even so / initially / since then / similarly(=likewise), namely, in comparison   전치사   전치사 + ~ing/명사  전치사 + 명사 + 목적어 X  전치사 + ~ing + 목적어 O   시간과 장소 전치사     In ⇒  [시간] 일정 기간(월/계절/연도)\t[장소] 도시/국가 또는 내부가 강조된 방,   On ⇒ [시간] 요일/날짜\t\t[장소] 거리명(표면 위),   At ⇒  [시간] 구체적인 시간\t\t[장소] 지점/회사/건물(기본위치)   관용어구 : at no charge(무료로) / at the time of(~할 때)   시점/기간 전치사     시점 / 기간 : after   시점 : before / toward / by / from / prior to / since / until(진행/계속)   기간 : during(+숫자X) / for(+숫자) / in / over / throughout / within / The + 날짜   방향/위치 전치사     방향 : Opposite / across from / for + (교통수단 목적지) / toward + (막연한 방향)        Across / through / along / into / out of       위치 : beside / next to / between / among / throughout / above / over / behind / near / around   past : (prep) ~지나서 / (a) 지난   alongside : (prep) ~의 옆쪽에 / (ad) 옆쪽에   ‘~에 관하여’ 전치사     as for/as to/concerning/regarding/on/over   (in/with) + (reference/regard/relation) to   pertaining to/related to/referring to   기타 전치사     제외 : except (for) / without / apart from / aside from   이유 : due to / because of  목적 : for   양보 : despite / in spite of / notwithstanding   부가 : besides / in addition to   By + 명사(~에 의해) / v-ing(~함으로써) / 교통수단 (~를 타고)   following / given / plus / amid                  according to       along with(~와 함께)       as of       owing to                 in accordance with       in the event of       in celebration of       in charge of                 in excess of       in keeping with       in light of       in place of                 in preparation for       in respect of       in terms of       in violation of                 on behalf of       as to       in exchange for       in place of                 in case of       in response to       regardless of       in charge of           동사 + 전치사                  Register for       rely on       count on       congratulate A on B       advertise on                 keep track of       direct A to B       comply with       return A to B       consist of                 transfer A to B       add to                                   형용사 + 전치사                  equivalent to       identical to       consistent with       similar to                         responsible for       comparable to       comparable with       familiar with                         eligible for       dependent on       reliant on       different from                         adjacent to       absent from       capable of       worthy of                      be eligible (for + 명사 / to V)   명사 + 전치사                  a solution to       concern (over/about)       a dispute over       a lack of       access to                 an effect on permission from       an advocate (for/of)       a problem with       a cause for       a reason for                 Respect for       an impact on       an influence on       an increase in       a decrease in           전치사 to / to 부정사     be (dedicated / committed / devoted) to ~ing, contribute to ~ing   leat to / look forward to / be used to / object to / be accustomed to   commitment + to 명사/to 부정사   접속사      접속사 S + V / 전치사 + 명사   전치사 : as to / during / despite / in spite of / because of / at the time of / thanks to / as for   접속사 : although / even though / while / because / at the time / even if / considering(that) / now that / as p.p / yet / for   since ⇒ 전치사:~이래로, 접속사:~때문에/~이래로   Whoever(접속사) == anyone(대명사) who == ‘누구든지’   Whoever : 선행사X, 동사가 바로 나옴   Anyone (who + be-V)   So / for 문장 접두에 사용 불가   상관 접속사(수일치)     both A and B (복수)   neither A nor B   either A or B   B as well as A = not only A but (also) B   to and from / before and after   시간/조건을 나타내는 접속사     접속사 + S + 현재시제, S +  미래시제   after / as soon as / by the time / when / while / if / once / unless / provided(that)   부사절   [시간 / 조건] 부사절 접속사 (미래시제 ⇒ 현재시제)     as : ~할 때, 함에 따라\t\t● as soon as \t\t\t● once   unless \t\t\t● in case(that)\t\t\t● in the event (that)   as long as\t\t\t● providing / provided (that)   only if\t\t\t\t● on condition that   [양보] 부사절 접속사     whereas / while   even if\t/ even though   [이유] 부사절 접속사     as / since\t\t\t● now that\t\t\t● in that   [목적] 부사절 접속사     so that\t\t\t\t● in order that   [결과] 부사절 접속사     so / such ~ that ~   [제외] 부사절 접속사     except that   비교구문   원급비교     동급 : as 형용사/부사 as, as (many/fewer/less + 명사) as   Not as ~ as = not so ~ as   비교급 : er ~ than     ※ than을 사용하지 않는 비교급 :            the same + N + as / (inferior/superior) to       just as(그만큼 ~ 한), Prior to(= before)       the 비교급, the 비교급       would rather ~ than           -er than ever   비교급 강조 부사 : much / even / far / a lot / still / by far   rather + 형용사(꽤) / 동사(차라리) / than(~보다)   비교급 표현                  No later than       늦어도 ~까지       No longer       더 이상 ~ 않다                         No sooner ~ than ~       ~하자마자 ~하다       Other than       ~이외에                         Rather than       ~보다는                                   최상급 : the ~est / the most ~     부사의 최상급은 the를 생략, 소유격으로 대체가능   Of all ~, the most ~   최상급 강조 부사 : much/by far/quite ⇒ 단연코   The 최상급 + possible/ever   최상급 + of~ / in~ / that절   관계사절 == 형용사절   관계사절 ⇒ 형용사 역할(‘~하는’) ⇒ 명사 수식   관계대명사(that / who / which / whose) = 접속사 + 대명사     관계 대명사(주격/목적격) + 불완전한 문장   whose(소유격) + 명사 : ~의   목적격 관계대명사 생략 가능   (주격 관계대명사 + Be동사) 생략 가능   관계대명사(주격) who + (S + V) + V   think/hope/believe/boast/say/feel   전치사 + 관계대명사(목적격) : 숙어 암기!   수량 표현(S) + of + 관계대명사(목적격) + V(수일치 주의!)   all/any/half/most/one/rest/some   ※ some/most/all (of the) 명사 + 동사(명사에 대해 수일치)   복합관계대명사(명사절/부사절 접속사)     Whatever(=anything which(범위X))‘‘무엇이든지’ 접속사로도 사용   whichever(=anything which(범위O))/whoever/whomever   Whatever/whichever ⇒ 복합관계형용사, 명사 수식   관계부사     when/where(=in which/at which/on which)/how/why ⇒ 완전한 절   the way / how 둘 중 선택하여 사용   복합 관계 부사     However(no matter how) + 형/부 + S + V : ‘아무리 ~하더라도’   wherever(no matter where), whenever(no matter when)   명사절   명사절 접속사     선행사 X + That(접속사) + 완전한 절 : ‘~의 것’으로 해석   cf) 관계대명사 that : 선행사 O + that + 불완전한 절   선행사X + What(관계대명사) + 불완전한 절 : ‘~의 것’으로 해석   say/indicate/ + (that)   동격절 ⇒ fact/confirmation/idea/news/opinion that   Whether / if : ‘~인지 아닌지’ + 완전한 문장   Whether S + V = to부정사   같은 의미의 if는 불가능!   If절은 whether절과 달리 동사의 목적어(동사 뒤), 보어로만 사용   의문사 = 의문대명사 + 의문부사   복합의문대명사(~든지)  : whatever / whoever / whichever   의문사 + S + V     주어, 목적어, 보어 자리에 사용 가능   의문대명사(who/whom/whose/what/which) + 불완전한 절   의문형용사(which/what/whose) + 명사   의문부사(when/how/why/where) + 완전한 절   How + 부사 / 형용사(뒤 문장에 Be동사가 있을 때): 얼마나 ~하게   How S + V : 어떻게 ~했는지   How much + S + V : 얼마나 ~ 하는지   의문사 + S + (should)V ⇒ to부정사   기타구문(가정법, 도치)   가정법 시제 일치     If S + 과거 완료 (had p.p), S + would/could/might/should 현재 완료 (have p.p)   If S + 과거 시제, S + would/could/might/should + 동사원형   But for / if it were not for + 명사 : ~가 없었더라면   Should + S + 동사원형 == if가 생략된 가정법 도치 구문   도치구문     부정부사            hardly/seldom/rarely/never/not only/neither/scarcely/barely + V + S  Only + 부사(구/절) + V + S  cf) hardly … when … : ~하자마자 ~했다            So/as(긍정) or neither/nor(부정)(=~도 역시) + do/does/did/be(V) + S   p.p + be-V + S ⇒ 수동태의 도치            attached/included/enclosed            전치사구 + be-V + S   5형식 도치 : O.C + S + V + O (주어 동사 위치 변경 X)            attached/included/enclosed 명령문 ⇒ (Please) V(동사원형) + O.C + O            기타문법     Lead A to V : A가 ~하게 하다   (Leave / drop off) A with B : A에게 B를 맡기다   Keep A updated : A에게 계속 상황을 알리다   Take A to B : A를 B로 데려가다   Enough + 명사 ‘a. 충분한’ / 형용사 + Enough ‘adv. 충분히’   Be used to V : ‘~하기위해 사용되다’ / be used to v-ing : ‘~하는 것에 익숙하다’   Used to V : ‘~하곤 했었다’   Be bound (to V : ‘분명히 ~하다’ / for + 목적지 : ‘~행이다’)   Fill in for : ‘~을 대신하다’   Deserve + ( 명사 : ‘~받을 자격이 있다’ / to V : ‘~할 자격이 있다’)   Be (required / expected) of A   Complain about (명사 : ‘~에 관해 불평하다’ / 명사 + v-ing : ‘명사가 ~하는 것에 불평하다’)   Appear + (형용사 / to V / that S + V) : ‘~인 것 같다’    제가 공부한 내용을 정리한거라 잘못된 부분이 있을 수도 있습니다.  추가로, 개선사항을 답글로 따로 남겨주시면 검토 후 수정하도록 하겠습니다.  스크랩 또는 공유시 가능한 출처표기 및 답글 부탁드리겠습니다~  ","categories": ["study"],
        "tags": ["TOEIC"],
        "url": "https://many258.github.io/study/toeic-grammar/",
        "teaser": null
      },{
        "title": "[(구)정처기/실기] 업무프로세스 키워드 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.           ERP(Enterprise Resource Planning : 전사적 자원 관리)  기업 내의 모든 인적/물적 자원을 효율적으로 관리 경영자원을 하나의 체계로 통합 시스템을 재구축 → 생산성 극대화            BPR(Business Process Reengineering : 업무 재설계)  경영 전반을 분석하여 경영 목표 달성에 가장 적합하도록 재설계            CPM(Corporate Performance Management : 기업 성과 관리)  예측 경영을 통한 최적의 의사 결정을 내릴 수 있게 해주는 시스템            BSC(Balanced Score Card : 균형 성과 평가 제도)  기업의 성과를 종합적으로 평가하는 균형 잡힌 성과측정기록표            WBS(Work Break down Structure : 업무 분업 구조)  성과 목표 완전 달성을 위한 프로그램            MBO(Management By Objectives : 목표 관리)  조직의 상/하위층이 참여하여 효과적으로 조직의 목표를 달성하려는 관리기법            BPM(Business Process Management)  기업 업무 프로세스를 효율적으로 관리하기 위한 솔루션            BPMS(Business Process Management System : 비즈니스 프로세스 관리 시스템)  업무와 인간과 시스템간의 관계를 통합 관리하는 시스템            SEM(Strategic Enterprise Management : 전략적 기업경영)  경영진이 가치 중심 경영을 할 수 있도록 도와주는 통합된 분석용 제품 툴과 프로세스            MIS(Management Information System : 경영정보 시스템)  경영 내외의 관련 정보를 즉각/대량으로 관리할 수 있도록 편성한 인간과 컴퓨터 결합            EA(Enterprise Architecture)  기업 조직의 구조와 운영을 정의하는 종합적인 청사진            EAI(Enterprise Application Integration : 기업 어플리케이션 통합) 기업에서 사용하는 서로 다른 애플리케이션 통합            SIS(Strategic Information System : 전략 정보 시스템)  경쟁 우위를 확보하기 위해 구축 및 이용하는 정시 시스템            DSS(Decision Support System : 의사 결정 지원 시스템)  정형화되지 않은 문제에 관해 의사 결정자가 효과적인 의사 결정을 할 수 있도록 지원            EIS(Executive Information System : 경영진 정보 시스템)  전략 구상을 지원할 목적으로 구축된 경영 정보 시스템            KMS(Knowledge Management System : 지식 관리 시스템)  조직 내의 인적자원들이 축적하고 있는 개별적인 지식을 체계화하여 공유            EDI(Electronic Data Interchange : 전자 문서 교환)  기업 간의 거래 데이터를 교환하기 위한 표준 포맷            CSF(Critical Success Factors : 주요 성공 요소)  핵심 업무를 성공적으로 수행하기 위한 중요한 요인을 찾아내어 경영상 중요한 정보 결정       5 Forces  다섯 가지 힘의 정도에 따라 힘이 강하면 위협, 약하면 기회가 될 수 있음을 의미            잠재적 경쟁자의 위협(진입장벽의 힘)  기존 기업과의 경쟁(산업 내 경쟁강도)  공급자의 교섭력(공급자의 힘)  소비자의 교섭력(구매자의 힘)  대체재의 위협(대체재의 힘)            AS-IS  새로운 프로세스 비전을 설정하기 위해 현재의 업무 프로세스 분석        To-Be  미래에 구현하고자하는 업무 프로세스를 정의            7S  조직 문화에 영향을 주는 조직내부요소 7가지 요인 Strategy / Structure / System / Staff / Style / Skill / Shared Value            SWOT  Strength / Weakness / Opportunity / Threat 경영 전략을 수립하기 위한 분석 도구            TQM(Total Quality Management : 전사적 품질 경영)  기존의 조직문화와 경영관행을 재구축            ITA(Information Technology Architecture)  조직 전체의 정보화 구성 요소들을 통합적으로 분석한 뒤 관계를 구조적으로 정리한 체계            6-Sigma  품질 혁신과 고객 만족을 달성하기 위한 과학적이고 합리적인 문제 해결 방법            SCM(Supply Chain Management : 공급망 관리)  공급 체인을 재공학 및 동시 공학 기법을 활용하여 시간과 비용을 절약하는 관리 기법            CRM(Customer Relation Management : 고객 관계 관리)  고객 중심의 경영 기법            MRP(Material Requirement Program : 자재소요량계획)  부품이 투입될 시점, 투입되는 양을 관리하기 위한 시스템            MOT(Moment of Truth)  결정적인 순간, 일상 생활 공간을 파고드는 마케팅 기법            VOC(Voice Of Customer)  고객의 소리            VBM(Value Based Management : 가치 창조 경영)  모든 의사 결정의 기준을 기업 가치 중심으로 하는 기업 관리 기법            CKO(Chief Knowledge Officer : 지식 총괄 책임자)  지식 활동을 총괄하는 최고 책임자            AIS(Accounting Information System : 회계 정보 시스템)  회계 정보를 회사 전체의 종합 시스템으로 결합/처리            CALS(Commerce At the Light Speed)  제품의 수명 주기를 통합 데이터베이스로 관리 및 지원하는 시스템            SOA(Service-Oriented Architecture : 서비스 지향 아키텍처)  정보 시스템을 공유와 재사용이 가능한 서비스/컴포넌트 중심으로 구축하는 아키텍처            CoP(Communities of Practice : 지식 공동체)  공통의 관심사를 가진 사람들의 비공식/자발적/소규모 연구 모임            EMR(Electronic Medical Record : 전자 의료 기록)  의료 기록 업무를 전산 처리            CBD(Component Based Development : 컴포넌트 기반 개발)  컴포넌트를 조립해서 하나의 새로운 어플리케이션 만드는 소프트웨어 개발 방법론            PDM(Product Data Management : 제품 데이터 관리)  제품 개발의 각 과정의 모든 데이터를 일원적으로 관리            EP(Electronic Payment : 전자 지불)  대금 지불을 전자적인 방법으로 처리            LMS(Learning Management System : 학습 관리 시스템)  학습 활동 지원 시스템            ABC(Activity Based Costing : 활동 기준 원가 계산)  비즈니스를 업무 활동 단위로 세분화하여 경비를 수치화 하는 방법            EIP(Enterprise Information Portal : 기업 정보 포털)  기업의 내부/외부 정보를 통합해 웹 포털 형태로 제공하는 통합 정보 시스템            G2B(Korea ON-line Procurement System : 나라장터)  국가 종합 전자 조달 서비스            ASP(Application Service Provider : 응용 서비스 제공자)  기업이나 개인에게 일정 기간 완성된 소프트웨어/솔루션 임대 제공            TPS(Transaction Processing System : 거래 처리 시스템)  업무 처리 시 발생하는 거래 자료를 전산화            EDMS(Electronic Document Management System :  전자 문서 관리 시스템)  문서 관련 전체 생명주기에 걸쳐 일관성있게 전자적으로 통합 관리하기 위한 시스템            BCP(Business Continuity Planning : 업무 연속성 계획)  재해 백업 시스템 운영 체계            WebSphere  JAVA 기반의 완전한 애플리케이션 서비스 세트를 구비, 기업 전반의 어플 관리/통합 지원       Reengineering  경영과정과 지원시트템을 근본적으로 재설계하는 기법  ","categories": ["study"],
        "tags": ["(구)정보처리기사"],
        "url": "https://many258.github.io/study/business-process/",
        "teaser": null
      },{
        "title": "[(구)정처기/실기] 신기술동향 키워드 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.   통신           NFC(Near Field Communication : 근거리 무선 통신)  고주파를 이용한 근거리 무선 통신 기술, 가까운 거리에서 양방향 통신을 지원하는 RFID            FemtoCell(펨토셀)  10-15을 뜻하는 펨토(Femto) + 이동통신에서 1개 기지국이 담당하는 서비스 구역(Cell)            AP(Access Point : 접근점)  네트워크와 이용자의 접근점 / 유선 랜을 통하여 무선망에 연결하는 기능            USIM(Universal Subscriber Identity Module : 유심)  휴대전화 사용자의 개인 정보를 저장하는 모듈            Anycast(애니캐스트)  IPv6에서 한 송신자와 인근에 있는 일단의 소수 수신자간의 통신을 의미하는 것            IPv6(128)  IPv4의 주소공간을 4배 확장한 128비트 인터넷 주소 체계            Cyber Bullying(사이버 협박)  개인이나 집단이 인터넷에서 상대에게 나타내는 적대 행위            Wibro(Wireless broadband)  휴대 인터넷 단말을 이용하여 언제 어디서나 고속으로 무선 인터넷 접속이 가능한 서비스            WIPI(Wireless Internet Platform for Interoperability)  한국형 무선 인터넷 플랫폼 표준 규격            ZigBee  저속 전송속도를 갖는 홈오토메이션 및 데이터 네트워크를 위한 표준 기술            Alljoyn(올조인)  사물인터넷 중심의 연합단체인 올신 얼라이언스에서 표준화한 오픈 소스 기반 IoT 플랫폼            Phablet(패블릿)  Phone + Tablet. 5인치 이상의 대화면 스마트폰을 지칭하는 용어            PICONET(피코넷)  여러 개의 독립된 통신장치가 블루투스/UWB 기술을 사용하여 통신망을 형성하는 기술            LTE(Long Term Evolution)  패킷 데이터 전송에 기반을 둔 다양한 서비스 지원을 목표로 하는 기술            M2M(Machine to Machine)  무선 통신을 이용한 기계와 기계 사이의 통신            MDM(Mobile Device Management : 이동 장비 관리)  모바일 장비의 소프트웨어/펌웨어를 업데이트하는 솔루션            Mobile Computing(모바일 컴퓨팅)  휴대형 기기로 이동하면서 자유로이 네트워크에 접속하여 업무를 처리하는 환경            Bluetooth(블루투스)  IEEE 802.15.1에서 표준화된 무선 통신 기기 간에 가까운 거리에서 낮은 전력으로 통신            BLE(Bluetooth Low Energy)  블루투스 4.0 스펙이 채택된 이후로 배포되는 저전력 블루투스            IMT-2000(International Mobile Telecommunication - 2000)  미래 공중 육상 이동 통신 시스템(FPLMTS)를 우리나라에서 부르는 이름            IMT-2020  국제전기통신연합(ITU)에서 채택한 5세대 이동통신의 공식 명칭. 5G            VHF(Very High Frequency : 초단파)  IEEE 802.11n 후속으로 진행하고 있는 표준안            Multipath Fading(다중 경로 페이딩)  전파가 2개 이상의 경로를 통하여 수신 측에 도달하는 경우, 강도가 변하는 현상       보안/해킹           APT(Advanced Persistent Threats : 지능형 지속 위협)  특정 기업이나 조직 네트워크에 침투해 정보를 외부로 빼돌리는 형태의 공격들의 총칭            DES(Data Encryption Standard : 데이터 암호화 표준)  비밀 키 방식, 64비트의 키를 사용하여 64비트의 평문을 암호화/복호화            Pharming(파밍)  사용자의 도메인 탈취 및 DNS 이름을 속여 사용자들이 진짜 사이트로 오인하도록 유도            DDoS(Distributed Denial of Service attack : 분산 서비스 거부 공격)  좀비PC 를 이용해 특정 시스템으로 다량의 패킷을 무차별적으로 보내 과다 트래픽 야기            Trust Zone(트러스트 존)  스마트폰의 AP칩에 적용된 보안영역            BOTNET(봇넷)  악의적인 의도로 사용될 수 있는 다수의 PC들이 네트워크로 연결된 형태            Attack Tool Kit(공격용 툴킷)  네트워크에 연결된 컴퓨터를 공격하려고 사용하는 악성 코드 프로그램을 모아 놓은 것            DoS(Denial of Service : 서비스 거부) 정당한 사용자가 적절한 대기시간 내에 사용하는 것을 방해하는 행위            WEP(Wired Equivalent Privacy : 유선급 프라이버시)  무선 랜의 보안 프로토콜            WBAN(Wireless Body Area Network)  웨어러블/ 몸에 심는 형태의 기기를 무선으로 연결하는 개인 영역 네트워킹 기술            Malware(Malicious Software : 악성 소프트웨어)  악의적인 목적을 위해 작성된 실행 가능한 코드. 악성코드라고 함            IAM(Identity and Access Management : 식별/접근 관리)  ID와 패스워드를 종합적으로 관리해주는 역할 기반의 사용자 계정 관리 솔루션            DLP(Data Leakage Prevention : 데이터 유출 방지)  내부자의 고의나 실수로 정보가 밖으로 새어나가는 것을 방지하는 시스템            Ping of Death(죽음의 핑)  인터넷 프로토콜 허용 범위 이상의 큰 패킷을 고의로 전송하여 발생한 서비스 거부 공격            LEA(Lightweight Low-power Encryption Algorithm)  국가보안연구소에서 개발한 블록 암호 기술            Spoofing(스푸핑)  승인 받은 사용자인 것 처럼 접근 통제를 우회            Sniffing(스니핑)  네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형의 하나            Splogger(스플로거)  Spam + Blogger. 다른 사람의 콘텐츠를 무단으로 복사해 자신의 블로그에 개제            Stuxnet(스턱스넷)  시스템을 마비하게 하는 악성 코드. (독일 지멘스사의 원격 감시 제어 시스템에 침입)            SYN Flood(신플러드 공격)  TCP/IP의 취약성을 이용한 서비스 거부 공격 방식 중 하나. 3방향 핸드셰이크 연관            Switch Jamming Attack(스위치 재밍)  위조된 MAC 주소를 지속적으로 네트워크로 보내 스위치 저장 기능을 혼란 야기            Trap Door(트랩도어)  액세스 편의를 위해 시스템 설계자가 고의로 만들어 놓은 시스템의 보안 구멍            Tvshing(티비싱)  TV + fishing. 스마트 TV에 악성 소프트웨어를 설치            QKD(Quantum Key Distribution : 양자 암호키 분배)  양자현상을 이용한 암호용 키 분배를 적용한 기술            WPA(Wi-Fi Protected Access)  Wi-Fi에서 제정한 무선 랜 인증 및 암호화 관련 표준            Zero Day Attack(제로 데이)  보안 취약점이 발견되었을 때 그 문제의 존재 자체가 널리 공표되기도 전에 취약점 약용            Zombie PC  해커의 원격 조정에 의해 공격을 수행하도록 설정된 컴퓨터나 서버            Zapping Effect(재핑 효과)  채널을 전환하다가 중간에 있는 채널의 시청률이 높아지는 현상            Certificate(공인인증서)  전자 서명법에 의한 공인 인증 기관이 발행한 인증서            CA(Certification Authority : 인증 기관)  인증업무를 수행하는 제3자의 신뢰 기관            CRL(Certificate Revocation List : 인증서 폐기 목록)  폐기된 인증서를 이용자들이 확인할 수 있도록 목록을 배포, 공포하기 위한 메커니즘            PKI(Public Key Infrastructure : 공개키 기반 구조)  공개 키 암호 시스템을 안전하게 사용하고 관리하기 위한 정보보호 표준 방식            Authentication(검증)  시스템이 작동 개시 정보를 확인하는 보안 절차            BCP(Basic Call Process :  기본 호 처리)  특정 기본 서비스의 제공을 지원            Key Pair(키 페어)  공개키 암호 알고리즘에 사용되는 개인키와 공개키 쌍을 의미            SAM(Secure Application Module)  스마트 카드 보안 응용 모듈. 카드 판독기 내부에 장착하여 보안 향상       가상현실           Augmented reality(증강 현실)  실제 촬영한 화면에 가상의 정보를 덧붙여 보여주는 기술, 혼합 현실(MR)이라고도 한다            HMD(Head Mounted Display : 두부 장착형 디스플레이)  보안경이나 헬멧형으로 눈 앞에 있는 스크린을 보는 영상 장치            Telepresence(텔레프레즌스)  가상화상회의 시스템       기업/사업           BEMS(Building Energy Management System : 건물 에너지 관리 시스템)  건물에 IT 기술을 활용하여 여러 건축 설비를 관리하는 시스템            ERM(Enterprise Risk Management : 전사적 위험 관리)  경영 위험들을 전사적으로 차원에서 통합 관리하는 위험관리 방식            CC(Common Criteria : 공통 평가 기준)  정보 보호 제품 평가 기준            Devops(디봅스)  Development + Operation. 시스템 개발과 운영을 병행 및 협업            OGSA(Open Grid Service Architecture :  오픈 그리드 서비스 아키텍처)  웹 서비스 표준과 인프라 자원의 공유를 위한 그리드 기술의 결합            RPO(Recovery Point Objective : 목표 복구 시점)  재난 상황으로 IT 시스템 마비 시 백업 수단을 활용하여 복구할 수 있는 기준점            SaaS(Software as a Service : 서비스형 소프트웨어)  소프트웨어의 기능 중 사용자가 필요로 하는 서비스만 이용가능하도록 한 소프트웨어            DRM(Digital Rights Management : 디지털 저작권 관리)  저작권 소유자나 판권 소유자가 이용하는 정보 보호 기술의 일종인 접근 제어 기술            Escrow Service(에스크로 서비스)  전자 상거래 등에서 구매자와 판매자 사이에 중개 서비스 회사가 개입해 대행            Gap Filler(갭 필러)  송신소로부터 발사된 전파를 수신하여 재송신하는 소출력 재송신소            G-PIN(Government-Personal identification Number : 정부 개인 식별 번호)  정부가 추진하고 있는 주민 등록 번호 대체 수단            HSDPA(High Speed Downlink Packet Access : 고속 하향 패킷 접속)  비동기식 3세대 이동 통신의 하향 링크에서 고속 패킷 데이터 서비스를 제공 전송 규격            M-Commerce(모바일 전자상거래)  무선 데이터 장비를 이용하여 정보/서비스/상품 등을 교환            OSMU(One Source Multi Use)  1차 콘텐츠를 시장에 성공시킨 후 투자 및 라이센스를 통해 2, 3차 콘텐츠로 발전            IT Compliance(IT 규제준수)  기업이 따라야 하는 규정과 지침 및 법규를 준수하는 것을 의미            Service Delivery  고객과의 서비스 수준 계약과 이에 따른 서비스 수준 모니터링을 정의            SLA(Service Level Agreement : 서비스 수준 협약)  서비스 사업자와 사용자가 제공될 정보 서비스 및 연관된 조건들에 대한 협약서            SOA(Service-Oriented Architecture : 서비스 지향 아키텍처)  정보 시스템을 공유와 재사용이 가능한 컴포넌트 중심으로 구축하는 정보 기술 아키텍처       빅데이터           Big Data(빅 데이터)  막대한 양의 정형/비정형 데이터 집합            HADOOP(High-Availability Distributed Object-Oriented Platform : 하둡)  오픈 소스 기반 분산 컴퓨팅 플랫폼            CEP(Complex Event Processing : 복잡 이벤트 처리)  실시간으로 발생하는 많은 사건 중 의미가 있는 것만 추출            SEO(Search engine optimization : 검색엔진 최적화)  글을 효과적으로 싣고 널리 알릴 수 있도록 웹 페이지를 구성해서 상위에 오르는 작업            Metadata  일련의 데이터를 정의하고 설명해주는 데이터       미래기술           Smart grid(스마트 그리드)  정보 기술을 전력에 접목에 접목해 효율성을 제고한 시스템. 에너지 사용 효율 증대            Cloud Computing(클라우드 컴퓨팅)  가상화된 정보 기술 자원을 서비스로 제공하는 컴퓨팅            Crowd Sourcing(크라우드 소싱)  기업 활동의 전 과정에 소비자/대중이 참여할 수 있도록 일부를 개방            Digital Archiving(디지털 아카이빙)  디지털 정보 자원을 장기적으로 보존하기 위한 작업            Digital Forensics(디지털 포렌식)  디지털 정보를 수집하고 범죄의 증거를 확보하는 기술            Stereoscope(스테레오스코프)  다른 각도에 촬영한 사진들을 동시에 보여줌으로써 물체를 입체적으로 만드는 기술            Thin Client(신 클라이언트)  소유 총비용의 삭감을 목표로 하는 클라이언트 하드웨어의 구상을 의미            Biometrics(생체인식)  자동화된 장치로 사람의 신체/행동 특징을 추출하고 분석하여 개인의 신원을 확인            ETL(Extract Transform and Load : 추출/변환/올려놓기)  시스템에서 시스템으로 데이터를 이동시키는 기능의 3가지 형태            Giga Fi(기가 파이)  60GHz 대역을 이용해 데이터를 기가급으로 전송할 수 있는 기술            GT(Green Technology : 녹색 기술)  에너지와 자원을 절약하고 효율적으로 사용하여 오염 물질의 배출을 최소화            SED(Surface-conduction Electron-emitter Display : 표면전도 전자방출 디스플레이)  화소 하나 하나가 CRT의 전자총에 해당하는 나노 수준의 미세 구조            Semantic Web  이해하기 쉬운 의미를 가진 차세대 지능형 웹            Relational Technology  상호관계를 이해하는 관계성을 기반으로 하는 새로운 패러다임            T-Ray  테라헤르츠대의 전파를 이용하여 물질 내부의 모습을 보여주는 기술       프로그램 언어           XML(Extensible Markup Language : 확장성 생성 언어)  하이퍼텍스트 생성 언어(HTML) 기능을 확장한 목적            AJAX(Asynchronous Javascript And Xml)  전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법            JAX(Java API for Xml)  확장성 생성 언어 데이터 처리를 위한 자바 응용 프로그램 인터페이스            RSS(Really Simple Syndication : 초간편 배급)  업데이트된 정보를 쉽게 사용자들에게 제공. XML을 기초로 만들어진 데이터 형식            DOM(Document Object Model : 문서 객체 모델)  웹 브라우저를 통한 XML 문서의 상호 연동을 위한 객체 기반의 문서 모델       하드웨어           Flash Memory (플래시 기억 장치)  전원이 제거되어도 정보를 그대로 유지하는 비휘발성 기억 장치            Memristor(멤리스터)  메모리 + 레지스터. 기존의 상태를 모두 기억하는 소자            MEMS(Micro Electro Mechanical Systems)  마이크로시스템, 마이크로머신.       네트워크           ICN(Information Centric Networking : 정보 중심 네트워킹)  통신을 기반으로 한 패러다임을 정보 중심으로 재편성하려는 네트워킹            ICMP(Internet Control Message Protocol : 인터넷 제어 메시지 프로토콜)  IP와 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로의 변경등을 위한 무연결 전송            SAN(Storage Area Network)  서버 옆에 있는 고속 네트워크. 서버 간에 정보 교환 가능하게 구현            SCO(Synchronous Connection Oriented link : 동기식 접속 지향 링크)  지정된 대역폭 통신을 위한 전용 회선의 동기식 접속 방법            SDN(Software Define Network : 소프트웨어 정의망)  네트워크를 컴퓨터처럼 모델링하여 네트워킹 가상화            Tajo  아파치, 하둡 기반의 분산 데이터 웨어하우스 프로젝트            TEIN(Trans Eurasia Information Network : 트랜스 유라시아 네트워크)  아시아와 유럽을 연결하는 초고속 정보 통신망            Typo-squatting(타이포스쿼팅)  실수를 이용하기 위해 유사한 유명 도메인을 미리 등록            USN(Ubiquitous Sensor Network)  각종 센서에서 감지한 정보를 무선으로 수집할 수 있도록 구성한 네트워크            Trackback(트랙백)  다른 사람의 포스트를 자신의 블로그에 가져와서 다른 사람의 댓글이 보이도록 핑 보냄            Unicast(유니캐스트)  메시지의 수신 주소를 1개만 지정하는 1:1 통신 형태            CTTH(Coax To The Home)  기존 케이블 방송망으로 초고속/대용량 서비스를 제공하는 새로운 전송 방식            NAS(Network-Attached Storage)  네트워크에 연결된 파일 수준의 데이터 저장 서버            Network Neutrality(망 중립성)  모든 네트워크 사업자는 모든 콘텐츠를 동등하게 취급하고 차별하지 않는다는 원칙            OFDM(Orthogonal Frequency Division Multiplexing : 직교 주파수 분할 다중)  디지털 변조 방식            WCDMA(Wideband Code Division Multiple Access : 광대역 부호 분할 다중 접속)  ITU가 표준화를 추진하고 있는 IMT-2000을 위해 CDMA을 광대역하는 기술            Web 2.0  다양한 신규 서비스를 만들 수 있는 플랫폼으로서의 웹 환경            Quickdom(퀵돔)  짧은 형태의 도메인            SON(Self Organizing Network)  자가진단네트워크. 인공지능 기술을 통신장비에 접목한 기술            STTD(Space Time Transmit Diversity : 시공간 송신 다이버시티)  광대역 부호 분할 다중 접속 시스템에 적용하는 송신 다이버시티 방식            UPNP(Universal Plug and Play : 범용 플러그 앤 플레이)  주변 기기를 가정의 네트워크에 접속해 공유할 수 있도록 하는 기술       멀티미디어 서비스           DAISY(Digital Accessible Information System : 데이지)  시각 장애인이나 독서 장애인을 위한 국제 디지털 문서 포맷            VoIP(Voice Over Internet Protocol : 인터넷 텔레포니)  음성서비스를 IP기술을 사용하여 제공            Groupware(그룹웨어)  여러 사람이 함께 사용할 수 있는 소프트웨어, 집단의 생산성을 향상시키기 위해 사용            BYOD(Bring Your Own Device)  개인 소유 단말기를 업무에 사용하는 환경            IMS(IP Multimedia Subsystem)  넷 프로토콜(IP)를 기반으로 멀티미디어 서비스를 제공하는 규격            T-DMB(Terrestrial Digital Multimedia Broadcasting : 지상파 DMB)  지상파 디지털 멀티미디어 방송 표준. 약 1.5MHz의 대역폭을 갖는 초단파(VHF) 대역            S-DMB(Satellite Digital Multimedia Broadcasting : 위성 DMB)  위성을 방송 매체로 사용            RVC(Reconfigurable Video Coding : 재설정 비디오 코딩) 다중 비디오 부호화 표준. 하나의 디지털 미디어 기기에서 다양한 콘텐츠를 재생            i-PIN(internet Personal Identification Number : 인터넷 개인 식별 번호)  사이버 신원 확인 번호            VOD(Video On Demand : 주문형 비디오)  가입자가 원하는 시간에  프로그램을 즉시 선택해 시청할 수 있는 양방향 영상서비스            Cresumer  크리에이티브 + 컨슈머. 소비를 통해 욕구 충족을 넘어 개성을 표현하는 소비자            CCL(Creative Commons License : 저작물 이용 약관)  자유 이용을 허락하는 내용의 라이선스            FDR(Flight Data Recorder : 비행 기록 장치)  비행할 때 있었던 주요 사항을 자동으로 기록하는 장치            LBSNS(Location Based Social Network Service : 위치 기반 소셜 네트워크 서비스)  위치 기반 서비스(LBS) + 소셜 네트워크 서비스(SNS).            ACN(Automatic Crash Notification : 자동차량충돌알림)  차량충돌에 관계된 정보를 가공하여 제공하는 무선통신매체를 이용한 자동 시스템            QoS(Quality of Service : 서비스 품질)  통신 서비스에서 사용자가 이용하게 될 서비스의 품질 척도            Miracast(미라캐스트)  휴대 기기로부터 대형 TV스크린에 정보를 전송하는 Wi-Fi 기반의 표준            Multicast(멀티캐스트)  인터넷에 접속되어 있는 일부 사용자 내에서 한 사람이 몇 사람에게 정보를 송신            N-Screen(N 스크린)  N개의 이종 단말기에서 동일한 콘텐츠를 자유롭게 이용할 수 있는 서비스            Widget(위젯)  운영체제 위에 화면을 표시하는 작은 그래픽 사용자 인터페이스 도구            Active X  윈도우 사용자들이 인터넷을 편리하고 쉽게 이용하도록 마이크로소프트 사에서 개발            Alt-Text(Alternate Text)  시각 장애인이 웹 사이트에 게시된 이미지를 이해할 수 있도록 설명해주는 글            AMR(Automatic Meter Reading : 원격 검침)  고객을 방문하지 않고 원격에서 단말기를 이용해 검침 데이터를 읽을 수 있는 시스템            CODEC(Coder/Decoder)  큰 파일/프로그램이 차지하고 있는 저장 공간을 줄여주는 알고리즘            ITS(Intelligent Transport System :  지능형 교통 시스템)  종합 교통 정보의 수집/가공/전파 시스템            IT389(8대 정보통신/방송 서비스)  미래의 정보기술 시장을 선도하기 위하여 정보통신부가 수립한 IT 성장 전략 방향            JPEG(Joint Photographic Experts Group)  칼라 정지영상의 저장 및 전송을 위한 효율적인 압축 표준            MMS(Multimedia Messaging System : 멀티미디어 메시징 시스템)  다양한 형식의 데이터를 주고받을 수 있는 메시징 시스템            PostNet(Postal Numeric Encoding Technique)  IT기반 우편 물류 통합 정보 시스템. 우편물에 RFID칩 부착            QMail  유닉스 운영체제의 인터넷 메시지 전송 에이전트(MTA)            QoE(Quality of Experience : 체감 품질)  이용자가 각자의 기대치에 근거하여 주관적으로 인지하는 서비스의 총체적인 허용도            Digilog(디지로그)  디지털 기술과 아날로그적 정서가 결합된 제품/서비스            LBS(Location Based Service : 위치 기반 서비스)  위치 정보를 기반으로 여러가지 애플리케이션을 제공하는 서비스 지칭            Kill Switch  원격 제어를 통해 사용을 제한하는 소프트웨어 기술            OLAP(Online Analytical Processing)  이용자가 직접 데이터베이스 검색/분석하여 문제점이나 해결책을 찾는 분석형 앱 개념            Telematics  자동차 안의 단말기를 통해서 운전자에게 다양한 종류의 정보 서비스를 제공하는 기술            U-Health  정보통신기술을 의료서비스에 접목. 언제 어디서나 건강 관리를 받을 수 있는 서비스            VMC(Vehicle Multihop Communication : 차량 멀티홉 통신)  자동차에 정보 기술을 접목해 차량 충돌을 예방하는 기술       MPEG(Moving Picture Experts Group : 엠펙)  디지털 컬러 동화상 및 오디오 신호의 국제 표준화 작업을 추진하는 조직   MPEG-1  디지털 저장 매체용 컬러 동화상 및 오디오의 압축/부호화 방식의 국제 표준        MPEG-2  TV 방송, 통신, 오디오/비디오 기기 등 광범위한 적용 분야를 대상으로한 국제 표준       OCAP(OpenCable Application Platform)  대화형 TV 서비스나 응용 프로그램을 설계할 수 있는 미들웨어 소프트웨어 계층   사회           DAI(Digital Access Index : 디지털 접근 지수)  정보통신기술(ICT)의 접근성과 서비스 이용에 관한 전 세계적 비교 지수            Bio Informatics(BIT : 바이오 정보학)  생물학 데이터를 IT 기술로 분석하는 학문            Infolust  정보(Information) + 열망(lust). 정보를 열광적으로 모으고 퍼뜨리는 사람들            Digital Prosumer(디지털 프로슈머)  정보와 자료를 얻는 소비자이면서 의견을 적극 개진해 생산에도 영향을 미치는 사람            Patent Troll(특허 괴물)  로열티 수입만으로 이익을 창출하는 특허 관리 전문 기업            Hacktivism(핵티비즘)  해커 + 행동주의. 자신들의 정치적 목적을 달성하기 위해 해킹하는 일체의 활동이나 주의            Media Bigbang(미디어 빅뱅)  새로운 미디어가 등장하여 기존의 미디어 질서가 해체되는 현상            Meformer(미포머)  나(me) + 정보 제공자(informer). 나를 알리는 데에만 열중하는 사람            NRI(Network Readiness Index : 네트워크 준비 지수)  경제 발전과 국가 경쟁력에 미치는 영향력을 평가한 종합 지수            Pro-teur(Professional amateur : 프로튜어)  전문가 같은 아마추어. 일반 네티즌이 정보의 수요자가 아닌 공급 주체            Social Engineering(사회 공학)  인간 상호 작용의 신뢰로 사람들을 속여 보안 절차를 통과하는 비기술적 침입 수단            Smart Divide(스마트 정보격차)  스마트 미디어를 활용하는 사람과 그렇지 못한 사람들의 정보 격차            Space Club(스페이스 클럽)  인공위성을 자국에서 우주로 발사한 나라를 통틀어 일컫는 말            Subscription Commerce(정기 구독 상거래)  구독료를 지불하면 해당업체가 상품을 선택해 배달            W3C(WWW Consortium)  WWW 브라우저/서버 기술의 표준화를 추진하는 단체            Webaholism(웨바홀리즘)  Web + Alcoholism. 일상 생활에 지장을 느낄 정도로 지나치게 인터넷에 몰두            Wikipedia(위키페디아)  누구나 자유롭게 작성할 수 있고 함께 만들어 가는 웹을 기반한 백과사전            Wikinomics(위키노믹스)  대중들의 지성과 지혜를 바탕으로 한 협업이 중심적 역할을 하는 새로운 경제 패러다임            Bio Information Technology(BIT : 생명 정보 기술)  생물학과 IT가 융합된 기술            Digerati(디저라티)  Digital + Literati. 디지털 분야의 지식이 많은 사람을 지칭            Cyber Stalking(사이버 스토킹)  정보 통신망을 이용해 악의적인 의도로 지속적으로 공포감/불안감 등을 유발 야기 행위            Collective Intelligence(집단 지성)  다수의 개체가 서로 협력/경쟁하여 얻게 되는 지적 능력의 결과로 얻어진 집단적 능력            Digital Native(디지털 원주민)  디지털 기술을 어려서부터 사용하면서 성장한 세대            Vandalism  다수가 참여할 수 있도록 공개된 문서의 내용을 훼손            Ubiquitous(유비쿼터스)  시간과 공간에 구애받지 않고 언제나 네트워크에 접속할 수 있는 통신 환경            UCC(User Created Content : 사용자 제작 콘텐츠)  일반 사용자들이 직접 만들어 유통되는 콘텐츠            Killer APP(Killer Application)  오랜 시간 시장을 지배하던 경쟁자를 압도한 소프트웨어            Long tail  역 파레토 법칙. 80% 소외 받던 책들의 매출 합계 &gt; 20% 베스트셀러 매출 합계            ONE Seg(원 세그)  일본의 디지털 휴대 이동 방송 서비스 명칭            CLMS(Copyright License Management System : 저작권 라이선스 통합 관리 시스템)  디지털 저작물에 대한 체계적인 관리를 위해 추진하고 있는 시스템            Taxonomy  전통적인 분류학 기반의 분류체계      ","categories": ["study"],
        "tags": ["(구)정보처리기사"],
        "url": "https://many258.github.io/study/technology-trend/",
        "teaser": null
      },{
        "title": "[Jekyll X BLOG] 나만의 블로그 설정 준비하기(feat. Jekyll)",
        "excerpt":"목차     Jekyll로 블로그 설정 준비하기   (2) 원하는 Jekyll 테마 찾아보기   (3) Markdown 기본 문법   (4) Git을 이용해서 실제 배포해보기   (5) 내 블로그 검색되게 해주세요(Google-Search/Naver-Advisor)   개요  나만의 블로그를 제작하는 방법은 여러가지가 있습니다.  예를 들자면, 네이버 블로그나 티스토리가 있죠  하지만 뭔가 심심한 느낌이 있고 내가 스스로 이것저것 만들고 바꿔보고 싶다면   개발자가 아니더라도 따라하면 쉽게 가능하니 이제 시작하는 문서를 참고부탁드립니다.  예로부터 시작이 반이라고 했고 초기 설정만 제대로 한다면 솔직히 반 이상을 한거나 다름이 없다고 생각합니다.   본 블로그는 Windows 환경에서 제작되었습니다.   환경 설정하기   Ruby?     Jekyll은 Ruby로 만들어졌기에 기본적으로 설치를 하셔야 사용이 가능합니다    프로그램 언어 중 하나이자 스크립트 언어의 일종, Python과는 라이벌 관계. 초보자들이 다루기 쉬운 언어라고 합니다. 응용해서 Ruby on rails라는 웹 프레임워크를 사용할 수 있지만  단순히 Jekyll을 사용할 것이므로 간단히 설치해주고 넘어갈게요   참고로 Ruby 언어가 매력적으로 느껴지신다면,  코드카데미 강좌[영문]  초보자를 위한 레일스 가이드북  해당 사이트에서 더 깊은 공부를 하실 수 있습니다.   루비 공식 홈페이지에서 다운로드페이지로 넘어갑니다      원하는 버전에 유의하시어 각자 환경에 맞는 인스톨러를 설치합니다.  처음 설치하시는 분들은 추천버전(Devkit 포함) 다운받는 것을 권장합니다.            MYS32 development toolchain : 루비로 개발 시 필요하므로 체크하고 넘어갑니다      설치가 완료되면 CMD창이 나오는데 여기서 필요하에 (저의 경우) 1, 2, 3 순서대로 완료하시고   끝으로 CMD창을 열어     ruby -v   을 입력하시면      다음과 같이 버전 정보가 나오면 성공!   Gem     젬은 루비 프로젝트에 포함시킬 수 있는 코드입니다. 기능들을 패키지화해서 다른 사람들이나 프로젝트에 공유할 수 있게 해줍니다.    간단하게 필요한 기능이 있을 때, 이 때 Gem을 통해 루비 어플리케이션이나 라이브러리를 설치 및 패키징 관리하는 역할을 합니다.   gem install '패키지명' (설치)   gem update '패키지명' (갱신)   gem uninstall '패키지명' (삭제)     Bundler?      Bundler 는 Gemfile 에 있는 젬들을 설치합니다.    앞서 Gem들을 하나하나 설치하기 힘드므로 이를 한번에 묶음으로 처리해주기 위해 Bundler라는 프로그램을 사용합니다.   먼저 Bundler를 설치하기 위해서   gem install bundler  Gem의 사용방식과 유사합니다.   bundle install bundle update  GemFile?   Gemfile 은 사이트에 필요한 젬들의 목록입니다. 단순한 Jekyll 사이트를 예로 들면 이렇게 생겼습니다:   source \"https://rubygems.org\"  gem \"jekyll\"  group :jekyll_plugins do   gem \"jekyll-feed\"   gem \"jekyll-seo-tag\" end  이 문서에 필요프로그램을 작성하면 위 bundler가 한꺼번에 처리해주는 역할을 합니다.   일단 이 문서에서는 GemFile을 사용하지 않고 단순하게 Jekyll을 통해 로컬 서버에 적용하는 예제를 다루겠습니다.   Jekyll?     Jekyll 은 정적 사이트 생성기입니다.  당신이 즐겨 사용하는 마크업 언어로 작성된 텍스트를 Jekyll 에 넘겨주면 레이아웃을 사용해 정적 웹사이트를 생성합니다.  사이트 URL 의 형식이나 어떤 데이터를 사이트에 표시할 것인지 등, 여러 동작을 조정할 수 있습니다.    Jekyll 은 평범한 루비 젬이며, 거의 모든 시스템에 설치할 수 있습니다.   Jekyll을 설치하기 위해서 위와 같은 코드로  gem을 설치하고   gem install jekyll     하지만 설치도중 다음과 같은 에러가 발생했습니다.    추가로 Gem을 업데이트 시켜줍니다.  (저는 이전 버전을 쓰기때문에 발생하지 않았을까 생각이 드네요)   gem update --system     로컬서버에 적용하기  새 jekyll 사이트를 생성   jekyll new blog        생성된 디렉토리로 이동 후   새 파일을 생성해 index.html이라 저장합니다.  &lt;!doctype html&gt; &lt;html&gt;   &lt;head&gt;     &lt;meta charset=\"utf-8\"&gt;     &lt;title&gt;NEW BLOG&lt;/title&gt;   &lt;/head&gt;   &lt;body&gt;     &lt;h1&gt;Hello! World!&lt;/h1&gt;   &lt;/body&gt; &lt;/html&gt;   다시 Cmd로 돌아와서   cd blog   사이트를 빌드하고 로컬 서버에 적용  bundle exec jekyll serve     http://localhost:4000 접속 확인      위와 같은 화면이 표시된다면 성공! 로컬 서버를 종료시 Ctrl + C를 입력해주세요.   다음 시간엔 Jekyll에서 사용할 수 있는 테마와 구조에 대해 알아보도록 하겠습니다.   참고사이트  http://jekyllrb-ko.github.io/docs/installation/   수정이 필요하거나, 개선사항이 있을시 답글을 남겨주시면 빠른 시일안에 해당 항목을 수정하겠습니다.  ","categories": ["blog"],
        "tags": ["Jekyll"],
        "url": "https://many258.github.io/blog/start-wtih-jekyll/",
        "teaser": null
      },{
        "title": "[Jekyll X BLOG] 원하는 Jekyll 테마 찾아보기  ",
        "excerpt":"목차     Jekyll로 블로그 설정 준비하기   원하는 Jekyll 테마 찾아보기   (3) Markdown 기본 문법   (4) Git을 이용해서 실제 배포해보기   (5) 내 블로그 검색되게 해주세요(Google-Search/Naver-Advisor)   개요   저번 문서에서는 기본적으로 환경을 어떻게 설정하는가 기본 작업을 살펴보았습니다  하지만, 빈 화면에 덩그러니 Hello World만 있으니 뭔가 휑하게 느껴집니다.  세련되고 멋지게 해보고 싶은데 방법이 없을까…?  생각을 해보셨다면 이 문서를 천천히 읽어주시길 바라겠습니다.   사실 이번에 할 일은  위대한 선조님들이 이 고민을 할 우리들을 위해 틀을 이미 만들어 놓았기 때문에 이번에 해야할 일은 많지 않습니다.   그럼 시작해도록 하겠습니다.   테마 선택하기   다음 웹사이트에서 원하는 테마를 미리 데모로 실행해보고 다운받을 수 있습니다.   지킬 테마 홈페이지      여기서 각자 선호하는 테마를 선택하여 블로그에 적용시킬 수 있습니다.  저의 경우는 minimal-mistakes 라는 보통 많이 사용하는 테마를 사용하였습니다.   1. GitHub 계정이 있다면?      해당 홈페이지에서 Fork를 해서 내려받고  리포지토리의 이름을 username.github.io 변경하거나   2. GitHub 계정이 없다면?   minimal-mistakes 홈페이지에 접속하여 압축파일을 설치할 수 있습니다.    또는    차후 배포할 때 계정이 필요하니 지금 이순간에 회원가입을 하시길 권유드립니다.      그럼 이 블로그에 현재 적용된 테마에 대해 조금 더 면밀히 알아보도록 하겠습니다.   디렉토리 기본 설정하기   현재 버전에서 최초 파일 구조는 다음과 같습니다.      .editorconfig .gitattributes .github /docs /test CHANGELOG.md README.md screenshot-layouts.png screenshot.png  여기서 위 파일은 불필요한 파일이기에 삭제를 진행합니다.   이어서 _posts, _draft(선택) 폴더가 없다면 새로 추가해줍니다.   디렉터리 구조   이제 하나씩 구성요소를 분석해보겠습니다.   _data     사이트에 사용할 데이터를 적절한 포맷으로 정리하여 보관하는 디렉토리.  Jekyll 엔진은 이 디렉토리에 있는 (확장자와 포맷이 .yml 또는 .yaml, .json, .csv, .tsv 인) 모든 데이터 파일을 자동으로 읽어들여 site.data 로 사용할 수 있도록 만든다.  만약 이 디렉토리에 members.yml 라는 파일이 있다면, site.data.members 라고 입력하여 그 컨텐츠를 사용할 수 있다.    문장이 어려울 수 있으나, 단순히 말하자면 데이터 파일들이 모여있는 폴더라는 의미입니다. 여기서 데이터 파일은 테마를 커스텀하기 위해 사용됩니다.   예제: 구성원 목록 이 링크에서 예제를 확인할 수 있습니다   이 테마에서는 기본적으로 다음과 같은 데이터파일 2개가 존재합니다              navigation.yml  상단에 표시되는 메뉴들,  메뉴클릭시 지정된 URL페이지로 이동하여 문서를 보여줍니다            ui-text.yml  일종의 언어팩. 기본은 영어로 되어있으나 config 설정을 통해 한국어로 변경할 수 있으며, 해당 옵션을 다른 글로 변경하여 내 설정에 맞게 블로그에 반영할 수 있습니다       _includes     재사용하기 위한 파일을 담는 디렉토리로서, 필요에 따라 포스트나 레이아웃에 쉽게 삽입할 수 있다.  {% include file.ext %} 와 같이 Liquid 태그를 사용하면 _includes/file.ext 파일에 담긴 코드가 삽입된다.       재사용이 가능한 자잘자잘한 구성 요소들. 이 구성요소들로 커다란 틀(레이아웃)을 꾸미거나 기능을 추가할 때 이용합니다.      Analytics-provides  어떤 애널리틱스를 사용하는지에 따라 설정이 가능하며 config.yml analytics 부분에 정보를 입력해주면 됩니다               comments-providers  내 글에 댓글기능을 삽입할 수 있는데 여러 플랫폼이 있어 사용자가 원하는 플랫폼을 선택하여 추가할 수 있게끔 해준다(필자는 disqus로 설정!)            footer/head  각 폴더 내 커스텀 html 파일에서 사용자 취향에 맞게 설정할 수 있다            search  검색 엔진을 어떤 것으로 설정할 지 선택할 수 있는 폴더  comment-provider, analytics-provides와 마찬가지로 config.yml파일에서 해당 항목을 설정하여 적용시킬 수 잇다              Feature_row  여러 이미지를 한 줄로 나타낼 때 사용합니다.  갤러리와 유사하나 사진마다 제목과 부가설명이 있다는 차이점을 가지고 있습니다       feature_row:   - image_path: /assets/images/unsplash-gallery-image-1-th.jpg     alt: \"placeholder image 1\"     title: \"Placeholder 1\"     excerpt: \"This is some sample content that goes here with **Markdown** formatting.\"   - image_path: /assets/images/unsplash-gallery-image-2-th.jpg     alt: \"placeholder image 2\"     title: \"Placeholder 2\"     excerpt: \"This is some sample content that goes here with **Markdown** formatting.\"     url: \"#test-link\"     btn_label: \"Read More\"     btn_class: \"btn--inverse\"   - image_path: /assets/images/unsplash-gallery-image-3-th.jpg     title: \"Placeholder 3\"     excerpt: \"This is some sample content that goes here with **Markdown** formatting.\"   {% include feature_row %}      Figure  캡션을 가진 하나의 이미지를 생성할 때 사용한다   {% include figure image_path=\"/assets/images/unsplash-image-10.jpg\" alt=\"this is a placeholder image\" caption=\"This is a figure caption.\" %}      Gallery  캡션을 가질 수 있는 2개 이상의 이미지를 생성할 때 사용하며 갤러리를 배치하려면 추가적으로 yaml 파일 생성이 필요하다   gallery:   - url: /assets/images/unsplash-gallery-image-1.jpg     image_path: /assets/images/unsplash-gallery-image-1-th.jpg     alt: \"placeholder image 1\"     title: \"Image 1 title caption\"   - url: /assets/images/unsplash-gallery-image-2.jpg     image_path: /assets/images/unsplash-gallery-image-2-th.jpg     alt: \"placeholder image 2\"     title: \"Image 2 title caption\"   - url: /assets/images/unsplash-gallery-image-3.jpg     image_path: /assets/images/unsplash-gallery-image-3-th.jpg     alt: \"placeholder image 3\"     title: \"Image 3 title caption\"   {% include gallery caption=\"This is a sample gallery with **Markdown support**.\" %}      Video  유튜브, 비메오, 구글드라이브 영상을 내용 안에 담을 수 있습니다.  특정시점으로 부터 영상 재생도 가능한데  ex) https://www.youtube.com/watch?v=[id] 1:50초부터 영상을 시작하고 싶다면 ?start=110 를 추가하면 된다.   # 유튜브 {% include video id=\"id\" start=110 provider=\"youtube\" %}  # 비메오 {% include video id=\"id\" provider=\"vimeo\" %}  # 구글드라이브 예) https://drive.google.com/file/d/[id]/preview {% include video id=\"id\" provider=\"google-drive\" %}      TOC(Table of contents)  글 옆에 보이는 목차를 나타내주는 역할을 합니다. Toc : true를 통해 표시할 수 있습니다 다음과 같은 선택으로 커스터마이징이 가능합니다            Toc_label : TOC의 이름       Toc_icon : TOC 아이콘       Toc_sticky : TOC Liquid 문법으로 다음과 같이도 사용가능합니다.           {% include toc %}           nav-list  메뉴 상단 리스트  _data/navigation.yml에서 설정할 수 있으며 children : 태그를 통해 하위 메뉴를 생성하는 것도 가능하다            analytics  _config.yml에서 작성한 애널리틱스를 바탕으로 analytics-provides와 이어주는 역할을 한다            archieve-single  포스트 페이지들 링크를 모아둔 아카이브 페이지에서 각 포스트 링크가 어떻게 보여질지에 대한 문서            author-profile / author-profile-custom-links  _config.yml 사이트 저자에 대한 설명을 나타낼 때 사용하는 문서            breadcrumbs  페이지의 상대경로를 계층식 구조로 표시하는 역할을 해주는 문서  config.yml에서 설정이 가능하며 기본값으로 false이다       # breadcrumbs            : false # true, false (default)          browser-upgrade  IE9 브라우저로 접속할 경우 업그레이드를 요청한다            category-list / tag-list  각 카테고리/태그와 관련된 리스트를 만드는 문서  이 글의 하단에서 카테고리는 Blog, 태그 Jekyll을 확인할 수 있다            comment / comments  댓글에 관련된 정보를 다루는 문서            document-collection  collection은 아카이브페이지와 유사하지만, 태그/카테고리 별로 자동으로 분류되는 아카이브페이지와는 달리  서로 관련성이 있는 포스트를 사용자 정의로 그룹화한 페이지를 말한다            footer / head  페이지 하단/상단의 내용을 가지고 있는 문서            masthead  홈페이지 전체의 구조 중 네비게이션과 검색부분이 있는 상단 바로 아래 지평선            page_date / page_hero / page_hero_video / page_meta  페이지의 상단의 역할을 맡고있다  날짜, 상단의 이미지 또는 비디오, 상단의 보이는 ~분 소요시간을 나타낸다            page__taxonomy  페이지의 태그와 카테고리를 나타내는 역할을 한다            paginator / post_pagination  페이지 하단에 보면 이전글, 다음글에 관련된 문서            posts-category / posts-tag  각 카테고리, 태그를 모아놓은 아카이브 페이지            scripts  JavaScript, 검색 엔진, 댓글 플랫폼 관련 등 소스를 불러오는 곳            seo  검색 엔진 최적화(Search Engine Optimization : 내 웹사이트를 구글이나 네이버와 같은 검색엔진의 검색결과 상단에 노출시킬 수 있도록 최적화하는 방법)를 다루는 문서            sidebar  이 홈페이지 왼쪽 부분에 표시되는 사이드바 관련 문서            skip-links  홈페이지 내 간단하게 구현된 바로가기(숏컷)에 대한 문서            social-share  소셜서비스와 연관된 문서, 트위터/페이스북/링크드인 하이퍼링크로 구성되어 있다            toc  TOC의 기능을 모아놓은 문서       _layouts     포스트를 포장할 때 사용하는 템플릿이다.  각 포스트 별로 레이아웃을 선택하는 기준은 머리말이며, {{ content }}와 같이 Liquid 태그를 사용하면 페이지에 컨텐츠가 주입된다.    문서를 포스팅할 때 가장 큰 틀이며 기본적으로 default를 사용합니다.  만약 매 문서마다 같은 양식을 사용하고 싶다면 이 부분에서 수정하므로서 가능해집니다. 파일 내 코드를 살펴보면 {{ content }} 이 부분에 작성한 글의 내용이 삽입이 되는 구조입니다.   예시로 나만의 블로그 설정 준비하기문서는 single이라는 레이아웃으로 설정하였습니다.   --- layout: single title: \"[Jekyll X BLOG] 나만의 블로그 설정 준비하기(feat. Jekyll)\" categories:   - blog tags:   - Jekyll sidebar:   nav: \"docs\" ... ---   _posts     한마디로 말하면, 당신의 컨텐츠다.  중요한 것은 파일들의 명명규칙인데, 반드시 이 형식을 따라야 한다: YEAR-MONTH-DAY-title.MARKUP.  고유주소는 포스트 별로 각각 정의할 수 있지만, 날짜와 마크업 언어 종류는 오로지 파일명에 의해 결정된다.    실질적으로 우리가 앞으로 작성할 글(포스팅한 문서)들이 모여있는 폴더입니다.   _sass     이것은 당신의 main.scss 에 임포트할 수 있는 Sass 조각들로서,  하나의 스타일시트 파일 main.css 로 가공되어 당신의 사이트에서 사용하는 스타일들을 정의한다.  Jekyll 은 Sass 를 기본적으로 지원하고 루비 젬을 통해 CoffeeScript 와 연동할 수 있습니다. 사용 방법은, 일단 적절한 확장자 (.sass 나 .scss, .coffee 중 하나) 로 파일을 생성하고 파일의 시작부분에 3 개의 대시문자 두 줄을 입력해야 합니다(YAML 헤더)    혹시나  css에 대해 들어본 적 있으신가요?  덕분에 이쁘고 스타일리쉬하게 웹페이지를 만들 수 있었지만, 점점 늘어날수록 코드가 복잡해진다는 단점을 가지고 있었습니다.   이 단점을 보완하기 위해 탄생한 아이가 Sass입니다.  sass는 css 전처리(Preprocessor)이며 Css가 동작하기 전에 작동하는 방식으로 기존 css의 확장의 개념이다라고 생각하시면 편할 것 같습니다.  scss 파일을 모아놓은 폴더 위 설명과 같이 모든 scss 파일이 뭉쳐 main.css로 가공됩니다.   _site     Jekyll 이 변환 작업을 마친 뒤 생성된 사이트가 저장되는 (디폴트) 경로이다.  대부분의 경우, 이 경로를 .gitignore 에 추가하는 것은 괜찮은 생각이다.    Jekyll로 사이트를 빌드하면 해당 최종 결과물이 디렉토리에 생성됩니다. 차후 이 폴더에 있는 내용들로 배포를 할 예정입니다.   Assets  main.scss, images(없으면 새 폴더 추가해줍니다.) , javascript로 구성된 폴더 특히, 사진이나 이미지들은 images에서 주로 관리하게됩니다.   _config.yml 설정하기  이번 문서에서 가장 중요한 작업입니다  기존값 또는 기본값을 자신의 설정대로 변경하는 작업을 주로 다루겠습니다.   기본 사이트 설정   locale                   : \"ko\" # 한국어로 설정 title                    : \"\" # 사이트 제목 name                     : \"\" # 이름 description              : \"\" # 사이트 설명 url                      : \"\" # \"https://[github ID].github.io\" 결과적으로 github 리포지토리의 이름과 동일해야합니다.   사용하는 답글 플랫폼이 있다면 해당 플랫폼 설정   comments:   provider               : # false (default), \"disqus\", \"discourse\", \"facebook\", \"staticman\", \"staticman_v2\", \"utterances\", \"custom\"   disqus:     shortname            : # https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname-   discourse:     server               : # https://meta.discourse.org/t/embedding-discourse-comments-via-javascript/31963 , e.g.: meta.discourse.org   facebook:     # https://developers.facebook.com/docs/plugins/comments     appid                :     num_posts            : # 5 (default)     colorscheme          : # \"light\" (default), \"dark\"   utterances:     theme                : # \"github-light\" (default), \"github-dark\"     issue_term           : # \"pathname\" (default)   staticman:     branch               : # \"master\"     endpoint             : # \"https://{your Staticman v3 API}/v3/entry/github/\"   사이트 저자 관련 정보   author:   name             : \"\"    avatar           : # 보여질 이미지 경로 ex) \"/assets/images/bio-photo.jpg\"    bio              : \"\" # 부가 텍스트   location         : \"\" # 주소   email            :   links:     - label: \"Email\"       icon: \"fas fa-fw fa-envelope-square\"   블로그 하단에 표시할 사이트 저자 정보   footer:   links:     - label: \"Twitter\"       icon: \"fab fa-fw fa-twitter-square\"       # url:     - label: \"Facebook\"       icon: \"fab fa-fw fa-facebook-square\"       # url:     - label: \"GitHub\"       icon: \"fab fa-fw fa-github\"       # url:     - label: \"GitLab\"       icon: \"fab fa-fw fa-gitlab\"       # url:     - label: \"Bitbucket\"       icon: \"fab fa-fw fa-bitbucket\"       # url:     - label: \"Instagram\"       icon: \"fab fa-fw fa-instagram\"       # url:   가장 기초적인 설정은 위 내용만 수정해도 충분할 것이라 생각됩니다.   최종테스트  이전 문서에서 사용했던 것처럼 사이트를 빌드하고 로컬 서버에 적용해 접속하였을 때 정상적으로 블로그가 나타난다면 성공!   마무리  초라했던 블로그가 이제 제법 세련되어졌습니다.   이제 본격적으로 글을 작성해볼텐데 주로 Markdown(.md)을 사용합니다.   다음엔 이 마크다운 문법에 대해서 알아보도록 하겠습니다.   이상입니다. 고생많으셨습니다.   감사합니다 :)   참고사이트  https://ansohxxn.github.io/blog/jekyll-directory-structure/   수정이 필요하거나, 개선사항이 있을시 답글을 남겨주시면 빠른 시일안에 해당 항목을 수정하겠습니다.  ","categories": ["blog"],
        "tags": ["Jekyll"],
        "url": "https://many258.github.io/blog/jekyll-themes/",
        "teaser": null
      },{
        "title": "[NETFLIX] (내가 만든) 호러 X 스릴러를 위한 설연휴 넷플릭스 추천 가이드라인",
        "excerpt":"Intro  2020년 추석에 이어 이번 2021년 설에도 코로나의 영향이 고스란히 이어지고 있습니다.   이에 대해 정부에서는 간곡하게 설연휴 이동을 자제하도록 요구하고 있는데요.     가급적 모두 이 운동에 동참할 필요성이 있다고 생각합니다.   특히나 이번에 넷플릭스에서 설연휴 정주행 가이드라는 컨텐츠로 많은 영화/드라마를 추천하고 있는데요.   하지만, 호러스릴러 매니아에게는 안타깝지만 따로 카테고리를 만들어놓지 않았습니다..    그래서 나름대로 호러/스릴러 영화 10개를 추려내 보았습니다.        이 추천하는 영화들은 지극히 주관적인 평가이므로 만약 인상 깊게 감상한 영화가 있으시다면 답글로 부탁드리겠습니다 :)   ※ 이 글은 2021년 2월 10일자에 작성되었음을 알려드립니다!   10. 캐빈 인 더 우즈(The Cabin in the Woods)         감독 : 드류 고다드   개봉일 : 2012.06.28   넷플릭스 재개봉 : 2020.06.17   상영시간 : 95분 (X1.25 : 약 76분, X1.5 : 약 64분)   관람등급 : 18세이용가      기분전환을 위해 인적이 드문 숲으로 여행을 떠난 다섯 명의 친구들.  설레는 마음도 잠시, 곧 지옥의 시스템이 가동된다.          규칙을 어기는 순간 찾아오는 자비 없는 처벌, 단 한 명도 빠져나갈 수 없다.  게임이 끝날 때 까지.    주관적인 평가  스토리 : 3.8 / 5.0  잔인함 : 4.0 / 5.0  공포성 : 3.7 / 5.0   한마디:  저는 이 영화를 넷플릭스가 아닌 영화관에서 관람했었습니다.  처음엔 단순한 클리셰 느낌의 영화인 줄 알았으나, 중간쯤돼서 점점 장르가 변하는 것에 대해 굉장히 신선한 느낌을 받았습니다.   게다가 기존에 공포영화를 즐기셨던 분들은 짐작할 만한 많은 패러디 요소가 있으니 하나씩 찾아보는 재미도 느끼실 수 있으실 겁니다. 근데, 엔딩이 아쉬운 게 약간의 흠    9. 맨 인 더 다크(Don’t Breathe)         감독 : 페데 알바레스   개봉일 : 2016.10.05   넷플릭스 재개봉 : 2020.08.04   상영시간 : 88분 (X1.25 : 약 71분, X1.5 : 약 60분)   관람등급 : 18세이용가      10대 빈집털이범 록키, 알렉스, 머니는 밑바닥 삶을 청산하기 위해 눈 먼 노인을 겨냥한 마지막 한 탕을 준비한다.  노인이 잠 든 사이 거액의 현금을 쟁취하려던 순간 마침내 그가 깨어나게 되고, 이들의 치밀한 계획은 아무것도 보이지 않는 암전 속에서 모두 역전되기 시작하는데…    주관적인 평가  스토리: 4.0 / 5.0  잔인함: 2.8 / 5.0  공포성: 4.1 / 5.0   한마디:  팝콘을 사들고 들어갔는데 영화 컨셉 상 먹을 수가 없더라구요. 일하시는 분에게 죄송하지만 바닥에 거의 흩뿌리고 돌아왔습니다.   꼭 조용한 환경에서 시청부탁드리겠습니다. 분위기 장난이 아닌 영화 중 하나    8. 더 보이(The boy, 2016)         감독 : 윌리엄 브렌트 벨   개봉일 : 2016.06.01   넷플릭스 재개봉 : 2020.03.19   상영시간 : 97분 (X1.25 : 약 78분, X1.5 : 약 65분)   관람등급 : 15세이용가      그레타(로렌 코핸)는 어두운 과거에서 벗어나 새 출발을 하기 위해 외딴 마을의 대저택에 유모로 들어간다.       그러나 노부부가 아들 브람스라며 소개한 건 소년 인형.          장난이라는 의심과 달리 부부는 너무나 진지한 태도로 인형을 대하고, 심지어 10가지 규칙을 꼭 지켜야 한다고 당부한 후 여행을 떠난다.  대저택에 인형 브람스와 단둘이 남게 된 그레타는 자꾸만 일어나는 기이한 사건들을 겪으며 점점 인형이 살아있다고 믿게 되는데…    주관적인 평가  스토리: 3.5 / 5.0  잔인함: 2.5 / 5.0  공포성: 3.9 / 5.0   한마디:  인형이 스토리의 주가 되는 애나벨과 먼 친척뻘입니다.  컨져링이 한 때 뜨면서 같은 유니버스인 애나벨도 영향을 받아 높게 평가됐는데, 이 영화는 이 때문인지 주목을 많이 못받았던 것 같습니다. 반전도 나름 신선했기에 전 개인적으로 애나벨보다 이 영화를 추천드립니다.    7. 라이트 아웃(Light out)         감독 : 다비드 F. 산드베리   개봉일 : 2016.08.24   넷플릭스 재개봉 : 2020.06.10   상영시간: 81분 (X1.25 : 약 65분, X1.5 : 약 55분)   관람등급 : 15세이용가      불이 꺼지면 나타나는 누군가를 목격한 남매 레베카와 마틴.       알고보니 어둠 속 그 여자는 빛이 닿으면 피부가 타들어가는 기이한 병을 앓고 있던 엄마의 어릴적 친구 ‘다이애나’였고, 현재도 엄마 곁에서 함께 살고 있다는 걸 알게 되는데…    주관적인 평가  스토리: 3.0 / 5.0  잔인함: 2.0 / 5.0  공포성: 3.4 / 5.0   한마디:  짧은 독립영화가 유명해지자 만들어진 극장 영화.  저예산 영화임에도 불구하고 보이지 않는 공포요소를 잘 이용했습니다. 이 영화가 끝나면 그 날은 불을 끄고 자기 싫어질 거에요.    6. 유전(Hereditary)         감독 : 아리 애스터   개봉일 : 2018.06.07   넷플릭스 재개봉 : 2020.04.22   상영시간: 127분 (X1.25 : 약 106분, X1.5 : 약 85분)   관람등급 : 15세이용가      ‘애니’는 일주일 전 돌아가신 엄마의 유령이 집에 나타나는 것을 느낀다.  애니가 엄마와 닮았다며 접근한 수상한 이웃 ‘조안’을 통해 엄마의 비밀을 발견하고, 자신이 엄마와 똑같은 일을 저질렀음을 알게 된다.       그리고 마침내 애니의 엄마로부터 시작돼 아들 ‘피터’와 딸 ’찰리’에게까지 이어진 저주의 실체가 정체를 드러내는데…    주관적인 평가  스토리: 3.4 / 5.0  잔인함: 3.1 / 5.0  공포성: 3.6 / 5.0   한마디:  공포영화치고는 상영시간이 긴 만큼 점프스퀘어보다는 심리적으로 불안감과 불쾌함을 조성하여 천천히 관객을 몰입하게하며 옥죄어 옵니다. “뚂”    5. 블레어위치(Blair Witch, 2016)         감독 : 다니엘 미릭   개봉일 : 2016.11.23   넷플릭스 재개봉 :   상영시간: 89분 (X1.25 : 약 66분, X1.5 : 약 55분)   관람등급 : 15세이용가      1994년, 200년 동안 내려온 블레어 위치의 전설을 찾아 3명의 영화과 학생들이 버키츠빌 숲에 들어간 후 실종된다. 그리고 1년 후 그들이 찍은 필름이 발견된다. 1999년 오랜 법정 싸움 끝에 필름은 유가족에게 돌아가고 영화화가 결정된다. 영화는 전세계를 충격에 빠트린다.       그리고… 2016년       유가족 중 헤더의 동생은 SNS에 올려진 1999년의 영상 속에서 누나가 생존해 있을지 모른다는 단서를 발견한다. 그는 팀을 꾸려 버키츠빌로 떠나는데…    주관적인 평가  스토리: 3.4 / 5.0  잔인함: 3.1 / 5.0  공포성: 3.6 / 5.0   한마디:  셰이키캠, 핸드헬드 촬영기법으로 제작되었기에 멀미가 심하신 분들께는 추천드리지 않습니다.   이 영화를 즐기셨다면 전작인 블레어윗치(1999)도 같이 관람하시길 추천드립니다. 제 기준으로는 원작이 좀 더 스릴있었습니다.      4. 알포인트(R-POINT)         감독 : 공수창   개봉일 : 2004.08.20   넷플릭스 재개봉 : 2020.12.01   상영시간 : 105분 (X1.25 : 약 84분, X1.5 : 약 70분)   관람등급 : 15세이용가      1972년, 베트남 전쟁의 막바지.  200명의 부대원 중, 혼자 살아 남은 혼바우 전투의 생존자 최태인 중위(감우성)는 악몽에 시달리며 괴로워한다. 그러나 그의 본대 복귀 요청은 철회되고, CID 부대장은 그에게 비밀 수색 명령을 내린다.       1월 30일 밤 10시.  이날도 사단본부 통신부대의 무전기엔 “당나귀 삼공…”을 외치는 비명이 들어오고 있다. 6개월전 작전 지역명 ‘로미오 포인트’에서 사망한 것으로 추정되는 18명의 수색대원들로부터 구조요청이 오고 있었던 것. 그 흔적 없는 병사들의 생사를 확인할 수 있는 증거물을 확보하는 것이 이번 작전의 목표다.       3일 후.  좌표 63도 32분, 53도 27분 _ 로미오 포인트 입구. 어둠이 밀려오는 밀림으로 들어가는 9명의 병사들 뒤로 나뭇잎에 가려졌던 낡은 비문이 드러난다.          不歸! 손에 피 묻힌 자, 돌아갈 수 없다!!  7일간의 작전, 첫 야영지엔 10명!! 의 병사가 보이고…. 그러나 이제 하루가 시작되고 있을 뿐이다.    주관적인 평가  스토리: 4.2 / 5.0  잔인함: 2.7 / 5.0  공포성: 3.8 / 5.0   한마디:  군대를 다녀오기 전/후 관람하였는데, 다녀오고 난 후 보는게 더욱 무서웠습니다.  보통 한국 공포영화는 인정하지 않지만 이건 수작 중 하나라고 생각합니다. “하늘소…”    3. 부산행(Train To Busan)         감독 : 연상호   개봉일 : 2016.07.20   넷플릭스 재개봉 : 2020.07.01   상영시간 : 120분(X1.25 : 약 96분, X1.5 : 약 80분)   관람등급 : 15세이용가      정체불명의 바이러스가 전국으로 확산되고 대한민국 긴급재난경보령이 선포된 가운데, 열차에 몸을 실은 사람들은 단 하나의 안전한 도시 부산까지 살아가기 위한 치열한 사투를 벌이게 된다.       서울에서 부산까지의 거리 442KM  지키고 싶은, 지켜야만 하는 사람들의 극한의 사투!    주관적인 평가  스토리: 3.1 / 5.0  잔인함: 4.3 / 5.0  공포성: 3.7 / 5.0   한마디:  우리나라도 이제 좀비물 잘 만들 수 있다는 것을 보여준 작품.  한정된 공간이지만 계속 나아가야하는 긴박함을 잘 풀어낸 영화라 생각힙니다. 하지만, 한국 특유의 신파극만 좀 빼줬으면 좋겠네요.    2. 오큘러스(Oculus)         감독 : 마이크 플래너건   개봉일 : 2014.05.29   넷플릭스 재개봉 :   상영시간 : 105분(X1.25 : 약 85분, X1.5 : 약 70분)   관람등급 : 15세이용가      어린 시절, 충격적인 사고로 부모님을 잃은 남매. 이 일로 동생이 소년원에 수감된다.       그로부터 10년 후,  동생이 출감하기를 기다린 누나는 어린 시절의 일이 부모님들이 새 집에 이사오면서 들여놓았던 거울의 짓이라 믿고 조사에 들어간다.  그 거울의 역대 주인들을 추적한 결과, 모두 비참한 죽음을 맞이했다는 사실을 알게 되고 그들이 모두 거울의 조종을 받은 희생자들이란 가설을 세우게 되는데…    주관적인 평가  스토리: 4.3 / 5.0  잔인함: 2.3 / 5.0  공포성: 3.8 / 5.0   한마디 :  현재와 과거가 교차되며 뭐가 진짜고 뭐가 환상인지 계속 생각들게 하는 영화.  기존 귀신/악마로부터 도망다니는 일반적인 클리셰와 달리 맞서싸우고 극복하려는 모습에서 미스터리 장르에 조금 가깝다고 할 수 있겠습니다.    1. 향수 - 어느 살인자의 이야기(Perfume: The Story of a Murderer)         감독 : 톰 튀크베어   개봉일 : 2007.03.22   넷플릭스 재개봉 :   상영시간 : 146분(X1.25 : 약 117분, X1.5 : 약 98분)   관람등급 : 15세이용가      18세기 프랑스 생선시장에서 태어나자마자 사생아로 버려진 ‘장바티스트 그르누이’.       불행한 삶 속에서 그의 유일한 즐거움은 천재적인 후각으로 세상을 바라보는 것. 그러던 어느 날 그는 파리에서 운명적인 ‘여인’의 매혹적인 향기에 끌리게 된다. 그 향기를 소유하고 싶은 욕망에 사로잡힌 그는 향수제조사 ‘주세페 발디니’의 후계자로 들어간다.       뛰어난 후각으로 파리를 열광시킬 최고의 향수를 탄생시키지만, ‘여인’의 매혹적인 향기를 온전히 소유할 수 없었던 그는 해결책을 찾아 ‘향수의 낙원, 그라스’로 향하게 된다. 마침내 그곳에서 그는 그토록 원했던 자신만의 향수를 만드는 방법을 알아낸다. 한편 ‘그라스’에서는 아름다운 여인들이 나체의 시신으로 발견되는 의문의 사건이 계속되는데…    주관적인 평가  스토리: 4.5 / 5.0  잔인함: 2.9 / 5.0  공포성: 2.9 / 5.0   한마디 :  ‘사람의 욕망은 어디까지인가?’에 대해 물음을 던지는 영화. 공포스릴러장르에 속하지만 철학적인 냄새가 많이 나는 영화입니다.   광기 어린 잔혹한 사이코패스에 불과하지만 진정한 사랑의 의미를 몰랐기에 사랑을 줄 수도 받을 수조차도 없었던 비운의 소년 영화    마치며..  그 밖에도, 인시디어스(Insidious) 영화를 추천해 드리고 싶지만 1~4편 중 현재 2, 3편만 넷플릭스에 등록이 되어있기에 스포일러를 먼저 접하실 수도 있을 거 같다는 생각에 제외했습니다.      혹시 다 보셨던 건가요? 다가오는 3월에도 재밌는 영화가 많습니다.   추후 가능하다면 다음엔 영화가 아닌 드라마로 글을 작성해보려 합니다.   모두 건강하고 안전한 설 연휴 보내시길 바랍니다.     ","categories": ["hobby"],
        "tags": ["Netflix"],
        "url": "https://many258.github.io/hobby/netflix-holiday-guide/",
        "teaser": "https://many258.github.io/assets/images/netflix/teaser_netflix.png"
      },{
        "title": "[BoardGame] 디스워오브마인(This War of Mine : TWoM) 보드게임 룰",
        "excerpt":"Intro      스토리기반 전쟁생존 보드게임          게임인원 : 1인 ~ 6인 (1-2인 추천)   게임시간 : 45 ~ 120분   게임연령 : 18세이용가   난이도 : 2.33 / 5.0   핵전쟁이 일어난 후 민간인의 입장이 되어 최후의 순간까지 생존을 목표로 시나리오가 이어지는 보드게임입니다.  스토리가 전반전으로 탄탄하나 전쟁 컨셉 상 비참하고 무거운 느낌이 강할 수 있으며 플레이어의 윤리과 생존의 갈등을 테스트하고 크게 하루(아침-낮-해질녘-저녘-밤(수집/야간습격)-새벽)를 서사적으로 나누어서 진행하게 됩니다.   주로 ‘무엇을 얻는가’가 아닌 ‘무엇을 잃어야 하는가’에 대해 많은 고민을 하게 만드는 게임입니다.  난이도는 PC게임 원작보다 높은 편이라고 하며 계속해서 확장판을 제작중에 있어서 기대가 많은 게임이기도 합니다.   게임준비      리더 정하기  무작위로 플레이어 중 리더를 고른다.   캐릭터 카드 선택하기  캐릭터 카드들을 섞은 다음 뽑기 :     맨 처음 나온 빨간 테두리의 카드 1장(다음에 빨간 테두리의 카드가 나오다면 무시하고 캐릭터카드를 다시 뽑는다.)   맨 처음 나온 검은 테두리의 카드 2장   이 3장의 카드를 보드 근처에 앞면으로 놓는다.  이번 게임의 시작 캐릭터들이다.  세이브 시트에 이들의 이름을 적는다.  각 캐릭터의 옆에 배고픔 토큰(2 레벨)을 놓는다.  이들 캐릭터를 나타내는 피규어를 찾아 보드의 경계 칸에 놓는다.  남겨진 캐릭터 카드들은 사용되지 않은 캐릭터 칸에 놓는다.   카드 준비하기  모든 카드 더미들을 카드 뒷면과 보드의 일러스트가 일치하는 자기 칸 위에 놓는다.  초록 모서리의 설비 카드들은 설비 칸에 놓는다.  지속되는 설비 카드들은 알맞은 칸에 놓는다.   상단 우측 빨강 모서리의 한 밤의 습격 더미와 거주자 더미를 찾아 옆에 놓는다(나중에 필요하다).        지역 더미에서 3장의 카드를 뽑아 3 개의 지역 칸에 놓는다.   모든 주거지 카드 배치하기  모든 카드들을 앞면으로 놓아 확인한다(파랑 모서리가 없는지).     누구도 뒷면을 훔쳐보지 않는다.    각 주거지 카드는 반드시 카드에 있는 것과 같은 이름의 칸에 놓는다.  (예를 들어 고물 더미 카드는 고물 더미 칸에, 잠겨진 문 카드는 잠겨진 문 칸에).   이벤트 더미 준비하기  이벤트 카드들은 뒷면으로 이벤트 칸에 놓고(앞면을 보지 않고), 다음 순서대로 한다.   1) 3장의 엔딩 이벤트 카드를 섞는다. – 더미의 맨 아래에 놓일 것이다.  2) 챕터 3 카드를 더미의 맨 위에 놓는다.  3) 4장의 이벤트 카드를 무작위로 뽑아 더미의 위에 쌓는다.  4) 챕터 2 카드를 더미 위에 놓는다.  5) 3장의 이벤트 카드를 무작위로 뽑아 더미의 위에 쌓는다.  6) 챕터 1 카드를 더미의 위에 놓는다.   남은 이벤트 카드들은 이번 게임에서는 필요하지 않다   토큰과 자원 배치하기  토큰들과 자원들을 일러스트에 맞게 박스의 적절한 칸에 배치한다.   상태 토큰  게임 동안, 캐릭터들은 다치고, 굶주리고 피로하게 되는 등의 경험을 한다.  “증가/감소” 로 설명되는 피로/상처/비참함/배고픔/질병 효과들이 나올 때마다 토큰을 새로 놓거나 양면 토큰의 경우 뒤집어서 1씩 상태 토큰들의 레벨을 조정한다.  레벨 4 토큰은 당신에게 무슨 일이 일어날 지 알려줄 것이다.   전투 주사위  회색주사위는 비무장상태  노란주사위는 근접무기 무장상태  적색주사위는 화기 무장상태   상황에 맞는 주사위로 굴린다.  검정 주사위 (이하 D10)  소음 마커  일지  디스워오브마인 지원툴 또는 보드게임 내 스크립트 북을 참조한다. 게임 내에서 “~번을 확인하라” 내용이 있을 시 사용한다.   게임을 시작하기 전  최대 플레이 가능한 캐릭터는 4명  5번 째 캐릭터는 그룹에 추가될 수 없다.   컬러 베이스 디스크  캐릭터 피규어들을 쉽게 구분하기 위하여, 각 피규어를 한 색깔의 디스크에 끼운다. 그러면 캐릭터 카드에 토큰을 놓을 때 그 캐릭터의 색깔로 된 토큰을 놓으면 된다.          버리기/제거하기  박스 안에 있는 특정 자원이나 토큰이 바닥날 때마다, 그 아이템은 이제부터는 사용할 수 없다.  (찾거나, 사거나 등을 할 수 없음).   “토큰/자원 버리기”는 박스로 돌려 놓으라는 뜻이다.  “토큰/자원/카드 제거하기”는 이번 게임에서 사용할 수 없다.(Discard의 개념)   공유된 경험  캐릭터들은 개별 플레이어들에게 배당되지 않는다.  플레이어들은 그룹의 모든 캐릭터들과 상호작용한다.  현재 일지를 들고 있는 플레이어를 “리더” 라고 부른다.  플레이어가 ‘다음 플레이어-&gt;’라는 상징을 일지에서 볼 때 마다 :  일지를 자신의 왼쪽에 있는 플레이어에게 건네주고 건네받은 플레이어가 리더가 되며 권한도 위임받는다.  게임에서 당신에게 어떤 종류의 결정을 하라고 말할 때마다(캐릭터, 토큰, 액션 등을 고른다 던지),  플레이어들은 토론하거나, 제안하거나, 다툴 수도 있지만 반드시 최종 결정은 언제나 리더가 한다.     오직 리더만 게임 구성물을 만질 수 있습니다.(피규어, 카드, 토큰을 움직이기 등)    거주지에서의 이동  경계 칸에서 시작하는 캐릭터를 거주지의 어떤 칸이나 설비, 거주지 카드들에 놓을 수 있다.  캐릭터들은 수평으로는 자유롭게 움직인다. 층과 층 사이의 사다리들을 이용하여 수직으로도 움직일 수 있다.  하지만 창살이 있는 창문, 잠긴 문, 돌무더기, 구멍들과 같은 장애물들은 지나갈 수 없고, 그 너머에 있는 카드나 칸은 사용할 수 없다.   게임시작  아침(■□□□□□□)     새로운 날이 시작된다.    이벤트  이벤트 카드 더미의 맨 위 카드를 뽑고 해결한다. 추위 토큰(상단 왼쪽에 표시)을 보드의 추위 공간에 더하는 것을 잊지 않도록 합니다.   챕터 목표   챕터 목표의 경우 목표 상태 토큰을 이용하여 현재 진행도를 나타낼 수 있으며 나중에 챕터가 종료되었을 때 목표 달성 여부에 따라 보상 및 불이익을 적용한다.   다음 플레이어에게 순서를 넘긴다.   낮(■■□□□□□)     새로운 날이 시작된다.     밖은 남은 세력들의 충돌과 우리에게 총을 겨누고 있는 스나이퍼가 있다.  우리는 거주지의 떠날 수 없지만 이곳을 개선할 수 있다.     우리는 침대와 스토브, 심지어 라디오도 사용하여 이 곳을 좀 더 집 같은 느낌이 들게 만들 수 있다.  하지만 먼저, 우리는 여기저기를 치워야 할 것이다.     다행스럽게도 우리는 이 무더기들에 유용한 무언가를 찾을 수 있었다.    행동  각 캐릭터는 3개까지의 행동을 할 수 있다.  행동의 수는 그 캐릭터가 가지고 있는 상태 토큰에 있는 검정색 마커에 따라 적어질 수 있다.  상태 토큰이 보여주는 대로, 검정 마커는 3번의 행동 중 얼마나 사용이 불가한지를 나타낸다.   검은색 마커가 하나씩 칠해질 때마다 행동 횟수가 하나씩 줄어든다.  최종적으로, 캐릭터가 가진 상태 토큰 중 가장 많은 검은색 마커가 칠해진 토큰이 기준이 되어 행동 횟수를 판별한다.                예시로, 한 캐릭터가 위와 같은 상태를 가질 때,  검은 마커가 가장 많은 피로감(fatigue)를 기준으로 1번의 행동이 가능하다.   오직 한 캐릭터만을 각각의 설비/거주지 카드나 거주지 행동 칸에 놓을 수 있다. (돌무더기 뒤지기행동은 이 규칙의 적용을 받지 않는다)   개별 행동(첫 행동, 둘째 행동, 셋째 행동)을 시작할 때, 모든 사용가능한 캐릭터들의 행동을 선택한 다음 동시에 그들의 효과를 해결한다.   개별 행동 후에 다음 플레이어에게 순서를 넘긴다.   할 수 있는 행동들     거주지 칸/설비 카드에서의 행동  선택한 칸/카드에 캐릭터 놓고 요구되는(요구되는 것들이 있는 경우) 자원이나 토큰 저장고로부터 꺼내어 버린다.  만약 행동의 결과로 토큰이 만들어진다면 저장고에 더한다.              거주지 카드에서의 행동(카드 내 상단 빨간 손을 확인!)  선택한 거주지 카드에 캐릭터를 놓는다. 거주지 카드 행동의 결과로 카드의 뒷면을 해결한다.  어떤 거주지 카드(돌무더기, 창살 혹은 잠긴 문)는 캐릭터외에도 저장고로부터 특정 토큰(삽, 줄톱, 자물쇠 핀) 놓기를 요구한다.  행동을 해결한 후 토큰은 저장고로 돌려놓는다.  돌무더기, 돌무더기 잔해 카드의 경우, 삽 대신 추가 캐릭터를 놓을 수도 있다.                       잠긴 문 카드의 행동은 아래에 설명된 주사위 굴림을 요구한다.                      자물쇠 열기 - 자물쇠 핀 필요, D10[^blackDice]  결과 = 1~3 - 효과 없음  결과 = 4-10 - 자물쇠 핀 카드를 버리고 이 카드의 뒷면을 해결한다.                        새로운 설비 카드를 배치하기  설비 칸의 카드 더미에서 어떤 카드도 고를 수 있다.  거주지의 빈 칸(층 옵션의 수면, 경계 칸이나 다른 카드나 행동이 없는 칸)에 설비 카드를 놓으면,  거기에 어느 캐릭터든 놓고 요구하는 자원/토큰을 저장고로부터 버린다. 그 후 설비 카드를 앞면으로 뒤집는다.  정확한 설명과 요구사항은 각 설비카드의 뒷면에 써있다.            야외행동  D10을 굴림하고, 만약 1이 나온다면 저격수로부터 총을 맞고 상처 2를 증가시킵니다.  그런 다음에 방문자들 카드를 한 장을 뽑아 해결합니다.       해질녘(■■■□□□□)     태양은 지평선 너머로 사라졌다.  그림자들과 어둠이 도시를 지배한다.  지금이 밖으로 나가기에 조금은 더 안전하다.  하지만 먼저 우리의 체력부터 회복해야 한다.    각 캐릭터에게 물과 음식을 배급한다.   물 배급  물을 마시지 못한 캐릭터마다, D101을 굴린다 :                  D10       결과                 1 ~ 5       배고픔 1증가                 6 ~ 10       비참함 1증가           사용된 물은 버린다.   음식 배급                          결과                 배급안함       배고픔 1 증가                 야채       배고픔 현상태 유지                 날음식       배고픔 1 감소                 통조림       배고픔 2 감소           마찬가지로 사용된 음식은 버린다.   다음 플레이어에게 순서를 넘긴다.   저녁(■■■■□□□)     어두워지기 전에 우리는 거주지에 머물며 체력을 회복하거나 문을 지키는 사람과 폐허가 된 도시로 모험을 떠날 사람을 결정해야 한다.     우리의 유일한 희망은 약간의 음식와 약품들과 다른 필요한 것들을 찾아내는 것이다.    각 캐릭터를 4 가지의 가능한 과제들 중 하나에 분배한다.   침대에서 자기 :  1 개의 침대 카드에 최대 1 명의 캐릭터를 놓는다. 해당 캐릭터의 피로도가 0이 된다.   바닥에서 자기 :  바닥에서 자기 칸에 캐릭터를 얼마든지 놓는다. 해당 캐릭터들의 피로도가 2 감소한다.   경계 서기 :  야간습격↓단계 동안의 공격들로 부터 거주지를 지키기 위해 경계 칸에 캐릭터를 얼마든지 놓는다.  경계 실력이 높을 수록 좋다.  경계 칸에 최소 1명의 캐릭터를 놓지 않았다면, 스크립트 북의 333을 참조한다.  해당 캐릭터들의 피로도가 1 증가한다.   수집 :  3명의 캐릭터까지 수집 칸에 놓으면 수집 단계 동안 그들을 폐허가 된 도시로 보낸다. 캐릭터의 인벤토리와 실력이 좋을 수록 수집 단계 동안의 수행이 더 좋다.  캐릭터의 피로도가 1 증가한다.   다음 플레이어에게 순서를 넘긴다.   수집(■■■■■□□)     밤이 도시를 돌아다니기에 조금 더 안전하다.  여전히 산발적으로 총성이 들린다.  당신은 배낭을 조여 메고 거주지를 떠난다.  당신은 신중하게 포탄이 떨어진 거리를 따라 폐허가 된 가게와 집들로 발걸음을 옮긴다…    지역 선택하기     3개의 가능한 지역 카드 중 1개를 선택하기(근거리/중거리/원거리) 수집 칸에 놓은 모든 캐릭터를 지역 카드 위로 이동시킨다.  만약 추가 규칙이 있다면 지역 카드의 빨간 칸에 쓰여 있을 것이다.   장비 선택하기  저장고에 무기(손도끼, 칼, 총 등)나  장비(자물쇠핀, 줄톱, 삽 같은)가 있다면,  수집하러 가는 그룹에 이 토큰들을 분배한다(찾은 것들 칸에 놓는다).  또한 만약의 사태를 대비해 거래를 위한 토큰들도 가져갈 수 있다.   소음 마커 셋팅하기  소음 마커를 소음 트랙의 1 칸에 놓는다.  게임에서 소음의 증가나 감소를 이야기할 때마다 소음 마커를 트랙의 위나 아래로 움직인다.  ‘소음 굴림’이라고 쓰여져있으면, D10을 굴린다.   그 결과가 현재의 소음 보다 같거나 낮으면 원하지 않는 만남이 즉시 일어난다 :     소음 마커를 1 칸으로 셋팅한다.   거주자 카드 더미의 맨 위 카드를 뽑고 해결한다.   거주자 카드를 해결한 후, 수집을 재개한다(또 다른 누군가를 여전히 만날 수 있다!)  전투진행시↓   미확인 더미와 탐색 준비하기  당신이 탐색하기로 선택한 지역의 칸에 보이는 만큼의 탐색 카드를 뽑는다.  (근거리 = 10 / 중거리 = 12 / 원거리 = 14)  앞면을 보지 않고 그 카드들을 엎은 채로 미확인 더미에 놓는다.  이제 이 카드들을 하나씩 해결한다.  해결된 카드는 보드 위의 버린 카드 칸에 앞면으로 버린다.   각 카드를 해결한 후 다음 플레이어에게 순서를 넘긴다.   게임이 탐색 카드를 되돌려 놓으라고 하면 앞면을 보지 않고 미확인 더미에서 탐색 카드 더미로 확인하지 않은채로 되돌려 놓는다.  미확인 더미가 다 떨어지면, 탐색이 자동적으로 끝난다.   수집 중에 획득한 모든 아이템은 저장고가 아닌 찾은 것들 칸에 놓아야 한다.  수집 단계가 끝나면 당신은 어떤 것을 두고 가고 어떤 것을 거주지로 가져 갈 건지 결정해야 한다.   찾은 것들 선택하기  탐색이 끝나면, 모든 탐색 카드, 거주자 카드들을 섞어 그들이 있던 카드 더미에 넣는다.      수집을 나선 모든 캐릭터의 전체 보관함(카드 하단 오른쪽 수치)와 동일한 무게2만큼의 토큰/자원(당신이 가져간 장비와 무기를 포함한)을 가지고 돌아올 수 있다.  가지거나 운반할 수 없는 모든 것들을 버려두고 떠나야 한다.  캐릭터들과 그들이 찾은 것들은 새벽↓ 단계에 돌아온다.  그 전에 한 밤의 습격이 일어난다…   다음 플레이어에게 순서를 넘긴다.   야간습격(■■■■■■□)     그동안 거주지에서는…        우리가 가진 것들을 빼앗기 위하여 밤 중에 누군가가 왔다.    경계 서는 자를 위한 무기 선택하기  저장고에 무기 토큰을 가지고 있다면, 그것들을 경계 서는 자에게 줄 수 있다(무기 토큰을 경계 칸에 놓는다).  각 캐릭터는 오직 하나의 무기만 들 수 있다.   한 밤의 습격  야간습격 카드 더미의 맨 위 카드를 뽑고 해결한다.   손실 - 빼앗긴 토큰과 자원들은 반드시 저장고에서 버려져야 한다.  (경계 서는 사람이 들고 있는 무기들은 안전하게 남는다)   상처 - 상처들은 반드시 경계 칸의 캐릭터들에게 나누어 입혀야 한다.  손실과 상처를 최소화 할 수 있는 방법은 아래와 같다.   경계자와 무기  경계 칸의 각 캐릭터를 위해 전투 주사위(사용하고 있는 무기에 맞는)를 굴린다.   하얀 전투 주사위 - 비무장 노란 전투 주사위 - 근거리 무기(손도끼, 칼) 빨간 전투 주사위 - 화기(권총, 자동 소총, 샷건)   굴려진 주사위의 아이콘 수는 손실(토큰, 자원)이나 상처의 고통을 피할 수 있는 양을 나타낸다.   야습 동안 무기 사용하기  권총 - 탄약 토큰을 반드시 버린다.  자동 소총 - 탄약 토큰을 반드시 버린다.   → 만약 2 개의 탄약 토큰을 버린다면 2개의 샷으로 인정된다.  샷 건 - 탄약 토큰을 반드시 버린다.   샷 건을 사용하는 동안 샷-건 아이콘이 나오면, 진행 중인 야습 카드를 즉시 무시한다.  손도끼 – 손도끼를 사용하는 동안 손도끼 아이콘이 나오면, 진행 중인 야습 카드를 즉시 무시한다.   샷 건 아이콘과 손도끼 아이콘은 다른 무기를 사용하는 동안은 빗맞음으로 간주한다.   야습 동안의 실력  실력은 캐릭터가 야습 중에 더 낳은 결과를 내기 위해 주사위를 다시 굴릴 수 있는 횟수를 결정한다.  캐릭터는 모든 재굴림 기회를 사용하지 않아도 되지만 마지막으로 굴린 주사위가 최종 결과가 된다.   보드 개선 (나무가림막) :  모든 설치된 보드 개선 토큰은 [상처 1] 또는 [손실 1]을 피하게 해준다.         지나가는 밤마다 상황은 더욱 냉혹 해지고있다.    범죄 발생  셋팅 동안, 빨강 모서리의 야습 카드와 거주자 카드는 옆에 셋팅한다.  만약 이 카드들이 남아 있다면 :  2 장의 카드를 임의로 조합하여(야습/거주자) 해당 더미에 섞는다.   다음 플레이어에게 순서를 넘긴다.   새벽(■■■■■■■)     생존을 위한 또 다른 날. 우리는 포기할 수 없다…    수집조의 복귀  모든 수집에 나섰던 캐릭터들을 거주지로 이동시키고, 그들이 가져온 토큰/자원들을 저장고에 놓는다.   약과 붕대 분배하기  약/약초/붕대가 저장고에 있다면, 그것들을 질병/상처가 있는 캐릭터 카드를 선택하여 놓을 수 있다.  다음에 이어질 운명의 내용에 따라 아이템을 사용하거나 버린다.   운명 카드 뽑기  운명 카드 1 장을 뽑고 해결한다(아랫 부분에 있는 죽음 마크는 무시한다). 운명 카드가 지역 카드 교체를 말한다면, 그 카드를 게임에서 제거하고 남아 있는 지역 카드들을 아래로 내린다. 그러면 제일 윗 칸이 비게 된다.   다음 플레이어에게 순서를 넘긴다.   이야기 행동 카드(네러티브 행동)  2장의 이야기 행동 카드를 뽑아 1장을 선택한 후, 나머지 1장은 더미로 돌려 놓은 뒤 섞는다.   다음 플레이어에게 순서를 넘긴다.   술  운명 카드를 해결하기 전이나 후에 사용할 수 있다(저장고에서 버리며) :  밀주 - 선택한 캐릭터의 피로를 2 를 올리고, 비참함을 1 내린다.  100% 알콜 - 선택한 캐릭터 피로를 1 올리고, 비참함을 1 내린다.   우리 안에 있는 죽음  새벽 단계가 끝나면 오늘 하루동안 캐릭터들이 죽었는지, 버려졌는지 체크한다.  만약 그렇다면 검은 주사위를 굴려 각 캐릭터의 감정이입 결과와 비교한다.  결과가 그들의 감정이입 보다 같거나 낮으면 - 그들의 비참함 2 증가한다.   저장  지금 당신은 현재 게임의 상태를 저장하고 박스에 넣을 수 있다.  언제든 당신이 돌아와 게임을 시작하려 할 때, 당신이 떠났던 시점부터 시작할 수 있다.  스크립트 책의 10 을 보라.      지난 날을 돌아보자.  우리는 어떻게 해왔나?  다음으로 우리에게 필요한 것은 무엇일까?  우리가 반드시 수집하거나 교환해야 하는 것은 무엇일까?  우리가 반드시 만들어야 하는 건 무엇일까?     … 자, 이제 내일이 우리에게 가져올 것을 보자.    새로운 날이 시작된다(아침 단계↑로 되돌아간다)…   전투  거주자 카드를 해결하는 동안 뽑게 된 A, B, C 토큰들은 당신의 적들을 나타낸다.  이 토큰들은 그들의 무기(거주자 카드에 설명되어 있는)와 실력(숫자)를 결정한다.  전투 차트의 첫째 칸에 적 토큰들을 놓는다.  건강함 -&gt; 상처 1 -&gt; 상처 2 -&gt; 상처 3 = 죽음(적 토큰을 버린다)      각 캐릭터는 찾은 더미에 있는 무기 하나를 분배 받을 수 있다.  (거주지에서 싸움이 일어났다면 저장고에 있는 무기를 가지고온다)   전투는 라운드 단위로 진행한다.  각 라운드마다 당신은 각 캐릭터와 적의 전투 주사위(사용하고 있는 무기에 맞는)를 굴린다.   굴려진 주사위의 아이콘의 수는 입힌 상처의 양을 뜻한다.  적들에 의해 나온 상처의 양은 캐릭터들에게 분배해야 한다.  캐릭터들에 의해 나온 상처의 양은 적들 중에서 선택하여 분배한다.  각 라운드 마다 전투에 임하는 사람들은 동시에 싸우고 상처를 준다.     적의 상처는 전투 차트 위의 적 토큰을 오른쪽으로 이동하는 것으로 표시한다.   캐릭터의 상처는 상처 상태 토큰으로 표시한다.   전투 시나리오  전투 주사위(당신이나 적의) 굴림에서 § 아이콘이 나오면, 당신은 빗맞음/운명을 선택해야 한다.  운명을 선택한다면, 운명 카드를 뽑고 전투 주사위의 아이콘 색이 그 카드에 있는지 체크한다.  만약 굴려진 전투 주사위와 일치하면, 전투 주사위 아이콘 아래의 문장을 읽고 따른다.  일치하지 않는다면 빗맞음으로 간주한다.      전투에서의 실력(재굴림)  실력은 캐릭터가 전투 중에 더 낳은 결과를 내기위해 주사위를 다시 굴릴 수 있는 횟수를 결정한다.  캐릭터는 모든 재굴림 기회를 사용하지 않아도 되지만, 마지막으로 굴린 주사위가 최종 결과가 된다.  적들은 자동적으로 그들의 실력을 사용한다 - 결과가 상처 0일 때만 재굴림 한다.   도망가기  전투의 각 라운드를 시작하기 전에 당신은 싸움을 계속하는 대신 도망가기를 선택할 수 있다.  이 행동을 한다면, 적은 등치기 행동을 한다. 해결한 후에 캐릭터들은 지역을 떠난다.  찾은 것들 중에 선택하기 단계를 해결한다.  (수집 - 찾은 것들 선택하기 단계를 참조한다)   등치기(배후공격)  보통 전투와는 다르게 등치기 할 때는 한 쪽 편만 공격하고(오직 캐릭터들이나 오직 적들), 상대 측은 보복할 수 없다.  보통 전투처럼 공격 주사위를 굴리고 해결한다.  은신한 상태에서 등치기를 하는 경우에는(탐색 카드 더미의 은신처 카드를 참고한다), 등치기를 해결한 후 정식 전투가 시작된다.   전투 시 무기 사용하기  화기(권총, 자동 소총, 샷 건) – 총을 가진 사람이 항상 먼저 굴린다.  만약 총을 가지지 않은 적이 죽었다면, 공격할 기회를 얻지 못한다.   캐릭터가 한 발 쏠 때마다 무조건 탄약 토큰을 1 개 버린다.  만약 캐릭터에게 탄약이 없다면,     반드시 다른 무기를 사용하거나   (다른 무기를 사용할 수 없다면) 비무장으로 싸워야 한다.   적들은 탄약 토큰을 사용하지 않는다.  그 대신 전투 주사위를 굴려 탄약 없음 아이콘이 나오면 해당 적을 전투 차트의 다른 줄로 옮긴다.  (다른 무기가 있거나 무기 없이 싸워야 될 수 있다)   자동 소총 - 만약 2 개의 탄약 토큰을 버린다면 2개의 샷으로 인정된다. 적들은 항상 2 개씩 쏜다.    샷 건 - 샷 건을 사용할 때 샷건 아이콘이 나오면, 목표는 즉시 죽는다.   손도끼 – 손도끼를 사용할 때 손도끼 아이콘이 나오면, 목표는 즉시 죽는다.   샷 건 아이콘과 손도끼 아이콘은 다른 무기를 사용하는 동안은 빗맞음으로 취급한다.   적의 죽음 – 당신이 누군가를 죽인다면(침입자를 제외하고),  검정 주사위를 굴리고 각 캐릭터의 현재 감정이입 상태와 비교한다.  그 결과 그들의 감정이입 보다 같거나 낮다면, 그들의 비참함은 1 증가한다.   캐릭터의 죽음  스크립트 북(266) 참조   거래  거래는 어떤 지역/방문자/거주자 카드와 스크립트들에서 가능한 행동이다.  토큰(수집 동안은 찾은 것들, 거주지로 방문자가 올 때는 저장고에 있는 것들)을 주어진 스크립트나 카드의 범위 안에서 다른 토큰들과 교환할 수 있다.  거래를 시작하기 전에, 당신은 반드시 거래 수수료를 먼저 지불해야 한다.  주어진 카드/스크립트의 거래에 대한 설명에 묘사된 만큼의 전체 가치3의 토큰들을 버려야 함을 뜻한다.  (이것은 당신과 물물교환을 하는 거래자의 이익을 나타낸다)   이제 당신이 사고자 하는 토큰들의 가치와 같거나 더 높은 가치의 토큰들을 버리며 교환할 수 있다.  물, 나무, 부품들은 거래하면서 결코 사거나 팔 수 없다.    각주  1: 검은 주사위 ↩  2: 토큰 내 검은 아이콘에 있는 수치를 나타내며, 없을 시 0으로 책정한다. ↩  3: 각 토큰들은 노랑 아이콘으로 가치를 보여준다. ↩     참고사이트  http://boardlife.co.kr/bbs_detail.php?bbs_num=3571&amp;id=&amp;tb=info_files&amp;game_category=  ","categories": ["hobby"],
        "tags": ["BoardGame","This War of Mine"],
        "url": "https://many258.github.io/hobby/this-war-of-mine/",
        "teaser": null
      },{
        "title": "[정보처리기사/컴퓨터일반] 컴퓨터의 역사",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.   세대별 분류     1세대 컴퓨터(1951-1958)            주로 통계 및 미사일 탄도 등 과학 계산에 사용       진공관과 자기드럼(주기억장치 용도)을 사용       부피와 전력 소모는 크지만 계산 능력 및 신뢰도는 떨어졌으나, 계산성능 및 필요성으로 개발은 활발히 진행됨과 함께 상용화가 시작되었다.       기계어, 어셈블리어       대표기종 :  ENIAC, EDVAC, UNIVAC I, 80, 90과 IBM 650과 700계열, Burroughs 220           2세대 컴퓨터(1958-1963)            기억장치를 이루는 회로소자가 트랜지스터(크기 및 발열이 개선)와 다이오드 등 반도체 소자로 제작       IBM 기업이 주도하였으며, 고수준 프로그래밍 언어가 개발되기 시작한 시기       FORTRAN, COBOL, ALGOL 등의 프로그램 언어가 등장과 언어번역 프로그램인 컴파일러가 개발되었음       대표기종 : IBM 1401, 7070, UNIVAC Ⅲ, 1107, USSC 80, CDC 3000계열           3세대 컴퓨터(1964-1970)            집적회로(IC: Integrated Circuit)가 등장해 중앙처리장치가 작아지고 기억용량이 거대해짐       운영체제(operating system: OS), 다중프로그램, 실시간 처리시스템, 시분할시스템 등이 실현       경영 정보 시스템(MIS)이 도입       BASIC, PASCAL, LISP, PL/1 등       대표기종 : IBM 360계열, UNIVAC 1108, CDC 6000계열, Burroughs 5500, Honeywell 200계열, NCR Centry, G.E. 400, 600           4세대 컴퓨터(LSI)(1971-1983)            대규모집적회로(Large Scale Integration: LSI)를 소자로 사용한 컴퓨터       최초의 개인용 컴퓨터(마이크로프로세서(Micro Processor)의 출현으로 컴퓨터의 소형화)와 슈퍼 컴퓨터가 등장       네트워크의 발전과 가상 기억 장치 기법(Virtual Memory)이 도입       개인용 컴퓨터가 개발되기 시작과 사용이 전반적으로 확대       C,ADA 사용       공장자동화(FA), 사무자동화(OA), 가정자동화(HA) 등 각종 분야에 컴퓨터를 이용한 자동화       대표기종 : IBM PC, VAX 780, APPLE 2           5세대 컴퓨터(VLSI)(1984∼ )            초고밀도 집적회로 사용(VLSI)       Visual C, Visual Basic, Java, Delphi 등의 언어 사용       복잡한 계산을 수행하고 고도의 시스템 분야에 활용하고 있다.           기계식 컴퓨터     파스칼의 치차식 계산기   라이프니츠의 가감승제 계산기   배비지의 차분-해석 기관   홀러리스의 천공카드 (PCS)   ABC(Atanasoff Berry Computer : ABC)            진공관으로 이루어진 특수 목적용 컴퓨터           마크원 : 최초의 전기 기계식 자동계산기   에니악(ENIAC：Electronic Numerical Integrater And Computer)     전쟁을 위해 고안된 진공관을 사용한 컴퓨터   최초의 디지털 컴퓨터                                         ENIAC      (출처 : 위키피디아)           에드삭(EDSAC : Electronic Delay Storage Automatic Calculator)     최초의 프로그램 내장 컴퓨터는 아니었으나, 세계 최초의 실용적 프로그램 내장 전자식 컴퓨터   에드박(EDVAC;Electronic Discrete Variable Automatic Computer)     기존의 10진수 계산을 2진수 계산으로 처리   폰 노이만의 전자식 프로그램 내장방식을 사용                                         EDVAC      (출처 : 위키피디아)           유니박 I(UNIVAC－I)     최초의 상업용 컴퓨터   자기테이프를 보조기억장치로 도입                                         UNIVAC      (출처 : 위키피디아)           집적회로의 발전     무어의 법칙(Moore’s Law) :  집적회로의 트랜지스터 개수는 2년마다 2배로 증가한다.   폴락의 법칙(Pollack’s Law) :  성능은 면적(트랜지스터 수) 증가량의 제곱근과 비례   황의 법칙 (Hwang’s Law):  무어의 법칙과 달리 메모리반도체의 집적도가 1년에 두 배씩 늘어난다는 이론  ","categories": ["study"],
        "tags": ["(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/computer-history/",
        "teaser": null
      },{
        "title": "[NCS/경제상식] 국제수지와 환율",
        "excerpt":"국제수지  경상수지     경제적으로 항상 있는 일로 발생한 수지타산의 준말    국가가 재화와 서비스를 외국과 거래한 결과로 나타나는 수입과 지출의 차액  상품수지  일반적인 상품의 수출입  서비스수지  운송/여행/금융/보험/지적재산 사용료 등 서비스의 거래  본원소득수지  국내외 노동자의 임금 소득과 투자 소득  이전소득수지  개인 송금, 기부, 원조 등 무상으로 주고받는 거래에서 발생한 수지   경상수지와 경제     흑자 : 외국에서 구매한 물건 &lt; 외국에 판매한 물건            수출 증가 ⏩ 국내총생산의 증대 ⏩ 고용 및 소득의 증대 ⏩ 소비 증가 ⏩ 경제 호황       외화자산의 증대(통화량 증가) ⏩ 외채 감소, 외국에서 생산되는 원자재의 공급이 수월, 해외 직접투자의 증대 ⏩ 환율 하락           적자 : 외국에서 구매한 물건 &gt; 외국에 판매한 물건            수출 감소 ⏩ 국내총생산의 감소 ⏩ 고용 및 소득의 감소 ⏩ 소비 감소 ⏩ 경제 악화           자본·금융 계정(자본수지)  제품이나 서비스 거래가 아닌  국내 기업,  금융 기관과 외국의 기업,  금융기관이 서로 돈을 꾸거나 빌려주는 거래를 통해 생기는 수입과 지출의 차액   외국인 투자, 해외투자, 차관 등이 포함   환율     국가 간 통화의 교환 비율    환율의 증감     환율 인상 ⏩ 원화 가치 하락(원 약세/절하) ⏩ 국내 물가 상승, 수입품의 가격경쟁력 하락  수출 증가, 수입 감소, 자국민 해외여행 감소, 외국인 국내여행 증가   환율 인하 ⏩ 원화 가치 증가(원 강세/절상) ⏩ 수출품의 가격경쟁력 감소  수출 감소, 수입 증가 ⏩ 경상수지의 적자 가능성 증가  ","categories": ["study"],
        "tags": ["NCS"],
        "url": "https://many258.github.io/study/current-account-balance/",
        "teaser": null
      },{
        "title": "[웹 프로그래밍] HTML5",
        "excerpt":"HTML5     HTML(Hyper Text Markup Language)의 완전한 5번째 버전  WWW(World Wide Web)의 핵심 표준 마크업 언어       ? 마크업 언어  문서 안의 정보를 구조화시키는 언어   탄생배경  기존의 HTML은 HTML4.0 이후에도 W3C에 의해서 HTL 4.01, XHTML 1.0, 1.1, 2.0 등으로 발전해왔지만,  그 동안의 HTML에서의 한계를 극복하기 위해 탄생   특징  기존 HTML과의 호환성 유지, 간단한 업데이트   어도비 플래시나 실버라이트 등의 플러그인을 기반으로 하는 응용프로그램에 대한 필요성을 줄이는 것에 초점   비디오, 오디오 등 다양한 부가기능과 최신 멀티미디어 콘텐츠를 액티브 X 없이 브라우저에서 쉽게   웹 표준, 웹 접근성 한층 증대   JAVA Script 사용하지 않고도 문법이 간결하고 명확하게 변화 ⏩ 문서의 크기 감소 ⏩ 생산성 향상   HTML5 기반 암호화 표준화 진행     모질라 한국 커뮤니티는 웹 표준 기반 HTML5 암호화 및 대한민국의 공인인증서등에 사용가능한  W3C 웹 크립토그래피 API를 제안    주요기능     Device Access  카메라, 동작센서 등의 H/W 기능을 웹에서 직접적으로 제어   Connectivity  웹(클라이언트)에서 서버 측과 직접적인 양방향 통신 가능   3D Graphics &amp; Effects  다양한 2/3차원 그래픽 기능을 지원   Styling Effects(CSS3)  글씨체, 색상, 배경 등 다양한 스타일 및 이펙트 기능 제공   Multimedia  비디오 및 오디오 기능을 자체적으로 지원   Offline &amp; Storage  네트워크 미지원 환경에서도 웹 이용을 가능하게 함   Geo-Location  GPS없이도 단말기의 지리적인 위치 정보를 제공   Semantics  웹 자료에 의미를 부여하여 사용자 의도에 맞는 맞춤형 검색 제공   기타기능     캔버스 : 2차원 그래픽(애니메이션, 게임)을 그리기 위한 캔버스 API 제공   오프라인 웹 : 인터넷 연결이 되지 않은 상태에서도 정상적인 기능을 지원하는 애플리케이션 캐시 API 제공   웹 데이터베이스 : 표준SQL을 사용할 수 있는 데이터베이스 API 제공   로컬 저장소 : 클라이언트에 데이터를 저장하기 위한 API 제공  (웹 브라우저가 실행되는 컴퓨터에 데이터를 저장하는 API, 쿠키와 유사한 역할을 가지나 더 큰 용량으로 저장공간을 이용할 수 있다.)   웹 워커 : 웹 응용을 스레드 기능에 대한 API 제공  (시간이 많이 소요되는 작업들을 백그라운드로 개발해 웹 브라우저의 UI가 느려지지 않도록 하는 기능)   드래그앱드롭 : 모든 요소를 드래그 앤 드랍으로 이동할 수 있음   SSE(Server-Send Events) : 웹페이지가 자동으로 서버에서 업데이트 정보를 가져오는 기능(페이스북, 트위터…)   다양한 Element, Attribute의 변화        시멘틱 태그 추가  웹 리소스와 정보를 모두 컴퓨터가 처리할 수 있도록 구조화시킨 기술                   태그       설명                 Header       문서의 Header를 나타낼 때                 Footer       문서의 Footer를 나타낼 때                 Nav       문서 내 네비게이션(Navigation) 요소가 있을 때                 Section       문서의 영역을 구성, 문서 구조를 구성하는 H1~H6와 함께 사용                 Article       뉴스기사나 블로그 Article과 같은 독립된 Contents를 표시할 때 사용                 Aside       주요 컨텐츠 이외의 참고가 될 수 있는 컨텐츠를 구성할 때 사용                 Figure       그림, 비디오와 같은 포함된 컨텐츠의 Caption 을 표시할 때 사용                 Figcaption       캡션에 사용                 Details       사용자가 필요에 따라 보거나 숨길 수 있는 세부정보를 지정                 Summary       details 요소 안에 보이는 머리글을 정의.   summary를 클릭하여 세부정보를 보거나 숨길 수 있음                 Main       문서의 중요내용을 지정. 고유한 내용. 둘 이상의 main 태그가 존재할 수 없음                 Mark       텍스트 부분을 강조                 Meter       알려진 범위 또는 또는 분수값내에서 스칼라 측정을 정의                 Progress       진행바를 표시                 Time       일자/시간을 정의하는 태그                 Wbr       텍스트에서 줄 바꿈을 추가할 수 있는 위치 지정   (같은 기능의 br 와 달리 공간이 충분할 경우에는 줄바꿈을 수행하지 않음)          ","categories": ["study"],
        "tags": ["HTML5"],
        "url": "https://many258.github.io/study/html5/",
        "teaser": "https://many258.github.io/assets/images/html5/html5.jpg"
      },{
        "title": "[면접/Interview] 면접 시 준비항목 및 키포인트",
        "excerpt":"자주 나오는 질문들  자신을 소개하십시오  ❓ 질문의도  일반적으로 서류상의 내용들을 간략하게 듣기 위한 경우이며, 면접대상자의 언어구사력, 표현력 등을 판단.   🔑 올바른 답변  자기 소개는 자신의 PR입니다. 업무와 연결되는 장점, 성취업적을 부각시켜야 합니다.  2~3분 정도가 가장 적당하며, 회사가 왜 자신을 고용해야 하는지 자신의 주장이나 생각을 숫자, 금액 등을 이용해서 말합니다.   이 때 자신감이 가장 중요한 요소로 여겨집니다.   💯 답변 예시     신입사원의 경우, 학력 및 현재상황을 중심으로 답변   경력사원의 경우, 경력위주(성취업적, 수행업무, 특기사항 등) 중심으로 답변   우리 회사에 지원하게 된 계기는 무엇입니까? (= 지원동기)  ❓ 질문의도  회사의 기여도 및 개인의 목표의식을 알아보려는 질문.  또한 회사에 공헌할 의지가 있는지 아니면 회사가 제공하는 안정, 혜택에만 관심이 있는지를 파악하려는 질문입니다.   🔑 올바른 답변  이 질문에 대한 답변은 자신의 장점을 최대한 부각시켜야 합니다.  업무와 연결하여 자신이 회사를 위해 무엇을 할 것이며, 무엇을 해결할 수 있는지를 구체적으로 말합니다.   이 질문의 답변을 위해 회사의 대한 정보나 자료 수집이 중요합니다.  (회사연혁, 사훈, 경영이념, 가치관, 회사의 대표사업모델, 회사의 자제적 능력개발에 대한 제안, 상품, 기업문화 등)   회사업무 및 당면문제 등을 해결하는데 적절한 능력과 경력을 갖추고 있음을 언급하는 것 또한 좋은 인상을 받을 수 있습니다.  특정분야에 경험, 경력, 자격이 없다면 이 일에 대한 열정을 강조하여 어필합니다.   💯 답변 예시     저는 ~에서 모집하는 분야에 있어 ~한 업무 경력과 업무수행, 업적등으로 인해 누구보다도 업무를 잘 진행할 수 있다고 확신합니다.   저는 모집분야에 있어 최고의 전문가가 되겠다는 강한 목표가 있습니다.   귀사는 매우 빠른 성장을 보이는 회사입니다. 현재의 규모는 작지만 앞으로의 성장 가능성을 믿고 같이 일하고 싶습니다.   전 직장에서 경력은 무엇입니까? ( = 경력사항)  ❓ 질문의도  회사에서 모집하는 업무에 적합한 사람인지 파악하려는 질문   🔑 올바른 답변  체계적이고 실질적인 답변이 중요  실제 사례를 들어 문제상황, 해결 과정 등을 가급적 금액, 숫자, %와 같이 구체적으로 답변  지원회사에서 필요한 자질과 능력에 초점   💯 답변 예시     공정관리를 보다 효율적으로 수행하여 생산성을 00% 높였습니다.   사무실내 관련서류를 전산화하여 업무를 효육성 있게 만들고 회사 경비를 00% 줄였습니다.   품질관리 부분에서 불량률을 00% 정도 줄였습니다.   회사를 왜 퇴직하였는지? 이직하는 이유는 무엇입니까?  ❓ 질문의도  전 직장에서 왜 퇴사하는지? 또 다시 퇴사를 반복할 것인지? 처음 회사에 입사했을 경우 얼마나 일할 사람인지 도는 퇴사이유가 합리적인 부분인지,  구직자의 성향이 어떠한 사람인지 등 대부분 기업이 불안정하기 때문에 이 불안감을 해소하고자 계속해서 확인 차 면접자에게 물어보는 질문   🔑 올바른 답변  전 직장에 대한 어떠한 부정적인 답변을 하지 않습니다.  단어조차도 긍정적인 답변으로 예로서 ‘희망퇴직’, ‘업무가 없어짐’, ‘라인드롭’과 같은 표현을 사용해야 합니다.   기타 ‘도전과 배움에 대한 열망’, ‘새로운 분야로의 접근’, ‘자신의 능력을 향상시켜 보여줄 수 있는 직업선택’ 등이 있습니다.   회사나 상사와의 좋지 않은 감정에 대한 언급은 절대 없어야 합니다.  퇴직을 자청한 이유는 본인에게 더 큰 만족을 줄 수 있는 좋은 직종에서 일을 하고 싶어한다는 부분이 강조되어야 합니다.   💯 답변 예시     중소업체에서 다양한 분야의 일을 하고 싶습니다. 현재 직장은 일은 좋지만 역할이 너무 제한되어 있습니다.   비중 있는 역할을 위해 더 성장 가능성이 있는 귀사에 지원하였습니다.   이전 직장보다 좀 더 제 능력을 인정 받는 곳에서 일을 하고 싶습니다.   원하는 급여는 어느정도 입니까?  ❓ 질문의도  일과 급여는 매우 밀접한 상관관계가 있습니다.  급여에 따라 회사에서의 의욕과 열의, 근무 여부, 재직 후 이직여부 등 여러가지 복합적인 부분을 알아보려는 질문.   🔑 올바른 답변  지원자는 면접 전에 회사의 급여에 대한 정보를 확보하는 것이 현명합니다.  면접 초기 단계는 고용에 대해 회사에서도 확신이 없는 단계이며, 정확한 급여가 정해지지 않을 수 있습니다.  급여는 일을 선택하는데 고려할 것 중의 한가지에 불과하며 그보다는 일 자체에 대해 자세하게 알고 싶다고 말하는 것이 현명합니다.  특히 경력자들은 급여부분에 있어 너무 많은 것을 요구하면 탈락하는 경우가 있습니다.  지원자가 원하는 액수를 말한다면 지원자가 돈에 연연하는 인상을 줄 수 있습니다.  회사가 생각하는 액수보다 높을 경우 지원자를 채용하지 않을 수 있습니다.   💯 답변 예시     제 자신의 경력으로는 어느 정도의 급여가 가능합니까?   정말 중요한 것은 적당한 업무를 찾는 것이며 저의 경력과 자질을 고려할 때, ~ 이상이 되리라 생각합니다.   급여도 중요하지만 매일 제가 맡아야 되는 업무 내용이 더 중요합니다. (회사의 급여 정보를 확보했을 시)   지금까지 취업을 왜 못하셨나요?  ❓ 질문의도  한 직장에 오래 근무할 수 있는지 파악하려는 질문.  오랜 기간동안 취업을 못해 심리적으로 위축된 구직자를 기업에서는 부정적으로 보는 경향이 있습니다.  또한 일할 의욕과 의지를 가지고 있는 사람인지도 평가할 것입니다.   시간상 공백기간은 면접관으로부터 그 동안의 생활, 인생의 목표, 비전의 확립 등에 대한 집요한 질문의 표적이 됩니다.   🔑 올바른 답변  지원자가 지원하고자 하는 분야에 좀 더 능력과 특기를 살리기 위해서 그리고 궁극적으로 회사에 이바지할 수 있는 적합한 직종을 찾는 기간이라는 점이 부각되어야 합니다.  지원자의 목적이 무조건 취업이 아니고 지원자 자신의 적성과 자질을 살려 회사에 기여할 수 있는 직종을 찾아다닌다는 것이 부각되어야 합니다.   또한 구직기간 동안 자신의 능력 및 경력을 향상(학업, 학원수강 등)시켰다는 점이 나타나는지를 평가합니다.   💯 답변 예시     제가 지닌 경력과 능력을 바탕으로 기여할 수 있는 일을 찾고 있습니다.   일을 찾는 것은 어렵지 않지만 정말 제가 원하는 일을 찾는 것은 쉽지 않았습니다. 지금은 귀사를 위해 큰 기여를 할 준비가 되었습니다.   장점이 무엇입니까?  ❓ 질문의도  당신의 장점이 회사에서 필요한 사람인지를 파악하려는 질문.   🔑 올바른 답변  업무를 수행하는데 회사가 중요하게 생각하는 것과 지원자의 답변이 어떠한 연관관계가 있는지를 파악합니다.   지원자의 장점을 통해 수행한 부분이 무엇인지를 판단합니다.  업무와 관련된 신임, 열의, 책임감 등의 실례를 유도하여 판단합니다.   💯 답변 예시     저는 두 가지 장점이 있는데 하나는 분석능력이고 다른 하나는 문제해결능력입니다. 이러한 두 가지 능력으로 문제를 해결하는데 뛰어납니다.   저는 추진력이 강합니다. 일을 완수할 때까지 적극적으로 움직입니다.   저의 장점은 진지하고 성실한 것입니다. 전직장의 상관도 저의 성실성과 진지함을 인정하셨습니다.   저는 목표가 뚜렷하고 그 목표를 위해 계속 노력한다는 것이 장점입니다.   단점은 무엇입니까?  ❓ 질문의도  업무수행에 있어 문제가 될 수 있는지를 파악하려는 질문.   🔑 올바른 답변  업무를 수행하는데 문제가 될 만한 단점은 언급하지 않습니다.  약점으로 여겨질 수 있는 지원자의 단점을 최대한 장점화 시켰는지를 봅니다.   지원자가 업무를 수행하는데 어떤 작은 단점이라도 극복할 자신이 있음을 판단합니다.   💯 답변 예시     나이가 많다는 부분이 단점이지만 저의 전문분야에 대한 더 많은 지식과 훈련 습득을 볼 때, 업무에 안정되고 책임감이 있다고 할 수 있습니다.   결정에 있어 너무 신중해 느릭 결정을 내리곤 합니다. 올바른 결정이 빠른 결정보다 중요하다 생각합니다.   일에 집중하면 동료에게 매우 냉정합니다. 그 외 업무수행에 문제될 큰 단점은 없습니다.   5년(10년) 후의 당신의 비전은 무엇입니까? ( = 미래계획)  ❓ 질문의도  목표를 이루기 위해 지원자의 노력과 진지함을 묻는 질문.  확고한 장/단기 목표와 그 목표를 이루기 위해 구체적인 행동의식을 파악합니다.   🔑 올바른 답변  이력이나 면접에서의 목표를 위해 과거에 무엇을 했고 앞으로는 무엇을 할 것인자를 구체적으로 체계적으로 답변합니다.   💯 답변 예시     컴퓨터 능력을 겸비한 예산전문 회계사가 되고 싶습니다.   모든 직원에게 신뢰를 받고 존경받는 관리자가 되고 싶습니다.   5년 내 저희 동료들도 믿고 따를 수 있는 능력을 겸비한 관리자가 되고 싶습니다.   더 질문이 있습니까?  ❓ 질문의도  회사는 회사에 대해 특별한 관심과 열의가 있는지 파악할 수 있는 질문.   아무 질문이 없으면 해당분야에 정보 및 경험이 없다고 이해할 수 있습니다.   🔑 올바른 답변  지원자가 회사에 대해 미래지향적인 생각을 갖고 있음을 파악합니다.  질문을 통해 지원자의 특징을 부각할 수 있습니다.   지원자의 희망업무나 회사에 대한 파악은 회사에 대한 특별한 관심을 보여줄 수 있습니다.  그러나, 급여/혜택/근무시간/휴가에 대한 질문은 최종 결정이 될때까지 삼가야 할 질문 중에 하나입니다.   💯 답변 예시     지금의 직책은 어떤 사업부문에 속합니까?   해당 업무에서 수행해야 할 목표는 무엇입니까?   업무를 수행하기 위해 추가적인 교육은 어떤 것이 있습니까?   본인이 해결해야 하는 문제와 업무는 어떤 것이 있습니까?   제가 갖추어야 하는 가장 중요한 요소들은 무엇이 있습니까?   일반적인 질문들  당신의 성격은 어떻습니까?  면접대상자가 서부사료에 적합한지의 여부를 판단하기 위한 질문.  회사의 분위기와 문화에 맞는지를 판단.   성격은 반드시 지원자가 지원하는 직종에 적합하도록 성격 특성도 준비되어 있는지를 판단합니다.   당신의 취미는 무엇입니까?  지원자가 균형잡인 생활을 하고 있는지를 판단하는 질문.  취미생활을 위한 적당한 시간할애는 하고 있는지, 취미를 위해 너무 많은 시간을 보내고 있는지를 판단.  중요한 점은, 지원자의 취미생활 및 여가활동이 지원자의 성격과 가치관을 반영한다는 점을 염두해두어야 합니다.   어떤 종류의 책을 읽으십니까?  지원자가 지원하는 직업과 관련한 전문서적에 관해 언급하는 지를 보고 판단.  만약, 취미로 읽는 책에 관해서도 언급한다면 독서 생활을 균형있게 한다는 것을 보여주는 것으로 판단할 수도 있습니다.   팀 별로 일하는 부분에 문제가 없는지?  대답은 지원자가 지원한 분야가 독자적인 업무인지 아니면 팀 별로 일하는 부분인지를 사전에 파악했는지 여부를 판단.  때때로 혼자 일하는 것이 시간이 절약되는 경우가 있지만 서로의 생각을 공유함으로 더 나은 결과를 얻을 수 있다는 점이 강조되어야 합니다.  체계적인 조직의 통제력을 받을 때 독창적이고 혁신적인 성과를 거두는 경우가 많습니다.   우리 회사에 대해 알고있는 점은?  지원자가 지원하는 회사에 대해 나름대로 관심을 가져왔다는 점을 판단.  회사의 전망, 시장상황, 기술 여건 등에 대한 지원자의 생각을 유도하는 것이 중요합니다.   어려운 업무상황에 처했을 경우 어떻게 문제해결을 했는지?  힘든 상황을 극복하거나 개선하기 위해 지원자가 어떤 기술을 사용했는가의 관점에서 판단.  조직문화에 따라 회사의 마찰, 팀 관리, 직원관리 등에 역점을 둘 수 있습니다.  만일 지원자가 지원하는 회사에서도 동일한 문제가 존재한다면 이에 대해 긍정적으로 대처할 것인지 부정적으로 대처할 것인지를 봅니다.  지원자가 그러한 문제를 극복하고 개선시킬 수 있는 것이라면 그러한 지원자의 능력이 무엇인지를 판단합니다.   이전직장에서 보람됐던 일은?  전 직장에서 업무를 수행하면서 팀 별로 업무를 완수한 일, 계획수립 후 업무완수, 과도한 업무 끝에 성공한 일들이 무엇인지를 봅니다.   이전 상사에 대해 어떻게 생각하십니까?  지원자가 이전 직장 상사와 갈등의 관계에 있었는지를 판단.  만약 이전 상사에 대해 좋은 감정을 가지고 있다면 그 이유가 무엇인지에 대한 질문을 유도합니다.   우리 회사에서 뚜렷한 성과를 이룰때까지 어느정도 기간이 소요되리라 생각합니까?  가능한 한 현실적인 답변을 하는 지원자가 좋은 평가를 받으며 보통 6개월에서 1년 정도의 구체적 기간을 언급하는 것이 효과적입니다.  수긍이 가는 대답을 할 수 있을 정도로 직책에 대한 정보를 가지고 있는 것이 중요합니다.   당신의 관리 스타일은?  회사는 관리자의 스타일로서 높은 참여 의식을 선호하는지 아니면 권위주의 선호하는지에 대해 알려고 합니다.   상황 예시 후 어떻게 문제를 해결할 것인지 말씀해보십시오.  상황과 관련하여 지원자의 성과나 업적을 보여줍니다.  조직의 문화나 필요에 따라 경영상에 있어서 마찰, 팀 관리, 부하 직원 관리 등에 대해서 역점을 둘 수도 있습니다.   관리자로서 직원을 고용할 때는 어떤점을 중요시하십니까?  직원의 능력, 솔선함, 적응능력, 성향이 조직에 적합한가 여부를 판단합니다.   업무적인 측면에서 힘들었던 상황은?  이러한 힘든 상황을 극복하거나 개선하기 위해 지원자가 어떤 기술을 사용했는가의 관점에서 봅니다.  문제를 극복하고 개선시킬 수 있는 것이라면 그러한 지원자의 능력이 강조되었는지를 평가합니다.   이전 직장에서 성취하지 못했던 목표와 그 이유는?  지원자가 계획된 모든 목표를 달성했다면 그 사실을 그대로 답변합니다.   정당한 이유로 해낼 수 없었다면 통제할 수 없었던 부분에 대한 설명을 유도합니다.  통제할 수 없었던 장애물로 인하여 당신이 재조정해야 했던 목표에 대해 어떻게 대처했는지는 보는 것이 중요합니다.   리더로서의 경험을 사례를 들어 말씀해주십시오.  지원자의 리더십 기술을 증명하는 성과 등을 예로 들어 답변합니다.   지원자의 전 상사는 당신의 장점의 단점은 무엇이라고 생각하십니까?  전 직장 상사가 이에 대해 어떻게 대답할 것인지 일관성있게 답변하는지를 평가합니다.  어떤 단점이라도 긍정적으로 얘기하고 있는지를 봅니다.  대부분 이전 직장의 상사는 지원자에게 좋은 신용보증을 해주려 할 것입니다.  그러니 되도록 지원자는 상사를 위해 했던 좋은 일들을 많이 열거하도록 합니다.   단답형 질문  지망 동기에 관한 질문     다른 회사에 지망한 적이 있습니까?   우리회사를 들어오기 전에 본인이 특별히 노력한 것이 있습니까?   우리회사의 제품을 보신적이 있습니까? 어떻게 생각하는지?   회사를 선택할 시 중요시하는 것은 무엇입니까?   추천인과는 어떤 관계입니까?   우리회사에 채용이 안되면 어떻게 하실 예정입니까?   우리회사와 다른 회사가 동시에 합격되었을 경우 어떻게 하실겁니까?   지망회사를 결정하기 위해 누구와 상담하셨습니까?   우리회사와 같이 중소기업을 선택한 이유는 무엇입니까?   우리회사의 장점과 단점은?   집에서 회사까지 시간이 얼마나 소요됩니까?   업무에 대한 질문     당신이 희망하는 직종은?   상사와 의견이 다를 경우에 어떻게 하겠습니까?   입사 후 자신이 싫어하는 업무를 맡았을 때 어떻게 하겠습니까?   지방근무를 할 수 있습니까?   이 회사에 입사한다면 어떤 업무를 맡고 싶습니까?   당신에게 직업은 무엇입니까?   입사하면 어떤 일을 하고 싶습니까?   희망부서에 배치되지 않을 경우에 어떻게 하겠습니까?   희망하는 근무지   일과 개인 생활 중 어느 쪽을 선호하십니까?   어떤 일이 적성에 맞는다고 생각합니까?   당신의 특성을 일에서 어떻게 살릴 생각입니까?   입사 후 다른사람에게 절대로 지지 않을 만한 것은?   회사에 대해 묻고 싶은 것은?   비즈니스 사회에서 가장 중요한 것은?   우리회사에서 언제까지 근무할 생각입니까?   어디까지 승진할 예정이십니까?   어떤 사람을 상사로 모시고 싶습니까?   첫 월급을 받으면 어디에 사용할 것입니까?   상사와 의견이 다를 경우에 어떻게 할것입니까?   자기 주장과 협조정신은 무엇입니까?   당신의 포부는 무엇입니까?   자신에 대한 질문     당신의 개성은 무엇입니까?   리더십이 있습니까?   협조정신이 있습니까?   친구가 많습니까?   사람과 이야기하는 것을 좋아합니까?   사람과 함께 있는 것을 좋아합니까?   어떤 성향의 사람을 좋아합니까?   지금까지 좌절감을 느껴본 적이 있습니까?   대인관계를 잘 유지할 자신이 있습니까?   당신은 주위로부터 의논을 받는 편입니까?   일을 시작하면 끝까지 합니까?   살면서 가장 기뻤던 경우와 슬펐던 경우에 대해 말씀해 주십시오.   자신에게 있어 가장 소중한 것은 무엇입니까?   타인의 입을 통한 본인의 평가는 무엇입니까?   생활신조는 무엇입니까?   학창시절에 대한 질문     출신학교 및 본인의 전공은 무엇이며 전공을 선택한 이유는?   학창시절 서클활동과 내용에 대해서 간단히 말씀부탁드립니다.   아르바이트를 해본 경험이 있습니까?   어떤 면을 보고 친구를 사귑니까?   대학생활에서 얻은 것이 있다면 무엇입니까?   제일 좋아하는 과목은 무엇입니까?   친하게 지내는 친구는?   친구는 당신에게 어떤 존재입니까?   친구들은 당신을 어떻게 본다고 생각하십니까?   개인의 인생관     인생의 좌우명이 있다면 무엇입니까?   자신의 인생지표가 되는 사람이 있다면 누구입니까? 그 이유는 무엇입니까?   10년 뒤 당신의 모습은?   휴일에 시간을 어떻게 보냅니까?   기상시간과 취침시간은 언제입니까?   최근에 읽은 책의 내용과 느낀점을 말씀해 주십시오.   신문을 자주 봅니까? 어느 분야를 우선적으로 봅니까?   최근에 흥미있게 본 뉴스에 대해 말씀해 주십시오.   존경하는 사람은 누구입니까?   건강관리를 위해 어떤 것들을 하실겁니까?   지금 가장 원하는 것은 무엇입니까?   기타 질문     앞으로의 포부를 말씀해 주십시오.   자신이 본 책/영화 중 가장 감명 깊게 본 책/영화는 무엇입니까?   현재 가장 하고 싶은 일은 무엇입니까?   어려운 일이 생기면 주로 누구와 상의합니까?   입사하게 되면 회사에 바라는 것은 무엇입니까?   스트레스가 누적되면 어떻게 해결하려고 합니까?   앞으로의 계획은 무엇입니까?   ","categories": ["study"],
        "tags": ["Interview"],
        "url": "https://many258.github.io/study/interview-keypoint/",
        "teaser": null
      },{
        "title": "[알고리즘] 정렬 알고리즘(Sorting Algorithm)",
        "excerpt":"정렬 알고리즘     원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘    내부정렬(Internal Sort)     입력의 크기가 주기억 장치의 공간보다 크지 않은 경우    외부정렬(External Sort)     입력의 크기가 주기억 장치 공간보다 큰 경우, 보조 기억 장치에 있는 입력을 여러 번에 나누어 사용    계산 복잡도 이론(Computational Complexity Theory)  복잡도의 기준은 알고리즘이 소모하는 소요 시간과 메모리 사용량 등의 자원이다.  전자를 시간 복잡도, 후자를 공간 복잡도라 한다.   알고리즘의 시간복잡도는  어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법인 점근 표기법 중 빅오 표기법을 사용한다.   빅 오 표기법(Big-O)     수리과학의 여러 분야에서 함수의 증감 추세를 비교하는 표기법이다    알고리즘에서 시간의 복잡도를 표시하기 위하여 대문자 오(O)를 사용하여 나타내는 표기.  입력된 데이터의 크기를 n이라 가정할 때, O(n), O(2) 등으로 표기한다.      O(1)  상수시간 입력값이 아무리 커도 실행 시간이 일정한 경우 최고의 알고리즘이지만 상수값이 매우 크다면 의미가 없다. 해시 테이블의 조회 및 삽입   O(log n)  로그시간 매우 큰 입력값에도 크게는 영향을 받지 않는 경우 입력값에 영향을 받기 시작하지만 크기가 어느만큼 커져도 견고한 편이다 이진 검색   O(n)  선형시간 입력값만큼 실행 시간에 영향을 받는 경우 원하는 값을 찾기 위해 적어도 모든 입력을 살피게 되는 경우 정렬되지 않은 리스트에서 값 탐색   O(n log n)  선형-로그시간 대부분의 효율 좋은 정렬 알고리즘 병합 정렬   O(n2)  2차시간 입력값의 제곱만큼의 시간이 소요되는 경우 버블 정렬 등 비효율적인 정렬 알고리즘   O(2n)  지수시간 재귀로 계산되는 경우   O(n!)  팩토리얼시간 가장 짧은 경로를 찾는 문제 등에 브루트 포스로 풀이 무차별로 대입하는 경우로 제일 느린 알고리즘.      버블 정렬(Bubble Sort)     이웃하는 숫자를 비교하여 작은 수를 앞쪽으로 이동시키는 과정을 반복하여 정렬하는 알고리즘  오름차순으로 정렬할 때, 작은 수는 배열의 앞부분으로 이동하는데, 배열을 좌우가 아니라 상하로 그려보면 정렬하는 과정에서 작은 수가 마치 거품 처럼 위로 올라는 것에서 영감    거의 모든 상황에서 최악의 성능, 효율성이 낮다   의사코드   크기가 n인 배열A  for pass = 1 ~ n-1   for i = 1 ~ n-pass     if (A[i-1] &gt; A[i])       swap A[i-1], A[i]  return A            복잡도                                            최선 시간복잡도       O(ｎ)                 평균 시간복잡도       O(n2)                 최악 시간복잡도       O(n2)                 공간복잡도       O(ｎ)           선택정렬(Selection Sort)  입력 배열 전체에서 최솟값을 선택하여 배열의 0번 원소와 자리를 교환하고,  다음에는 0번 원소를 제외한 나머지 원소에서 최솟값을 선택하여 배열의 1번 원소와 자리를 바꾸는 과정이 정렬이 완료될 때까지 반복한다.   의사코드  크기가 n인 배열A  for i = 0 ~ n-2   min = i   for j = i+1 ~ n-1     if(A[j] &lt; A[min])       min = j   swap A[i], A[min] return A            복잡도                                            최선 시간복잡도       O(n2)                 평균 시간복잡도       O(n2)                 최악 시간복잡도       O(n2)                 공간복잡도       O(ｎ)           삽입정렬(Insertion Sort)  배열이 정렬된 부분과 정렬이 안 된 부분으로 나누고,  정렬이 안 된 부분의 가장 왼쪽 원소를 정렬된 부분의 적절한 위치에 삽입하고 그 뒤의 원소를 한 칸씩 뒤로 밀어내는 방식   의사코드  크기가 n인 배열A  for i=1 ~ n-1   currentElement = A[i] # 정렬이 안 된 부분의 가장 왼쪽 요소   j = i-1   while(j &gt;= 0) &amp;&amp; (A[j] &gt; CurrentElement)     A[j+1] = A[j]     j = j-1   A[j+1] = CurrentElement return A              복잡도                                            최선 시간복잡도       O(ｎ)                 평균 시간복잡도       O(n2)                 최악 시간복잡도       O(n2)                 공간복잡도       O(ｎ)           병합정렬(Merge Sort)  입력이 2개의 부분문제로 분할되고, 부분문제의 크기가 1/2로 감소하는 분할 정복 알고리즘 즉, N개의 숫자들을 N/2개씩 2개의 부분문제로 분할하고,  각각의 부분문제를 재귀적으로 합병 정렬한 후,  2개의 정렬된 부분을 합병하여 정렬한다.   데이터 크기만한 메모리가 더 필요하지만 최대의 장점은 데이터의 상태에 별 영향을 받지 않는다는 점이다.   의사코드   MergeSort(A, p, q) # 입력 A[p]~A[q]  if(p &lt; q&gt;)   k = |(p+q)/2|   MergeSort(A, p, k)   MergeSort(A, k+1, q)   A[p]~A[k] / A[k+1]~A[q] 합병            복잡도                                            최선 시간복잡도       O(ｎlogｎ)                 평균 시간복잡도       O(ｎlogｎ)                 최악 시간복잡도       O(ｎlogｎ)                 공간복잡도       O(ｎ)           힙정렬(Heap Sort)  힙(Heap)     힙은 힙 조건을 만족하는 완전 이진트리이다.  힙 조건이란, 각 노드의 값이 자식 노드의 값보다 커야하는 것을 의미.  노드의 값은 우선순위라고 일컫는데 따라서 힙의 루트에는 가장 높은 우선순위(가장 큰 값)가 저장되어 있다.    힙 정렬은 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법이다.   힙의 루트에는 가장 큰 수가 저장되므로, 루트의 숫자를 힙의 가장 마지막 노드에 있는 숫자와 교환한다.  (즉, 가장 큰 수를 배열의 가장 끝으로 이동시킨 것)  루트에 새로 저장된 숫자로 인해 위배된 힙 조건을 해결하여 조건을 만족시킨다.  힙 크기를 1 줄인다. (루트를 출력하고 힙에서 제거)  이러한 과정을 반복하여 나머지 원소를 정렬한다.   추가적인 메모리를 전혀 필요로 하지 않는다는 점과, 최악의 경우 O(n2)의 성능을 내는 퀵정렬과 달리 항상 O(ｎlogｎ) 정렬의 성능을 발휘하는 장점이 있다.   의사코드   heapify(i) # 위배된 힙 조건을 만족시키기 위한 함수   l = 왼쪽노드   r = 오른쪽노드   if(l &lt;= Heapsize &amp;&amp; A[l]&gt;A[i])     big = l   else     big = i   if(r &lt;= Heapsize &amp;&amp; A[r]&gt;A[big])     big = r   if big != i     swap A[i], A[big]     heapify(i)  build_max_heap()   HeapSize = Length   for i = Length/2 ~ 1 (--)     heapify(i)  build_max_heap(A) for i = length ~ 2   swap A[1], A[i]   HeapSize = HeapSize-1   heapify(A, i)             복잡도                                            최선 시간복잡도       O(ｎlogｎ) 모든 키가 구별되는 경우                 평균 시간복잡도       O(ｎlogｎ)                 최악 시간복잡도       O(ｎlogｎ)                 공간복잡도       O(ｎ)           셀정렬(Shell’s Sort)     삽입 정렬이 거의 정렬된 배열에서 최적의 성능을 내는 것에서 착안한 정렬 방법  버블 정렬, 삽입 정렬에서 이웃하는 원소의 숫자들끼리의 비교를 통해서 느리게 이동하는 단점을 보완    삽입 정렬을 이용하여 배열 뒷부분의 작은 숫자를 앞부분으로 빠르게 이동시키고,  동시에 앞부분의 큰 숫자는 뒷부분으로 이동시키며, 가장 마지막에는 전체에 대해 삽입 정렬을 수행한다.   의사코드   for each gap h 큰 간격 부터 차례로   for i = h ~ n-1     CurrentElement = A[i]     j = i     while(j &gt;= h) &amp;&amp; (A[j-h] &gt; CurrentElement)       A[j] = A[j-h]       j = j-h     A[j] = CurrentElement return A            복잡도                                            최선 시간복잡도       O(ｎlogｎ)                 평균 시간복잡도       O(ｎlogｎ)                 최악 시간복잡도       O(n4/3)                 공간복잡도       O(ｎ)           퀵정렬(Quick Sort)  원소 하나를 기준(피벗)으로 삼아 그보자 작은 것은 앞으로 빼내고 그 뒤에 피벗을 옮겨 피벗보다 작은 것, 큰 것으로 나눈 뒤 나누어진 각각에서 다시 피벗을 잡고 정렬해서 각각의 크기가 0이나 1이 될 때까지 정렬.   의사코드  QuickSort(A, l, r) # 배열A, 왼쪽, 오른쪽 if(l &lt; r)   피봇(p)을 A[l]~A[r] 중 적절한 알고리즘으로 인하여 선택   피봇을 A[l]과 교환한 후   피봇과 배열의 각 원소를 비교하여 피봇보다    작은 숫자들은 A[l] ~ A[p-1]로 옮기고   큰 숫자들은 A[p+1] ~ A[r]로 옭기고 피봇은 A[p]에 놓는다.   QuickSort(A, l, p-1)   QuickSort(A, p+1, r)            복잡도                                            최선 시간복잡도       O(ｎlogｎ)                 평균 시간복잡도       O(ｎlogｎ)                 최악 시간복잡도       O(n2), 피벗을 최대값/최소값으로 설정할 경우                 공간복잡도       O(n)           기수정렬(Radix Sort)     비교정렬이 아닌, 숫자를 부분적으로 비교하는 정렬 방법 제한적인 범위 내에 있는 숫자에 대해서 각 자릿수별로 정렬하는 알고리즘.    어느 비교정렬 알고리즘보다 빠르다는 장점을 가지고 있다.   의사코드   n개의 r진수 for i = 1 ~ K(K자리 숫자)   각 숫자의 i자리 숫자에 대해 안정한 정렬을 수행 return A  복잡도                                            최선 시간복잡도       O(ｎ)                 평균 시간복잡도       O(dn) d는 데이터의 자릿수                 최악 시간복잡도       O(dn)           정렬 알고리즘의 속도 비교    ","categories": ["study"],
        "tags": ["Algorithm"],
        "url": "https://many258.github.io/study/sorting-algorithm/",
        "teaser": null
      },{
        "title": "[리눅스] 기본 디렉토리 구조",
        "excerpt":"주요 디렉토리  리눅스의 디렉토리 혹은 파일 시스템 구조는 윈도우와는 조금 다른 구조를 가지고 있습니다.  기본적으로 디렉토리를 구분하는 ‘/’(슬래시)는 리눅스에서 사용하고 윈도우는 반대인 ‘'(역슬래시)를 사용합니다.  디렉토리 또한 그 명칭을 리눅스에서는 디렉토리(directory), 윈도우에서는 폴더(folder)라고 지칭합니다.   리눅스 시스템의 디렉토리 구조는 전체적으로 역 트리(tree) 구조를 하고 있습니다.  그리고 명령어의 종류와 성격, 사용권한등에 따라 각각의 디렉토리들로 구분됩니다.  리눅스 배포판들은 ‘리눅스 파일시스템 표준’ 인 FSSTND(LINUX FILE System Standard) 라는 표준을 준수하므로 대부분의 리눅스 배포판들은 그 기본 골격이 같습니다.      /(루트)  최상의 디렉토리인 루트 디렉토리를 의미하며, 리눅스의 모든 디렉토리들의 시작점이다. 모든 디렉토리들을 절대경로로 표기할 때에 이 디렉토리로부터 시작해야 한다.   /bin  Binary의 약자로 기본적인 명령어가 저장된 디렉토리.  리눅스 시스템사용에 있어 가장 기본적이라고 할 수 있는 mv, cp, rm… 등과 같은 명령어들이 이 디렉토리에 존재하며  root 사용자와 일반사용자가 함께 사용할 수 있는 명령어 디렉토리이다.   /sbin  bin과 유사하나 ifconfig, e2fsck, ethtool, halt 등과 같이 주로 시스템 관리자 또는 루트 유저들이 사용하는 시스템관리자용 명령어(시스템 점검, 복구, 초기, 종료 명령 등)를 저장하고 있는 디렉토리.   /boot  리눅스 부트로더(Boot Loader)가 존재하는 디렉토리. GRUB 과 같은 부트로더에 관한 파일들(grub.conf 등)이 이 디렉토리에 존재한다.   /dev  시스템 디바이스(Device)파일을 저장하고 있는 디렉토리. 하드디스크 장치파일 /dev/sda, CD-ROM 장치파일 /dev/cdrom 등과 같은 장치파일들이 존재하는 디렉토리이다.   /etc  대부분의 환경설정 파일이 존재하는 디렉토리.  네트워크 관련 설정 파일, 사용자 정보 및 암호정보, 파일 시스템 정보, 보안파일, 시스템 초기화 파일 등 중요 설정 파일들이 위치.  /etc/sysconfig(시스템 제어판용 설정파일),  /etc/passwd(사용자관리 설정파일),  /etc/named.conf(DNS 설정파일) 등과 같은 파일들이 존재한다.   /etc/mai/  sendmail.cf 나 access 파일등의 sendmail 의 설정파일들이 존재하는 디렉토리.   /etc/ssh/  SSH 서비스, 즉 sshd 데몬에서 사용하는 각종 설정파일들이 존재하는 디렉토리.   /etc/squid/  squid 프록시서버의 설정파일들이 저장된 디렉토리.   /etc/samba/  삼바관련 설정파일들이 저장된 디렉토리   /etc/gnome/  GTK+ 정의파일들이 있음   /etc/skel/  계정사용자 생성시의 초기화파일들이 저장된 디렉토리(useradd 에서 사용함)   /etc/rc.d/  부팅레벨별 부팅스크립트파일들이 존재하는 디렉토리.   /etc/rc.d/init.d/  시스템 초기화 파일들의 실제파일들이 존재함.   /etc/pam.d/  PAM 설정 정보파일들이 저장된 디렉토리.   /etc/security  터미널 보안에 관련된 설정이 있음   /etc/httpd/  RPM 으로 설치된 아파치 설정파일(httpd.conf 등)들이 저장된 디렉토리.   /etc/cron.d/, /etc/cron.daily/, /etc/cron.hourly/, /etc/cron.monthly/, /etc/cron.weekly/  모두 크론설정파일이 존재하는 디렉토리임.   /etc/xinetd.d/  xinetd 수퍼데몬에 의해 서비스되는 서비스설정파일이 존재함.   /home  사용자의 홈디렉토리, useradd 명령어로 새로운 사용자를 생성하면 대부분 사용자의 ID와 동일한 이름의 디렉토리가 자동으로 생성됨.   /lib  커널모듈파일과 라이브러리파일.  커널이 필요로하는 커널모듈파일들과 프로그램(C, C++ 등)에 필요한 각종 라이브러리 파일들이 존재하는 디렉토리.   /media  DVD, CD-ROM, USB 등과 같은 탈부착이 가능한 장치들의 마운트포인트로 사용되는 디렉토리.   /mnt  /media 디렉토리와 비슷한 용도로 사용되나, 다른점은 사용자가 직접 마운트를 경로로 사용   /srv  서버를 위한 폴더. FTP/SFTP/RSync와 같은 프로토콜을 이용하여 외부 사용자와의 공유를 위해 사용   /sys  실제 디스크의 물리적 영역이 아닌 RAM을 기반으로 한 파일시스템.  커널 데이터에 대한 구조 속성 등 시스템 전반에 대한 내용을 제공   /proc  일명 가상파일시스템 이라고 하는 곳으로 현재 메모리에 존재하는 모든 작업들이 파일형태로 존재하는 곳이다.  디스크상에 실제 존재하는 것이 아니라 메모리상에 존재하기 때문에 가상파일시스템이라고 부른다.   현재 시스템 정보을 제공하며 존재하는 파일들 가운데 실행중인 커널(kernel)의 옵션 값을 즉시 변경할 수 있는 파라미터파일들이 있기 때문에 시스템 운용에 있어 매우 중요한 의미를 가진다.   /root  시스템 최고관리자인 root 사용자의 개인 홈 디렉토리.   /tmp  공용디렉토리. 시스템을 사용하는 모든 사용자들이 공동으로 사용하는 디렉토리.   /opt  응용프로그램 패키지 설치 장소. 패키지 매니저가 자체적으로 설치 및 삭제를 수행   /usr  User System Resource의 약자로 일반사용자들이 주로 사용하는 디렉토리. 각 유저 이름에 맞는 폴더이름이 생성되어 있으며 각 폴더마다 bin/sbin/shared/lib와 같이 각 유저들이 사용할 수 있는 폴더들이 위치   /usr/bin/  일반 사용자들이 사용가능한 명령어 파일들이 존재하는 디렉토리.   /usr/sbin/  /bin 에 제외된 명령어와 네트워크관련 명령어가 들어있는 디렉토리.   /usr/X11R6/  X 윈도우 시스템의 루트 디렉토리.   /usr/include/  C 프로그램에 필요한 헤드파일(*.h) 디렉토리.   /usr/lib/  /usr/bin과 /usr/sbin에 있는 실행 바이너리를 실행하기 위한 라이브러리 디렉토리   /usr/src/  프로그램 소스 및 주로 커널 소스가 저장되는 디렉토리.   /usr/local/  새로운 프로그램들이 설치되는 곳 (windows의 Program Files 와 유사)   /usr/share/man/  명령어들의 도움말을 주는 메뉴얼(manual)페이지 디렉토리.  이 디렉토리에는 시스템에서 사용하는 모든 맨페이지파일(man page)이 존재함.   /var  시스템 운용중에 생성되었다가 삭제되는 동적인 데이터를 일시적으로 저장하기 위한 디렉토리.  거의 모든 시스템 로그파일은 /var/log 에 저장되고,  DNS 의 zone 설정파일은 /var/named 에 저장되고,  메일파일은 /var/spool/mail 에 저장되며,  크론설정파일은 /var/spool/cron 디렉토리에 각각 저장됨.   /var/tmp/  /tmp 디렉토리와 같은 공용디렉토리.  /tmp 디렉토리와 /var/tmp 디렉토리의 퍼미션은 1777 로서 sticky bit 가 설정되어 있는 공용디렉토리이다.  리눅스 시스템에서 공용디렉토리는 /tmp 와 /var/tmp 둘뿐이다.   /var/log/  시스템로그파일(messages, secure, xferlog 파일등)이 저장되는 디렉토리.   /var/ftp/  vsftp 등과 같은 FTP 서비스를 위한 다운로드될 파일들   /var/named/  BIND 즉, DNS 에서 사용하는 zone 파일들이 저장되는 디렉토리.   /var/spool/mail/  각 계정사용자들의 메일파일이 저장되는 디렉토리.   /var/spool/lpd/  프린트를 하기 위한 임시 디렉토리(스풀링 디렉토리).   /var/spool/mqueue/  발송을 위한 메일 일시저장 디렉토리.   /var/spool/cron/  각 사용자들의 cron 설정파일들이 저장된 디렉토리.   /var/spool/at/  예약작업에 관한 파일들이 저장되는 디렉토리.   /lost+found  부팅시 파일시스템 손상이 되었을 때 사용되는 디렉토리.  평소에는 파일에 이상이 없으면 비어있음  ","categories": ["study"],
        "tags": ["Linux"],
        "url": "https://many258.github.io/study/linux-file-structure/",
        "teaser": null
      },{
        "title": "[리눅스] 계정 패스워드와 관련된 파일 (/etc/passwd, /etc/shadow)",
        "excerpt":"리눅스의 계정 관리 파일  리눅스에서는 파일로 사용자 계정을 관리합니다.  계정을 생성할 경우 다음과 같은 파일에 내용이 추가됩니다.   /etc/passwd : 계정을 관리하는 파일  /etc/shadow : 패스워드를 관리하는 파일   /etc/passwd 파일 구조   root : x : 0 : 0 : root : /root : /bin/bash                                                                                          root       x       0       0       root       /root       /bin/bash                 1       2       3       4       5       6       7           한 줄의 각 항목은 콜론 문자(:)에 의하여 분리되어 있으며 총 7개의 필드로 구성되어 있다.     사용자 명(ID)   사용자 패스워드. x로 되어있는 것은 /etc/shadow 파일에 암호화되어 저장되어 있다는 의미.   사용자 ID 를 의미하며 root 경우 0  adduser 스크립트에 의하여 부여됨.   사용자가 속한 그룹 ID 를 의미하며 root 경우 0   사용자 계정 이름 (정보)   사용자의 홈 디렉토리   사용자가 기본으로 사용하는 쉘 종류 지정   /etc/shadow 파일 구조   root : &amp;6$zF24Dfs5&amp;...(생략) : 15426 : 0 : 99999 : 7 :   :   :                                                                                                                           root       &amp;6$zF24Dfs5&amp;…       15426       0       99999       7                                                         1       2       3       4       5       6       7       8       9                           한 줄의 각 항목은 콜론 문자(:)에 의해 분리되어 있으며 총 9개의 필드로 구성되어 있다.     사용자 명(ID)   패스워드를 암호화시킨 값. 앞에 !가 있으면 잠긴 상태   (::) : 패스워드가 필요없다는 것을 나타낸다.   (:*:) : 계정을 막아두었다는 것을 나타낸다.   1970-01-01 날짜부터 패스워드가 수정된 날짜의 일수를 계산한 값   패스워드 최소 유지기간   0 이면 언제든지 바꿀 수 있다는 의미.   패스워드 최대 유지기간   99999 는 오랫동안 패스워드를 바꾸지 않았다는 것을 의미.   패스워드 만료 경고기간   패스워드 만료 전 경고 메세지가 나오는 일수    ex) 만료일이 90일이고, 만료 경고기간이 7일이면 83일부터 90일까지 7일동안 경고메지니가 나오다 91째 만료된다.   계정 잠김으로부터 남은 일수(패스워드 만료 후 계정이 잠기는 일수)   계정 만료 일자(비어있으면 만료 없음)   예약 필드(사용되지 않음).   /etc/shadow 내 2번째 필드      [$Hashid $Salt $Hash vlaue]    Hashid  적용된 단방향 해시 알고리즘을 나타냅니다.  사용되는 Scheme은 1.MD5 2. BlowFish 5. SHA-256 6. SHA512  주로 $1, $5, $6 이 많이 사용되는 HashID입니다.   Salt  해시는 기본적으로 단방향 함수이므로 이미 수행된 결과값을 이전값으로 복호화가 불가합니다.   공격을 시도하는 해커들은 레인보우테이블을 구비하는데, 여기서 레인보우테이블은 모든 해시의 쌍들을 미리 구해둔 데이터로 이를 이용하여 빠르게 대입해 패스워드를 크랙할 수 있습니다.   그래서, 이 공격을 힘들게 하기 위해 중간에 OS 내에서 생성하는 임의의 값인 Salt를 추가합니다.  마치 음식 간을 맞추기위해 소금을 첨가하는 것과 마찬가지로 Salt를 추가해서 암호화 강도를 높이는 역할을 합니다.   실제로 passwd 명령로 똑같은 암호로 변경한 후 shadow 파일을 확인해보면 값이 달라져있는 것을 확인할 수 있습니다.  이는 패스워드를 변경할 때마다 Salt 값이 변하기 때문입니다.   즉, 패스워크 크랙하기 위해서는 Salt 값을 알아야 하며 해당 Salt 값을 모르면 레이보우 테이블을 가지고 있어도 의미가 없게 됩니다.   Hash Value  HashID 에 따른 해시 방법과 Salt 값을 가지고 해쉬 함수를 수행한 결과.   관련된 리눅스 명령어           passwd [계정]  계정 비밀번호 설정                                  옵션           설명                             -s           사용자의 패스워드에 대한 정보 표시                             -d           계정 비밀번호를 삭제                             -l           계정 비밀번호 잠금 (로그인 잠금)                             -u           계정 비밀번호 잠금 해제                             -n           사용자가 암호를 바꾸지 못하는 Min day 설정                             -x           사용자 암호 변경없이 사용 가능한 Max day 설정                             -i           사용자 패스워드가 만료된 후 실제로 로그인이 불가능해질 때까지의 기간 설정                             -e           다음 로그인 시 무조건 패스워드를 변경하도록 하는 옵션                             -w           패스워드 만료 전 경고 날짜를 지정                                chage  사용자 패스워드를 관리하는데 사용. /etc/shadow의 날짜와 관련된 필드의 설정을 모두 변경할 수 있는 명령어                                  옵션           설명                             -l(대문자 : L)           사용자 패스워드에 대한 정보 표시                             -d           최근 패스워드를 변경한 날을 수정 (/etc/shadow 3번째 필드)                             -m           패스워드 변경 후 최소로 사용하는 날 지정                             -M           설정한 패스워드의 만기일을 지정                             -I (소문자 : i)           패스워드 만기일 이후 실제 패스워드가 사용 불가능해질 때까지의 기간                             -W           패스워드 만기 전 변경을 요구하는 경고 날짜 지정                             -E           계정이 만기되는 날을 지정                                pwconv  일반 패스워드에서 shadow 패스워드로 변경하는 명령어. 수행되고 나면 /etc/passwd 의 내용 중 두 번째 필드에 있는 암호화된 패스워드 부분만이 /etc/shadow 파일에 따로 저장.            pwunconv  shadow 패스워드에서 일반 패스워드로 되돌리는 명령어. /etc/shadow 파일에 보관되었던 패스워드를 다시 /etc/passwd 파일에 저장.      ","categories": ["study"],
        "tags": ["Linux"],
        "url": "https://many258.github.io/study/linux-security-structure/",
        "teaser": null
      },{
        "title": "[정보보안기사/정보보안일반] 보안 기술 요소",
        "excerpt":"정보보호     정보의 수집/가공/저장/검색/송신/수신 중에 정보를 훼손/변조/유출 등을 방지하기 위한 관리적/기술적 수단    정보보호 목표          기밀성(Confidentiality)  허가되지 않은 사용자가 기업 혹은 개인의 중요자료에 접근하거나 또는 중요자료가 유출되었을 때 그 내용을 알 수 없도록 암호화하는 것을 의미  접근 통제 측면에서 중요자료에 대해서 보안등급을 부여해 접근 및 열람이 가능한 주체를 정의하여 통제            무결성(Integrity)  중요자료에 대해서 임의적으로 변경하지 못하도록 하는 것을 의미. 대표적인 방법은 해시함수이며 종류로는 MD2, MD4, MD5, SHA가 존재.            가용성(Availability)  정당한 사용자가 서비스를 요청할 때 서비스를 제공할 수 있는 특성을 의미.  가용성을 확보하기 위해 주로 디스크, 네트워크, 서버를 이중화하며 RAID, DRS의 방법을 사용.  RAID : 디스크를 이중적으로 구성하여 하나의 디스크에 장애가 발생할 경우 백업된 디스크를 사용해서 중단 없이 시스템을 이용.  DRS : 재해복구시스템으로 서버를 2대의 Active로 구성하여 한 대의 서버에 장애가 발생해도 2번째 서버를 이용하여 서비스 중단 상황을 방지.       정보보호 공격유형          변조(Modification)  원래의 데이터를 조작하는 행위.  소스 프로그램을 변경하여 악성코드를 실행하거나 특정 URL로 접속하게 유도  ex) Redirection            가로채기(Interception)  네트워크상에서 전송되는 데이터에 대하여 복사, 열람 등을 하는 공격유형  가로채기는 정보를 열람하는 것이고 이러한 공격을 수동적 공격(Passive Attack)이라고 지칭.  ex) 스니핑(Sniffing)            차단(Interruption)  정상적인 서비스를 방해하는 행위.  ex) DoS 및 프로세스 고갈 공격            위조(Fabrication)  송신되는 메시지를 변조하여 상대방을 속이는 행위.       정보보호 대책          일반 통제  소프트웨어 생명주기에 대한 통제  모든 애플리케이션에 공통으로 적용하는 IT조직, 직무분리, 시스템 개발, 논리적 및 물리적 보안, 하드웨어 통제, 백업 및 복구, 비상계획 등을 수립하는 통제            응용 통제  정보시스템에서 발생시키는 트랜잭션과 데이터 무결성을 확보하기 위한 통제       시점별 분류          예방 통제(Preventive)  능동적인 통제로, 발생가능한 문제점을 사전에 식별하여 통제를 수행하는 것.  물리적 접근 통제 : 승인되지 않은 사람이 주요 정보시스템에 출입 방지. ex) 경비원  논리적 접근 통제 : 인증받지 못한 사람이 주요 정보시스템에 접근 방지. ex) 방화벽            탐지 통제(Detective)  예방 통제를 우회하여 발생되는 문제점을 식별. ex) CCTV, 경보            교정 통제(Corrective)  탐지된 위협과 취약점에 대응하는 것. ex) 백신 S/W            복구 통제(Recovery)  자원과 능력을 복구.  ex) 백업 및 복구       사용자 인증 방식 및 원리  지식기반 인증     사용자의 기억으로만 인증하는 방식. ex) 패스워드, PIN       패스워드 공격기법  무차별 공격(Brute Force Attack)  사전 공격(Dictionary Attack)  트로이목마 프로그램  사회 공학적 공격 : 예로 콜 센터 등에 전화하여 패스워드를 알아내는 심리적 공격 방법  전자적 모니터링 : 패스워드 입력/전송 시 스니핑   소유기반 인증     대표적인 예로는 열쇠가 있으며 복제와 분실의 위험이 존재.       스마트 카드 :  메모리 토큰과 달리 프로세스 능력 보유  통일성 결여(표준의 미흡)  주파수를 복제의 위험성이 존재   존재(생체)기반 인증     불변의 특성을 지닌 생체적, 행동적 특징을 자동회된 수단으로 등록    생체인증 분류     존재 특징 : 생체 특성, 지문, 장문, 얼굴, 손 모양, 홍채   행동 특징 : 서명, 음성, 키보드 입력   생체인증 특징          보편성(University)            유일성(Uniqueness)            지속성(Permanence)            성능(Performance) 개인 확인 및 인식의 우수성, 시스템 성능            수용성(Acceptance) 거부감이 없어야 함.            저항성(Resistance) 위조가능성이 없어야 함.       생체인증 평가항목     FRR(False Reject Rate)  잘못된 거부율, 편의성 관점, 정상적인 사람을 거부함   FAR(False Acceptance Rate)  잘못된 승인율, 보안 관점, 비인가자를 정상인 사람으로 받아들임   CER(Crossover Error Rate), ERR(Equal Error Rate)  FRR과 FAR가 교차되는 지점. 효율성 및 생체인증의 척도      행동기반 인증     개인의 고유한 행동적 특성을 사용하여 인증하는 기술    서명, 키스트로크, 마우스 움직임, 걸음걸이, 모바일 단말기 사용패턴 등을 분석하여 인증   커버로스(Kerberos) 인증  중앙 집중형 사용자 인증 프로토콜 = RFC1510  대칭키 암호화 기법에 바탕을 둔 티켓기반 인증 프로토콜  3A 지원(AAA서버). Authentication(인증), Authorization(인가), Accounting(과금)   커버로스 구성요소          KDC(Key Distribution Center)  키 분배센터. TGS + AS로 구성  사용자와 서비스 암호화 키를 유지하고 인증 서비스를 제공하며 세션 키를 만들고 분배            TGS(Ticket Granting Service)  티켓 부여 서비스. 티켓(인증 토큰)을 만들고 세션 키를 포함한 Principals에 티켓을 분배하는 KDC의 한 부분            AS(Authentication Service)  인증 서비스. 실질적 인증 수행            Principals  인증을 위하여 커버로스 프로토콜을 사용하는 모든 실제를 이르는 말            TimeStamp  시간 제한을 설정하여 다른 사람이 티켓을 복사하여 나중에 그 사용자인 것처럼 위장하여 티켓을 사용하는 것(Replay Attack)을 방지         ","categories": ["study"],
        "tags": ["정보보안기사"],
        "url": "https://many258.github.io/study/security-access-control/",
        "teaser": null
      },{
        "title": "[엑셀/Excel] 자주 출제 및 사용하는 함수",
        "excerpt":"수학 관련 함수  통계          SUM(숫자1, [숫자2], [숫자3],…)  지정된 셀 범위의 합계를 구하는 함수            SUMIF(조건범위, 조건, [찾을범위])  조건을 만족하는 데이터의 합계            SUMIFS(합을 구할 범위, 참조할 범위1, 조건1, [참조할 범위2], [조건2], …)  범위 안 여러개의 조건을 만족하는 값의 합계            DSUM(전체범위, 찾을 열 필드, 조건범위)  조건을 만족하는 값의 합계를 출력            AVERAGE(숫자1, 숫자2, 숫자3,…)  지정된 셀 범위의 평균을 구하는 함수            DAVERAGE(전체 범위, 찾을 열번호, 기준)  전체 데이터베이스 내에서 기준에 맞는 자료의 평균            MAX(숫자1, 숫자2, 숫자3,…)  지정된 셀 범위 내 최대값 출력            MIN(숫자1, 숫자2, 숫자3,…)  지정된 셀 범위 내 최솟값 출력            LARGE(인수 또는 셀범위, 숫자인수)  범위 내 [지정한 숫자인수 값] 번째로 큰 수 출력            SMALL(인수 또는 셀범위, 숫자인수)  범위 내 [지정한 숫자인수 값] 번째로 작은 수 출력            MODE(범위1, [범위2],…)  인수들 중 가장 많이 발생한 값인 최빈값 출력            RANK(값, 범위, [논리값])  범위 내에서 지정한 수의 순위를 구한다.  논리값이 0이거나 생략되면 내림차순으로, 0이외의 값은 오름차순으로 표시            COUNT(숫자1, 숫자2, 숫자3,…)  인수로 입력된 숫자의 개수 출력            COUNTA(범위1, 범위2,…)  셀 범위 중 비어있지 않은 셀의 개수 출력            COUNTBLANK(범위)  비어있는 셀의 개수 출력            COUNTIF(범위, 조건)  범위 내 조건을 만족하는 셀의 개수 출력            COUNTIFS(범위1, 조건1, 범위2, 조건2, …)  범위 내 여러 조건을 만족하는 셀의 개수 출력            DCOUNT(전체 범위, 찾을 열번호, 기준)  전체 데이터베이스 내에서 기준에 맞는 숫자 포함 셀들의 개수            DCOUNTA(전체 범위, 찾을 열번호, 기준)  전체 데이터베이스 내에서 비어있는 셀은 무시하고 기준에 맞는 셀들의 개수       어림값          EVEN(숫자)  가까운 짝수값으로 올림            ODD(숫자)  가까운 홀수값으로 올림            ROUND(인수, 소수점 이하 자릿수)  표시된 소수점 이하 자릿수에서 반올림            ROUNDDOWN(인수, 내림할 자릿수)  지정된 자릿수 아래의 수를 내림            ROUNDUP(인수, 올림할 자릿수)  지정된 자릿수 아래의 수를 올림            TRUNC(버림할 인수, 자릿수)  지정된 자릿수에서 버림하여 출력       표시 형식          INT(실수)  실수에서 소수점 이하 절삭 후 정수로 내림            ABS(숫자)  숫자의 절대값을 변환            SQRT(양수)  양수의 제곱근을 구함            CEILING(숫자, 기준배수)  특정 배수를 기준으로 올림된 수를 반환            FLOOR(숫자, 기준배수)  숫자의 배수 중 기준이 되는 배수와 가장 가까운 내림된 값을 반환            MROUND(숫자, 기준배수)  특정값에 가장 가까운 배수를 계산            EXP(숫자)  인수를 자연로그의 밑 e의 지수로 올린다            FACT(숫자)  인수의 팩토리얼을 표시            PI()  원주율 값            MOD(나누어질 인수, 나눌 인수)  나머지 출력            PRODUCT(인수 또는 셀 범위)  모든 셀을 곱한 값 출력            SUMPRODUCT(배열1, 배열2,…)  배열을 n차원 벡터로 취급하고 내적            POWER(인수, 승수)  인수의 지정한 승수만큼의 값 출력  예를 들어 = POWER(2, 3)면, 23  ** 1번 인수가 음수라면, 2번 인수가 정수가 아닐 경우 계산 불가            SUBTOTAL(함수, 참조1, [참조2], …)  필터링으로 가려진 데이터들을 제외하고 계산 작업을 할 수 있게 돕는 함수       날짜/시간 관련 함수          DATE(년, 월, 일)  특정 날짜 출력            TODAY()  현재 컴퓨터 시스템의 날짜 표시            NOW()  현재 컴퓨터의 날짜와 시간을 표시            YEAR(날짜) / MONTH(날짜) / DAY(날짜)  연도/월/일 값 출력            WEEKDAY(날짜, 유형)  해당하는 요일 번호 표시            TIME(시, 분, 초)  특정 시간 출력            HOUR(시간) / MINUTE(시간) / SECOND(시간)  시/분/초 값 출력       논리 관련 함수          IF(조건, 참값, 거짓값)  조건을 만족 시 참값, 불만족 시 거짓값으로 출력            IFERROR(검사수식, 반환값)  수식에서 오류가 발생할 경우 사용자가 지정한 값을 반환            AND(조건1, 조건2,…)  모든 논리가 전부 참일 경우 TRUE 를 출력하고, 하나라도 거짓이 있을 경우 FALSE 를 출력            OR(조건1, 조건2,…)  하나라도 참이 있을 경우 TRUE 를 출력하고, 전부 거짓일 경우 FALSE 를 출력            NOT(조건)  논리식의 결과 값을 반대로 출력       문자열 관련 함수          LEFT(문자열, 정수)  주어진 문자열 중 왼쪽으로부터 정수번째 있는 값 출력            RIGHT(문자열, 정수)  주어진 문자열 중 마지막부터 정수번째 있는 값 출력            MID(문자열 또는 문자열 참조 셀, n번째 글자, x개까지)  문자열의 가운데 부분을 추출해 표시한다. n번째 글자부터 x개만큼을 추출            LOWER(문자열)  입력된 문자열을 모두 소문자로 표시            UPPER(문자열)  입력된 문자열을 모두 대문자로 표시            PROPER(문자열)  문자열에서 첫단어만 대문자로 표시            TRIM(셀 또는 문자열)  해당 셀/문자열의 텍스트 양 끝에 있는 공백을 제외한 텍스트를 추출            LEN(문자열)  문자열의 길이 출력            FIND(찾으려는 문자, 문자열, 시작위치)  특정문자가 시작하는 위치를 숫자로 반환            SEARCH(찾을 문자, 검색할 문자열, [시작지점])  문자열에서 특정 문자의 시작위치 검색            REPLACE(문자열, 시작위치, 문자열 수, 대체할 문자열)  문자열의 시작위치에서부터 지정하는 수 만큼 문자열을 다른 문자열로 대체            SUBSTITUTE(문자열, 찾을문자, 새로운문자, [바꿀지점])  문자열에서 특정 문자를 찾아 다른 문자로 대체 한 셀 내에 대상 텍스트가 여러 개가 있는 상황에서는 바꿀지점을 활용할 수 있는데,       모두 바꾸려면 생략하고, 숫자를 입력하면 그만큼 왼쪽에서부터 대상 텍스트를 세어서 선택적으로 적용            CONCATENATE(문자열1, 문자열2, …)  여러 문자열을 하나로 조인            REPT(문자열, 반복 횟수)  문자열을 지정한 횟수만큼 반복            VALUE(문자열)  문자열을 숫자로 변환       검색 기능 함수          COLUMN(셀)  해당 셀의 가로열의 번호를 표시            ROW(셀)  해당 셀의 세로행의 번호를 표시하는 함수            CHOOSE(색인번호(1 이상 254이하의 정수형), 값1, [값2], …)  순번으로 구성된 색인을 참조하여 목록에서 해당 순번의 값을 반환            INDEX(배열, 행위치, 열위치)  배열 내의 몇 행 몇 열에 해당하는 대상을 찾아서 출력            OFFSET(시작지점, 행이동, 열이동, [높이], [넓이])  시작지점으로부터 지정한만큼 이동한 곳의 셀 참조 또는 값을 반환       VLOOKUP(찾을 값, 참조범위, 열번호, [옵션])  가로(수직)로 된 범위에서 값을 참조하여 다른 항목의 값을 반환            옵션  1 : 유사값이나 생략  0 : 정확한 값           HLOOKUP(찾을 값, 참조범위, 행번호, [옵션])  가로(수평)로 된 범위에서 값을 참조하여 다른 항목의 값을 반환            옵션  1 : 유사값이나 생략  0 : 정확한 값           XLOOKUP(찾을 값, 참조 범위, 출력 범위, [옵션], [검색옵션])  범위에서 일치하는 항목을 찾아 반환            옵션  0 : 정확히 일치하는 값만 반환하며 일치하는 값이 없을 경우 #N/A 반환  -1 : 일치하는 값이 없을 때 그보다 적으면서 가장 가까운 값 반환  1 : 일치하는 값이 없을 때 그보다 많으면서 가장 가까운 값 반환  2 : 와일드카드 옵션       검색옵션  1 : 오름차순  -1 : 내림차순  2 : 데이터가 정렬되었다고 가정한 오름차순  -2 : 데이터가 정렬되었다고 가정한 내림차순           MATCH(찾을값, 범위, [옵션])  배열 내에서 찾고자 하는 값이 몇 번째에 위치하는지 찾아서 숫자로 출력            옵션  0 : 정렬되지 않은 배열에서 정확히 일치하는 값을 검색. 여러 개가 검색되었을 경우 첫째 것을 출력  1 : 오름차순으로 정렬된 배열에서 작거나 같은 값 중 가장 큰 값  -1 : 내림차순으로 정렬된 배열에서 크거나 같은 값 중 가장 작은 값           XMATCH(찾을 값, 찾을 범위, [옵션], [검색옵션])  배열 또는 범위에서 특정 값의 상대 위치(순번)을 반환            옵션  0 : 정확히 일치하는 값만 반환하며 일치하는 값이 없을 경우 #N/A 반환  -1 : 일치하는 값이 없을 때 그보다 적으면서 가장 가까운 값 반환  1 : 일치하는 값이 없을 때 그보다 많으면서 가장 가까운 값 반환  2 : 와일드카드 옵션       검색옵션  1 : 오름차순  -1 : 내림차순  2 : 데이터가 정렬되었다고 가정한 오름차순  -2 : 데이터가 정렬되었다고 가정한 내림차순          ","categories": ["study"],
        "tags": ["Excel"],
        "url": "https://many258.github.io/study/excel-function/",
        "teaser": null
      },{
        "title": "[정보보안기사/정보보안일반] 접근 통제 기술",
        "excerpt":"접근통제  접근의 개요          주체  자원의 접근을 요구하는 활동 개체. (사람, 프로그램…)            객체  자원을 가진 수동적인 개체(DB, 컴퓨터, 파일…)            접근  주체와 객체의 정보 흐름       정보 접근의 단계          식별(Identification)  사용자 ID를 확인하는 과정            인증(Authentication)  패스워드가 정확한지 판별            인가(Authorization)  인증된 사용자에게 파일을 Read/Write/Execute 권한을 부여       접근 통제의 정의  주체의 대한 객체의 접근을 통제.  사용자가 파일인 객체에 대해 읽기/쓰기/실행의 권한이 있는지 확인하고 권한이 있으면 권한을 부여하고 권한이 없으면 접근을 차단하는 것이다.   접근 통제 원칙          최소 권한의 원칙  최소한의 권한만을 허용하여 권한의 남용을 방지            직무분리  업무의 발생/승인/변경/확인/배포 등이 한 사람에 의해 처리되지 않도록 직무를 분리       참조 모니터  주체의 객체에 대한 접근 통제를 결정을 중재하는 OS의 보안 커널로서, 일련의 SW   주체가 객체를 참조할 때 직접참조를 수행하지 않고 보안 커널을 통해서 참조.     보안 커널    주체에 대해서 정당한 권한을 확인하고 접근한 객체에 대한 정보를 모두 로그에 기록  결함으로 발생할 수 있는 취약점 차단   참조 모니터의 3가지 요소          완전성(Completeness)  우회가 가능하지 않아야 함.            격리(Isolation)  부정 조작이 불가능해야 함. (Tamper Proof)            검증성(Verifiability)  분석하고 테스트할 정도로 충분히 작아야 함       접근 통제 기술  MAC(Mandatory Access Control)  강제적 접근 통제  주체의 객체에 대한 접근이 주체의 비밀 취급 인가 레이블(Clearance Label) 및 객체의 민감도 레이블(Sensitivity Lable)에 따라 지정되는 방식   MAC 특징  데이터에 대한 접근을 시스템이 결정(정해진 룰에 의해)한다.  데이터 소유자가 아닌 오직 관리자만이 자원의 카테고리를 변경 가능  비밀성을 포함하고 있는 개체에 대해 주체가 가지고 있는 권한에 근거하여 객체의 접근을 제한하는 정책   구현/운영의 어려움. 높은 비용   MAC 종류     Rule-Based MAC  주체와 객체의 특성에 관계된 특정 규칙에 따른 접근 통제 방화벽   Administratively-directed MAC  객체에 접근할 수 있는 시스템 관리자에 의한 통제   CBP(Compartment-Based-Policy)  일련의 객체 집합을 다른 객체들과 분리.  동일 수준의 접근허가를 갖는 부서라도 다른 보안등급을 가질 수 있다.   MLP(Multi-Level Policy)  각 객체별로 지정된 허용 등급을 할당하여 운영(Top Secret, Secret, Confidentiality…)  미국 국방성 컴퓨터 보안 평가지표에 사용. BLP 수학적 모델로 표현 가능  *BLP : 높은 등급의 사용자는 낮은 등급의 정보에 접근이 불가능   DAC(Discretionary Access Control)  자율적 접근 통제  객체의 소유자가 권한 부여   DAC 특징  사용자의 신분에 따라 임의로 접근을 제어하는 방식(User-Based, Identity)  융통성이 좋아 UNIX, DBMS 등 상용 OS에서 구현 가능  접근 통제 목록(ACL : Access Control List) 사용    – 특정 객체에 접근할 수 있는 사용자 목록과 접근 권한을 명시 (객체 관점)   트로이목마 공격에 취약, ID 도용 문제   DAC 종류     Identity-Based DAC  주체와 객체의 ID에 따른 접근 통제. 주로 UNIX에서 사용   User-Based DAC  객체 소유자가 접근 권한을 설정 및 변경할 수 있는 방식   Non-DAC(Non-Discretionary Access Control)  비임의적 접근 통제  주체의 직무와 역할에 따라 접근할 수 있는 객체를 지정하는 방식   Non-DAC 특징  MAC과 DAC의 단점을 보완하기 위한 대안  기업 내 개인의 작은 이동 및 조직 특성에 밀접하게 적용하기 위한 통제 방식  Role-Based, Task-Based 이라고도 함.  Central Authority(중앙 인증) : 중앙 관리자에 의해 접근 규칙을 지정한다.  사용자별 접근 통제 규칙을 설정할 필요가 없다.   Non-DAC 종류     Role-Based Accesss Control(RBAC)  사용자가 적절한 역할에 할당되고 역할에 적합한 권한이 할당된 경우만 사용자가 특정한 모드로 정보에 대한 접근을 통제할 수 있는 방법   Latice-Based Non-DAC  역할에 할당된 민감도 레벨에 의해 결정. 관련된 정보로만 접근 가능  주체와 객체의 관계에 의거하여 접근을 통제할 수 있는 Upper Bound와 Lower Bound를 설정하여 제어.   Task-Based Non-DAC  조직 내 개인의 임무에 의한 접근 통제   RBAC(Role Base Access Control)  권한들의 묶음으로 Role을 만들어서 사용자에게 Role 단위로 권한을 할당하고 관리   RBAC의 특징  관리 수월 - 관리자에게 편리한 관리 능력을 제공, 비용 감소  보안관리 단순화 - 권한 지정을 논리적/독립적으로 할당하거나 회수 가능  최소 권한 - 최소한의 권한만을 허용하여 권한의 남용을 방지  직무분리 - 시스템상에서 오용을 일으킬 정도의 충분한 특권이 사용된 사용자 방지  데이터 추상화 - 역할에 대한 계층을 두어 상속 가능   접근 통제 방법  Capability List  주체별로 객체를 링크드리스트로 연결하고 권한을 할당한 구조   주체별로 모든 파일리스트가 존재하므로 권한을 알기 위한 탐색시간이 오래 걸리는 단점 존재.   Access Control List  주체와 객체간의 접근 권한을 테이블로 구성한 것  행에는 주체, 열에는 객체를 두고 행과 열의 교차점에는 주체가 객체에 대한 접근 권한(W/R/D/E)을 기술하여 이름 기반으로 제어하는 방식   접근 통제 매트릭스 종류          객체 기반 접근 제어(ACL:Access Control List)  객체 관점에서 접근 권한을 테이블 형태로 기술하여 접근 제어  구분될 필요가 있는 사용자가 비교적 소수와 분포도가 안정적일 때 적합  지속적 변경 환경에서는 부적합            내용 의존 접근 통제(Content Dependent Acceess Control)  데이터베이스에서 가장 많이 사용.  접근 제어가 내용에 의해 이루어지는 접근 통제  (데이터베이스에 사용자 정보를 등록하고 입력된 정보와 비교하여 접근 통제를 수행)            제한적 인터페이스(Restricted Interfaces)  특정 기능이나 자원에 대한 접근 권한이 없을 경우 아예 접근을 요청하지 못하도록 하는 방식       접근 통제 모델  Bell-Lapadula  기밀성 모델로서 높은 등급의 정보가 낮은 레벨로 유출되는 것을 통제하는 모델    정보 구분 : Top Secret / Secret / Unclassified    최초의 수학적 모델. 보안 등급과 범주를 이용한 강제적 정책에 의한 접근 통제 모델    미 국방성(DOD)의 지원을 받아 설계된 모델로서 오렌지북인 TCSEC의 근간이 됨.    시스템의 비밀성을 보호하기 위한 보안 정책           No-Read-Up(NRU or ss-Property) : 단순 보안 규칙  주체는 자신보다 높은 등급의 객체를 읽을 수 없다.  주체의 취급인가가 객체의 비밀 등급보다 같거나 높아야 그 객체를 읽기 가능            No-Write-Down(NWD or *-Property) : 스타-보안 규칙  주체는 자신보다 낮은 등급의 객체에 정보를 쓸 수 없다.  주체의 취급인가가 객체의 비밀 등급보다 같거나 낮을 때 그 객체를 주체가 기록 가능            Strong *-Property  더욱 강화된 모델. 주체는 자신과 등급이 다른 객체에 대해 읽기나 쓰기 불가       Biba 모델  Bell-Lapadula 모델의 단점인 무결성을 보장할 수 있는 모델  주체의 의한 객체 접근의 항목으로 무결성을 다룬다.     No Read-Down(NRD or Simple Intergrity Axiom)   No Write-Up(NWU or *Intergrity Axiom)   클락 윌슨 모델 (Clark and Wilson)  무결성 중심의 상업용으로 설계. App의 보안 요구사항을 다룬다.  정보의 특성에 따라 비밀 노출 방지보다 자료의 변조 방지가 더 중요한 경우가 있음을 기초로 한다.  주체와 객체 사이에 프로그램이 존재, 객체는 항상 프로그램을 통해서만 접근이 가능  2가지 무결성을 정의 : 내부 일관성(시스템 이용), 외부 일관성(감사에 활용)   만리장성 모델(Chinese Wall = Brewer-Nash)  서로 상충 관계에 있는 객체 간의 정보 접근을 통제하는 모델(이익 상충 금지)  상업적으로 기밀성 정책에 따른다.   보안 운영체제  보안 취약성으로부터 시스템 자체를 보호하기 위해 기존 운영체제의 커널 등급에 추가적인 보안 기능을 강화시킨 OS   Secure DBMS 구조          신뢰 필터 구조  신뢰할 수 없는 전위 사용자 인터페이스와 후위 DB 사이에 신뢰 필터를 사용하여 데이터에 대한 접근 통제 및 보안 서비스 제공  신뢰 필터는 하부의 보안 운영체제가 제공하는 보안 서비스 및 메커니즘에 의존       장점 : 다른 구조에 비해 간단. 크기가 작음 ==&gt; 보안 기능의 검증 및 평가가 용이  단점 : 데이터의 보안을 침해하는 일부의 위협에 대해서는 취약성을 가짐            커널 구조  TCB 분할 개념에 의해서 구현. 따라서 DB시스템은 보안 커널 외부에 존재하면서 임의적 보안만을 관리  DB 객체에 대한 임의적 접근 통제 - DBMS에 의해 수행  DB 파일에 대한 임의적 접근 통제 및 모든 강제적 접근 통제 - 하부의 보안 운영체제에 의하여 제공            이중 커널 구조  강제적 보안 기능을 갖는 DB 시스템을 구현하고,  이를 보안 운영체제와 함께 시스템의 TCB(Trust Computing Base)로 간주하여 보안시스템을 평가            중복 구조  낮은 보호 수준의 데이터를 DB에 중복하여 저장하는 방식.            *은닉 채널(Convert Channel)  기본 통신채널에 기생하는 통신채널로서, 스테가노그래피로 숨겨진 메시지를 송신자와 수신자만 확인 가능.  보안 메커니즘에 의해 통제되지 않는 정보 흐름으로 시스템의 보안 정책을 위반하는 행위  은닉 채널의 위험은 대역폭에 따라 변경되기 때문에 한 번에 전달되는 정보량을 줄이기 위해 대역폭 제한 필요       키 분배 프로토콜  대칭키 암호화(Symmetric Key)  Session Key, Shared Key, Secret Key, Conventional Key(관용키)라고도 한다.  암호화할 때 사용하는 암호화 키와 복호화할 때 사용하는 복호화 키가 동일한 암호화 기법(양방향 암호화 기법)  작은 비트의 암호호 키를 사용하여 빠르게 암호화/복호화가 가능하다. (대용량 Data 암호화에 적합)  기밀성을 제공하나 무결성, 인증, 부인방지는 보장할 수 없다  같은 키를 사용하므로 안전한 키 전달 및 공유 방법이 필요   대칭키 암호화의 종류          스트림 암호(Stream Cipher)  하나의 비트/바이트 단위로 암호화  평문을 XOR로 1Bit 단위로 암호화  실시간 암호/복호화, 블록 암호화보다 빠르다.  종류 : RC4, SEAL, OTP            블록 암호(Block Cipher)  여러 개의 Bit를 묶어 블록 단위로 치환/대칭을 반복하여 암호화  대용량의 평문 암호화  종류 : DES, 3DES, AES, IDEA, Blowfish, SEED       공개키 암호화(Public Key)  공개키와 개인키라는 두개의 암호화 키를 사용하여 암호화/복호화  클라이언트 - 공개키를 수신 받은 후 공개키로 암호화하여 메시지 전송  수신자 - 개인키로 복호화   대칭키 암호화 기법의 키 공유 문제를 해결한 방법이나, 암호화 키의 길이가 길어 암호화/복호화 성능 비효율  공개키/개인키를 사용하여 인증, 서명, 암호화를 수행   공개키 암호화 방식          암호모드  소량의 메시지 암호화 목적, 주로 키교환의 용도로 사용            인증모드  메시지를 인증(부인방지)하는 것이 목적          공개키 암호화 종류          Diffie Hellman - 이산대수  최초의 공개키, 키 분배 전용 알고리즘  필요 시에만 생성(저장 불필요)  암호 모드로 사용 불가, 위조에 취약            RSA - 소인수분해  대표적 공개키 알고리즘  컴퓨터 속도의 발전으로 키 길이 증가            DSA - 이산대수  간단한 구조를 가진 전자서명 전용 알고리즘 표준  암호화, 키 교환 불가            ECC - 타원곡선  짧은 키로 높은 암호 강도. 160키 = RSA1024  오버헤드가 적으며 키 테이블(20KB) 필요  PDA, 스마트폰       ","categories": ["study"],
        "tags": ["정보보안기사"],
        "url": "https://many258.github.io/study/access-control/",
        "teaser": null
      },{
        "title": "[데이터베이스/DB] 트랜잭션(Transaction)과 병행제어 및 회복",
        "excerpt":"트랜잭션  데이터베이스의 상태를 하나의 상태에서 또 다른 일관된 상태로 변화시켜주는 일련의 논리적인 연산 집합  한번에 모두 소행되어야하는 연산들의 집합, 하나의 작업을 처리하기위한 작업 단위  하나의 트랜잭션은 완료(Commit)되거나 복귀(Rollback)되어야 한다   트랜잭션의 성질          Atomicity(원자성)  트랜잭션이라는 것은 연산의 집단을 의미하지만, 논리적으로는 하나의 의미 연산들은 모두 수행되거나 모두 수행되지 않아야한다(= 일부의 완료는 존재하지 않는다)            Consistency(일관성)  고정 요소는 트랜잭션 실행 전과 후가 같아야 한다는 성질 트랜잭션이 실행되고 나서도 데이터베이스의 상태는 무결성이 유지되고 모순되지 말아야 된다는 성질            Isolation(독립성,격리성)  트랜잭션이 실행되는 중간에는 다른 트랜잭션 연산이 침범하지 못하는 성질 같은 자원에 대해 여러 개의 트랜잭션이 동시에 사용할 수 없다는 성질            Durability(영속성,지속성)  트랜잭션에 의해서 변화된 상태는 계속해서 유지될 수 있어야 한다는 성질       트랜잭션의 상태          활동(Active)  트랜잭션이 실행 중인 상태            부분 완료(Partially Committed)  트랜잭션이 마지막 연산을 끝내고 데이터베이스에 실행 결과를 적용하기 직전의 상태            완료(Committed)  트랜잭션이 연산을 완료하고 연산의 결과를 데이터베이스에 적용한 상태            실패(Failed)  트랜잭션이 실행 중 어떤 오류에 의해서 더 이상 진행될 수 없는 상태            철회(Aborted)  트랜잭션 실행이 실패하여 복귀된 상태       병행제어  다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행수행할 때,  동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것을 의미.   목적     데이터베이스의 공유를 최대화   시스템의 활용도 최대화   데이터베이스의 일관성 유지   사용자에 대한 응답시간 최소화   제약없는 병행 처리(Concurrency Processing) 시 문제점  병행제어 기법에 의한 제어 없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용할 경우 다음과 같은 문제점이 발생           분실된 갱신(Lost Update)  두 개의 트랜잭션이 같은 데이터에 대해서 동시에 갱신 작업을 하면 하나의 갱신 작업이 분실되는 경우            모순성(Inconsistency, 불일치)  한 개의 트랜잭션 작업이 갱신 작업을 하고 있는 상태에서 또 하나의 트랜잭션이 같은 작업 구역에 침범하여 작업하게 되면, 트랜잭션이 모두 끝나게 되더라도 그 데이터에 대한 결과는 사용자가 원하는 결과와 일치하지 않는 상태가 되어 데이터베이스의 일관성을 해치는 경우            연쇄 복귀(CasCading Rollback)  다른 트랜잭션이 처리하는 과정에서 실패하게 되면 두 개의 트랜잭션 모두 복귀되는 현상            비완료 의존성(Uncommitted Dependency)  한 개의 트랜잭션이 수행과정에서 실패하였을 때, 이 트랜잭션이 회복되기 전에 다른 트랜잭션이 이 트랜잭션의 수행 결과를 참조하는 현상       병행제어 기법의 종류  로킹  자원 이용에 대하여 상호배제 기능을 이용하는 기법   직렬성을 보장하기 위해 하나의 트랜잭션이 어떤 데이터에 대해서 액세스하는 동안 또 다른 트랜잭션이 이 데이터에 대해 액세스하기 위해서는 로크를 소유하고 있어야만 가능하도록 하는 방법.  언제 로크를 소유하고 해제하는가 하는 로킹 규칙을 정해놓고 해결.      로킹 기법                     공유 잠금(Shared Lock)  잠금 걸린 데이터에 대해 읽기 가능, 쓰기 불가능                        베타 잠금(Exclusive Lock)  잠금 걸린 데이터에 대해 읽기, 쓰기 불가능                   로킹단위(Locking Granularity)  병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기  주요 단위로는 DB, DBSPACE, 테이블, 페이지 등                     로킹 단위가 작다  데이터의 공유도와 병행성이 증가하나 로크의 수가 많아 병행 제어 기법이 복잡하고 관리가 어렵다.                        로킹 단위가 크다  데이터의 공유도와 병행성 이 감소하고 로크의 수가 적어 병행 제어 기법이 간단하고 관리가 쉽다.                   2단계 로킹 규약(Two-Phase Locking Protocol)  트랜잭션 스케쥴의 직렬성을 보장하는 대표적인 기법            요청단계(Growing Phase) = 확장 단계  로크를 얻는 과정에서는 어떠한 로크도 반납될 수 없다는 것을 나타내는 단계(잠금만 수행)       반납단계(Shrinking Phase) = 축소 단계  트랜잭션이 완료되는 시점에서 데이터에 대한 로크를 반납하는 과정에서는 어떠한 로크도 획득할 수 없는 단계(해제만 수행)           타임스탬프  시스템에 진입하는 트랜잭션 순서대로 타임스탬프를 지정하여 동시성을 제어하는 기법   검증 기법  = 최적 병행수행, 확인 기법, 낙관적 기법   읽기 단계, 검증 단계, 기록 단계를 이용하여 직렬성을 보장하는 기법   다중버전 기법  = 다중 버전 타임 스탬프 기법   갱신 연산 때마다 새로운 버전을 만들어 병렬수행을 제어하는 기법   회복(Recovery)  어떤 외부적인 장애 요인이나 내부적인 장애 요인에 의해서 데이터베이스의 상태가 일관성 유지에 제약이 걸렸을 때, 장애 이전의 일관된 상태가 되도록 복원하는 일   장애(Failure)의 유형     실행 장애   트랜잭션 장애   시스템 장애  H/W 시스템 자체에서 발생할 수 잇는 장애   미디어 장애  디스크 자체의 손상으로 발생할 수 있는 장애   UNDO  변경된 데이터를 취소하여 원래의 내용으로 복원시키는 연산   주로 트랜잭션이 실행 중인 상태에서 실행이 실패하였을 경우 원래의 내용으로 복원하는 경우에 사용   REDO  이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 것을 의미   주로 데이터베이스의 내용이 손상되었을 때, Backup 본으로 회복한 다음 Backup 본에 있는 데이터 이후는 로그에 갱신되어 있는 데이터를 데이터베이스에 적용하는데 사용   회복 기법     로그 기반 회복 기법                     즉시 갱신  트랜잭션이 수행중인 상태에서도 그 결과를 즉시 데이터베이스에 반영  커밋 발생 이전의 갱신은 원자성이 보장되지 않는 미완료 갱신이므로 장애 발생 시 UNDO 연산 필요                        지연 회복 기법  트랜잭션의 갱신 결과를 로그에 기록하여 두었다가 트랜잭션의 연산이 완료되면 한번에 데이터베이스에 반영 처리 도중 장애가 생기더라도 데이터베이스에 반영되지 않았으므로 UNDO 연산이 불필요 (REDO 연산 수행)                        검사점(CheckPoint) 회복 기법  장애 발생 시 검사점 이전에 처리된 트랜잭션은 회복에서 제외하고 검사점 이후에 처리된 트랜잭션은 회복작업을 수행  장애 발생 시점 이전에 Commit이 완료된 경우 - UNDO 수행  장애 발생 시점 이전에 Commit을 못한 경우 - REDO 수행            그림자페이징 기법  로그를 이용하지 않으며 트랜잭션이 실행되는 메모리상의 현 페이지 테이블(Current Page Table)과 하드디스크의 그림자페이지 테이블(Shadow Page Table) 사용       트랜잭션 시작지점에서 현 페이지 테이블과 동일한 그림자페이지 테이블 사용  트랜잭션이 성공으로 완료될 경우, 그림자페이지 테이블 삭제  트랜잭션이 실패할 경우, 그림자페이지 테이블을 현 페이지 테이블로 교체            미디어 회복 기법  디스크와 같은 비휘발성 저장 장치가 손상되는 장애 발생을 대비한 회복 기법       데이터베이스의 내용을 백업/미러링/RAID 등을 통해 별도의 물리적 저장장치에 덤프  미디어 장애 시 가장 최근 덤프로 복구하고 로그 파일을 참조해 덤프 이후의 작업을 REDO 수행 (UNDO는 수행하지 않음)       ARIES 회복 기법            REDO 중 역사 반복(Repeating history)  붕괴가 발생했을 때의 데이터베이스 상태를 복구하기 위하여 붕괴 발생 이전에 수행했던 모든 연산을 다시 한번 수행.  붕괴가 발생했을 때 완료되지 않은 상태였던 (진행 트랜잭션)은 UNDO 된다.                UNDO 중 로깅(Logging)  UNDO를 할 때에도 로깅을 함으로써 회복을 수행하는 도중에 실패하여 회복을 다시 시작할 때에 이미 완료된 UNDO 연산은 반복하지 않는다.               주요 3단계                    분석(Analysis)단계: 붕괴가 발생한 시점에 버퍼에 있는 수정된 페이지와 진행 트랜잭션을 파악, REDO가 시작되어야 하는 로그의 위치를 결정           REDO 단계: 분석 단계에서 결정한 REDO 시작 위치의 로그로부터 로그가 끝날 때 까지 REDO를 수행, REDO 된 로그 레코드의 리스트를 관리하여 불필요한 REDO 연산이 수행되지 않도록 한다.           UNDO 단계: 로그를 역순으로 읽으면서 미완료된 트랜잭션의 연산을 UNDO 한다.                       구성 요소                    WAL(Write Ahead Logging)  DB 변경 사항에 대한 전체 로깅           LSN(Log Sequence Number)  모든 로그에 대한 고유 순서 번호           Repeating History  장애 시 이전의 데이터베이스 수행 기록을 모두 추적하여 REDO           Logging Changes  UNDO 완료된 트랙잭션을 기록하여 UNDO 반복 수행 회피                          ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-transaction/",
        "teaser": null
      },{
        "title": "[운영체제/OS] RAID",
        "excerpt":"RAID  Redundant Array of Independent/Inexpensive Disks : 복수 배열 독립 디스크  여러 대의 물리적 디스크를 하나의 논리적 디스크로 인식시키는 기술  여러 개의 하드 디스크에 일부 중복된 데이터를 나눠서 저장하는 기술 = 디스크 어레이   데이터를 나누는 다양한 방법이 존재하며, 이 방법들을 레벨이라 하는데, 레벨에 따라 저장장치의 신뢰성을 높이거나 전체적인 성능을 향상시키는 등의 다양한 목적을 만족시킬 수 있다.   RAID의 사용 목적     무정지 구현(가용성)   성능 향상   주의) 데이터의 무결성, 안전, 백업에 대한 목적은 아니다.   RAID 0  스트라이핑 Striping   일련의 데이터를 하나의 논리적 디스크 배열에 일정한 크기로 나누어서 분산 저장하는 기법  사용자와 시스템 데이터는 하나의 논리 디스크상에 저장되어 있는 것으로 인식하며 디스크는 스트립(Strip)이라는 일정한 크기의 섹터 또는 물리적 블록 단위로 나누어 연속적인 배열 구성요소와 대응되도록 순환할당된다.  이와 같이 하나의 스트립들과 각 배열의 구성요소가 대응하는 논리적으로 연속적인 스트립의 집합을 스트라이프라고 한다.   RAID 0 방식은 데이터를 입출력할 때, RAID 컨트롤러에서 여러 개의 하드 디스크로 나눠서 쓰고 읽어 들이므로 중요하지 않은 데이터에 대한 빠른 데이터 입출력 성능이 요구되는 동영상 편집 등에 적합   데이터를 중복해서 기록하지 않으므로 장애발생에 대비한 여분의 저장 공간을 가지고 있지 않다. 즉, 어느 한 드라이브에서 장애가 발생하면 데이터는 손실      RAID 1  미러링 Mirroring + 스트라이핑 Striping   RAID 0 과 같이 데이터 스트라이핑을 사용하면서 배열 내의 모든 디스크가 동일한 데이터를 가지는 미러 디스크를 가진다. 각 논리적 스트립은 두 개의 별도 디스크에 대응되므로 미러링이라고도 하는데, 중복 저장된 데이터를 가진 적어도 두 개의 드라이브로 구성   멤버 디스크 중 하나만 살아남으면 데이터는 보존되며 복원도 1:1복사로 매우 간단하기 때문에 서버에서 끊김없이 지속적으로 서비스를 제공하기 위해 사용   읽기 요구는 요구 데이터를 가지고 있는 두 개의 디스크 중 어떤 디스크에서도 서비스를 받을 수 있기 때문에 성능이 향상될 수 있으나, 데이터를 분할 저장하지 않기 때문에 두 스트립이 모두 갱신되어야 하며 쓰기 요구는 단일 디스크 드라이브의 경우와 같다.      RAID 2  스트라이핑 + 허밍 코드 Hamming Code   디스크들 간에 데이터 스트라이핑을 사용하며 오류 검출 능력이 없는 드라이브를 위해 허밍 코드 기법을 사용한다.(안전성 확보)  몇몇 디스크들은 오류를 감지하고 수정하는 데 사용되는 오류정정코드(ECC, Error Correcting Code)정보를 저장   허밍 오류정정코드는 패리티 비트를 사용해 디스크로부터 전송된 데이터에 오류가 있는지 검사 및 정정   실시간 오류수정이 가능하다는 장점이 있지만, 현재의 SCSI 드라이브들이 자체 오류 검출 능력을 갖고 있기 때문에 실제 잘 쓰이지 않음.      RAID 3  RAID 0과 같이 스트라이브를 사용하며, 오류 검출과 수정을 위해 별도의 드라이브 한 개를 패리티 드라이브로 사용  각각의 데이터 디스크에 데이터를 비트 단위로 스트라이핑하여 기록   대형 레코드가 많이 사용되는 단일 사용자 시스템과 다량의 데이터 전송이 요구되는 작업에 적합      RAID 4  데이터 분산 저장을 위해 스트라이핑과 패리티 드라이브를 사용한다는 점에서 RAID 3과 유사하지만, 각 드라이브에 데이터를 블록 단위로 분산 저장한다는 점에서 다름   쓰기 요청이 있을 때마다 사용자 데이터와 함께 패리티 정보를 갱신해야 하기 때문에 추가시간이 소요되므로 크기가 작은 입출력이 요청될 때 쓰기 성능 저하(입출력의 병목현상 유발)  데이터 읽기 요청은 RAID 0과 비슷한 성능을 가짐   여러 드라이브 중에서 한 대의 드라이브만이 여분의 패리티 정보를 기록하는데 사용되기 때문에 용량당 비용은 높지않아 저렴한 가격으로 장애 복구 능력이 요구되거나 빠른 판독속도가 필요한 경우에 사용      RAID 5  RAID 4 구성과 유사하며 별도의 패리티 드라이브 대신 모든 드라이브에 패리티 정보를 나누어 저장. (디스크 병목현상 해결)   다중 프로세스 시스템에서와 같이 작고 잦은 데이터 기록이 있을 경우 더 빠르지만, 읽기 요청의 경우 각 드라이브에서 패리티 정보를 건너뛰어야 하기 때문에 RAID 4보다 속도가 느리다.   최소한 3대, 일반적으로 5대 이상의 드라이브가 필요. N개의 디스크를 사용하면 (N-1)배의 저장 공간을 사용 가능하다.   데이터는 각 데이터 영역에 블록 단위로 스트라이핑하여 저장된다.  병렬 입출력이 가능하기 때문에 기록과 읽기가 동시에 가능하며 데이터 입출력 선능이 아주 빠르면서도 안전성 또한 높은 편으로 파일 서버 등의 입출력이 빈번한 업무에 적합하다.      RAID 6  RAID 5와 원리는 같으며, 서로 다른 방식의 패리티 2개를 동시에 사용한다.  성능과 용량을 희생해서 가용성을 높인 셈.   N개의 디스크를 사용하면 (N-2)배의 저장 공간을 사용할 수 있다.      Nested RAID  레이드 볼륨의 멤버로 다른 레이드 볼륨을 사용하는 형태.  멤버 디스크를 묶는 배열을 하위 배열, 하위 배열을 묶는 배열을 상위 배열이라고 한다. 표기 방법은 m(하위 배열)n(상위 배열)이며 m=0이면 뒤에 +를 붙인다.   RAID 0+1  RAID 0으로 스트라이핑 된 볼륨을 RAID 1로 미러링. (적어도 4개의 디스크 필요)  ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-raid/",
        "teaser": null
      },{
        "title": "[네트워크] 네트워크 개요 및 일반",
        "excerpt":"네트워크  송신자의 메시지를 수신자에게 전달하는 과정으로 한 지점에서 원하는 다른 지점까지 의미 있는 정보를 보다 정확하고 빠르게 상대방이 이해할 수 있도록 전송하는 것을 의미   프로토콜  송신자와 수신자가 통신이라는 것을 하려면 서로 메시지의 포맷, 언제 데이터를 보낼 것인지, 한 번 전송하고 한 번 응답받는 형태로 할 것인지에 관한 것을 서로 약속해야 한다. 이 때, 이러한 약속이 프로토콜을 의미한다.   네트워크의 분류  거리에 따른 네트워크 유형          PAN(Personal Area Network)  3M 이내의 인접 지역 간의 통신 방법  짧은 거리로 인하여 유선보다는 무선의 WPAN이 많이 활용            LAN(Local Area Network)  근거리 영역의 네트워크로 동일한 지역 내 고속의 전용 회선으로 연결하여 구성하는 통신망  Client/Server와 peer-to-peer 모델            WAN(Wide Area Network)  광대역 네트워크망으로 서로 관련이 있는 LAN 간의 상호 연결망  LAN에 비해 선로 에러율이 높고, 전송 지연이 크다  두 목적지 사이를 최단경로로 연결시켜 주는 라우팅 알고리즘 필요            MAN(Metropolitan Area Network)  LAN과 WAN의 중간 형태의 네트워크로 데이터, 음성, 영상 등을 지원하기 위해 개발  DQDB(Distributed Queue Dual Bus)       데이터 전송 방식     단방향(Simplex)   반이중(Half Duplex)   전이중(Full Duplex)   회선교환(Circuit Switching)  교환기를 통해 통신 회선을 설정하여 직접 데이터를 교환하는 방식     특징            전송 전에 회선이 전용선으로 설정 : 동일한 경로(독점)       데이터 전송이 없더라도 회선 해제 요청이 없으면 계속 접속 유지       전송 시작 후 오버헤드가 없음       Point-to-Point 전송 구조       전송된 데이터의 에러 제어나 흐름 제어는 사용자에 의해 수행되어야 한다           장점            대용량의 데이터를 고속으로 전송할 때 좋으며, 고정적인 대역폭 사용       접속에는 긴 시간이 소요되나 그 후 접속이 항상 유지되어 전송 지연이 없고, 데이터 전송률이 일정       아날로그나 디지털 데이터로 직접 전달       연속적인 전송에 적합(실시간)           단점            회선 이용률 면에서 비효율적       연결된 두 장치는 반드시 같은 전송률과 같은 기종 사이에서만 송수신이 가능       속도나 코드의 변환이 불가능 : 교환망 내에서의 에러 제어 기능이 어려움       실시간 전송보다 에러없는 데이터 전송이 요구되는 구조에서는 부적합       통신 비용 고가           패킷교환(Packet Switching)  송신측에서 메시지를 일정한 크기의 패킷으로 분해/전송, 수신측에서 원래의 데이터로 조립     특징            패킷 다중화, 논리 채널, 경로 선택 제어, 순서 제어, 트래픽 제어, 오류 제어       수신된 패킷의 저장기능(대기 큐)       순서 제어 기능 : 목적지에서 수신된 패킷의 순서를 재정렬       트래픽 제어 : 흐름 제어, 혼잡 제어, 교착상태       경로 배정 요소 : 성능 기준, 결정 시간, 결정 장소, 네트워크 정보           장점            회선 이용률이 높고, 속도 변환, 프로토콜 변환 가능, 음성 통화       고신뢰성 : 상황에 따라 교환기 및 회선 등의 장애가 발생하더라도 패킷의 우회전송이 가능하므로 전송의 신뢰성 보장       고품질 : 디지털 전송이므로, 인접 간에 또는 단말기와 교환기 간에 전송, 오류 검사를 실시하여 오류 발생 시 재전송 가능       고효율 : 다중화를 사용하므로 전송로 사용 및 효율이 좋다       이 기종 단말장치 간 통신 : 전송 속도, 전송 제어 절차가 다르더라도 교환망이 변환 처리를 제공하므로 통신 가능           단점            각 교환기의 경로에서 다소 지연이 발생       이러한 지연은 가변적임. 전송량이 증가함에 따라 지연이 더욱 심할 수 있음       패킷별 헤더 추가로 인한 오버헤드 발생 가능성           패킷교환 방식의 종류     가상회선(Virtual Circuit)            패킷을 전송하기 전에 논리적인 연결을 먼저 수행 : 연결형 서비스       호출 요구를 하고 호출 수신 패킷을 주고받아서 연결하는 방식(X.21)       회선교환처럼 사용하지만 교환기에 패킷이 일시적으로 저장되며 일정한 전송률 보장 불가       비교적 긴 메시지의 전송 시 더 효과적           데이터그램(Datagram)            각 전송 패킷을 미리 정해진 경로 없이 독립적으로 처리하여 교환하는 방식       같은 목적지의 패킷도 같은 경로를 거치지 않고 서로 다른 경로를 통해서 목적지에 도달       망의 한 부분이 혼잡할 때 패킷에 다른 경로를 지정하여 배정 가능, 융통성 있는 경로를 설정       특정 교환기의 고장 시 모든 패킷을 잃어버리는 가상회선 방식과는 달리, 그 경로를 피해서 전송할 수 있음 : 신뢰성 보장       짧은 메시지의 패킷들을 전송할 때 효과적, 재정렬 기능 필요           네트워크 토폴로지(Network Topology)  컴퓨터 네트워크의 요소들(링크, 노드)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식         계층형(트리형)            Tree 구조, 최상위에 있는 노드가 네트워크 제어       통제 및 유지 보수 용이       단말기의 추가나 제거 및 에러 발생 시 발견이 쉬움       병목 현상 발생 가능, 중앙 노드 장애 발생 시 전체 통신망 마비           수평형(버스형)            중앙 통신 회선 하나에 여러 대의 노드를 연결하는 방식       근거리 통신망에서 볼 수 있는 일반적인 형태       하나의 컴퓨터가 다운되어도 나머지 컴퓨터에는 지장이 없음       DTE 추가 삭제가 용이       우선순위 제어가 어려움       통신 회선의 길이에 제한, 충돌이 자주 발생           성형(스타형)            중앙에 있는 컴퓨터를 중심으로 터미널이 연결된 중앙 집중식 형태       유지보수 및 관리가 용이, 단말기 고장 시 발견이 용이       중앙 컴퓨터 고장 시 전체 네트워크 마비       통신망 제어가 복잡           원형(링형)            인접해 있는 노드들을 연결하는 단방향 전송 형태       매채 엑세스 방식       토큰 링 이용, 동축/광섬유 케이블 이용       전송 매체와 DTE 고장 시 발견이 용이       단말기 추가 및 삭제가 어려움       전송 지연 발생 시 DTE 간의 순차적 전송때문에 중계기 기능이 필요           망형(메쉬형)            모든 노드들이 상호 연결       통신 회선 장애 시 다른 경로로 데이터 전송이 가능       DTE 고장과 병목 현상에 대해 면역성이 있음       가장 많은 통신 선로가 필요           OSI 7계층  Open System Interconnection 7-layer  개방형 시스템 네트워크의 효율적인 이용을 위하여 모든 데이터 통신 기준으로 계층을 분할하고, 각 계층 간의 필요한 프로토콜을 규정한다.   정보가 전달되는 Framework를 제공하며, 네트워크 형태에 차이가 발생해도 데이터 통신을 지원   OSI 7계층 구조                  OSI 7계층       주요 내용       주요 프로토콜(매체)                 7. Application       사용자 소프트웨어를 네트워크에 접근 가능하도록 함. 사용자에게 최종 서비스를 제공       FTP, SNMP, HTTP, Mail, Telnet 등                 6. Presentation       포맷 기능, 압축, 암호화 텍스트 및 그래픽 정보를 컴퓨터가 이해할 수 있는 16진수 데이터로 변환       압축, 암호, 코드 변환  GIF, ASCII, EBCDIC                 5. Session       세션 연결 및 동기화 수행, 통신 방식 결정 가상 연결을 제공하여 Login/Logout 수행       반이중, 전이중, 완전이중 결정                 4. Transport       가상연결, 에러 제어, 데이터 흐름 제어, Segment 단위 두 개의 종단 간 End-To-End 데이터 흐름이 가능하도록 논리적 주소 연결 신뢰도, 품질보증, 오류탐지 및 교정 기능 제공  다중화(Multiplexing) 발생       TCP, UDP                 3. Network       경로선택, 라우팅 수행, 논리적 주소 연결(IP) 데이터 흐름 조절, 주소 지정 메커니즘 구현  네트워크에서 노드에 전송되는 패킷 흐름을 통제하고, 상태메시지가 네트워크상에서 어떻게 노드로 전송되는 가를 정의, Datagram(Packet) 단위                         2. Data Link       물리주소 결정, 에러 제어, 흐름 제어, 데이터 전송 Frame 단위, 전송 오류를 처리하는 최초의 계층       흐름제어, 오류제어(ARQ)  브리지, PPTP, L2TP, HDLC  Frame Relay                 1. Physical       전기적, 기계적 연결 정의, 실제 Data Bit 전송 Bit 단위, 전기적 신호, 전압구성, 케이블, 인터페이스 등을 구성 Data Rates, Line noise Control, 동기화 기능 수행       매체: 동축케이블, 광섬유, Twisted Pair Cable              End-to-End : 7 ~ 4계층, 송수신자 간의 에러 제어   Point-to-Point : 4 ~ 1계층, 각 구간에 대해 에러 제어   OSI 계층별 하드웨어 장비     Physical                     Cable  Twisted Pair Cable, Coaxial, Fiber-Optic Cable                        Repeater  네트워크 구간 케이블의 전기적 신호를 재생하고 증폭하는 장치 디지털 신호를 제공, 아날로그 신호 증폭 시 잡음과 왜곡까지 증폭                   Data Link                     Bridge  서로 다른 LAN Segment를 연결, 관리자에게 MAC 주소 기반 필터링 제공하여 더 나은 대역폭 사용과 트래픽을 통제 리피터와 같이 데이터 신호를 증폭하지만 MAC 기반에서 동작                        Switch  목적지의 MAC 주소를 알고 있는 지정된 포트로 데이터를 전송 Repeater와 Bridge의 기능을 결합 네트워크의 속도 및 효율적 운영, Data Link 계층에서도 작동                   Network            Router  패킷을 받아 경로를 설정하고 패킷을 전달 Bridge는 MAC 주소를 참조하지만, Router는 네트워크 주소를 참조하여 경로를 설정 패킷 헤더 정보에서 IP 주소를 확인하여 목적지 네트워크로만 전달하며 Broadcasting을 차단           Application            Gateway  서로 다른 네트워크망과의 연결(PSTN, Internet, Wireless Network 등) 패킷 헤더의 주소 및 포트 외 거의 모든 정보를 참조           데이터 전송 방식  직렬 전송(Serial Transmission)  한 문자의 각 비트 열을 하나의 전송 선로를 통해 순차적으로 전송하는 방식(모뎀)      시프트 레지스터를 이용하여 병렬을 직렬화한 후 송신   동기 전송 방식의 요구   전송 에러가 적고, 장거리에 적합   통신 회선 설치 비용이 저렴   전송 속도가 느림   병렬 전송(Parallel Transmission)  한 문자를 이루는 각 비트가 각각의 전송로를 통해 한꺼번에 전송되는 방식(프린터) 블록 버퍼를 이용      송수신 문자 간격을 식별하는 스트로브 신호와 BUSY 신호로 다음 문자의 송신 시기 결정   단위 시간에 다량의 데이터를 빠른 속도로 전송   전송 길이가 길어지면 에러 발생 가능성 농후   통신 회선 설치 비용이 커짐   동기 방식(Synchronous Method)  전송할 데이터를 여러 블록으로 나누어 블록 단위로 전송하는 방식 제어 정보를 데이터의 앞뒤에 붙여 프레임을 구성      전송 단위 : 프레임, 문자 중심 / 비트 중심   에러 검출 : CRC   오버헤드 : 프레임당 고정된 크기   전송 속도 : 고속   전송 효율 : 높다(휴지 간격 없음, 채널 할당 시간 공백 없음)   장점            원거리 전송에 이용           단점            에러 발생 확률이 높다       고가(별도의 하드웨어 장치가 필요)           비동기 방식(Asynchronous Method)  한 번에 한 문자씩 전송하는 방식(한 문자 전송 시마다 동기화하는 방식)  start-stop 비트를 사용, 패리티 비트, 정지 비트 ‘1’ 시작비트 ‘0’      전송 단위 : 문자 단위의 비트 블록   에러 검출 : 패리티 비트   오버헤드 : 문자당 고정된 크기   전송 속도 : 저속   전송 효율 : 낮음   장점            동기화가 단순하며 저렴           단점            문자당 2~3비트의 오버헤드가 발생       프레임 에러가 발생할 가능성이 있음          ","categories": ["study"],
        "tags": ["데이터통신","네트워크"],
        "url": "https://many258.github.io/study/network-base/",
        "teaser": null
      },{
        "title": "[웹프로그래밍] Ajax",
        "excerpt":"   보통 우리가 생각하는 웹프로그래밍은 클릭과 같은 이벤트를 통해 웹 서버에 요청하고 요청에 대한 응답을 클라이언트에게 보내주어 갱신되는 것이 일반적이다.     하지만, 구글 지도와 같은 몇 웹페이지에서는 신기하게도 전체 페이지를 다시 새로고침하지 않고도 지도 정보만 갱신되는 것을 볼 수 있다.    Ajax  (Asynchronous JavaScript and XML, 에이잭스)  비동기적인 웹 애플리케이션의 제작을 위해 아래와 같은 조합을 이용하는 웹 개발 기법     표현 정보를 위한 HTML (또는 XHTML) 과 CSS   동적인 화면 출력 및 표시 정보와의 상호작용을 위한 DOM, 자바스크립트   웹 서버와 비동기적으로 데이터를 교환하고 조작하기 위한 XML, XSLT, XMLHttpRequest   JavaScript의 라이브러리 중 하나이며, JavaScript를 사용한 비동기 통신, 클라이언트와 서버 간에 XML 데이터를 주고받는 기술이다.   즉, 자바스크립트를 통해 다양한 형태의 데이터(JSON, XML, CSV)를 서버와 주고받을 수 있다.   비동기 방식  웹페이지를 새로고침하지 않고 데이터를 불러오는 방식.   보통 자주가는 카페를 예로 들어보자면,  동기 방식의 경우는 손님이 들어올 때마다 주문을 받고 손님은 커피를 받기 전까지 카운터에서 기다리는 상황이고  비동기 방식은 진동벨을 구비해서 손님의 주문을 받음과 동시에 진동벨을 배분하고 일을 하다가 중간에 다른 손님이 오더라도 주문을 받을 수 있는 상황과 유사하다고 할 수 있다.   위 예시에서 손님이 갑자기 몰려온다고 생각해보자.  동기 방식에서는 손님이 주문하고 커피를 준비하고 넘겨주어야 다음 손님을 맞을 수 있으므로 시간 낭비가 심하다.  하지만, 비동기 방식에서는 손님을 기다리게 하고 다른 업무를 할 수 있으니 시간적으로 효율이 좋다.   즉, 비동기 방식의 장점은  기존의 변경할 필요가 없는 이미지, 스크립트 등은 남겨두고 필요한 부분만 갱신해 사용할 수 있다는 점이다.      데이터 전송 방식     GET  지정한 URL의 데이터를 열람하기 위한 메소드  사용이 간편하고 전송량이 적으나 사용자정보를 URL에 노출함으로 보안상 취약할 수 있음   POST  지정한 URL에 데이터를 생성하기 위한 메소드(수정 및 삭제 작업도 수행 가능)   PUT  지정한 URL의 데이터를 갱신하기 위한 메소드   DELETE  지정한 URL의 데이터를 삭제하기 위한 메소드   HEAD  지정한 URL의 헤더 정보를 요청하는 메소드   AJAX의 장점     웹페이지 속도 향상   서버 처리를 기다리지 않고, 비동기 요청 가능   수신하는 데이터의 양을 줄일 수 있고, 클라이언트에게 처리를 위임할 수도 있다.   플러그인 없이도 인터렉티브한 웹페이지 구현이 가능   AJAX의 단점     Ajax를 쓸 수 없는 브라우저에 대한 문제가 있음   HTTP 클라이언트 기능이 한정되어 있음   페이지 이동없는 통신으로 인한 보안상의 문제 발생 가능성   히스토리 관리가 되지 않음   지원하는 Charset이 한정   스크립트로 작성되므로 디버깅이 용이하지 않음   요청을 남발하면 역으로 서버 부하가 늘 수 있음   동일-출처 정책으로 인하여 다른 도메인과는 통신이 불가능(Cross-Domain문제)   AJAX 프레임워크  Ajax를 이용하여 개발을 손쉽게 할 수 있도록 미리 여러 가지 기능을 포함해 놓은 개발 환경      JQuery   Prototype   script.acul.us   dojo   Google Web Toolkit   ASP.NET AJAX   YUI   AJAX 예제  JavaScript에서 Ajax   var xmlhttp; if (window.XMLHttpRequest) {     xmlhttp = new XMLHttpRequest(); }  else {     xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); }   xmlhttp.onreadystatechange = function() {     if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) {          //통신 성공시 구현부분           //readState : Ajax 통신의 진행중인 상태 표시          // 0 : 초기화되지 않은 상태(open 메소드가 호출되지 않은 상태)          // 1 : open 메소드가 호출된 상태(send메소드는 호출되지 않은 상태)          // 2 : 송신완료, 요청을 시작한 상태(요청은 하지 않았지만 데이터가 아직 오지 않은 상태)          // 3 : 수신 중인 상태(데이터를 받고 있는 상태)          // 4 : 수신 완료(데이터를 모두 받은 상태)           //status : 데이터 수신의 성공 여부를 판단해주는 속성값          // 0 : 로컬로 접근 성공을 의미          // 200 : 해당 URL로 접근 성공한 상태          // 403 : 접근이 거부됨.          // 404 : 해당 URL이 없음          // 500 : 서버오류      } } xmlhttp.open(\"GET\", \"exam.xml\", true); xmlhttp.send()   JavaScript에서 Ajax는 텍스트/XML 타입으로만 데이터를 가져올 수 있기 때문에 JSON/CSV 형식으로 데이터를 받기 위해서는 따로 파싱(Parsing)하는 코드 작업이 필요.   JQuery에서 Ajax   &lt;script  src=\"http://code.jquery.com/jquery-latest.min.js\"&gt;&lt;/script&gt;  $.ajax({     url:'', //request 보낼 서버의 경로     type:'post', // 메소드(get, post, put 등)     data:{ name: 'yoo'}, //보낼 데이터     datatype: \"json\"     success: function(data) {         //서버로부터 정상적으로 응답이 왔을 때 실행     },     error: function(err) {         //서버로부터 응답이 정상적으로 처리되지 못햇을 때 실행     } });  또는  $.ajax({     url:'', //request 보낼 서버의 경로     type:'post', // 메소드(get, post, put 등)     data:{ name: 'yoo'}, //보낼 데이터     datatype: \"json\"})     .done(function(json){       // HTTP 요청이 성공하면 요청한 데이터가 done 메소드로 전달     })     .fail(function(xhr, status, errorThrown){       // HTTP 요청이 실패하면 오류와 상태에 대한 정보가 fail 메소드로 전달     })     .always(function(xhr, status){       // HTTP 요청이 성공, 실패에 상관없이 언제나 alway 메서드 실행     }); });  ","categories": ["study"],
        "tags": ["AJAX"],
        "url": "https://many258.github.io/study/web-ajax/",
        "teaser": null
      },{
        "title": "[네트워크] TCP/IP 4계층 및 응용계층",
        "excerpt":"TCP/IP  Transmission Control Protocol/Internet Protocol   DoD(미국방성)모델이라고 하며 OSI 7계층과 흡사하나 OSI보다 먼저 만들어지고 가장 많이 사용중이다.   TCP/IP 구조          Application(Application/Presentation/Session)  네트워크를 실제로 사용하는 응용프로그램으로 구성  FTP, TELNET, SMTP 등등            Transport(Transport)  도착하고자 하는 시스템까지 데이터를 전송  Port를 가지고 있으며, 프로세스를 연결 또는 비연결해서 통신함  TCP, UDP            Internet(Network)  Datagram을 정의하고 routing하는 일을 담당  IP, ARP, RARP, ICMP, IGMP            Network Access(Data Link/Physical)  케이블, 송수신기, 링크 프로토콜, LAN 접속과 같은 물리적 연결 구성을 정의       Application Layer  일반 사용자들이 사용하는 프로그램이 있는 계층. 사용자는 프로그램을 사용하여 통신.           FTP(File Transfer Protocol)  사용자 파일의 업로드 혹은 다운로드를 수행하는 프로그램 파일 전송을 위한 인터넷 표준으로 제어 접속과 데이터 접속을 위한 분리된 포트를 사용            DNS(Domain Name Service)  DNS 쿼리를 사용해서 DNS서버에 URL을 전송하고 해당 URL에 매핑되는 IP주소를 제공하는 서비스       HTTP(Hyper Text Transfer Protocol) WWW(World Wide Web)로 시작되는 인터넷에서 웹브라우저와 웹 서버 사이에 웹 페이지의 Request 및 Response를 수행하는 W3C 표준 개방형 프로토콜  TCP 기반 프로토콜의 80번 포트를 사용, State-less로 프로토콜을 구성                     HTTP v1.0  연결을 수행할 때 마다 3-Way Handshaking 기법 사용  HTML 페이지를 수신 받고 완전히 종료  필요 시 재연결하고 페이지를 수신받음                        HTTP v1.1  어느 정도 대기한 후에 연결을 종료(Keep Alive Connection)                        HTTP v2.0  멀티플랙싱(Multiplexing) : 순차적 연결이 아니라 동시 다발적인 양방향 통신 지원  헤더압축(Header Compression) : 헤더 정보를 1/3 수준으로 압축. 속도 향상  서버푸시(Server Push) : 웹 서버가 웹 브라우저에게 필요한 데이터를 알아서 미리 전송할 수 있는 기술                        Telnet  특정 지역의 사용자가 지역적으로 다른 곳에 위치한 컴퓨터를 온라인으로 연결하여 사용하는 서비스            SMTP(Simple Mail Transfer Protocol)  TCP 25 Port. RFC821에 명시된 인터넷 전자우편(MIME 데이터 형식)을 위한 프로토콜로 메시지 전달을 위해 Store and Forward 방식을 사용  암호화 및 인증 기능 없이 사용자의 e-mail을 전송하는 프로토콜       SNMP(Simple Network Management Protocol)  네트워크에 대한 트래픽, 세션 등의 네트워크 상태를 모니터링하고 정보를 전달할 때 사용되는 프로토콜   3-Way Handshaking  1) 웹브라우저(클라이언트)가 웹 서버에 SYN 메시지를 전송  2) 웹 서버는 웹브라우저에게 SYN, ACK로 응답  3) 웹브라우저는 웹 서버에 최종 연결확립 메시지인 ACK를 전송해 웹 서버와 연결 확립(ESTABLISHED 상태)      HTTP  Header : Request 시 전달해야 하는 웹브라우저 정보, 요청방식, 파라미터  Body : Request 할 때는 사용하지 않고 POST 방식의 Request 시 Body에 파라미터 정보를 넣고 전송     HTTP Request 시 Header 구조                     Request Method  호출되는 메소드. GET/POST/OPTIONS/PUT/DELETE/TRACE/CONNECT                        Accept  웹 브라우저에서 사용 가능한 미디어 타입. text/html..등                        Accept-Language  웹 브라우저가 인식할 수 있는 언어를 의미                        User-Agent  웹 브라우저 정보 의미                        Accept-Encoding  웹 브라우저에서 제공되는 인코딩 방식                        Host  웹 서버의 기본 URL                        Connection  연결 지속(Keep Alive) 및 연결 끊기(Close) 상태 표시                   HTTP Response 시 Header 구조                     Status Code  HTTP 응답코드. 200 : 성공적으로 처리                        Server  서버 프로그램 이름과 버전 전송                        Expires  자원의 만기일자                        Cache Control  캐시 사용 여부. HTTP/1.1                        Pragma  캐시 사용 여부. HTTP/1.0                        Content-Encoding  응답되는 메시지의 인코딩 방식                        Content-Length  바이트 단위로 응답되는 리소스의 크기                        Keep-Alive  연결 유지 시간을 의미                        Connection  Keep-Alive 사용 여부                        Content-Type  응답되는 미디어 타입                   HTTP 요청 방식                     GET 방식  서버에 전달할 때 데이터를 URL에 포함시켜서 요청  전송할 수 있는 데이터 양이 제한(2Kbyte or 4Kbyte)                        POST 방식  서버에 전달할 때 데이터를 Request Body에 포함시킴  데이터 전송량의 제한이 없음                        쿠키(Cookie)  웹브라우저에서 저장할 수 있는 작은 공간으로 개발자가 프로그램에 필요한 정보를 임시적으로 저장 가능  쿠키 값은 변조가 가능하기에 보안 상 주의를 요함       세션(Session)  클라이언트와 웹 서버 사이의 네트워크 연결이 지속적으로 유지되는 상태   SMTP     구성요소                     MTA(Mail Transfer Agent)  메일을 전송하는 서버                        MDA(Mail Delivery Agent)  MTA에게 받은 메일을 사용자에게 전달(수신측에 고용된 우체부)                        MUA(Mail User Agent)  사용자들이 사용하는 클라이언트 어플리케이션                        기본 동작 방식  1) 송신자가 보낸 전자우편은 전자우편을 관리하는 메일 서버에 전달  2) 메일 서버는 수신자의 전자우편 주소를 분석하고 최단 경로를 찾아 근접한 메일 서버에게 편지를 전달  3) 최종 수신자 측 메일 서버에 도착하기까지 연속적으로 전달하는 중계 작업을 수행            POP3  TCP 110 Port. 메일서버에 접속하여 저장된 메일을 내려 받는 MDA 프로그램  메시지를 읽은 후 메일 서버에서 해당 메일을 삭제       IMAP &amp; IMAP3  TCP 143 Port. 위 POP과 역할은 유사하나 메일을 내려받아도 메일 서버에 원본을 계속 저장한다는 차이점이 있음   FTP  해당 컴퓨터에 등록된 사용자만 파일전송이 가능하며, 그 외에는 익명으로 사용  ftpuser에 등록된 사용자는 FTP 접근 불가  제어 접속과 데이터 접속 포트 분리           Active Mode  1) 클라이언트에서 서버 TCP 21번 포트로 접속 시도  2) 서버는 TCP 20번 포트로 데이터를 송수신            Passive Mode  1) 클라이언트는 서버의 TCP/21번 포트로 접속 후 두 번째 포트를 질의  2) 서버는 클라이언트에게 데이터 연결을 위한 두 번째 포트(TCP 1024 ~ 65535)을 알림  3) 클라이언트는 서버가 알려 준 두 번째 포트로 접속       SNMP  운영되는 네트워크의 안정성, 효율성을 높이기 위해 구성/장애/통계/상태 정볼르 실시간으로 수집 및 분석하는 네트워크 관리 시스템   NMS(Network Management System)는 SNMP 프로토콜을 사용해서 네트워크 정보 수집  MIB(Management Information Base)는 SNMP에서 모니터링해야 하는 객체 정보를 소유      SNMP 명령                     GET  장비의 상태 및 기동시간 등의 관리 정보 읽기                        GET-NEXT  정보가 계층적 구조를 가지므로 관리자가 장비 조회를 해서 해당 트리보다 하위층 정보를 읽기                        SET  장비 MIB를 조작하여 장비 제어/관리자는 요청을 보내 초기화 혹은 장비 재구성                        TRAP  일반적으로 SNMP는 Polling 방식으로 주기적으로 정보 요청과 요청에 대한 정보 응답 방식으로 동작되는데,  이 때 만약 연결구간이 혼잡하게 될 경우 중요한 관리 정보가 손실되어 그 정보를 인지 못할 수도 있다는 문제점을 보완하기 위해 TRAP 기술 도입           Manager가 요청 않더라도 Agent에 의해 자의적으로 경고, 고장통지 등 미리 설정된 유형의 보고서를 생성/송신                  ","categories": ["study"],
        "tags": ["네트워크","데이터통신"],
        "url": "https://many258.github.io/study/tcp-ip-application/",
        "teaser": null
      },{
        "title": "[네트워크] TCP/IP 인터넷, 네트워크 접근 계층",
        "excerpt":"인터넷 계층(Internet Layer)  송신자의 IP주소와 수신자의 IP주소를 읽어서 경로를 결정하거나 전송하는 역할을 수행  다중 네트워크 링크를 통해 패킷의 발신지-대-목적지 전달에 대한 책임을 가진다.(데이터 링크 층은 노드간 전달 책임, Point-to-Point)   IP, ICMP의 TCP/IP 프로토콜 군이 존재하고 멀티캐스팅을 위한 IGMP, 라우팅을 위한 BGP, OSPF, RIP 존재      경로설정(Routing)  수신자의 IP주소를 읽어서 어떻게 목적기까지 가는 것이 최적의 경로인지를 판단하는 것. 라우터(Router)의 역할   Point-To-Point 패킷 전달   논리 주소 지정 : IP주소로 변환하여 사용   주소 변환   데이터그램 : 기존 패킷에 IP Header를 붙이는 것을 의미   라우팅  목적지 IP주소를 읽어서 경로를 결정하는 작업.      정적 경로 방법(Static Routing)  특정 목적지 네트워크로 가는 경로를 관리자가 직접 라우팅 테이블의 경로를 설정하는 방법  실시간으로 이루어지지 않기에 초기에 관리자가 다양한 라우팅 정보를 분석하여 최적의 경로 설정이 가능  라우터의 직접적인 처리 부하를 감소시킬 수 있어서 비교적 환경변화가 적은 형태의 네트워크에 적합            Floating static routing           동적 경로 방법(Dynamic Routing)  네트워크 상태를 파악해서 최적의 경로를 결정하는 방법  실시간으로 이루어지므로 네트워크 환경변화에 능동적인 대처가 가능  라우팅 알고리즘을 통해 자동으로 경로 설정이 이루어지며,  수시로 환경이 변화되는 형태의 네트워크에 적합            Distance Vector routing       Linked state routing           라우팅 프로토콜  인터네트워크를 통해서 데이터를 근원지에서 목적지로 전달하는 기능 수행  경로 결정에서 최단경로 선정 및 전송 수행, 목적지에 대한 경로 정보를 인접한 라우터들과 교환하기 위한 규약           IGP(Internal Gateway Routing Protocol)  동일 그룹(기업 또는 ISP) 내에서 라우팅 정보를 교환            EGP(Exterior Gateway Routing Protocol)  다른 그룹과의 라우팅 정보를 교환       Distance Vector routing  최단 경로를 구하는 벨만 포드 알고리즘 기반  통과해야 하는 라우터의 수가 적은 쪽으로 경로를 결정. 일명 Hop Count 또는 TTL(Time to Live)  네트워크 변화 발생 시 해당 정보를 인접한 라우터에 정기적으로 전달하고,  인접 라우터에서는 라우팅 테이블 정보 갱신            라우팅 정보 : 모든 라우터까지의 거리 정보 보관       정보 전송 시점 : 일정주기(30초, 이웃 라우터와 공유)       대표 프로토콜 : RIP, IGRP, EIGRP(내부 라우팅), BGP       단점  변화되는 라우팅 정보를 모든 라우터에 주기적으로 갱신(브로드캐스팅)하므로 망 자체 트래픽 유발  라우팅 정보를 변경하는 문제 발생 시 Routing Loop가 발생할 가능성 존재           Linked state routing  최소 신상 트리를 구하는 다익스트라 알고리즘 기반  네트워크 대역폭, 지연정보 등을 종합적으로 고려해 Cost를 산정하고 해당 Link의 Cost에 따라 경로를 결정하는 방법  네트워크 변화 감지 시 링크 상태 변경 정보를 인접한 라우터에게 즉각 전달하고 이를 저장            라우팅 정보 : 인정 라우터까지의 Link Cost 계산       정보 전송 시점 : 변화 발생 시에만       대표 프로토콜 : OSPF, IS-IS(소규모 네트워크)       단점  네트워크 전체 정보 유지를 위한 많은 메모리 소요  라우터의 CPU 사용량이 많아짐  라우터간 회선의 대역차이로 동기화 실패할 가능성 존재                RIP(Routing Information Protocol)  RFC 1058. 대표적인 거리 벡터 라우팅 프로토콜       라우터 간 거리 계산을 위한 척도로 홉수(Hop Count) 사용  16Hop 이상이면 패킷을 폐기  180초 이내에 새로운 라우팅 정보가 수신되지 않으면 해당 경로를 이상 상태로 간주  수신된 목적지의 거리 값과 현재 거리 값을 비교하여 작은 것을 기준으로 라우팅 테이블을 변경       라우팅 정보 변경 시 모든 망에 적용하므로 큰 규모의 망에는 부적합            OSPF(Open Shortest Path First)  RFC 1247. IP 라우팅 프로토콜       링크에서의 전송 시간을 링크 비용으로 사용하여 각 목적지별 최단 경로를 계산  네트워크에 변화가 발생했을 때 상대적으로 짧고 간단한 링크 상태 정보 교환       Link의 delay, throughput, reliability를 이용하여 기본적인 throughput만 이용하고, Hop수에 대한 제약이 없음  네트워크를 Area로 구분하여 많은 라우팅 정보의 교환으로 인한 라우터의 성능저하를 예방(대역폭을 절약)  Link 변화 감지 시 해당 Link에 대한 정보만을 즉시 모든 라우터에 전달하며 Convergence가 매우 빠름  Supernetting된 형태로 Routing Information을 전달할 수 있어 라우터 메모리 절약, 성능 향상 및 대역폭 절약              ABR(Area Border Router)  Area에 백본망을 연결해주는 라우터       ASBR(Autonomous System Boundary Router)  다른 AS(Autonomous System)에 속한 라우터와 경로 정보를 교환       IR(Internal Router)  Area에 접속한 라우터       BR(Backbone Router)  백본망에 접속한 모든 라우터                BGP(Border Gateway Protocol)  AS 상호 간의 routing에 적용되는 라우팅 프로토콜.  ISP(Internet Service Provider) 사업자들 상호 간에 주로 사용       EGP라고 하는 Inter-Domain routing Protocol  인터넷을 AS 상호 간 연결 Path로 이루어진 방향성 그래프의 집단으로 인식  경로 벡터 라우팅 방법(path vector routing)을 적용하며 경로 벡터 라우팅 테이블을 유지             Looping Free Routing       TCP 기반 라우팅  BGP 라우팅 정보는 라우터 간에 179번 포트를 통하여 TCP에 의해 신뢰성 있게 전달       라우팅 정보의 점진적 갱신  BGP는 주기적으로 라우팅 정보를 갱신하지 않고, 변화가 있을 때 이웃 라우터에게 갱신 정보를 전달       다양한 라우팅 metric 사용  최상위 경로 선택을 위해 우선순위가 있는 각 metric을 참조       Class 없는 주소체계 지원  CIDR(Classless Inter-Domain Routing) 지원       IBGP(Internal BGP) : 동일한 AS에 속한 BGP 라우터 간의 동작       EBGP(External BGP) : 서로 다른 AS에서 동작하는 BGP 프로토콜           IP(Internet Protocol)  IP 주소 형태로 송신자와 수신자의 IP를 가지고 있고 IP주소를 읽어서 최적의 경로를 결정할 수 있게 함      주소화, 데이터그램 포맷, 패킷 핸들링 등을 정의해놓은 인터넷 규약   IPv4 : 32bit 주소체계를 사용. (네트워크 ID + 호스트 ID)   IPv6 : IP주소의 부족 문제를 해결하기 위해 주소 비트수를 128bit로 확장.   IP Header 구조     Version : IPv4 버전   Header Length : Header의 전체 길이   Type of Service : 서비스 유형   Total Length : IP Datagram의 byte 수   Identification : Host에서 보낸 DataGram 식별        Flags &amp; Offset  IP Datagram 단편화 정보  네트워크에는 MTU(Maximum Transmission Unit)라는 것이 존재하는데, 한 번에 통과할 수 있는 패킷의 최대 크기를 의미한다.       즉, MTU 값보다 크면 패킷은 분할(단편화 : Fragmentation)되고 그 정보를 Flags &amp; Offset이 가지고 있게 된다.       Time to Live  Datagram이 통과할 수 있는 라우터 수(Linux 기본 = 64, Window 기본 = 128)  IP 패킷이 통과할 수 있는 라우터의 수를 의미. 라우터를 하나 통과 시 1씩 감소하며 0이 될 경우 자동 폐기   Protocol : IP헤더 위의 상위 프로토콜 종류. ICMP, TCP, UDP   Header Checksum : IP Header 무결성 검사   IP 주소의 구조  클래스로 분류되며 클래스는 IP 주소를 분류하는 기준으로 사용.                  Class       Content                 Class A       첫 바이트 7bit가 네트워크 식별자 한 네트워크에 가장 많은 호스트 수용 가능                 Class B       14bit의 네트워크 식별자 한 네트워크에 약 216대의 호스트 수용                 Class C       세 번째 바이트까지 네트워크 식별자 한 네트워크에 254대까지 수용                 Class D       멀티캐스트 주소로 사용              서브넷팅(Subnetting)  주어진 네트워크 주소를 작게 나누어 여러 개의 서브넷으로 구성  네트워크 식별자 부분을 구분하기 위한 Mask를 서브넷 마스크라고 함   수퍼넷팅(Supernetting)  ISP(Internet Service Provider) 사업자가 많은 네트워크 망을 효율적을 관리하기 위해서 네트워크를 묶어 관리하는 방법   CIDR(Classless Inter-Domain Routing)  RFC 4632. IPv4의 IP 주소 고갈 및 라우팅 테이블 대형화에 대한 해소책  기존의 클래스 A, B, C 네트워크 주소의 개념을 무시하고 IP주소와 서브넷 마스크를 이진 표기법으로 표현하여 기존의 고정크기 네트워크를 다양하고 세부적으로 분할한 것   VLSM(Variable Length Subnet Mask : 가변길이 서브넷 마스크)  서브넷팅을 실시한 이후에도 IP 주소가 낭비되는 것을 방지하기 위해서 서브넷 마스크의 길이를 더 확장하여 늘리는 기능   ICMP(Internet Control Message Protocol)  TCP/IP 오류 제어 프로토콜  호스트 및 라우터는 다른 호스트나 라우터가 현재 도달 가능한지의 여부를 결정  라우터는 특정 목적지 네트워크로 후속 IP 데이터그램을 보냈는데, 사용할 수 있는 최적의 경로가 있을 때 근원지 호스트에게 통지  호스트나 라우터는 그들이 처리하기에 너무 빠른 IP 데이터그램이 도착하면 다른 시스템에게 통보      오류 보고 메시지 : IP 패킷 처리 도중 발견된 문제를 보고   질의 메시지 : 다른 호스트로부터 특정 정보를 획득하기 위해 사용   ICMP 메시지 구조     Type : ICMP 메시지 유형 표시   Code : Type과 같이 사용되며 세부적인 유형을 표현   Checksum : IP Datagram Checksum   ICMP 메시지                  Type       Message       Content                 3       Destination Unreachable       라우터가 목적지를 찾지 못할 경우 보내는 메시지                 4       Source Quench       패킷을 너무 빨리 보내 네트워크에 무리를 주는 호스트를 제지할 때 사용                 5       Redirection       패킷 라우팅 경로를 수정, SMURF 공격에서 사용                 8 or 0       Echo Request or Reply       Host의 존재를 확인                 11       Time Exceeded       패킷을 보냈으나 시간이 경과하여 패킷이 삭제되었을 때 보내는 메시지                 12       Parameter Problem       IP 헤더 필드에 잘못된 정보가 있다는 것을 알림                 13 or 14       Timestamp Request and Reply       Echo와 비슷하나 시간에 대한 정보 추가           데이터 전송 방식          Unicast  1:1 전송 방식.            Broadcast  1:N 전송 방식. 동일한 서브넷 상의 모든 수신자에게 전송       Multicast  M:N 전송 방식. 하나 이상의 송신자들이 특정 그룹의 수신자에게 전송  IGMP : 그룹에 등록된 사용자를 관리하는 프로토콜            IGMP 메시지 구조 (8byte)                    Version : IGMP 프로토콜의 버전           Type : 메시지 유형. (1 = 보고, 2 = 질의메시지)           Group ID  보고 메시지의 경우 호스트에서 신규 가입하고자 하는 멀티캐스트 서비스의 group id,  계속 받아보기를 원하는 멀티캐스트 서비스의 group id 질의 메시지인 경우는 ‘0’                           Anycast  그룹에 등록된 노드 중에서 최단경로 노드 한 개에만 전송.  IPv6에서 사용 (Broadcast 대신)   ARP(Address Resolution Protocol)  IP주소를 물리적 하드웨어 주소인 MAC 주소로 변경하는 프로토콜  IP 주소와 이에 해당하는 물리적 네트워크 주소 정보는 각 IP 호스트의 ARP 캐시라 불리는 메모리에 테이블 형태로 저장된 후 다음 패킷 전송 시에 다시 사용  ARP Cache Table : MAC 주소와 IP 주소를 보유하고 있는 매핑 테이블   RARP(Reverse Address Resolution Protocol)  물리적인 주소 MAC을 기반으로 논리적인 주소 IP를 알아오는 프로토콜  운영체제도 없는 일종의 더미 터미널 Diskless Host에서 사용하는 것으로 자신의 물리적 주소인 MAC주소를 서버에 전송하고 IP주소를 수신 받아서 기동   네트워크 접근 계층  논리적 주소인 IP 주소를 물리적 MAC 주소로 변환  Physical Layer가 이해할 수 있는 헤더를 붙여주는 Layer, Frame 단위, MAC Address를 사용하는 계층   Point-to-Point 간 신뢰성 있는 전송으로 흐름 제어 기능을 담당  에러 제어 : Error Detection, Error Correction  MAC(Media Access Control) : LAN 카드의 물리적 주소   CSMA/CD  Carrier Sense Multiple Access/Collision Detection  유선 LAN에서 메시지를 송수신하기 위한 접근 방법. IEEE 802.3   1) 각 호스트들이 전송매체에 경쟁적으로 데이터를 전송  2) 프레임을 전송하면서 충돌여부를 검사  3) 전송 중 충돌이 감지되면 패킷의 전송을 즉시 중단  4) 충돌이 발생한 사실을 모든 스텐이션들이 알 수 있도록 간단한 통보신호 송신  5) 통보신호에 따라 전송을 조절   Collision이 일어난 경우 Back off 알고리즘을 이용하여 재전송  리피터와 허브를 이용하면 Collision이 발생하나 Switch는 Collision을 막을 수 있다  Switch는 브로드캐스트를 막을 수 없고 Router가 브로드캐스트를 막을 수 있다.      Non-Persistent  매채가 사용 중이 아니면 즉시 전송  매체가 사용 중이면, 확률분포에서 구한 재전송 지연시간만큼 대기            임의 지연 사용은 충돌 확률을 감소       매체가 비었을 때 임의 지연 때문에 데이터 전송이 없는 채널 휴지 발생           1-Persistent  매체가 사용 중이 아니면 즉시 전송  매체가 사용 중이면 대기 후 채널이 비는 순간 즉시 전송            채널 휴지 시간을 제거하기 위해 사용       임의 지연이 없게 하여 채널 휴지는 거의 없지만 충돌 확률이 높음           p-Persistent  매체가 사용 중이 아니라면, 확률 p로 전송하고 (1-p)의 확률료 하나의 시간단위를 지연  매체가 사용 중이면 기다렸다가 채널이 비는 순간 확률 p로 전송하고 확률 (1-p)로 대기            위 장단점을 상호보완하기 위해 사용           CSMA/CA  Carrier Sense Multiple Access/Collision Avoidance  무선 LAN에서 메시지의 송수신하기 위한 접근 방법   프레임 전송 이전에 제어 메시지를 이용하여 수신자로부터 간단한 전송 유발  제어 신호에 대한 응답이 도착하면 프레임 전송  ","categories": ["study"],
        "tags": ["네트워크","데이터통신"],
        "url": "https://many258.github.io/study/tcp-ip-internet-network-access/",
        "teaser": null
      },{
        "title": "[네트워크] TCP/IP 전송 계층",
        "excerpt":"Transport Layer  수신측에 전달되는 데이터에 오류가 없고 데이터의 순서가 그대로 보존되도록 보장하는 연결 지향 서비스의 역할을 하는 종단 간 서비스(End-to-End) 계층   신뢰성 있는 전송을 하는 TCP와 비신뢰성 전송을 하는 UDP가 존재      Segment  애플리케이션 계층의 메시지에 TCP 혹은 UDP의 헤더를 붙인 것을 의미.   TCP(Transmission Control Protocol)  클라이언트와 서버 간의 연결 지향, 신뢰성 있는 데이터 전송, 에러 제어, 흐름 제어, 완전이중 방식  신뢰성있는 데이터 전송을 위해 가상 연결 수행  송신자가 메시지를 전송하면 수신자는 ACK를 되돌려서 수신 여부를 확인     혼잡 제어(Congestion Control)  수신자 동일한 ACK 번호를 반복적으로 전송 =&gt; 데이터를 받지 못함 ==&gt; GO-BACK-N 방법으로 재전송   흐름 제어(Flow Control)  수신자가 메시지를 제대로 받지 못하면 송신자는 전송 속도를 늦추어 네트워크 효율성 제어   순서 제어 : Sequence 번호를 가지고 메시지의 순서 파악   Checksum : TCP, UDP 모두 존재. 송신 중 메시지의 변조 파악하기 위해 에러 체크   Receive Windows  수신자의 윈도우 크기이자 메모리 버퍼.  수신자의 버퍼가 비어 있으면 송신자는 해당 버퍼의 크기만큼 데이터를 한꺼번에 전송   TCP의 상태 전이  netstat 명령어로 확인 가능   1) 클라이언트는 서버에 연결요청 메시지인 SYN 신호를 보내고 SYN_SEND 상태 전환  2) 서버는 기동되면 클라이언트의 연결을 받기 위해 LISTEN 상태로 클라이언트의 연결 대기  3) 서버는 클라이언트로부터 SYN 메시지가 수신되면 서버는 클라이언트에게 SYN, ACK를 전송하고 SYN_RECEIVED 상태 전환  4) 클라이언트는 ACK를 서버에 전송하고 클라이언트와 서버는 ESTABLISHED(연결 확립) 상태      TCP 프로토콜의 Header 구조          근원지 포트(Source Port)  가상 선로의 송신측 포트(End point of Sender)            목적지 포트(Destination Port)  가상 선로의 수신측 포트(End point of receiver)            일련번호(Sequence Number)  송신자가 전송하는 데이터의 일련번호            전송확인(Piggyback Acknowledgement)  수신자와 응답하는 받은 데이터의 수            TCP 헤더 길이(Header Length)  TCP 헤더에 몇 개의 32Bit 워드가 포함되어 있는가를 나타내는 필드  옵션 필드가 가변 길이를 갖기 때문에 필요, 이 값을 이용하여 실제 데이터의 시작점을 계산            URG(Urgent)  긴급 지점이 사용될 때 1로 설정            ACK(Acknowledgement)  전송 확인을 필요로 할 때 설정            EOM(End of Message)  마지막 메시지임을 가리킴            재설정(RST)  연결의 재설정. 비정상적인 종료            동기화(SYN, Synchronization)  연결 설정 요구            FIN(Finish)  연결 해제에 사용되며, 송신측에서 더 이상 전송할 데이터가 없음을 의미            윈도우 크기(Window size)  수신측에서 수신할 수 있는 최대 Byte 수            체크썸(Checksum)  전송 데이터에 대한 완벽한 신뢰성을 위한 것으로, 모든 데이터의 합에 대한 ‘1’의 보수로 계산 무결성을 확인하기 위해 CRC(Cyclic Redundancy Check)코드 사용 CRC : 데이터 통신에서 전송 중에 전송 오류가 발생하였는지 확인하기 위해 덧붙인 코드            급송 지점(Urgent point)  다음에 이어지는 데이터가 급송되어야 함을 의미. 인터럽트 메시지 대신 사용            옵션  전송 셋업 과정의 버퍼 크기에 대한 통신 등 기타 목적에 활용       에러 제어          FEC(Forward Error Correction)  송신측이 특정한 정보 비트를 함께 전송하여 수신측에서 이 정보 비트로 에러 발생 시 수정하는 방식(수신측이 에러 처리)       데이터 전송과정에서 발생한 오류를 검출하여 오류를 재전송 요구 없이 수정  재전송 요구가 없어 역 채널이 필요 없고, 연속적인 데이터 전송 가능  오류 검출 및 수정을 위한 잉여비트들이 추가 전송되므로 전송 효율 감소             해밍 코드       상승 코드                BEC(Backward Error Correction)  수신측이 에러 검출 후 송신측에게 에러가 발생한 데이터 블록을 재전송 요청(송신측이 에러 처리, ARQ:Auto Repeat reQuest)       패리티 검사, CRC 등 CheckSum을 이용하여 오류 검출 후, 오류 제어는 ARQ가 처리                      Stop-And-Wait  하나의 데이터를 송신하고 수신 확인 신호를 받을 때까지 기다린 다음 전송                        Go-Back-N  수신자가 데이터를 수신 받지 못할 경우 마지막으로 수신 받은 데이터 이후의 모든 데이터 재전송 TCP에서 사용하는 방식                        Selective Repeat ARQ  수신받은 데이터 중에서 중간에 빠져있는 것만 재전송                        Adaptive ARQ                   흐름 제어  송수신측 사이의 전송 패킷의 양, 속도를 조절하여 네트워크를 효율적으로 사용      슬라이딩 윈도우(Sliding Window)  호스트 간에 송수신 혹은 수신할 수 있는 Size 정보를 제공  Stop-And-Wait의 단점을 보완한 방식으로 수신측의 확인 신호를 받지 않더라도 미리 정해진 프레임의 수만큼 연속적으로 전송  수신자의 버퍼 크기를 확인함으로서 최대한 전송 효율 극대화   혼잡 제어  라우터가 패킷을 처리할 수 있는 속도보다 많은 패킷을 수신하는 경우 라우터는 패킷을 손실하게 된다. 송신측에서는 패킷을 재전송하게 되는데, 이러한 과정의 연속으로 데이터의 손실이나 지연이 발생 혼잡 제어는 송신 단말의 전송률을 직접 제어하여 혼잡으로 인해 손실된 데이터를 재전송하기 위함           TCP Slow Start  TCP가 시작될 때 전송속도를 초기값부터 지속적으로 올리는 방법       송신측에서 패킷을 전송하는 비율과 수신측에서 수신된 ACK를 통해 Congestion Window(cwnd)를 지수의 크기로 증가.  cwnd는 계속적으로 증가하다가 임계값에 이르게 되면 Congestion Avoidance로 동작            Congestion Avoidance  Duplication ACK 값이 오거나 일정 시간 동안 ACK가 수신되지 않으면 전송속도를 낮춤  매번 ACK가 수신될 때마다 cwnd를 1/cwnd만큼 증가(선형적인 증가)            Fast Retransmit  Retransmit Threshold 이상 연속된 Duplicate ACK를 수신하는 경우 TCP는 해당 Segment를 재전송            Fast Recovery  Fast Retransmit한 이후 새로 Slow Start를 통해서 설정된 연결의 안전상태에 도달할 필요없이 Congestion Avoidance 상태에서 전송할 수 있도록 하는 것       UDP(User Datagram Protocol)  비연결성, 비신뢰성(블록 재전송 및 흐름 제어 등이 없음)을 특성으로 패킷을 고속 전달할 수 있는 프로토콜  비접속형 : 전달되는 패킷에 대한 상태 정보를 유지하지 않음  간단한 헤더구조(8Byte), 블록 단위로 데이터 전송   UDP 프로토콜의 Header 구조          근원지 포트(Source Port)            목적지 포트(Destination Port)            수신자의 포트번호 길이(Length)            체크썸(Checksum)       VoIP(Voice Over IP)  UDP 프로토콜은 빠르게 데이터를 전송해야 하는 서비스에서 사용하는데 대표적인 활용이 VoIP      RTP(Real Time Protocol) : 음성 전송   RTCP(Real Time Control Protocol) : 에러 처리  ","categories": ["study"],
        "tags": ["네트워크","데이터통신"],
        "url": "https://many258.github.io/study/tcp-ip-transmission/",
        "teaser": null
      },{
        "title": "[데이터베이스] 데이터베이스 설계",
        "excerpt":"데이터베이스 설계  데이터베이스 설계 시 유의사항  저장된 데이터가 연산 수행 후에도 무결성이 유지될 수 있도록 설계  시스템 장애 시 복구될 수 있도록 회복과 예비 절차를 염두에 두고 설계  외부로부터 불법적인 접근을 방지할 수 있는 보안 절차를 유의하여 설계  데이터 관리에 대한 효율성과 일관성이 유지되도록 설계  데이터베이스의 확장과 축소에 대비한 신축성을 고려하여 설계   데이터베이스의 생명주기     요구 조건 분석 : 범위 설정을 위한 사용자와 그 응용을 식별하는 단계   설계 : 개념적 설계, 논리적 설계, 물리적 설계까지의 단계   구현 : 스키마 정의, 빈 데이터베이스 파일 생성, 응용 소프트웨어 구현 단계   운영 : 실제로 운영하여 사용자에게 서비스를 제공하는 단계   감시 및 개선 : 응용 과정에서 새로운 요구조건에 대처하고 성능을 개선하는 단계   데이터베이스 설계 순서  요구 조건 분석 단계  사용자 식별 및 범위 설정   요구되는 개체와 속성, 관계성, 제약조건, 트랜잭션의 유형, 실행 횟수 등을 파악    사용기관의 사용 목적과 내규, 법적인 규정, 데이터베이스의 사용자 식별, 사용 범위 결정 등 분석   개념적 설계 단계          개념 스키마 모델링  요구 분석 단계에서 나온 결과를 E-R 다이엉그램과 같은 DBMS에 독립적이고 고차원적인 표현 기법으로 기술하는 과정을 의미            트랜잭션 모델링  요구 조건 분석 결과로 식별된 응용을 검토해서 이들을 구현할 수 있는 트랜잭션을 고차원 명세로 기술하는 과정       논리적 설계 단계  DBMS에 따라 논리적 모델로 변환, 트랜잭션의 인터페이스 설계, 스키마 평가 및 정제   물리적 설계 단계  물리적 구조 설계, 트랜잭션의 세부 사항 설계     물리적 설계 사항                     저장될 레코드의 양식 설계  데이터 타입, 접근 횟수, 데이터 값의 분포 등을 고려                        저장될 레코드들의 분포 및 집중에 관한 설계  레코드의 저장 방식과 물리적 블록의 크기 고려                        접근 경로의 설계  데이터를 물리적 저장 장치에 어떻게 저장시킬 것이며, 그 저장된 데이터를 어떤 방법으로 가져다 쓸 것인지에 대한 접근 방법을 설계하는 것으로 인덱스 등을 설계                   물리적 설계 옵션 선택 시 고려 사항            응답시간       저장 공간의 효율화       트랜잭션 처리도           물리적 데이터베이스 설계 시 결정 사항            어떤 인덱스를 만들 것인지 고려       성능 향상을 위한 개념 스키마의 변경 여부 검토       빈번한 질의와 트랜잭션들의 수행 속도를 높이기 위한 사항을 고려       파일에 대한 트랜잭션의 갱신과 참조 성향 검토           구현 단계  DDL로 스키마 작성, 트랜잭션 프로그래밍(응용프로그램 작성)   ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-design/",
        "teaser": null
      },{
        "title": "[데이터베이스] 데이터 모델링",
        "excerpt":"데이터 모델  현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위해 사용되는 도구      개념적 데이터 모델(High-Level, Conceptual Data Model)  속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실 세계를 표현하는 방법            종류                    E-R 모델(Entity-Relationship Model)           이진 모델(Binary Model)           의미적 데이터 모델(Semantic Data Model)           정보 논리 모델(Information Logical Model)           함수적 데이터 모델(Functional Data Model)                           논리적 데이터 모델(Logical Data Model)  필드로 기술된 데이터 타입들 간의 관계를 이용하여 현실 세계를 표현하는 방법            종류                    관계형 데이터 모델           계층형 데이터 모델           네트워크형 데이터 모델           객체지향형 데이터 모델                           데이터 모델 구성요소          Structure  데이터의 논리적 구조  데이터 모델을 기술할 때는 데이터 사이의 관계성을 파악하여 그 논리적 구성 형태를 기술해 주어야 한다.            Operation  개체 인스턴스를 처리하는 연산  실제 데이터를 어떤 방법으로 삽입, 선정, 변경, 삭제할 것인가 하는 사항을 기술해야 한다.            Constraint  개체 인스턴스에 대한 논리적 제약 사항  실제 데이터의 특징과 특성을 파악하여 어떤 데이터만을 받아들이며 어떤 관계만을 허용할 것인가를 기술해야 한다.       개념적 데이터 모델  개체 관계 모델(Entity-Relationship Model)  개념적 단계에서 개체 내의 관계, 개체와 개체 사이의 사상 관계를 표현하는 데 쓰이며 사용자의 관점에서 가장 좋은 도구로 많이 사용되는 모델   특징  1976년 Peter Chen에 의해 제안된 이래 개념적 설계에 가장 많이 사용되는 모델  개체 타입과 관계 타입을 이용해서 현실 세계를 개념적으로 표현한 모델  개체라는 것은 현실 세계에 존재하는 객체들을 의미  관계라는 것은 개체들 사이의 관계를 표현하는 것  E-R 다이어그램은 그래프 형태로 표시  최초에는 Entity, Relationship, Attribute와 같은 개념들로 구성되었으나 나중에는 확장된 모델로 발전   기호      사상 원소수(Mapping cardinality)     1:1   1:N   N:1   N:M   논리적 데이터 모델  논리적 단계에서 쓰이는 도구로서 개념적 단계에서 만들어진 개념적 구조를 컴퓨터에 저장시킬 수 있는 논리적 구조로 변환하고자 쓰이는 데이터 모델   데이터베이스의 전체적인 논리적 구조를 설명할 때 사용되는 데이터 모델 관계 표현 : 관계 데이터 모델 - 테이블 구조, 계층 데이터 모델 - 트리 구조, 네트워크 데이터 모델 - 그래프 구조   관계형 데이터 모델(Relational Data Model)  통일적이고 단순한 데이터 구조로 되어 있다  사용자에게 가장 뛰어난 논리적 구조를 지원  릴레이션 구조로 운영되는 데이터베이스  개체나 관계 모두가 릴레이션 형태  기본키와 이를 참조하는 외래키로 데이터 간의 관계를 표현   계층형 데이터 모델(Hierarchical Data Model)  데이터 간의 관계를 순서 트리 형태로 표현  속성 간의 관계를 레코드, 레코드 간의 관계를 링크로 표현  계층 정의 트리 형태로 나타낼 때 노드는 레코드 타입이 되며 가지는 두 레코드 타입 사이의 링크가 된다  모든 링크의 관계는 1:N 관계  두 레코드 타입 간의 관계는 하나의 링크 관계만 있을 수 있으므로 별도의 이름을 부여하지 않음  레코드 타입 간에는 상하 계층이 존재, 사이클이 허용되지 않음  대표적인 DBMS = IMS   네트워크 데이터 모델(Network Data Model)  데이터 간의 관계는 그래프 구조 형태  1에 해당하는 레코드 타입을 오너 레코드 타입, N에 해당하는 레코드 타입을 멤버 레코드 타입, 이들의 관계를 오너-멤버(Owner-Member)관계라 한다.  레코드 타입 간의 관계는 1:1, 1:N, N:1, N:M이 될 수 있다 다 대 다의 관계가 있기 때문에 데이터 간의 연계성이 매우 뛰어난 모델이나 복잡하고 구축 비용이 크다 노드는 레코드 타입이 되고 링크는 개체 집합 간의 관계성을 표현 링크는 어느 한쪽으로 반드시 함수적 관계로 해서 화살표로 표현 링크 위에는 두 레코드 타입 간의 관계를 레이블로 표시 CDASYL(Conference On Data System Languages), DBTG(Data Base Task Group) 보고서에서 DBTG 모델이라는 것을 정의하여 네트워크 데이터 모델에 대한 이론적 개념을 정립   ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-modeling/",
        "teaser": null
      },{
        "title": "[데이터베이스] 데이터베이스 정규화",
        "excerpt":"관계 스키마 설계  데이터베이스 설계에서 중요한 사항 중 하나가 현실 세계를 가장 정확하게 표현하기 위한 데이터의 논리적 구조를 결정하는 것   설계 원칙  필요한 속성, 개체, 관계성을 식별하여 릴레이션을 구성  불필요한 데이터의 중복이 발생하지 않도록 설계  속성 사이의 관계성과 데이터의 종속성을 고려하여 설계  효율적 데이터 처리와 일관성 유지 방법 등을 고려하여 설계   스키마 변환(Schema Transformation)  관련된 어트리뷰트를 수집하고 이들 간에 존재하는 종속성을 파악하여 어트리뷰트의 집합인 릴레이션으로 만든 다음 보다 바람직한 형태의 릴레이션으로 다시 변환하는 과정      스키마 변환 원칙  공해의 원칙  정보 무손실 원칙  데이터 중복 감소의 원칙   이상(Anomaly) 현상  관계 스킴이 잘못되면 불필요한 데이터 중복을 초래하게 된다. 이러한 데이터 중복은 릴레이션을 조작할 때 곤란한 현상을 발생시키는 현상을 의미           삭제 이상(Delete Anomaly)  임의의 튜플을 삭제했을 때 그것과 관계를 형성하고 있는 관계성까지 모두 삭제되는 현상            삽입 이상(Insert Anomaly)  임의의 튜플을 삽입했을 때 삽입 의도가 없는 관계까지도 삽입되는 현상            갱신 이상(Update Anomaly)  임의의 데이터를 갱신했을 때 그것과 관계를 맺고 있는 데이터에 대해 일관성을 유지할 수 없는 현상       정규화 과정  하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해 나가는 과정           목적 구성되는 릴레이션이 중복되지 않게 효과적으로 데이터베이스 내에 표현이 가능하도록 한다 보다 간단한 연산자에 의해 효과적인 연산이 가능하도록 한다 릴레이션에 삽입 이상, 삭제 이상, 갱신 이상의 목제가 발생하지 않도록 한다 새로운 형태의 데이터가 삽입될 때 릴레이션을 재구성할 필요성을 감소시키도록 한다            필요성 자료의 저장 공간을 최소화 자료의 불일치를 최소화 자료 구조 안정화 자료의 삽입, 삭제, 갱신 시 이상 현상을 방지       함수 종속     어떤 릴레이션 R에서 A, B가 릴레이션 R의 부분 속성이라고 할 때,     임의 시점에서 A의 어떤 값도 반드시 B의 하나의 값에 대응되지만, B의 하나의 값이 A의 복수의 값에 대응되는 경우 B는 A의 함수 종속이라 하고, A → B로 표기한다. 여기서 A는 결정자, B는 종속자라 한다.    기본 정규형  제1정규형  어떤 릴레이션 R에 속한 모든 도메인이 원자값(분해될 수 없는 값)으로만으로 되어 있다면 제1정규형에 속한다.   제2정규형  어떤 릴레이션 R이 제1정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 완전 함수적 종속(부분 함수 종속 제거)이면 제 2정규형에 속한다.  기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미.      완전 함수 종속성  A, B가 각각 관계 R의 속성이고 B가 A에 함수 종속(A→B)인 경우, A의 임의의 부분 집합에 대하여 B의 어떤 값도 A의 부분 집합의 값에 대응하지 않으면 B는 A에 완전함수(적) 종속   제3정규형  어떤 릴레이션 R이 제2정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 이행적 함수 종속이 아니면 제3정규형에 속한다      이행 함수 종속성  A, B, C가 각각 관계 R에 상호 중복되지 않는 속성(다만, A는 1차 키 이외의 속성)인 경우에, A가 B에 함수 종속적이 아니면 이때 C는 A에 이행함수 종속이라고 한다. A-&gt;B 이고 B-&gt;C 일 경우에만 A-&gt;C 이면 이행함수(적) 종속이라고 한다.   보이스 코드 정규형(Boyce-Codd Normal Form : BCBF)  릴레이션 R의 모든 결정자가 후보키이면 릴레이션 R은 BC(Boyce-Codd)정규형에 속한다.           슈퍼키  레코드를 유일하게 식별해낼 수 있는 속성들의 집합이다. 한 개의 테이블은 여러 개의 슈퍼키를 가질 수 있다.            후보키  슈퍼 키에서 레코드를 유일하게 식별하는데 있어서 필요없는 속성을 제거한 슈퍼 키의 부분집합       제4정규형  릴레이션 R에 비당연 MVD A-»B가 존재할 때 R의 모든 속성도 A에 함수 종속이면 릴레이션 R은 제4정규형에 속한다      다치 종속성(MVD)  어떤 레코드의 존재가 다른 레코드의 존재로 이어짐을 의미한다. 다치종속성은-»으로 표시하는데, R｛A,B,C｝일 때 (A,C)-»｛B｝≡(A) -&gt;｛B｝ 성립한다. , A-»B이면 A-»C도 성립하고 A-»B│C이다.   제5정규형  릴레이션 R에 존재하는 모든 조인 종속(JD)이 릴레이션 R의 후보키를 통해서만 성립된다면 릴레이션 R은 제5정규형 또는 PJ/NF(Projection-Join Normal Form)에 속한다      조인 종속  릴레이션 R이 그의 프로젝션 A,B,…..,Z의 조인과 동일하면 R은 JD*(A,B,….,Z )를 만족한다. 이때 A,B,….,Z는 R의 애트리뷰트에 대한 부분집합이다.  다시말해서, 테이블 R이 R의 속성의 부분집합을 가지는 여러 개의 테이블들을 조인하여 만들어질 수 있을 때, R은 조인 종속성을 가진다고 한다.  ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-normalization/",
        "teaser": null
      },{
        "title": "[데이터베이스] 관계 데이터베이스",
        "excerpt":"관계 데이터베이스  데이터 간의 관계를 테이블 구조로 나타내는 데이터베이스   이 데이터베이스는 개체를 표현하는 데 있어 속성과 속성 간의 연관 관계를 파악하여 테이블의 형태로 표현하며, 개체와 개체 사이의 연관 관계도 테이블 형태로 표현한다.      관계 데이터베이스 용어  속성(Attribute)  어떤 개체의 정보의 특성이나 특징에 대한 이름을 의미. 파일 시스템의 레코드 필드와 유사   속성이란 용어는 우리가 프로그래밍하게 되면 어떤 값을 넣을 변수를 선언하게 되는데 이 변수의 개념에 해당   도메인(Domain)  한 속성의 의미로 들어오는 실제 값(원자값)들의 집합   변수를 선언하게 되면 그 선언 타입에 해당하는 개념   튜플(Tuple)  릴레이션 스킴에 따라 각 속성으로 실제 값이 입력됐을 때 하나의 행 값에 해당하는 개념  파일시스템의 레코드 개념과 유사   릴레이션(Relation)  데이터 간의 관계를 나타내는 표 자체   한 개 이상 속성들의 집합으로 표현 릴레이션의 일반적 의미는 테이블과는 학술적으로 다르게 사용되어 진다 릴레이션이라는 것은 릴레이션 스킴과 릴레이션 어커런스를 합쳐 지칭하는 용어   릴레이션 스킴(Relation Scheme)  릴레이션 스키마(Schema), 릴레이션 타입(Type) 또는 릴레이션 내포(Intention)라고도 불리며  릴레이션의 논리적 구조를 정의하는 것으로 릴레이션 이름과 해당 릴레이션을 형성하는 하나 이상의 속성을 합쳐 정의하는 개념   릴레이션 어커런스(Relation Occurrence)  릴레이션 인스턴스(Instance) 또는 릴레이션 외연(Extension)이라고도 하며  어느 한 시점(시간에 가변적인 특성)에서 릴레이션 스킴에 따라 실제 데이터로 입력된 튜플들의 집합을 의미하는 개념   릴레이션의 특성          튜플의 유일성  모든 튜플은 다르다는 것으로, 하나의 릴레이션으로 입력되는 튜플은 중복된 튜플이 존재하지 않는다는 개념            튜플간의 무순서  릴레이션으로 입력되는 모든 튜플은 순서가 정해져 입력되는 것이 아니라 상황에 따라 순서 없이 입력된다는 개념            속성값은 원자값  릴레이션에서 하나의 속성으로 입력되는 도메인 값은 하나의 튜플에서 분해 될 수 없는 형태로 입력되어야 한다는 개념            속성 간의 무순서  하나의 릴레이션에서 속성 간의 논리적인 순서는 관계가 없다는 개념            속성 이름의 유일성  하나의 릴레이션에서 속성 이름은 유일해야 한다       차수(Degree)  하나의 릴레이션에서 정의된 속성의 개수, 즉 필드의 개수를 표현  설계의 변경이 이루어지지 않는 한 항상 정적인 상태를 유지   카디널리티(Cardinality)  기수라고도 하며, 하나의 릴레이션에 형성된 튜플의 개수, 즉 레코드의 수를 의미  데이터 조작 연산에 의해 항상 변화하므로 동적인 상태   NULL 값  Empty, 모르는 값, 정의되어 있지 않은 값을 의미. 0과 공백의 의미와 다르다는 것을 유의   관계 데이터베이스 키 제약사항  키(Key)는 각각의 튜플을 유일하게 구분할 수 있는 개념이며 유일한 식별성과 최소성을 가지고 있어야 하며, 하나의 릴레이션에는 최소한 하나의 키가 있어야 한다.      최소성  가장 적은 개수의 어트리뷰트로 구성될 수 있는 성질   유일성  릴레이션으로 입력되는 모든 튜플을 유일하게 구별할 수 있는 성질   슈퍼키(Super Key)  최소성 없이 단지 튜플을 식별하기 위해 두 개 이상의 속성 집합으로 이루어진 키를 의미   후보키(Candidate Key)  하나의 릴레이션에서 유일성과 최소성을 가지고 있는 모든 속성 또는 속성의 집합   기본키(Primary Key)  후보키들 중 데이터베이스의 설계자에 의해 선택된 한 개의 키를 의미   기본키로 선택된 속성은 중복되지 않으며 정의되지 않는(NULL) 값을 가질 수 없다   대체키(Alternate Key)  후보키 중 기본키를 제외한 모든 키는 대체키의 역할을 한다.   외래키(Foreign Key)  테이블의 필드(attribute) 중 다른 테이블의 행(row)을 식별할 수 있는 키를 의미   두 테이블을 연결하는 연결다리 역할을 하며, 참조하는 테이블에 무결성을 높여주는 역할을 수행   무결성(Integrity) 제약사항  데이터베이스에 저장되는 데이터에 대한 정확성을 부여할 목적으로 제약사항을 설정하는 것을 의미   도메인 무결성(Domain Integrity)  기본적인 무결성 규정으로 데이터베이스 릴레이션에서 주어진 속성으로 입력되는 모든 값은 그 속성으로 정의되거나 제약된 도메인 영역에 있어야 한다는 규정을 의미   개체 무결성(Entity Integrity)  하나의 개체 릴레이션에서 기본키를 구성하는 속성은 널(NULL)값이나 중복된 튜플이 존재해서는 안된다는 규정을 의미   참조 무결성(Referential Integrity)  외래키 값은 NULL 값이거나 참조 릴레이션의 기본키와 동일해야 한다. 즉, 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 의미   릴레이션에 있는 튜플 정보가 다른 릴레이션에 있는 튜플 정보와 비교하여 관계성이 있으며, 관계되는 정보의 정확성을 유지하는 가를 규정하는 것   고유 무결성  특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성값은 모두 달라야 하는 제약조건   NULL 무결성  특정 속성값에 NULL값을 가질 수 없다는 조건이 주어진 경우, 그 속성값은 NULL값이 올 수 없다는 제약조건   키 무결성  한 릴레이션에는 최소한 하나의 키가 존재해야 한다는 제약 조건  ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-relationship/",
        "teaser": null
      },{
        "title": "[데이터베이스] 관계 데이터 연산",
        "excerpt":"관계 대수(Relational Algebra)  릴레이션으로부터 필요한 릴레이션을 만들어내는 연산자의 집합  주어진 릴레이션 조작을 위한 연산의 집합  원하는 정보와 그 정보를 어떻게 유도하는가(How)를 기술하는 절차적인 방법  관계 해석과 관계 대수는 표현 방법만 다를 뿐이지 표현 능력의 차이는 없다   집합연산자(Set Operations)          합집합(Union : ∪)  이항 연산으로 관계성이 있는 두 개의 릴레이션에 속하는 튜플의 집합을 구하여 하나의 릴레이션으로 만들어 내는 연산            교집합(Intersection : ∩)  이항 연산으로 관계성이 있는 두 개의 릴레이션에서 중복된 튜플을 선택하여 새로운 릴레이션을 만들어 내는 연산            차집합(Difference : -)  이항 연산으로 관계성이 있는 두 개의 릴레이션이 있을 때 그 중 하나의 릴레이션에서 또 다른 릴레이션의 튜플과 겹치는 튜플을 제거하여 새로운 릴레이션을 생성하는 연산            곱집합(Cartesian Product : ×)  이항 연산으로 두 개의 릴레이션이 있을 때 두 릴레이션의 튜플들을 접속하여 순서쌍의 집합을 만들어 새로운 릴레이션을 만들어 내는 연산       결과 릴레이션의 차수는 연산 대상 릴레이션 차수를 더해서 나오고 카디널리티는 곱해서 나온다       관계연산자(Relational Operations)          설렉션(Selection : σ(sigma))  단항 연산으로 릴레이션에서 조건에 맞는 레코드(튜플)을 분리해 내는 연산       하나의 릴레이션에서 수평적 부분집합을 취하는 연산       A와 B를 릴레이션 R의 애트리뷰트,  θ는 비교 연산자(=,≠, &lt;, ≤, &gt;, ≥),  v는 상수라고 할 때                                               σAθB(R) = {r             t∈R ∧ r.Aθv}                                   σAθB(R) = {r             t∈R ∧ r.Aθr.B}                                      위와 같이 설렉션 연산을 표현한다       설렉션에 표현된 식 r.Aθv나 r.Aθr.B을 비교식/조건식/프레디킷(Predicate)이라 하는데 셀렉션은 바로 이 프레디킷을 참으로 만드는 튜플을 선택            프로젝션(Projection : ∏(pi))  단항 연산으로 릴레이션에서 구하고자 하는 속성을 선택하여 분리해 내는 연산       하나의 릴레이션에서 수직적 부분집합을 취하는 연산       릴레이션 R이 있고, R에 속한 튜플을 t, A, B가 R 릴레이션의 속성이라 할때 프로젝션 여산의 수학적 표현은 다음과 같다                                               ∏A, B(R) = {t.A, t.B             t∈R}                                           조인(Join : ⋈)  두 개 이상의 릴레이션에서 조건에 맞는 속성이 들어 있는 튜플을 접속하여 새로운 릴레이션을 생성하는 연산       두 릴레이션 R과 K가 있다고 가정할 때  R에 속한 튜플을 r, K에 속한 튜플을 k,  R에 속한 속성을 A, K에 속한 속성을 B,  θ는 관계 연산자(=,≠, &lt;, ≤, &gt;, ≥)라 할 때 수학적 표현은 다음과 같다.                                               R⋈AθBK = { r · k             r∈R ∨ k∈K ∧ (r.Aθk.B) }                                                      세타 조인(Theta Join)  조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플을 반환                        동등 조인(Equi Join)  세타조인에서 = 연산자를 사용한 조인을 의미                      R⋈R.C=K.EK                                 자연 조인(Natural Join)  동등 조인에서 중복된 속성을 제거한 결과를 반환                      R⋈NK                                 세미 조인(Semi Join)  자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환           닫힌 쪽의 릴레이션 튜플만 반환                                   외부 조인(Outer Join)  자연 조인 시 조인에 실패한 튜플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환           종류 : 왼쪽 외부조인, 오른쪽 외부조인, 완전 외부조인                                              디비전(Division : ÷)  두 개의 릴레이션 R과 K가 있을 때 K 릴레이션의 모든 조건을 만족하는 경우의 튜플들을 릴레이션 R에서 분리해 내어 프로젝션하는 연산       관계 해석  수학의 프레디킷 해석(Predicate Calculus)에 기반  질의하는 형식으로 원하는 형태의 릴레이션을 정의하는 연산  구하고자 하는 정보가 무엇(What)이라는 것만 명시하는 비절차적 형태의 연산   관계 해석 기호     ∀ : 모든 것에 대하여(for all)   ∃ : 존재한다(There exist)   ∈ : t가 r에 속함( t ∈ r )   θ : 비교 또는 관계 연산자(=,≠, &lt;, ≤, &gt;, ≥)   ∨ : OR 연산자   ∧ : AND 연산자   ㄱ : NOT 연산자   튜플 관계 해석(Tuple Relational Calculus)  원하는 릴레이션을 튜플 해석식으로 정의하는 표기법      정의            {t[A], t[B] | F(t)}  F(t) : 정형식  / t : 튜플변수  / t[A] : 한정 속성            도메인 관계 해석(Domain Relational Calculus)  원하는 릴레이션을 도메인 해석식으로 정의하는 표기법      정의            { &lt;x1,x2,…,xn&gt;｜F(x1,…, xn, xn+1,…, xn+m)}   &lt;x1,x2,…,xn&gt;: 구해야 할 도메인 변수  F(x1,…, xn,…) : 정형식의 구성 원칙에 따라 구성된 식           ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-relational-operation/",
        "teaser": null
      },{
        "title": "[데이터베이스] SQL",
        "excerpt":"SQL(Structured Query Language)  ANSI, ISO에서 선정한 관계 데이터베이스 표준 언어  관계 대수와 관계 해석을 기초로 한 혼합 언어  데이터 정의, 조작, 제어 기능을 모두 갖추고 있다.  비절차식 언어이며 대화식 질의어로 사용 가능  다른 프로그램 언어(COBOL, PL/1, C, Pascal)에 삽입된 형태로 사용 가능   SQL에서 사용하는 테이블     기본 테이블  DDL에 의해 만들어지는 테이블로 독립적으로 존재하며 테이블명을 기록하게 되어 있다   뷰 테이블  역시 DDL에 의해 만들어지며 기본 테이블에서 유도되어 만들어지는 가상 테이블   임시 테이블  질의 처리과정에서 DML에 의해 만들어지는 테이블로 임시적으로 만들어지는 테이블   SQL에서 사용하는 자료형의 종류                  타입명       구분       설명                       BIT(N)       비트열       고정길이로 Bit단위로 할당                 VARBIT(N)       비트열       가변길이로 Bit단위로 할당                 CHAR(N)       문자열       고정 길이로 N개 할당                 VARCHAR(N)       문자열       가변 길이로 N개 할당                 SMALLINT       정수형       2바이트 고정 소수점 형식                 INT or INTEGER       정수형       4바이트 고정 소수점 형식                 FLOAT       실수형       4바이트 부동 소수점 형식                 DOUBLE       실수형       8바이트 부동 소수점 형식                 DECIMAL(i,j)       10진형       i는 10진수의 개수, j는 소수점 이하 자리수                 GRAPHIC(N)       그래픽형       그림 형태의 내용을 기억시킬 기억 장소 할당                 LOGICAL       논리형       TRUE, FALSE를 기억시킬 기억 장소                 DATE       날짜형       YY-MM-DD 형식                 TIME       시간형       HH:MM:SS 형식           SQL 명령어의 분류     데이터 정의어(DDL : Data Definition Language)            CREATE : 테이블/인덱스/뷰의 생성       ALTER : 테이블의 변경       DROP : 테이블/인덱스/뷰의 제거       TRUNCATE : 테이블 초기화           데이터 조작어(DML : Data Manipulation Language)            SELECT : 데이터 검색       UPDATE : 데이터 갱신       INSERT : 데이터 삽입       DELETE : 데이터 삭제           데이터 제어어(DCL : Data Control Language)            GRANT : 사용자에게 권한 부여       REVOKE : 사용자의 권한 해제           트랜잭션 제어어(TCL : Transaction Control Language)            COMMIT : 데이터를 데이터베이스에 저장하고 트랜잭션을 성공적으로 종료       ROLLBACK : 데이터의 변경사항을 취소하고 원상태로 복귀한 후 트랜잭션 종료           데이터 정의어  CREATE  테이블, 뷰, 인덱스 등을 생성할 때 사용   테이블 생성 구문  CREATE TABLE 테이블 명 ({속성의 멤버 정의...}) {[PRIMARY KEY 속성]} {[UNIQUE 속성]} {   [FOREIGN KEY 속성 REFERENCES 기본테이블] 속성   [ON DELETE {RESTRICT/CASCADE/SET NULL/SET DEFAULT}]   [ON UPDATE {RESTRICT/CASCADE/SET NULL/SET DEFAULT}]   [] } {[CHECK 조건식]}     NOT NULL : 널 값을 허용하지 않을 때 지정   PRIMARY KEY : 기본키를 구성하는 속성을 지정   FOREIGN KEY : 외래키로 어떤 릴레이션의 기본키를 참조하는지를 지정   RESTRICT : 동작이 취소(제한)됨   CASCADE : 연속으로 같은 동작을 수행   SET NULL : 모두 NULL로 바꿔주는 동작 수행   SET DEFAULT : 주어진 초기 값으로 설정   CHECK : 속성의 제약조건 지정   뷰 생성 구문  CREATE VIEW 뷰이름(속성)   AS SELECT (속성)     FROM 테이블명     [WHERE 조건식]   인덱스 생성 구문  CREATE [UNIQUE] INDEX 색인명   ON 테이블명 (속성 [ASC/DESC])   [CLUSTER]     UNIQUE : 색인화되어야 할 하나의 필드나 필드 조합이 중복되어서 같은 값이 나타나지 않게 하고자 사용   ASC/DESC : 명시하지 않으면 오름차순(ASC)으로 자동설정   CLUSTER : 색인 값과 물리적인 실제 데이터를 일치시킬 때 사용하는 옵션으로 하나의 테이블에서 한번빡에 생성할 수 없음   ALTER  생성된 기본 테이블이나 도메인의 정의를 변경하고자 할 때 사용하는 명령어   기본 구문  ALTER TABLE 테이블명   [ADD/ALTER/DROP/MODIFY] 변경하고자 하는 속성     ADD : 테이블에 속성 추가   ALTER : 도메인 정의 변경   DROP : 테이블에서 속성이나 제약조건 삭제   MODIFY : 속성의 데이터 유형, 제약조건에 대한 변경                     MODIFY COLUMN 시 고려사항           해당 컬럼의 크기를 늘릴 수는 있지만 줄이지는 못한다. 이는 기존의 데이터가 훼손될 수 있기 때문이다.           해당 컬럼이 NULL 값만 가지고 있거나 테이블에 아무 행도 없으면 컬럼의 폭을 줄일 수 있다.           해당 컬럼이 NULL 값만을 가지고 있으면 데이터 유형을 변경할 수 있다.           해당 컬럼의 DEFAULT 값을 바꾸면 변경 작업 이후 발생하는 행 삽입에만 영향을 미치게 된다.           해당 컬럼에 NULL 값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있다.                   DROP  테이블, 뷰, 인덱스의 정의를 제거   기본 구문  DROP TABLE 테이블 이름 [CASCADE | RESTRICT] DROP VIEW 뷰 이름 [CASCADE | RESTRICT] DROP INDEX 인덱스 이름   데이터 조작어  SELECT  테이블이나 뷰에 접근해서 원하는 튜플이나 속성을 검색하는 명령어   기본 구문  SELECT [COUNT/SUM/AVG/MAX/MIN](속성)    FROM 테이블명  SELECT [ALL(*)/DISTINCT] 속성 리스트   FROM 테이블명   [WHERE 조건식]   {     속성 BETWEEN 값1 AND 값2     속성 IS (NOT) NULL     속성 IN (도메인값:집합형태)     속성 LIKE '문자'   }   [GROUP BY 속성][HAVING 조건식]   [ORDER BY 속성[ASC/DESC]]     ALL(*) : 하나의 테이블에 있는 모든 속성 출력   DISTINCT : 중복을 제거하는 옵션   집계함수            COUNT : 해당 열이 있는 총 튜플의 개수       SUM : 해당 열에 있는 데이터의 합       AVG : 해당 열에 있는 데이터들의 평균       MAX : 해당 열에 있는 데이터 중 최대값       MIN : 해당 열에 있는 데이터 중 최소값           BETWEEN : 값1과 값2 사이에 해당하는 조건   IS (NOT) NULL : 값이 NULL일 경우(아닐 경우) 조건   IN : 연산자는 조건의 범위를 지정하는 데 사용된다. 값은 콤마( , )로 구분하여 괄호 내에 묶으며, 이 값 중에서 하나 이상과 일치하면 조건에 맞는 것으로 평가   LIKE : 문자열 연산으로 사용되며 부분적으로 일치하는 값을 검색(숫자로 되어있는 필드는 사용 불가)            ‘_‘(하이픈) : 한 문자의 대표 문자       ’%’(퍼센트) : 모든 문자의 대표 문자       예시)  ‘유__’ : 문자 ‘유’로 시작하는 3글자 검색  ‘유%’ : 문자 ‘유’로 시작되는 모든 문자열 검색           GROUP BY : 그룹 지정, 조건식으로 HAVING 문법 사용   ORDER BY : 정렬 검색, [ASC: 오름차순 / DESC : 내림차순]   INSERT  원하는 테이블에 원하는 튜플을 삽입시키는 연산   기본 구문  INSERT INTO 테이블명(삽입시킬 속성들)   VALUES(삽입시킬 속성에 삽입될 실제 값들)   UPDATE  테이블에서 원하는 속성값을 변경시키는 연산   기본 구문  UPDATE 테이블명 SET 속성=값 [WHERE 조건식]   DELETE  원하는 테이블에서 원하는 레코드를 삭제시키는 연산   기본 구문  DELETE FROM 테이블 [WHERE 조건식]   데이터 제어어  GRANT  사용자에 따라서 접근할 수 있는 DB데이터와 사용할 수 있는 기능을 제한   기본 구문  GRANT 권한(ALL PRIVILEGES/SELECT/UPDATE/INSERT ...) ON 데이터베이스.테이블  TO '아이디'@'호스트' IDENTIFIED BY '비밀번호' WITH GRANT OPTION  FLUSH PRIVILEGES;     WITH GRANT OPTION : 권한을 할당받은 유저가 GRANT 명령어도 사용할 수 있는 권한을 가지게 된다. 권한의 해제는 REVOKE GRANT OPTION 명령어를 사용한다.   REVOKE  REVOKE 권한 ON 데이터베이스.테이블 FROM 사용자  ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-sql/",
        "teaser": null
      },{
        "title": "[자료구조] 자료구조 기본",
        "excerpt":"자료구조(Data Structure)     문제 해결에 있어 가장 효율적으로 자료를 조직하고 구조화하며, 자료를 표현하고 연산하는 일련의 활동을 의미한다.    자료구조의 분류     선형구조(Linear)            스택(Stack)       큐(Queue)       데크(Deque)       배열(Array)       연결리스트(Linked list)           비선형구조(Non-Linear)            트리(Tree)       그래프(Graph)           자료의 표현     외부 표현            BCD 코드 : 6비트, 64가지 표현, 소문자는 표현 불가       ASCII 코드 : 7비트, PC와 데이터 통신에서 주로 사용       EBCDIC 코드 : 8비트, 대형 컴퓨터에서 주로 사용           내부 표현            수치 표현 : 컴퓨터 내부에 크기를 표현하기 위한 방법       포인터 표현 : 컴퓨터 내부에서 주소를 표현하기 위한 방법       논리 표현 : 긍정과 부정의 개념을 컴퓨터 내부에 표현하기 위한 방법           예외 표현 : 10진수 표현, 에러 검출, 데이터 송수신 등 용도로 사용            그레이 코드       3초과 코드       패리티 코드       해밍 코드           음수 표현 방식 컴퓨터 내의 연산 시 감산기(뺄셈)을 따로 만들지 않고 가산기(덧셈)만을 이용하여 덧셈과 뺄셈을 수행하기 위해 숫자자료는 보수 표현을 사용한다            부호화 절대치 : 첫 번째 비트가 0이면 양수이고 1이면 음수를 사용하는 방식                    수의 표현 범위 : -(2n-1-1) ~ 2n-1-1                       부호화된 1의 보수 : 양수의 1의 보수값을 음수로 사용                    수의 표현 범위 : -(2n-1-1) ~ 2n-1-1                       부호화된 2의 보수 : 양수의 2의 보수값을 음수로 사용                    수의 표현 범위 : -(2n-1) ~ 2n-1-1                           선형 구조     데이터를 저장시키는데 있어 데이터와 데이터를 1:1 대응 구조로 관계 맺어 저장시키는 형태의 구조를 의미    스택(Stack)  처음 입력시킨 자료는 맨 마지막에 출력되고 맨 마지막에 입력시킨 자료는 맨 처음에 출력되는 LIFO(Last in First Out)구조   한쪽에서만 입출력하는 구조      스택의 응용 분야            함수 호출이나 서브 프로그램 호출 시 복귀를 지정할 때       인터럽트 분기 시 복귀 주소를 저장할 때       되부름 시 복귀 주소를 저장할 때       수식을 연산할 때       수식의 후위 표기법 변환       0주소 명령어 형식의 자료 저장소           삽입 알고리즘 (PUSH)  IF TOP &gt;= M Overflow TOP ← TOP + 1 STACK(TOP) ← X   TOP 포인터가 전체 크기 M보다 크거나 같으면 오버플로가 발생하고 그렇지 않으면 TOP 포인터 값을 하나 증가시켜 원하는 자료 X를 스택의 TOP포인터 위치에 삽입   삭제 알고리즘 (POP)  IF TOP = 0 Underflow X ← STACK(TOP) TOP ← Top - 1  TOP 포인터가 0과 같으면 스택에 데이터가 없는 것이므로 언더플로가 발생하고 그렇지 않으면 스택에서 TOP 포인터 위치와 값을 X에 넣어 삭제시켜주고 TOP 포인터 값을 하나 감소시킨다.   큐(QUEUE)  먼저 입력된 자료가 먼저 출력되는 FIFO(First In First Out) 구조 또는 FCFS(First Come First Serve) 구조라 불린다.   한쪽 방향에서는 입력만 하고, 다른 한쪽 방향에서는 출력만 이루어진다.   삽입(Rear or Tail)과 삭제(Front or Head) 포인터 두 개를 두고 운용한다.  삽입 시 Rear 값을 증가 시키고 삭제 시 Front를 감소시킨다.      큐의 응용 분야            스풀 운용 처리에 사용       운영체제의 스케줄링 작업에 사용           삽입 알고리즘(Enqueue)   IF rear &gt;= M overflow QUEUE(rear) ← X rear ← rear + 1  Rear 포인터가 큐의 전체 크기 M보다 크거나 같으면 오버플로가 발생하고 그렇지 않으면 큐에서 Rear 포인터가 가리키는 위치에 X라는 자료를 삽입하고 삽입 포인터 Rear를 하나 증가시킨다.   삭제 알고리즘(Dequeue)  IF front = rear underflow X ← QUEUE(front) front ← front + 1  삭제 표인터 Front와 삽입 포인터 Rear가 같으면 데이터가 없는 언더플로가 발생하고 그렇지 않으면 큐에서 Front 포인터가 가리키는 위치의 값을 X에 치환하고 삭제 포인터 Front를 하나 증가시킨다.   데크(Deque)  포인터를 두 개 두고 운영(Left, Right)  양쪽끝에서 입출력이 일어나는 구조   입력 제한 데크는 스크롤(Scroll), 출력 제한 데크는 셀프(Shelf)   환형 큐(Circular Queue)  선형 큐는 front가 증가하여 Size 에 도달했을때 다시 빈 공간을 활용할 수 없다는 단점이 있는데,  이 점을 보완하여, 원형 큐를 사용하면 원형으로 배열 요소를 접근하게 하여 빈 공간에 다시 재할당이 가능해진다   큐가 가득 찬 경우와 큐가 비어있는 경우를 구분이 불가능한 단점  =&gt; 배열을 가득 채우지 않고 배열의 길이 N일 경우 N-1개 채워졌을 때 이것을 가득 찬 것으로 가정하여 해결   환형 큐의 상태 알고리즘  // Empty IF QUEUE → Rear == QUEUE → Front   EMPTY  // Full IF (QUEUE → Rear + 1) % QUEUE_SIZE == QUEUE → Front   FULL  // EnQueue IF FULL(QUEUE) Overflow QUEUE → Rear = (QUEUE → Rear + 1) % QUEUE_SIZE QUEUE → Data[QUEUE → Rear] = X  // DeQueue   IF EMPTY(QUEUE) Underflow QUEUE → Front = (QUEUE → Front + 1) % QUEUE_SIZE X = QUEUE → Data[QUEUE → Front]   배열(Array)  같은 크기의 기억 장소를 연속된 공간에 모아 놓고 원하는 데이터를 기록하거나 액세스하는 것을 의미      특징  엑세스 속도가 빠르다  삽입, 삭제가 어렵고 메모리에 종속적이다   연결리스트(Linked List)  자료를 구성할 때 포인터 자료를 포함해서 하나의 자료를 구성하는 형태로, 이 포인터를 이용해 현 자료와 관계있는 자료를 연결하는 형식으로 구성하여 저장      특징  액세스 속도가 느리다  중간에 단절되면 다음 노드를 찾기 어렵다  메모리에 대해 독립적이며 삽입, 삭제가 간편하다  메모리 단편화를 방지하여 기억 장소를 절약할 수 있다  포인터를 위한 추가 공간이 별도로 필요   비선형 구조  자료가 있을 때, 이 자료와 관계를 맺고 있는 다른 자료가 여러 개 존재하는 경우 이러한 관계성(1:N, N:M)을 표현하기 위한 구조   트리(Tree)  노드와 선분으로 되어 있고 정점 사이에 사이클이 형성되지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 구조   여기서는 트리의 용어와 종류만 간단하게 언급하고 다음 장에서 부가 설명을 할 계획      용어            근노드(Root Node) : 트리의 뿌리가 되는 노드       단노드(Terminal Node, Leaf) : 노드의 차수가 0인 노드 또는 자식이 없는 노드를 의미       간노드(Nonterminal Node) : 노드의 차수가 0이 아닌 노드 또는 자식을 가지고 있는 노드를 의미       차수(Degree) : 각 노드의 가지 수, 또는 각 노드가 가지고 있는 자식 노드의 수를 의미       트리의 차수(Tree Degree) : 트리 전체에서 노드의 차수가 가장 큰 것을 의미       레벨(Level) : 근 노드를 1레벨로 하여 차례로 2, 3 레벨로 증가하여 표시       깊이(Depth) : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수       높이(Height) : 트리의 총 레벨을 의미       자노드(Child Node) : 각 노드에 연결되어 있는 다음 레벨의 노드를 의미       부노드(Parent Node) : 각 노드의 바로 상위 레벨에 있는 노드를 의미       제노드(Sibling Node) : 같은 부노드에 연결되어 있는 노드를 의미       숲(Forest) : 트리가 모여서 이루어진 집합       서브 트리(Sub Tree) : 임의의 노드를 제거했을 때 생길 수 있는 트리의 집합을 의미           트리의 운행(Tree Traversal)            중위 운행(Inorder Traversal) : &lt;좌, 근, 우&gt; 순서로 운행       전위 운행(Preorder Traversal) : &lt;근, 좌, 우&gt; 순서로 운행       후위 운행(Postorder Traversal) : &lt;좌, 우, 근&gt; 순서로 운행       레벨 순서 순회(Level-order Traversal) = 너비 우선 순회(Breadth-First Traversal) : 노드를 레벨 순서로 방문하는 순회 방법       위 3가지는 스택을 활용하여 구현이 가능하며, 레벨 순서 순회는 큐를 활용하여 구현이 가능하다           종류            이진 트리       이진 탐색 트리(AVL)       레드 블랙 트리       스레드 이진 트리       B-트리, B+트리       이집 힙           그래프(Graph)  트리보다 더 일반적인 자료 구조이며, 그래프는 트리를 포함한다. 일반적으로 정점과 선분으로 되어있으면서 사이클이 형성되는 경우를 트리와 구별하여 그래프라 지칭      용어            그래프의 표시 : G = (V, E) {V: 정점들의 집합, E: 간선의 집합}       정점(Vertex) : 표현하고자 하는 대상 자료의 집합       간선(Edge) : 정점 사이에 관계       경로(Path) : 임의의 정점과 정점을 연결하는 경로       사이클(Cycle) : 경로의 길이가 2이상인 경로에서 종착점과 시작점이 같은 경로       차수(Degree) : 임의의 정점에 연결되어 있는 가지 수, 간선의 수                    진입 차수(In-Degree) : 정점으로 들어오는 간선의 수           진출 차수(Out-Degree) : 정점에서 나가는 간선의 수                       임의의 두 노드가 하나의 간선으로 연결돼 있을 경우, 이 노드들은 서로 인접(Adjacent)해 있으며, 간선은 두 노드에 부속(Incident)           그래프의 종류          비방향성 그래프(Undirected Graph)  간선 사이에 방향이 표시되지 않은 그래프. G(A, B)로 표현            방향성 그래프(Directed Graph)  간선 사이에 방향이 표시되어 있는 그래프. G&lt;A, B&gt;로 표현            완전 그래프(Complete Graph)  그래프를 구성한 모든 정점에서 자기 자신을 제외한 모든 정점에 대하여 간선이 있는 경우를 의미            레이블 그래프(Labeled Graph)  그래프에서 간선에 실수 레이블을 붙여 표시하는 그래프       그래프의 표현     인접 행렬   인접 리스트      ","categories": ["study"],
        "tags": ["자료구조","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/datastructure/",
        "teaser": null
      },{
        "title": "[알고리즘] 최소신장트리(MST)와 그래프의 순회(Graph Traversal)",
        "excerpt":"신장 트리(Spanning Tree)  그래프 내의 모든 정점을 포함하는 트리  최소 연결 부분 그래프.   N개의 정점을 가지는 그래프의 최소 간선의 수는 N-1개이며, N-1개의 간선으로 연결되어 있으면 필연적으로 트리 형태가 이루어지고 이것이 바로 Spanning Tree라 할 수 있다.   하나의 그래프에는 많은 신장 트리가 존재할 수 있으며, 트리의 특수한 형태이므로 모든 정점들이 연결되어 있어야 하고 사이클을 포함해서는 안된다.   최소 신장트리(MST : Minimum Spanning Tree)  가능한 신장트리에서 간선의 가중치 합이 최소인 신장트리를 의미   최소 비용 신장 트리를 구하는 방법들은 모두 탐욕 알고리즘(Greedy Algorithm)으로 구현   ** 탐욕 알고리즘 : 각 단계에서 최선의 선택이 최종 단계에서도 최선의 결과를 나타낼 것이라고 생각하는 알고리즘   크루스칼 알고리즘(Kruskal’s Algorithm)  간선 위주의 알고리즘.      모든 간선들의 가중치를 오름차순으로 정렬   가중치가 최소인 간선을 선택   위에서 선택한 간선이 연결하려는 2개의 노드가 서로 연결되지 않은 상태라면, 2개의 노드를 서로 연결(이 때, 사이클이 발생하지 않도록 주의)   최소신장트리가 만들어지기 전까지 2~3 과정 반복 수행   그래프 내 간선의 개수가 적은 희소 그래프의 경우 크루스칼 알고리즘에 적합하다      프림 알고리즘(Prim’s Algorithm)  정점 위주의 알고리즘      임의의 정점을 선택   정점에 인접한 간선 중 가중치가 최소인 간선으로 연결된 정점을 선택   위 정점에서 다시 최소 간선으로 연결된 정점을 선택   최소신장트리가 만들어지기 전까지 2-3 과정 반복 수행   그래프 내 간선의 개수가 많은 밀집 그래프의 경우 프림 알고리즘이 적합하다      그래프의 순회(Graph Traversal)  하나의 정점에서 시작하여 그래프에 있는 모든 정점을 한번씩 방문하는 것을 그래프 순회 또는 탐색이라 한다   DFS(깊이 우선 탐색 : Depth-First Search)  아직 방문하지 않은 자식 노드를 우선적으로 탐색      정점 i를 방문한다.   정점 i에 인접한 정점 중에서 아직 방문하지 않은 정점이 있으면 이 정점을 모두 STACK에 저장한다   스택에서 정점을 삭제하여 새로운 i를 설정하고 다시 1단계부터 수행   스택이 공백이 되면 연산을 종료         특징                     현 경로상의 노드만을 기억하면 되므로 저장 공간의 수요가 비교적 적지만, 한 경로가 무한히 깊을 경우 오버플로우가 발생할 수 있다.  이를 방지하기 위해, 깊이에 제한을 두고 구현이 필요하다                        목표에 도달하지 못할 가능성이 존재하며, 도달할지라도 해당 경로가 최단 경로라고 보장할 수 없다.                   BFS(너비 우선 탐색 : Breadth-First Search)  형제 노드를 우선적으로 탐색하는 기법      임의의 시작 노드를 정해 QUEUE에 넣는다   Dequeue연산을 통해 큐에서 노드를 가져와 현재 노드로 정한다   현재 노드의 인접 노드 목록을 순회하면서 방문하지 않은 노드가 있는지 확인한다   방문하지 않은 노드가 있다면 그 노드를 큐에 넣고 방문한다.   큐가 공백이 될 때까지 2~4과정을 반복 수행         특징            큐에 다음에 탐색할 정점들을 저장해야 하므로 저장공간이 많이 필요       단순 검색속도가 DFS보다 빠르다       최단 경로를 보장함과 동시에 반드시 찾을 수 있다          ","categories": ["study"],
        "tags": ["Algorithm","컴퓨터일반","Programming"],
        "url": "https://many258.github.io/study/algorithm-MST-graph-traversal/",
        "teaser": null
      },{
        "title": "[자료구조] 트리의 종류 및 특징",
        "excerpt":"트리의 종류  이진 트리(Binary Tree)  기본적으로 자식노드를 최대 2개 가지는 트리를 의미   완전 이진 트리(Complete Binary Tree)  왼쪽 자식노드부터 채워지며 마지막 레벨을 제외하고는 모든 자식노드가 채워져있는 트리      힙(Heap)  부모 자식 노드 간의 대소 관계는 정의되어 있으나 형제간의 대소관계는 정의되어 있지 않은 완전 이진트리 자료구조를 의미   힙에는 두가지 종류가 있으며, 부모노드의 키값이 자식노드의 키값보다 항상 큰 힙을 ‘최대 힙’, 부모노드의 키값이 자식노드의 키값보다 항상 작은 힙을 ‘최소 힙’이라고 명명한다.      포화 이진 트리(Perfect Binary Tree)  모든 노드가 0 or 2개의 자식노드를 가지며 모든 리프노드가 똑같은 레벨에 있는 경우의 트리   레벨의 수를 N이라 가정할 때, 2n-1 개의 노드를 가진다.      정 이진 트리(Full Binary Tree)  모든 노드가 0 or 2개의 자식노드를 가지는 트리를 의미      편향 이진 트리(Skewed Binary Tree)  노드들이 전부 한 방향으로 편향된 트리를 의미      이진 탐색 트리(BST : Binary Search Tree)  이진트리의 구조와 자료의 검색/삭제/삽입에 효율적이게 정렬의 개념이 추가된 형태   기본적인 특징은 이진 트리와 같지만 하나 다른 점은 자기 왼쪽에는 자신보다 값이 작은 노드가, 오른쪽에는 자신보다 값이 큰 노드가 존재해야 한다      중회 순회(Inorder) 시 순차적으로 데이터가 정렬된다.   자가 균형 이진 탐색 트리(Self-Balancing Binary Search Tree)  이진 탐색트리는 저장과 검색에 평균 logN시간이 소요되지만 편향으로 구성되어있거나 균형이 무너지면 N에 근접한 시간이 소요될 수 있다.   그래서, 고안해낸 것이 균형잡힌 이진탐색트리이다. 대표적으로 AVL트리와 레드블랙트리가 있으며 최악의 경우에도 이진트리의 균형이 잘 맞도록 유지한다.      AVL트리는 더욱 엄격한 균형을 이루고 있기 때문에 Red-Black 트리보다 더 빠른 검색을 제공   Red-Black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어지지 않기 때문에 AVL트리보다 빠르게 삽입/제거 작업을 수행   AVL트리는 각 노드에 대해 BF를 저장하므로 노드 당 int 저장이 필요 Red-Black 트리는 노드당 1bit의 정보만 필요   AVL 트리  스스로 균형을 잡는 이진 탐색 트리   검색/삽입/삭제 평균과 최악의 경우 O(log N)의 시간복잡도를 가지며,  노드가 삽입 또는 삭제될 때 회전을 통해 트리를 재구성하여 높이 균형 성질을 유지시킨다   균형인수(BF : Balance Factor)를 구성하며 왼쪽과 오른쪽 서브트리의 높이 차를 나타낸다      BF = hL - hR    값이 -1, 0, 1일 때만 균형있는 트리라고 할 수 있다.      레드블랙 트리(RB Tree : Red-Black Tree)  레드-블랙 트리는 자료의 삽입과 삭제, 검색에서 최악의 경우에도 일정한 실행 시간을 보장한다.  이는 실시간 처리와 같은 실행 시간이 중요한 경우에 유용하며 일정한 실행 시간을 보장하는 다른 자료구조(대표적으로 STL의 Map)를 만드는 데에도 사용된다.      RB Tree는 다음과 같은 특성을 가진다.           각 모든 노드는 레드 or 블랙 색상을 갖는다            Root Property  트리의 루트는 항상 블랙이다            External Property  모든 리프 노드(NIL)들은 블랙이다            Internal Property  노드가 레드이면 그 노드의 자식은 반드시 블랙이다            Depth Property  특정 노드에서 아래에 있는 모든 NULL 노드까지의 경로에서 만나는 블랙 색상의 노드의 수가 동일하다       다원 탐색 트리 (MST : M-way Search Tree)  균형을 유지한다는 점에서 균형 이진 트리와 유사하지만 트리의 각 노드가 여러 개의 자료를 가질 수 있고, 하위 트리의 수를 임의로 설정 가능하다는 차이점이 존재한다.   MST는 한개의 노드에 여러개의 키가 있을 수 있다. 자식 노드에도 여러 개의 키가 들어갈 수 있다.      특징            각 노드는 0에서 최대 M개의 서브 트리를 가진다       K개의 서브 트리를 가지는 노드는 (K-1)개의 자료를 가진다(단, K&lt;=M)       각 노드 안에서 자료들은 검색 키에 의해 정렬           B-트리(B Tree)  M원 탐색 트리의 차수가 많아져서 트리의 높이도 증가하면 점점 비효율적으로 변하게 된다. 그래서 B-트리를 고안해 규칙이 있는 MST를 구상했다.   대량의 데이터를 처리해야 하는 검색 구조 주로 데이터베이스, 파일시스템에서 인덱스 저장 방법으로 사용하는 자료구조이다.   노드 내 데이터 수가 N개라면 자식 노드의 수는 (N+1)이며, 노드의 데이터는 항상 정렬된 상태여야 한다.   노드 내 최대 데이터 수에 따라 2차 B-Tree(2개), 3차 B-Tree(3개), …라 명명         특징            루트 노드의 자식 수는 2 이상이어야 한다       모든 단말노드는 같은 레벨을 가진다       Internal 노드는 ⌈M/2⌉이상 M이하의 자식을 갖는다.       각 노드의 원소 수는 최소[M/2-1]개 이상 최대[M-1]개를 가진다           B+트리(B Plus Tree)  B-트리는 특성상 순회 작업이 상당히 난감하다. B+ 트리는 색인구조에서 순차접근에 대한 문제의 해결책으로 제시되었다.   B트리의 특징을 가지고 있지만 모든 키 값들이 Leaf 노드에 정렬되어 있는 트리 구조.   Leaf 노드들은 연결 리스트 형태로 서로 연결되어 있고 이를 순차집합(sequence set)이라고 하며 오름차순으로 정렬이 되어 있다      B+ 트리의 비단말 노드(not leaf)들은 데이터의 빠른 접근을 위한 인덱스 역할 수행(Index Set)   오직 리프노드에만 데이터 저장 가능하고 리프 노드에 모든 데이터가 있기 때문에 키 중복이 있다   리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용 가능   하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.   B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다      B*트리(B Star Tree)  삽입 또는 삭제 작업 수행 시 발생하는 노드 분리를 줄이기 위해 노드의 약 2/3 이상이 채워지는 B트리.   노드가 꽉 차면 분리하지 않고 키와 포인터를 재배치하여 다른 형제 노드로 옮김      리프를 제외한 모든 노드는 m개의 서브트리 이상을 가질 수 없다   루트와 리프를 제외한 모든 노드는 적어도 [(2m-2)/3]+1개의 서브트리를 갖는다   루트는 리프가 아닌 이상 최소 2개, 적어도 2[(2m-2)/3]+1개의 서브트리를 갖는다.   모든 단말노드는 같은 레벨을 가진다   각 리프노드는 최소[(2m-2)/3]개, 최대 m-1개의 키 값을 갖는다   노드에 저장되는 자료가 넘치는 경우(Overflow), 일단 형제 노드들로 재분배하는 과정 수행. 모든 형제 노드들이 가득 찬 경우에만 B-트리의 분할 연산을 수행(보조 연산 최소화)   트라이(Trie)  문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조 주로 검색어 자동완성, 사전찾기, 문자열 검사에서 사용   원하는 원소를 찾을 때, 원소의 길이가 L일 경우 O(L)의 시간복잡도를 가진다.   빠르게 탐색이 가능하다는 장점이 있으나 각 노드에서 자식들에 대한 포인터들을 배열로 모두 저장하고 있다는 점에서 저장공간의 크기(공간복잡도)가 크다는 단점을 지니고 있다.      ","categories": ["study"],
        "tags": ["자료구조","컴퓨터일반","Programming"],
        "url": "https://many258.github.io/study/data-structure-tree-type/",
        "teaser": null
      }]
