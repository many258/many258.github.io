<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My LifeChronicle</title>
    <description>Be a Imagineer.</description>
    <link>https://many258.github.io/</link>
    <atom:link href="https://many258.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 05 May 2021 22:57:25 +0900</pubDate>
    <lastBuildDate>Wed, 05 May 2021 22:57:25 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>[전자계산기] 프로세서(Processor)</title>
        <description>&lt;h2 id=&quot;프로세서의-종류&quot;&gt;프로세서의 종류&lt;/h2&gt;
&lt;h3 id=&quot;cisccomplex-instruction-set-computer&quot;&gt;CISC(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Complex&lt;/code&gt; Instruction Set Computer)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;초창기 대부분의 컴퓨터 구조&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;마이크로프로그램 제어&lt;/strong&gt; 방식을 사용&lt;/li&gt;
  &lt;li&gt;명령어의 크기는 &lt;strong&gt;16~64비트&lt;/strong&gt;, &lt;strong&gt;명령어의 개수&lt;/strong&gt;는 120~305개 정도로 &lt;strong&gt;많은&lt;/strong&gt; 편이다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모리 참조 연산&lt;/strong&gt;을 많이 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;riscreduced-instruction-set-computer&quot;&gt;RISC(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduced&lt;/code&gt; Instruction Set Computer)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;하드 와이어드 제어&lt;/strong&gt; 방식을 채택&lt;/li&gt;
  &lt;li&gt;중요 명령어들만 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROM&lt;/code&gt;에 저장&lt;/strong&gt;시켜 처리하고 나머지 명령어들은 &lt;strong&gt;사용 시에 소프트웨어적&lt;/strong&gt;으로 처리&lt;/li&gt;
  &lt;li&gt;명령어의 길이는 &lt;strong&gt;32비트로 고정 크기&lt;/strong&gt;이고 &lt;strong&gt;명령어의 개수&lt;/strong&gt;도 100개 미만으로 &lt;strong&gt;적다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;레지스터 참조&lt;/strong&gt; 연산을 많이 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;수퍼-스칼라-risc&quot;&gt;수퍼 스칼라 RISC&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;파이프라인 병렬 처리가 가능&lt;/strong&gt;하게 한 구조&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISC&lt;/code&gt;구조의 확장형&lt;/strong&gt;으로 명령어의 효율적인 처리를 위해 고안된 구조&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vliwvery-long-instruction-word&quot;&gt;VLIW(Very Long Instruction Word)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;수평 마이크로 명령 형식&lt;/strong&gt;을 사용하므로 &lt;strong&gt;명령어의 해독이 필요&lt;/strong&gt;없으며, 비트 하나가 &lt;strong&gt;하나의 명령&lt;/strong&gt;을 의미&lt;/li&gt;
  &lt;li&gt;하나의 &lt;strong&gt;명령어의 길이가&lt;/strong&gt; 수백 비트(128~512Bit)로 &lt;strong&gt;크다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;마이크로프로세서의-구성-방법&quot;&gt;마이크로프로세서의 구성 방법&lt;/h2&gt;
&lt;h3 id=&quot;비트-슬라이스-마이크로프로세서bit-sliced-microprocessor&quot;&gt;비트 슬라이스 마이크로프로세서(Bit Sliced Microprocessor)&lt;/h3&gt;
&lt;p&gt;Processor Unit, Micro-Program Sequencer, Control Memory 등을 &lt;strong&gt;각각 다른 IC에&lt;/strong&gt; 설계한 마이크로프로세서.&lt;/p&gt;

&lt;p&gt;이는 주어진 특성에 맞게 동적으로 &lt;strong&gt;재구성이 가능&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;단일-칩-마이크로-프로세서one-chip-microprocessor&quot;&gt;단일 칩 마이크로 프로세서(One Chip Microprocessor)&lt;/h3&gt;
&lt;p&gt;Processor Unit, Micro-Program Sequencer, Control Memory가 &lt;strong&gt;하나의 IC&lt;/strong&gt;로 구성된 프로세서를 의미.&lt;/p&gt;

&lt;p&gt;1개의 칩 안에 모든 기능을 집적한 고정된 형태를 가지므로 &lt;strong&gt;워드 길이, 명령 집합 등이 변경될 수 없다&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;중앙-처리-장치cpu&quot;&gt;중앙 처리 장치(CPU)&lt;/h2&gt;
&lt;h3 id=&quot;cpu의-구분&quot;&gt;CPU의 구분&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;스택 구조 CPU&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상체나 결과를 &lt;strong&gt;스택&lt;/strong&gt;에 넣어두고 운용하는 CPU&lt;/li&gt;
      &lt;li&gt;수식을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Postfix&lt;/code&gt; 표기법으로 변환 후, &lt;strong&gt;0-주소 명령어 형식&lt;/strong&gt;을 사용하여 연산&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단일 누산기 구조 CPU&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상체나 결과를 &lt;strong&gt;누산기&lt;/strong&gt;(Accumulator)에 넣고 운용하는 CPU&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;1-주소 명령어 형식&lt;/strong&gt;을 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;범용 레지스터 구조 CPU&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상체나 결과를 &lt;strong&gt;레지스터나 메모리&lt;/strong&gt;에 넣어두고 운용하는 CPU&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;2-주소 명령어 형식&lt;/strong&gt;을 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cpu의-구성&quot;&gt;CPU의 구성&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/cpu-architecture.png&quot; title=&quot;https://www.geeksforgeeks.org/last-minute-notes-computer-organization/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/cpu-architecture.png&quot; alt=&quot;&quot; title=&quot;CPU의 구성&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;연산 장치(ALU, Arithmetic and Logic Unit)&lt;/strong&gt;&lt;br /&gt;
산술 연산 및 논리 연산 등을 수행하는 장치&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;가산기&lt;/li&gt;
      &lt;li&gt;누산기&lt;/li&gt;
      &lt;li&gt;자리 올림 플립플롭&lt;/li&gt;
      &lt;li&gt;오버플로 체크 플립플롭&lt;/li&gt;
      &lt;li&gt;보수기 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제어 장치(Control Unit)&lt;/strong&gt;&lt;br /&gt;
주기억 장치에 기억되어 있는 명령어를 차례로 인출하여 해독하고, 해독한 결과에 따라 필요한 제어 신호를 각 장치에 보내는 역할을 수행&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;PC(Program Counter)&lt;/li&gt;
      &lt;li&gt;IR(Instruction Register)&lt;/li&gt;
      &lt;li&gt;명령 해독기(Instruction Decoder)&lt;/li&gt;
      &lt;li&gt;MBR(Memory Buffer Register)&lt;/li&gt;
      &lt;li&gt;MAR(Memory Address Register)&lt;/li&gt;
      &lt;li&gt;순서 제어기&lt;/li&gt;
      &lt;li&gt;주소 처리기&lt;/li&gt;
      &lt;li&gt;신호 방생 장치 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;메모리(Memory)&lt;/strong&gt;&lt;br /&gt;
입력된 자료, 상태 자료, 중간 계산 자료, 최종 결과 자료 등을 보관하는 위치&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;버스bus&quot;&gt;버스(Bus)&lt;/h3&gt;
&lt;p&gt;CPU에서 각 부분의 정보 교환은 어드레스 버스와 데이터 버스를 통하여 이루어진다. 정보 교환을 위해 버스를 사용하는 이유는 결선의 수를 줄일 수 있는 최선의 방법이기 때문이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버스의 형태
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;주소 버스(Address Bus)&lt;/strong&gt;
메모리의 특정 위치를 지정하기 위한 &lt;strong&gt;단방향&lt;/strong&gt; 신호 회선으로 신호선의 수는 &lt;strong&gt;메모리의 최대 용량&lt;/strong&gt;과 관계가 있다&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;주소 버스선의 수가 &lt;strong&gt;N&lt;/strong&gt;개 일 때, 메모리 용량은 &lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;데이터 버스(Data Bus)&lt;/strong&gt;
CPU와 주기억 장치 사이에서 데이터를 주고받기 위한 &lt;strong&gt;양방향&lt;/strong&gt; 회선으로 &lt;strong&gt;CPU가 한 번에 처리할 수 있는 Bit 수&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;제어 버스(Control Bus)&lt;/strong&gt;
CPU나 메모리 혹은 입출력 장치에 어떤 동작을 취하게 하기 위해 &lt;strong&gt;제어 신호를 전달&lt;/strong&gt;하는 &lt;strong&gt;단방향&lt;/strong&gt; 신호 회선&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cpu의-기능&quot;&gt;CPU의 기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;연산 기능&lt;/strong&gt; : CPU에 있는 ALU가 수행하는 기능으로 데이터에 대해 산술 처리나 논리 처리를 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;제어 기능&lt;/strong&gt; : CPU에 있는 제어 장치가 수행하는 기능으로 제어 신호를 발생시켜 하드웨어 요소들을 통제&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;기억 기능&lt;/strong&gt; : 정보를 일시적으로 저장하기 위한 &lt;strong&gt;레지스터&lt;/strong&gt;와 CPU나 프로그램의 상태를 나타내는데 쓰이는 &lt;strong&gt;플래그&lt;/strong&gt;들에 의해 수행되는 기능&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전달 기능&lt;/strong&gt; : 각 장치가 버스로 연결되어 정보를 주고받는 기능&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 05 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-processor/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-processor/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 주소 지정 방식</title>
        <description>&lt;h2 id=&quot;주소-설계-시-고려-사항&quot;&gt;주소 설계 시 고려 사항&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주소의 효율적 표현&lt;/strong&gt;&lt;br /&gt;
필요한 정보를 읽거나 저장하기 위해서는 읽을 위치나 저장 위치를 지정해 주어야 하는데 이 위치를 표현하기 위한 가장 작은 비트 수, &lt;strong&gt;가장 빠른 액세스를 가능하도록 하는 방법이나 절차&lt;/strong&gt;를 마련하는 것을 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;사용의 편리성&lt;/strong&gt;&lt;br /&gt;
사용자들이 주소를 사용하는 방법이 편리해야 한다는 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주소 공간과 기억 공간을 독립&lt;/strong&gt;&lt;br /&gt;
여러 개의 프로그램이 데이터를 사용하는데 있어 &lt;strong&gt;프로그램의 변경 없이&lt;/strong&gt; 서로 다른 시간에 데이터에 &lt;strong&gt;접근&lt;/strong&gt;할 수 있도록 &lt;strong&gt;재배치가 가능&lt;/strong&gt;하도록 하는 것을 의미&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주소-표현-방식&quot;&gt;주소 표현 방식&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;완전 주소&lt;/strong&gt; : 데이터가 기억된 장소를 직접 사상시킬 수 잇는 주소&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;약식 주소&lt;/strong&gt; : 주소의 일부분을 생략한 주소, 계산에 의한 주소 지정, 레지스터 이용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;생략 주소&lt;/strong&gt; : 주소를 구체적으로 지정하지 않는 경우, 스택, 누산기 지정시&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 자신&lt;/strong&gt; : 주소 표현 위치에 실제 데이터를 위치시키는 경우, 많은 비트 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주소-지정-방식&quot;&gt;주소 지정 방식&lt;/h2&gt;
&lt;h3 id=&quot;즉시-주소immediate-address&quot;&gt;즉시 주소(Immediate Address)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-immediate.png&quot; title=&quot;https://www.gatevidyalay.com/addressing-modes/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-immediate.png&quot; alt=&quot;&quot; title=&quot;즉시 주소 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;명령어의 주소 부분에 실제 데이터가 들어 있는 방식&lt;/strong&gt;으로 명령어 수행이 즉각적으로 이루어진다&lt;/li&gt;
  &lt;li&gt;실제 데이터를 가져오기 위해 &lt;strong&gt;메모리를 참조할 필요가 없다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;명령어에 실제 데이터를 포함하고 있으므로 &lt;strong&gt;수행 속도는 빠르지만&lt;/strong&gt; Operand에 실제 데이터를 넣기 위해서는 &lt;strong&gt;명령어 길이에 제약&lt;/strong&gt;이 따를 수 밖에 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;직접-주소direct-address&quot;&gt;직접 주소(Direct Address)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-direct.png&quot; title=&quot;https://www.studytonight.com/computer-architecture/addressingmodes-instructioncycle&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-direct.png&quot; alt=&quot;&quot; title=&quot;직접 주소 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어의 &lt;strong&gt;주소(Operand) 부분&lt;/strong&gt;에 데이터를 기억하고 있는 &lt;strong&gt;기억 장소의 주소를 지정&lt;/strong&gt;하는 방식&lt;/li&gt;
  &lt;li&gt;실제 데이터를 가져오기 위해 메모리는 &lt;strong&gt;한 번만 참조&lt;/strong&gt;하면 된다&lt;/li&gt;
  &lt;li&gt;단순한 대신에 &lt;strong&gt;융통성이 조금 떨어진다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;간접-주소indirect-address&quot;&gt;간접 주소(Indirect Address)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-indirect.png&quot; title=&quot;https://www.studytonight.com/computer-architecture/addressingmodes-instructioncycle&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-indirect.png&quot; alt=&quot;&quot; title=&quot;간접 주소 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어의 주소 부분이 지정하는 &lt;strong&gt;메모리 번지에 실제 데이터의 주소&lt;/strong&gt;가 저장되는 방식&lt;/li&gt;
  &lt;li&gt;실제 데이터를 가져오기 위해 메모리를 &lt;strong&gt;두 번 이상 참조&lt;/strong&gt;해야 한다&lt;/li&gt;
  &lt;li&gt;명령어의 길이가 짧고 제한되어 있어도 이것을 이용하여 &lt;strong&gt;긴 주소를 찾아갈 수 있기&lt;/strong&gt; 때문에 주소 지정에 많은 &lt;strong&gt;융통성이 있다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;계산에-의한-주소calculate-address&quot;&gt;계산에 의한 주소(Calculate Address)&lt;/h3&gt;
&lt;p&gt;오퍼랜드 부분에 있는 주소 값에 임의의 상수 값이나 레지스터에 있는 값을 더해서 유효 주소를 결정하는 방법&lt;/p&gt;

&lt;h4 id=&quot;인덱스-주소-지정index-register-address&quot;&gt;인덱스 주소 지정(Index Register Address)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-indexed.png&quot; title=&quot;https://www.gatevidyalay.com/addressing-modes/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-indexed.png&quot; alt=&quot;&quot; title=&quot;인덱스 주소 지정 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어 &lt;strong&gt;오퍼랜드 부분에 있는 주소 값&lt;/strong&gt;과 &lt;strong&gt;인덱스 레지스터&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IR&lt;/code&gt;, Index Register)에 들어 있는 값을 더해서 실제 데이터가 들어 있는 기억 장소의 위치를 지정하게 하는 방식&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;배열 엑세스 방식&lt;/strong&gt;에 주로 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;상대-주소relative-address&quot;&gt;상대 주소(Relative Address)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-relative.png&quot; title=&quot;https://www.gatevidyalay.com/addressing-modes/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-relative.png&quot; alt=&quot;&quot; title=&quot;상대 주소 지정 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어의 &lt;strong&gt;오퍼랜드 부분에 있는 주소 값&lt;/strong&gt;과 &lt;strong&gt;프로그램 카운터&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PC&lt;/code&gt;, Program Counter)에 들어 있는 값을 더해서 실제 데이터가 들어 있는 기억 장소의 위치를 지정하게 하는 방식&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 영역의 배치&lt;/strong&gt;와 &lt;strong&gt;프로그램 영역의 배치&lt;/strong&gt;가 &lt;strong&gt;유사한 경우&lt;/strong&gt;에 주로 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;분기 명령&lt;/strong&gt;에 많이 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;기준-주소-지정base-register-address&quot;&gt;기준 주소 지정(Base Register Address)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-base-register.png&quot; title=&quot;https://www.gatevidyalay.com/addressing-modes/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-base-register.png&quot; alt=&quot;&quot; title=&quot;기준 주소 지정 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어의 &lt;strong&gt;오퍼랜드 부분에 있는 주소 값&lt;/strong&gt;과 &lt;strong&gt;베이스 레지스터&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Base Register&lt;/code&gt;)에 들어 있는 값을 더해서 실제 데이터가 들어 있는 기억 장소의 위치를 지정하게 하는 방식&lt;/li&gt;
  &lt;li&gt;프로그램의 &lt;strong&gt;재배치&lt;/strong&gt;를 하는 경우에 상&lt;strong&gt;대적인 변위 지정만으로 해당 위치를 지정하기 위해&lt;/strong&gt; 많이 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다중 프로그래밍 기법&lt;/strong&gt;에서 주로 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;묵시적-주소implied-address&quot;&gt;묵시적 주소(Implied Address)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;0-주소 명령어나 1-주소 명령어 형식&lt;/strong&gt;&lt;a href=&quot;https://many258.github.io/study/electronic-calculator-instruction/#%ED%94%BC%EC%97%B0%EC%82%B0%EC%9E%90operand-address-%EA%B0%9C%EC%88%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B5%AC%EB%B6%84&quot; class=&quot;btn btn--info&quot;&gt;포스트 이동하기&lt;/a&gt;에서 스택이나 누산기의 위치를 지정할 때는 명시적으로 지정하는 것이 아니라 &lt;strong&gt;묵시적으로 가리키게 되는데&lt;/strong&gt;, 이 경우를 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;레지스터-주소register-address&quot;&gt;레지스터 주소(Register Address)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;명령어의 오퍼랜드에 레지스터의 위치를 지정하는 방식
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;레지스터 직접 모드&lt;/strong&gt;(Register Direct Mode)&lt;br /&gt;
레지스터에 실제 데이터가 있는 방식&lt;/p&gt;

        &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-register-direct.png&quot; title=&quot;https://www.gatevidyalay.com/addressing-modes/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-register-direct.png&quot; alt=&quot;&quot; title=&quot;레지스터 직접 주소 지정 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;레지스터 간접 모드&lt;/strong&gt;(Register Indirect Mode)&lt;br /&gt;
레지스터에 실제 데이터가 있는 기억 장소의 주소가 들어있는 방식&lt;/p&gt;

        &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-register-indirect.png&quot; title=&quot;https://www.gatevidyalay.com/addressing-modes/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-register-indirect.png&quot; alt=&quot;&quot; title=&quot;레지스터 간접 주소 지정 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주소-지정-방식-속도-비교&quot;&gt;주소 지정 방식 속도 비교&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-modes-speed.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-modes-speed.png&quot; alt=&quot;&quot; title=&quot;주소 지정 방식 속도 비교&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;입출력-장치의-주소-지정-방식&quot;&gt;입출력 장치의 주소 지정 방식&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;주소 지정 방식&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
      &lt;th&gt;장점&lt;/th&gt;
      &lt;th&gt;단점&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;기억 장치 사상 방식&lt;br /&gt;(Memory-Mapped)&lt;/td&gt;
      &lt;td&gt;입출력 장치와 주기억 장치가 &lt;strong&gt;하나의 주소 공간을 공유&lt;/strong&gt;해서 사용하는 방식&lt;/td&gt;
      &lt;td&gt;구조가 쉽고 관리하기 쉽다&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;주소가 한정&lt;/strong&gt;되어 있어 주기억 장치 확장일 때 문제가 있다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;분리형 입출력 방식&lt;br /&gt;(I/O Mapped)&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;입출력 주소와 기억 장치 주소가 각각 따로 존재&lt;/strong&gt;하는 방식&lt;/td&gt;
      &lt;td&gt;기억 장치 용량이 늘어나기 때문에 &lt;strong&gt;더 큰 프로그램 수행이 가능&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;기억 장치 주소와 입출력 주소를 구분하기 위해서 명령어를 사용해야 한다. 명령어가 늘어나면 제어하는 장치도 늘어나야 되서 &lt;strong&gt;하드웨어(CPU)가 복잡&lt;/strong&gt;해진다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Wed, 05 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-addressing-modes/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-addressing-modes/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 명령어</title>
        <description>&lt;h2 id=&quot;명령어instruction&quot;&gt;명령어(Instruction)&lt;/h2&gt;
&lt;h3 id=&quot;명령어의-구조&quot;&gt;명령어의 구조&lt;/h3&gt;
&lt;p&gt;명령어는 여러 동작을 실행하는데 필요한 정보를 가지고 있으며, 모든 컴퓨터에서 기본적으로 수행될 연산자와 그 연산에 사용할 대상체로 구성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;연산자(Operation, Op-Code)&lt;/strong&gt;&lt;br /&gt;
컴퓨터가 행하는 동작을 기호화해서 나타낸 정보로 연산자의 종류, 명령어 형식, 자료 종류 등의 정보를 나타내며, 명령어의 개수를 몇 개 사용할 것인지에 따라 사용 비트 수가 결정된다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Op-Code가 &lt;strong&gt;N&lt;/strong&gt;비트이면 생성될 수 있는 명령어의 개수는 &lt;strong&gt;2&lt;/strong&gt;&lt;sup&gt;&lt;strong&gt;N&lt;/strong&gt;&lt;/sup&gt;개&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;모드(Mod)&lt;/strong&gt;&lt;br /&gt;
대상체를 지정하는 방법으로 보통 &lt;strong&gt;직접 주소&lt;/strong&gt;와 &lt;strong&gt;간접 주소&lt;/strong&gt;로 구분&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주소(Address)&lt;/strong&gt;&lt;br /&gt;
처리할 정보 또는 처리된 정보를 기억시킬 곳을 나타내는 것으로 레지스터 번호나 메모리 주소를 나타내게 되는데, 메모리의 주소인 경우는 메모리 용량과 관계가 있다&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;어드레스 필드가 &lt;strong&gt;N&lt;/strong&gt;비트로 구성되어 있다고 할 때, 메모리 용량은 &lt;strong&gt;2&lt;/strong&gt;&lt;sup&gt;&lt;strong&gt;N&lt;/strong&gt;&lt;/sup&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p class=&quot;notice--info&quot;&gt;명렁어 세트의 &lt;strong&gt;효율성을 높이기 위한&lt;/strong&gt; 고려사항&lt;br /&gt;
&lt;br /&gt;
기억 공간, 사용 빈도, 함수 연산 기능 대 기타 연산 기능의 비율, 주기억 장치의 밴드폭 이용, 주소 지정 방식&lt;/p&gt;

    &lt;p class=&quot;notice--info&quot;&gt;명렁어 &lt;strong&gt;설계의&lt;/strong&gt; 고려사항&lt;br /&gt;
&lt;br /&gt;
어떤 종류의 연산자를 사용할 것인가?(연산자의 수 및 종류)&lt;br /&gt;
자료는 어떻게 지정할 것인가?(주소 지정 방식)&lt;br /&gt;
어떤 방식으로 연산자와 자료를 구조화할 것인가?(데이터 구조, Word 크기)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;연산자의-기능&quot;&gt;연산자의 기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;함수 연산 기능(Functional)&lt;/strong&gt;&lt;br /&gt;
산술적 연산과 논리적 연산을 수행하는 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;전달 기능(Transfer)&lt;/strong&gt;&lt;br /&gt;
버스 라인을 통해 레지스터 사이의 정보 이동 및 CPU와 주기억 장치의 정보를 이동시키는 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제어 기능(Control)&lt;/strong&gt;&lt;br /&gt;
제어 장치에 의해 명령어를 해독하여 명령어의 수행 순서를 제어하거나 연산 장치의 제어점 제어 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;입출력 기능(I/O)&lt;/strong&gt;&lt;br /&gt;
주기억 장치에 기억된 연산 결과를 출력 장치로 이동시키거나 입력 장치에 있는 데이터를 주기억 장치로 이동시키는 기능&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;명령어의-종류&quot;&gt;명령어의 종류&lt;/h3&gt;
&lt;h4 id=&quot;데이터-처리-명령어&quot;&gt;데이터 처리 명령어&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;산술 연산&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;ADD&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SUB&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;MUL&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;DIV&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;INC&lt;/strong&gt; : 1 증가시키는 명령&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;DEC&lt;/strong&gt; : 1 감소시키는 명령&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;논리 연산&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;AND&lt;/strong&gt; : 특정 문자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삭제&lt;/code&gt; 시 사용&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;OR&lt;/strong&gt; : 특정 문자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삽입&lt;/code&gt; 시 사용&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;XOR&lt;/strong&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비교&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;반전&lt;/code&gt; 시 사용&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;COMPLEMENT&lt;/strong&gt; : 1의 보수를 구할 때 사용&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CLEAR&lt;/strong&gt; : 모든 내용을 0으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리셋&lt;/code&gt;할 때 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시프트 연산&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;산술 Shift&lt;/strong&gt; : 2로 곱하거나 나누기를 하기 위한 오른쪽이나 왼쪽으로의 이동 명령&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;논리 Shif&lt;/strong&gt;t : 자료를 오른쪽이나 왼쪽으로 이동시키기 위한 명령&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Rotate&lt;/strong&gt; : 문자의 위치 변환을 위한 이동 명령(ROL, ROR)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;데이터-전송-명령어&quot;&gt;데이터 전송 명령어&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;LOAD&lt;/strong&gt; : 메모리로부터 &lt;strong&gt;CPU의 레지스터로 자료를 가져오는&lt;/strong&gt; 명령&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;STORE&lt;/strong&gt; : CPU의 레지스터에 있는 자료를 &lt;strong&gt;메모리에 기억&lt;/strong&gt;시키는 명령&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MOVE&lt;/strong&gt; : 레지스터에서 레지스터로 데이터를 전달하는 명령&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PUSH&lt;/strong&gt;, &lt;strong&gt;POP&lt;/strong&gt; : 스택에 데이터를 입출력하는 명령&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;INPUT&lt;/strong&gt; : 입력 장치에 있는 데이터를 메모리로 전달&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OUTPUT&lt;/strong&gt; : 메모리에 있는 데이터를 출력 장치로 전달&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;데이터-제어-명령어&quot;&gt;데이터 제어 명령어&lt;/h4&gt;
&lt;p&gt;모든 명령어들이 상황에 맞게 적절히 수행될 수 있도록 조작을 가하는 명령어&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;JUMP&lt;/strong&gt; : 원하는 곳으로 무조건 분기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SKIP&lt;/strong&gt; : 다음 명령어를 건너뛰고 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SMA&lt;/strong&gt; : ACC가 0보다 작을 때 SKIP&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SZA&lt;/strong&gt; : ACC가 0과 같을 때 SKIP&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SZC&lt;/strong&gt; : C가 0과 같을 때 SKIP&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ISZ&lt;/strong&gt; : 1 증가하여 0과 같으면 SKIP&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RETI&lt;/strong&gt; : 인터럽트로부터 &lt;strong&gt;복귀&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CALL&lt;/strong&gt; : 서브 프로그램의 &lt;strong&gt;호출&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RETURN&lt;/strong&gt; : 서브 프로그램에서 &lt;strong&gt;메인 프로그램으로 복귀&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HALT&lt;/strong&gt; : 컴퓨터의 동작을 &lt;strong&gt;일시적으로 정지&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기타-명령&quot;&gt;기타 명령&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;리커션(Recursion)&lt;/strong&gt;&lt;br /&gt;
자기가 자신을 호출하는 경우로 되돌아올 복귀 주소를 스택에 PUSH하고 다시 자신을 실행한다. 잘못하면 무한 루프에 빠질 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;반복(Iteration)&lt;/strong&gt;&lt;br /&gt;
주어진 자료를 가지고 처음에 실시된 계산은 정확한 정보를 나타내 주지 못하므로 그 결과를 가지고 처음의 자료를 다시 수정하여 계산하는 방법을 반복적으로 행하는 것으로 루틴 내부에서 자료를 얻어야 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;매크로(Macro)&lt;/strong&gt;&lt;br /&gt;
반복되는 일련의 루틴을 별도로 작성해 놓은 측면에서 부 프로그램과 유사하다. 자주 사용하는 여러 개의 명령어를 묶어서 하나의 명령어로 만든 것이나 컴파일 시는 원래의 명령어로 대치되기 때문에 인수의 형은 신경쓸 필요가 없다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;부 프로그램(Sub Program)&lt;/strong&gt;&lt;br /&gt;
CALL 문으로 호출해 사용하는 반면 매크로의 경우는 본문 자체에 삽입되어 사용&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기타-프로그램&quot;&gt;기타 프로그램&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;연계 편집기(Linkage Editor)&lt;/strong&gt;&lt;br /&gt;
목적프로그램을 실행 가능한 로드 모듈로 변환하는 시스템 서비스 프로그램&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;기계어&lt;/strong&gt;&lt;br /&gt;
컴퓨터가 직접 이해하고 수행할 수 있는 언어로 수행 시간이 신속하나 프로그램 과정이 불편하고 언어의 호환성이 없다는 단점을 가지고 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;고급 언어&lt;/strong&gt;&lt;br /&gt;
기계어와는 달리 프로그래머가 익숙한 표현 형식을 사용하도록 하는 프로그래밍 언어로 하드웨어에 상관없이 컴파일러로 분역되어 하드웨어와 호환되도록 한 언어&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;번역 프로그램&lt;/strong&gt; &lt;a href=&quot;https://many258.github.io/study/os-system-software/&quot; class=&quot;btn btn--info&quot;&gt;포스트 이동하기&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;디버깅(Debugging)&lt;/strong&gt;&lt;br /&gt;
트레이서나 덤프등을 이용하여 프로그램의 오류를 발견하고 그 원인을 밝히는 작업을 의미&lt;br /&gt;
&lt;br /&gt;
&lt;strong&gt;트레이서(Tracer)&lt;/strong&gt; : 프로그램의 실행 과정을 출력하는 프로그램&lt;br /&gt;
&lt;strong&gt;덤프(Dump)&lt;/strong&gt; : 주기억장치의 내용을 그대로 화면이나 프린터 등에 출력&lt;/p&gt;

&lt;h3 id=&quot;명령어의-형식&quot;&gt;명령어의 형식&lt;/h3&gt;
&lt;h4 id=&quot;피연산자operand-address-개수에-따른-구분&quot;&gt;피연산자(Operand Address) 개수에 따른 구분&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;0-주소 명령어 형식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;오퍼레이션 부분&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;만&lt;/code&gt; 있고 &lt;strong&gt;오퍼랜드 부분인 주소가 없는 명령어 형식&lt;/strong&gt;을 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;스택(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt;) 구조 컴퓨터&lt;/strong&gt;에서 사용하는 명령어 형식&lt;/li&gt;
      &lt;li&gt;모든 연산은 스택상에 있는 두 값을 묵시적으로 지정하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POP&lt;/code&gt;해서 연산을 수행하고 결과를 다시 스택상에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUSH&lt;/code&gt;하기 때문에 &lt;strong&gt;원래의 데이터는 모두 잃어버리게 된다&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/0-address-instruction-format.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/0-address-instruction-format.png&quot; alt=&quot;&quot; title=&quot;0-주소 명령어 형식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;1-주소 명령어 형식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;오퍼레이션 부분과 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;개의 오퍼랜드 부분&lt;/strong&gt;으로 구성된 명령어 형식을 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;누산기(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACCumulator&lt;/code&gt;) 구조 컴퓨터&lt;/strong&gt;에서 사용하는 명령어 형식&lt;/li&gt;
      &lt;li&gt;연산 시 두 개의 자료 중 하나는 묵시적으로 누산기를 지정하여 연산하고, &lt;strong&gt;연산 결과 역시 누산기에 저장하는 방식&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/1-address-instruction-format.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/1-address-instruction-format.png&quot; alt=&quot;&quot; title=&quot;1-주소 명령어 형식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;2-주소 명령어 형식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;오퍼레이션 부분과 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;개의 오퍼랜드 부분&lt;/strong&gt;으로 구성된 명령어 형식을 의미&lt;/li&gt;
      &lt;li&gt;연산 시 두 개의 자료는 오퍼랜드가 지정한 2개의 자료를 대상으로 연산하고, 연산 결과는 주로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Operand-1&lt;/code&gt;에 저장&lt;/li&gt;
      &lt;li&gt;연산 후 결과가 Operand-1에 저장되므로 &lt;strong&gt;Operand-1의 위치에 있던 내용은 잃어버리게 된다&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;계산 결과를 시험할 필요가 있을 때 &lt;strong&gt;계산 결과가 기억 장치에 기억될 뿐 아니라 중앙 처리 장치에도 남아&lt;/strong&gt; 있어서 중앙 처리 장치 내에서 직접 시험이 가능&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/2-address-instruction-format.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/2-address-instruction-format.png&quot; alt=&quot;&quot; title=&quot;2-주소 명령어 형식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;3-주소 명령어 형식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;오퍼레이션 부분과 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt;개의 오퍼랜드 부분&lt;/strong&gt;으로 구성된 명령어의 형식을 의미&lt;/li&gt;
      &lt;li&gt;연산 시 두 개의 자료는 Operand-1과 Operand-2에서 지정된 2개의 자료를 대상으로 연산하고, &lt;strong&gt;연산 결과는&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; Operand-3&lt;/code&gt;에 저장&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;연산 후 결과는 &lt;strong&gt;Operand-3 또는 Operand-1에 저장&lt;/strong&gt;되므로 &lt;strong&gt;원래의 내용은 모두 보존할 수 있다&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;명령어의 길이가 길다&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/3-address-instruction-format.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/3-address-instruction-format.png&quot; alt=&quot;&quot; title=&quot;3-주소 명령어 형식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;피연산자-위치에-따른-구분&quot;&gt;피연산자 위치에 따른 구분&lt;/h4&gt;
&lt;p&gt;연산 대상이 되는 자료를 어디에 보관하는가에 따라 분류하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;스택 명령어(SI, Stack Instruction)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상이 되는 자료가 &lt;strong&gt;스택&lt;/strong&gt;에 있고, 결과 또한 스택에 저장되는 경우&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;0-주소 명령어 형식&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;누산기 명령어(AI, Accumulator Instruction)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상이 되는 자료의 일부 도는 전부가 &lt;strong&gt;누산기&lt;/strong&gt;에 있고, 결과 또한 누산기에 저장되는 경우&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;1-주소 명령어 형식&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;레지스터-레지스터 명령어(RRI, Register-Register Instruction)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상이 되는 두 개의 자료가 모두 레지스터에 있는 경우&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;수행 속도가 빠름&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;전체 명령어의 &lt;strong&gt;길이가 짧다&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모리-레지스터 명령어(MRI, Memory-Register Instruction)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상이 되는 두 개의 자료 중 하나는 주기억 장치에 있고 하나는 레지스터에 있는 경우&lt;/li&gt;
      &lt;li&gt;주기억 장치에 &lt;strong&gt;한 번 접근&lt;/strong&gt;해야 하기 때문에 RRI에 비해 수행 속도가 느리다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모리-메모리 명령어(MMI, Memory-Memory Instruction)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상이 되는 두 개의 자료가 모두 주기억 장치에 있는 경우&lt;/li&gt;
      &lt;li&gt;주기억 장치에 &lt;strong&gt;두 번 접근&lt;/strong&gt;해야 하기 때문에 &lt;strong&gt;수행 속도가 느리다&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;strong&gt;명령어의 메모리 참조 방식&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
레지스터 참조 명령(RRI, Register Reference Instruction)&lt;br /&gt;
메모리 참조 명령(MRI, Memory Reference Instruction)&lt;br /&gt;
입출력 명령(IOI, Input/Output Instruction)&lt;/p&gt;
</description>
        <pubDate>Mon, 03 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-instruction/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-instruction/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 연산의 종류</title>
        <description>&lt;h2 id=&quot;연산의-분류&quot;&gt;연산의 분류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;성질에 따른 분류
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;비수치적 연산&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;NOT&lt;/li&gt;
          &lt;li&gt;AND&lt;/li&gt;
          &lt;li&gt;OR&lt;/li&gt;
          &lt;li&gt;E-OR(Exclusive OR)&lt;/li&gt;
          &lt;li&gt;논리 Shift&lt;/li&gt;
          &lt;li&gt;Rotate&lt;/li&gt;
          &lt;li&gt;Complement(보수)&lt;/li&gt;
          &lt;li&gt;MOVE&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;수치적 연산&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;팩 10진 연산&lt;a href=&quot;https://many258.github.io/study/electronic-calculator-data-form/#10%EC%A7%84%EC%88%98-%EC%A0%95%EC%88%98-%ED%91%9C%ED%98%84&quot; class=&quot;btn btn--info&quot;&gt;포스트 이동하기&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;ADD&lt;/li&gt;
          &lt;li&gt;SUB&lt;/li&gt;
          &lt;li&gt;MUL&lt;/li&gt;
          &lt;li&gt;DIV&lt;/li&gt;
          &lt;li&gt;산술 Shift&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;항에 따른 분류
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;단항 연산(Unary Operation)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;논리 Shift&lt;/li&gt;
          &lt;li&gt;산술 Shift&lt;/li&gt;
          &lt;li&gt;Rotate&lt;/li&gt;
          &lt;li&gt;Complement&lt;/li&gt;
          &lt;li&gt;NOT&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;이항 연산(Binary Operation)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;AND&lt;/li&gt;
          &lt;li&gt;OR&lt;/li&gt;
          &lt;li&gt;E-OR&lt;/li&gt;
          &lt;li&gt;ADD&lt;/li&gt;
          &lt;li&gt;SUB&lt;/li&gt;
          &lt;li&gt;MUL&lt;/li&gt;
          &lt;li&gt;DIV&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;연산 우선순위
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;산술 연산자(우선순위 높음)&lt;/strong&gt;
        &lt;blockquote&gt;
          &lt;p&gt;&lt;strong&gt;÷, ×, ＋, －&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;관계 연산자&lt;/strong&gt;
        &lt;blockquote&gt;
          &lt;p&gt;&lt;strong&gt;=, ＞, ＜, ≥, ≤, ≠&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;논리 연산자(우선순위 낮음)&lt;/strong&gt;
        &lt;blockquote&gt;
          &lt;p&gt;&lt;strong&gt;NOT, AND, OR&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비수치적-연산&quot;&gt;비수치적 연산&lt;/h3&gt;
&lt;h4 id=&quot;and-연산mask-마이크로-동작&quot;&gt;AND 연산(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mask&lt;/code&gt; 마이크로 동작)&lt;/h4&gt;
&lt;p&gt;비수치 자료의 특정 비트나 문자를 &lt;strong&gt;삭제하는 경우&lt;/strong&gt;에 사용&lt;/p&gt;

&lt;p&gt;특정 위치의 문자를 지우기 위해서는 &lt;strong&gt;Mask(0000 0000)를 사용해서 이항 연산에 의해 삭제&lt;/strong&gt;한다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/and-operation.png&quot; title=&quot;https://icarus.cs.weber.edu/~dab/cs1410/textbook/2.Core/bitops.html&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/and-operation.png&quot; alt=&quot;&quot; title=&quot;AND 연산 MASK 마이크로 동작&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;or-연산selective-set-마이크로-동작&quot;&gt;OR 연산(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Selective-Set&lt;/code&gt; 마이크로 동작)&lt;/h4&gt;
&lt;p&gt;비수치적 자료에서 특정 &lt;strong&gt;비트 또는 문자를 삽입하거나 결합&lt;/strong&gt; 시 사용&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/or-operation.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/or-operation.png&quot; alt=&quot;&quot; title=&quot;OR 연산 Selective-Set 마이크로 동작&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;exclusive-orcompare-마이크로-동작&quot;&gt;Exclusive-OR(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Compare&lt;/code&gt; 마이크로 동작)&lt;/h4&gt;
&lt;p&gt;비수치적 자료의 &lt;strong&gt;비교 시 또는 검출&lt;/strong&gt; 시 사용하거나 &lt;strong&gt;특정 비트의 반전&lt;/strong&gt;에 사용&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/xor-operation.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/xor-operation.png&quot; alt=&quot;&quot; title=&quot;eXclusive-OR 연산 Compare 마이크로 동작&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;논리-shift-연산&quot;&gt;논리 Shift 연산&lt;/h4&gt;
&lt;p&gt;비수치적 자료의 모든 비트를 &lt;strong&gt;우측 또는 좌측으로 자리 이동&lt;/strong&gt;시키는 연산을 의미&lt;/p&gt;

&lt;p&gt;단항 연산자로 자료의 이동에 주로 사용하며, &lt;strong&gt;좌우측 Shift에 모두 0이 Padding(패딩)&lt;/strong&gt;된다&lt;/p&gt;

&lt;h4 id=&quot;rotate-연산&quot;&gt;ROTATE 연산&lt;/h4&gt;
&lt;p&gt;비수치적 자료에서 문자의 위치 변환에 사용&lt;/p&gt;

&lt;p&gt;논리 Shift에서 Truncation되는 비트가 반대편으로 회전해서 패딩되는 경우를 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1비트 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우&lt;/code&gt;측으로 Rotate인 경우&lt;br /&gt;
&lt;strong&gt;LSB&lt;/strong&gt;(최하위 비트, Least Significant Bit)에서 Truncation된 비트가 &lt;strong&gt;MSB&lt;/strong&gt;(최상위 비트, Most Significant Bit)로 패딩&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1비트 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;좌&lt;/code&gt;측으로 Rotate인 경우&lt;br /&gt;
&lt;strong&gt;MSB&lt;/strong&gt;에서 Truncation된 비트가 &lt;strong&gt;LSB&lt;/strong&gt;로 패딩&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;complement보수-연산&quot;&gt;Complement(보수) 연산&lt;/h4&gt;
&lt;p&gt;단항 연산으로 1의 보수나 2의 보수를 구하는 연산&lt;/p&gt;

&lt;h3 id=&quot;수치적-연산&quot;&gt;수치적 연산&lt;/h3&gt;
&lt;h4 id=&quot;고정-소수점-연산&quot;&gt;고정 소수점 연산&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;부호화 절대치 연산&lt;/strong&gt;&lt;br /&gt;
부호가 같은 경우 &lt;strong&gt;가산기&lt;/strong&gt;, 부호가 다른 경우 &lt;strong&gt;감산기&lt;/strong&gt;를 사용하여 연산&lt;/p&gt;

    &lt;p&gt;부호가 다른 경우는 두 수를 비교하여 큰 수에서 작은 수를 감산기를 통해서 연산한 후 &lt;strong&gt;큰 수에 대한 부호를 결과&lt;/strong&gt;에 반영한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;1의 보수 연산&lt;/strong&gt;&lt;br /&gt;
덧셈기 하나만 있으면 덧셈과 뺄셈을 모두 연산할 수 있다&lt;/p&gt;

    &lt;p&gt;최상의 비트에서 &lt;strong&gt;캐리(Carry)가 발생하는 경우 1을 결과에 더한다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;2의 보수 연산&lt;/strong&gt;&lt;br /&gt;
최상의 비트에서 &lt;strong&gt;캐리가 발생하면 버린다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;부동-소수점-연산&quot;&gt;부동 소수점 연산&lt;/h4&gt;
&lt;p&gt;부동 소수점 표현이 &lt;strong&gt;부호, 지수, 가수&lt;/strong&gt;만 표현하므로 이것만 사용하여 연산 수행&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;덧셈과 뺄셈 과정&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;0인지 조사&lt;/li&gt;
      &lt;li&gt;지수값 비교&lt;/li&gt;
      &lt;li&gt;가수의 정렬&lt;/li&gt;
      &lt;li&gt;가수 부분 덧/뺄셈&lt;/li&gt;
      &lt;li&gt;정규화&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;곱셈 과정&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;0인지 조사&lt;/li&gt;
      &lt;li&gt;지수 &lt;strong&gt;덧셈&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;가수 곱셈&lt;/li&gt;
      &lt;li&gt;정규화&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;나눗셈 과정&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;0인지 조사&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;부호 결정&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;피제수의 위치 조정&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;지수 &lt;strong&gt;뺄셈&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;가수 나눗셈&lt;/li&gt;
      &lt;li&gt;정규화&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;산술-shift&quot;&gt;산술 Shift&lt;/h4&gt;
&lt;p&gt;우측이나 좌측으로 &lt;strong&gt;비트 전부를 한 비트씩 이동&lt;/strong&gt;시키는 것이며&lt;br /&gt;
&lt;strong&gt;우측 Shift&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;나눗셈&lt;/code&gt;), &lt;strong&gt;좌측 Shift&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;곱셈&lt;/code&gt;)을 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우측&lt;/code&gt; 산술 Shift (»)
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;부호와 절대치 표현&lt;/strong&gt;
&lt;a href=&quot;../../assets/images/electronic-calc/right-arithmetic-shift-abs.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/right-arithmetic-shift-abs.png&quot; alt=&quot;&quot; title=&quot;부호화 절대치 표현의 우측 시프트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;1의 보수&lt;/strong&gt;
&lt;a href=&quot;../../assets/images/electronic-calc/right-arithmetic-shift-1-complement.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/right-arithmetic-shift-1-complement.png&quot; alt=&quot;&quot; title=&quot;1의 보수의 우측 시프트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;2의 보수&lt;/strong&gt;
&lt;a href=&quot;../../assets/images/electronic-calc/right-arithmetic-shift-2-complement.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/right-arithmetic-shift-2-complement.png&quot; alt=&quot;&quot; title=&quot;2의 보수의 우측 시프트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;좌측&lt;/code&gt; 산술 Shift («)
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;부호와 절대치 표현&lt;/strong&gt;
&lt;a href=&quot;../../assets/images/electronic-calc/left-arithmetic-shift-abs.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/left-arithmetic-shift-abs.png&quot; alt=&quot;&quot; title=&quot;부호화 절대치 표현의 좌측 시프트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;1의 보수&lt;/strong&gt;
&lt;a href=&quot;../../assets/images/electronic-calc/left-arithmetic-shift-1-complement.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/left-arithmetic-shift-1-complement.png&quot; alt=&quot;&quot; title=&quot;1의 보수의 좌측 시프트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;2의 보수&lt;/strong&gt;
&lt;a href=&quot;../../assets/images/electronic-calc/left-arithmetic-shift-2-complement.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/left-arithmetic-shift-2-complement.png&quot; alt=&quot;&quot; title=&quot;2의 보수의 좌측 시프트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 30 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-operation-class/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-operation-class/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 자료 표현</title>
        <description>&lt;h2 id=&quot;자료-표현&quot;&gt;자료 표현&lt;/h2&gt;
&lt;p&gt;사람과 컴퓨터 간에 의사소통을 위해서 인간이 사용하는 기호나 숫자 또는 문자 등을 컴퓨터가 인식할 수 있도록 표현하기 위한 기술을 의미&lt;/p&gt;

&lt;h3 id=&quot;자료의-단위&quot;&gt;자료의 단위&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;단위&lt;/th&gt;
      &lt;th&gt;크기&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;비트&lt;/td&gt;
      &lt;td&gt;Bit&lt;/td&gt;
      &lt;td&gt;0,1의 표현으로 전산기 구조의 최소 단위&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;니블&lt;/td&gt;
      &lt;td&gt;Nibble&lt;/td&gt;
      &lt;td&gt;4개의 비트를 묶어 하나의 단위로 나타낸 것으로 보통 16진수표현 단위로 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;바이트&lt;/td&gt;
      &lt;td&gt;Byte&lt;/td&gt;
      &lt;td&gt;8개의 비트를 묶어 하나의 단위로 나타낸 것으로 문자 표현의 단위로 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;워드&lt;/td&gt;
      &lt;td&gt;Word&lt;/td&gt;
      &lt;td&gt;내부 표현이나 처리를 위해 사용되는 단위&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;하프 워드&lt;/td&gt;
      &lt;td&gt;Half Word&lt;/td&gt;
      &lt;td&gt;2Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;풀 워드&lt;/td&gt;
      &lt;td&gt;Full Word&lt;/td&gt;
      &lt;td&gt;4Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;더블 워드&lt;/td&gt;
      &lt;td&gt;Double Word&lt;/td&gt;
      &lt;td&gt;8Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;필드&lt;/td&gt;
      &lt;td&gt;Field&lt;/td&gt;
      &lt;td&gt;어떤 특성이나 속성 표현을 위한 단위로 최소의 논리적 단위&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;레코드&lt;/td&gt;
      &lt;td&gt;Record&lt;/td&gt;
      &lt;td&gt;워드가 모여서 이루는 논리적인 단위로 정보가 처리되는 단위&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;블록&lt;/td&gt;
      &lt;td&gt;Block&lt;/td&gt;
      &lt;td&gt;입출력을 위해 논리 레코드를 묶어 놓은 단위로 물리적 레코드라고 한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;파일&lt;/td&gt;
      &lt;td&gt;File&lt;/td&gt;
      &lt;td&gt;관련있는 종류의 레코드를 묶어 나타낸 단위로 저장 장치에 저장되는 단위&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;데이터베이스&lt;/td&gt;
      &lt;td&gt;Database&lt;/td&gt;
      &lt;td&gt;서로 관련이 있는 파일을 통합하여 묶어놓은 데이터 그룹&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;문자-자료의-표현&quot;&gt;문자 자료의 표현&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;표준 BCD Code&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;존(Zone) 2Bit와 디지트(Digit) 4비트&lt;/strong&gt;의 총 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6비트&lt;/code&gt;로 하나의 문자를 나타낸다. 최대 64문자까지 표현 가능하며 초창기에 사용하던 코드&lt;/p&gt;

    &lt;p&gt;영문자의 소문자는 표현이 불가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EBCDIC Code&lt;/strong&gt;&lt;br /&gt;
BCD 코드의 &lt;strong&gt;존 비트를 4비트 확장&lt;/strong&gt;(총 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8비트&lt;/code&gt;)하여 최대 256문자까지 표현할 수 있도록 한 확장된 BCD 코드(Zone 4비트, Digit 4비트)&lt;/p&gt;

    &lt;p&gt;IBM 사에서 개발한 것으로 대형 컴퓨터에 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ASCII Code(아스키코드)&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;7비트&lt;/strong&gt;(Zone 3Bit, Digit 4Bit)로 한 문자를 표현할 수 있어 128문자까지 표현 가능하며 &lt;strong&gt;1비트의 패리티 비트&lt;/strong&gt;를 합쳐 총 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8비트&lt;/code&gt;로 사용. 데이터 &lt;strong&gt;통신용&lt;/strong&gt;으로 널리 사용되며, 특히 개인용 및 소형 컴퓨터용으로 쓰인다&lt;/p&gt;

    &lt;p&gt;제어 부호 33개, 그래픽 기호 33개, 숫자 10개, 알파벳 대/소문자 52개로 구성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Unicode(유니코드)&lt;/strong&gt;&lt;br /&gt;
컴퓨터에서 세계 각국의 언어를 &lt;strong&gt;통일된 방법으로 표현&lt;/strong&gt;하도록 제안된 &lt;strong&gt;국제적인 문자 코드&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;세계 26개 언어의 문자와 특수 기호에 대해 코드값으로 구성되어 있다. ASCII를 인식할 수 있지만, &lt;strong&gt;ASCII에서는 유니코드의 특수 문자를 인식할 수 없다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;수치-자료의-표현&quot;&gt;수치 자료의 표현&lt;/h3&gt;
&lt;h4 id=&quot;10진수-정수-표현&quot;&gt;10진수 정수 표현&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;언팩 10진 형식&lt;/strong&gt;(Unpack Decimal Format)&lt;br /&gt;
10진수 한 자리를 표현하기 위해 1바이트(8bit)를 사용하는 형식&lt;/p&gt;

    &lt;p&gt;존 영역(4Bit) + 수치 영역(4Bit). 부호(+/-)는 &lt;strong&gt;마지막 존 영역&lt;/strong&gt;에 표시(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; : &lt;strong&gt;1100(C)&lt;/strong&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; : &lt;strong&gt;1101(D)&lt;/strong&gt;)&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;연산할 수 없으&lt;/strong&gt;며 &lt;strong&gt;입출력&lt;/strong&gt;을 위해 사용한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;팩 10진 형식&lt;/strong&gt;(Pack Decimal Format)&lt;br /&gt;
연산이 가능하며 10진수 한 자리를 표현하기 위해 &lt;strong&gt;존 영역없이 4비트&lt;/strong&gt;를 사용&lt;/p&gt;

    &lt;p&gt;최하위 4비트에 부호를 표시(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; : &lt;strong&gt;1100(C)&lt;/strong&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; : &lt;strong&gt;1101(D)&lt;/strong&gt;)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2진수-정수-표현&quot;&gt;2진수 정수 표현&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;부호와 절대치&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;최상위 1비트에 부호&lt;/strong&gt;를 표시(+ : 0, - : 1)
    &lt;blockquote&gt;
      &lt;p&gt;수의 표현 범위 : -(2&lt;sup&gt;n-1&lt;/sup&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt;) ~ 2&lt;sup&gt;n-1&lt;/sup&gt;-1&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;0의 표현은 0000 0000, 1000 0000 2가지로 표현 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;1의 보수&lt;/strong&gt;&lt;br /&gt;
임의의 양수 값이 있다면 양수 값의 &lt;strong&gt;1의 보수 값을 그 값의 음수&lt;/strong&gt; 값으로 사용하는 방식&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;수의 표현 범위 : -(2&lt;sup&gt;n-1&lt;/sup&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt;) ~ 2&lt;sup&gt;n-1&lt;/sup&gt;-1&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;0의 표현은 0000 0000, 1111 1111 2가지로 표현 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;2의 보수&lt;/strong&gt;&lt;br /&gt;
임의의 양수 값이 있다면 양수 값의 &lt;strong&gt;2의 보수 값을 그 값의 음수&lt;/strong&gt; 값으로 사용하는 방식&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;수의 표현 범위 : -(2&lt;sup&gt;n-1&lt;/sup&gt;) ~ 2&lt;sup&gt;n-1&lt;/sup&gt;-1&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2진수-실수-표현&quot;&gt;2진수 실수 표현&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;고정 소수점 표현
소수점이 항상 최상위 비트의 왼쪽에 고정되어 있는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;부동 소수점 표현
소수점위치를 변경시킴으로써 극히 작은 수에서 큰 수를 표현하는 방법&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;일반 부동 소수점 표현
        &lt;ul&gt;
          &lt;li&gt;부호(1) : 0(양수), 1(음수)&lt;/li&gt;
          &lt;li&gt;지수(7) : Bias 값 64에 지수값을 더해서 표현&lt;/li&gt;
          &lt;li&gt;가수(24) : 16진수로 표현&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;IEEE754 표준 부동 소수점 표현
        &lt;ul&gt;
          &lt;li&gt;부호(1) : 0(양수), 1(음수)&lt;/li&gt;
          &lt;li&gt;지수(8) : Bias 값 127에 지수 값을 더해서 표현&lt;/li&gt;
          &lt;li&gt;가수(23) : 2진수로 표현&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;정규화
        &lt;ul&gt;
          &lt;li&gt;유효숫자를 늘려 정밀도를 높이기 위한 목적으로 사용
            &lt;blockquote&gt;
              &lt;p&gt;일반 정규형 : 0.M × 16&lt;sup&gt;E&lt;/sup&gt;&lt;sub&gt;(단, M:가수, E:지수)&lt;/sub&gt;&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p class=&quot;notice--success&quot;&gt;&lt;strong&gt;메가플롭스(MFLOPS)&lt;/strong&gt; : 1초간에 실행되는 부동 소수점 연산의 수를 100만 단위로 하여 나타낸 수를 의미&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;코드의-표현&quot;&gt;코드의 표현&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;분류&lt;/th&gt;
      &lt;th&gt;코드 종류&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;가중치 코드&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt;&lt;br /&gt;Weighted Code&lt;/td&gt;
      &lt;td&gt;8421코드&lt;br /&gt;2421 코드&lt;br /&gt; 74&lt;span style=&quot;text-decoration:overline&quot;&gt;21&lt;/span&gt;코드&lt;br /&gt;8421 코드&lt;br /&gt; 5421코드&lt;br /&gt;51111 코드&lt;br /&gt;Biquinary 코드&lt;br /&gt;Ring Counter 코드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;비가중치 코드&lt;br /&gt;Unweighted Code&lt;/td&gt;
      &lt;td&gt;3초과 코드&lt;br /&gt;그레이 코드&lt;br /&gt;2-Out-of-5 코드&lt;br /&gt;3-Out-of-5 코드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;자기 보수 코드&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt;&lt;br /&gt;Self Complement Code&lt;/td&gt;
      &lt;td&gt;3초과 코드&lt;br /&gt;2421 코드&lt;br /&gt;5211 코드&lt;br /&gt;51111 코드&lt;br /&gt; 8421 코드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;에러 검출 코드&lt;br /&gt;Error Detecting Code&lt;/td&gt;
      &lt;td&gt;패리티 비트 코드&lt;br /&gt;해밍 코드&lt;br /&gt; Biquinary 코드&lt;br /&gt;Ring Counter 코드&lt;br /&gt;2-Out-of-5 코드&lt;br /&gt;3-Out-of-5 코드&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;가중치 코드&lt;/strong&gt; : 2진수 각 자리마다 &lt;strong&gt;고유의 기준치 값&lt;/strong&gt;이 있는 코드&lt;/p&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;자기 보수 코드&lt;/strong&gt; : 코드의 &lt;strong&gt;1의 보수가 10진수의 9의 보수&lt;/strong&gt;가 같은 코드&lt;/p&gt;

&lt;h4 id=&quot;8421-코드&quot;&gt;8421 코드&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;4비트(8,4,2,1)의 가중 값을 가지므로 &lt;strong&gt;가중치 코드&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;2진화 10진수로 사용될 때는 10진수 0~9까지 표현&lt;/li&gt;
  &lt;li&gt;4비트 표현이므로 2진 표현으로는 16가지 표현이 가능하나 &lt;strong&gt;10~15까지는 사용하지 않는다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2421-코드&quot;&gt;2421 코드&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;4비트(2,4,2,1)의 가중 값을 가지므로 &lt;strong&gt;가중치 코드&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자기 보수 코드&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;4비트 표현이므로 2진 표현으로는 16가지 표현이 가능하나 그 중 &lt;strong&gt;2~7까지(6가지)는 중복 표현&lt;/strong&gt;된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;7421-코드&quot;&gt;74&lt;span style=&quot;text-decoration:overline&quot;&gt;21&lt;/span&gt; 코드&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;4비트(7,4,-2,-1)의 가중 값을 가지므로 가중치 코드이며 가중치 값 중에 &lt;strong&gt;음수&lt;/strong&gt;를 가지고 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;허프만-코드huffman-code&quot;&gt;허프만 코드(Huffman Code)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;빈번히 발생&lt;/strong&gt;하는 데이터의 코드는 &lt;strong&gt;적은 수의 비트로 표현&lt;/strong&gt;하고, 빈번하지 않은 데이터는 상대적으로 많은 비트수로 표현하여 &lt;strong&gt;전체 데이터의 크기를 줄이는&lt;/strong&gt; 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;통계적인 부호화 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3초과-코드&quot;&gt;3초과 코드&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;비가중치 코드&lt;/strong&gt;, &lt;strong&gt;자기 보수 코드&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;8421 코드를 3초과시켜서 만든 코드&lt;/li&gt;
  &lt;li&gt;8421 코드는 뒤에서 6개의 코드 값을 사용하지 않지만 3초과 코드는 &lt;strong&gt;앞에서 3개, 뒤에서 3개를 사용하지 않는다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;연산 시 &lt;strong&gt;캐리 발생 여부만 판별&lt;/strong&gt;해서 3을 더해주거나 빼주면 되기 때문에 8421 코드에 비해 편리&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;그레이-코드gray-code&quot;&gt;그레이 코드(Gray Code)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;각 자리에 일정한 값을 부여하는 가중치 값이 없는 &lt;strong&gt;비가중치 코드&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;한 비트의 변환만으로 다음 값을 만들 수 있기 때문에 &lt;strong&gt;변화가 적다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;기계적인 동작을 제어하는 알맞은 코드&lt;/strong&gt;이며, 입출력 장치의 동작이나 &lt;strong&gt;아날로그 신호를 디지털 신호로 변환&lt;/strong&gt;하는데 사용할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;2진 코드 =&amp;gt; 그레이 코드&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;2진 코드에서 최상위 비트(MSB: Most Significant Bit)는 변하지 않고 그대로 Gray Code로 변환&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;좌측 비트에서 오른쪽으로 이웃한 비트&lt;/strong&gt;를 E-OR(Exclusive OR) 연산하여 차례로 그레이 코드의 다음 비트를 만들어 준다&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/binary-to-gray.png&quot; title=&quot;https://www.matrixlab-examples.com/gray-code.html&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/binary-to-gray.png&quot; alt=&quot;&quot; title=&quot;2진 코드에서 그레이 코드 변환&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;그레이 코드 =&amp;gt; 2진 코드&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;그레이 코드에서 최상위 비트(MSB)는 변하지 않고 그대로 Binary Code로 변환&lt;/li&gt;
      &lt;li&gt;변환된 2진 코드와 &lt;strong&gt;그레이 코드 오른쪽으로 이웃한 비트를 E-OR 연산&lt;/strong&gt; 차례로 바이너리 코드의 다음 비트를 만들어 준다&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/gray-to-binary.png&quot; title=&quot;https://www.matrixlab-examples.com/gray-code.html&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/gray-to-binary.png&quot; alt=&quot;&quot; title=&quot;그레이 코드에서 2진 코드로 변환&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;해밍-코드hamming-code포스트-이동하기&quot;&gt;해밍 코드(Hamming Code)&lt;a href=&quot;https://many258.github.io/study/data-communication-error-control/#%ED%95%B4%EB%B0%8D%EC%BD%94%EB%93%9Chamming-code&quot; class=&quot;btn btn--primary&quot;&gt;포스트 이동하기&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;에러 검출뿐만 아닌 수정까지 가능한 코드&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;패리티-비트parity-bit포스트-이동하기&quot;&gt;패리티 비트(Parity Bit)&lt;a href=&quot;https://many258.github.io/study/data-communication-error-control/#%ED%8C%A8%EB%A6%AC%ED%8B%B0-%EB%B9%84%ED%8A%B8&quot; class=&quot;btn btn--info&quot;&gt;포스트 이동하기&lt;/a&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2진수로 이루어진 코드에서 1의 개수가 홀수 개가 되는지 짝수 개가 되는지를 체크하기 위해 추가되는 비트를 의미&lt;/li&gt;
  &lt;li&gt;패리티 비트는 &lt;strong&gt;1비트 오류 검출&lt;/strong&gt;이 가능&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 29 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-data-form/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-data-form/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 순서 논리 회로(Sequential Logic Circuit)</title>
        <description>&lt;h2 id=&quot;순서-논리-회로&quot;&gt;순서 논리 회로&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;기억 능력&lt;/strong&gt;을 갖추면서 &lt;strong&gt;입력과 내부 상태의 조합&lt;/strong&gt;에 의해 출력이 결정되는 회로&lt;/p&gt;

&lt;p&gt;플립플롭이나 레지스터 장치로 구성된다&lt;/p&gt;

&lt;h3 id=&quot;플립플롭flip-flop&quot;&gt;플립플롭(Flip-Flop)&lt;/h3&gt;
&lt;p&gt;순서 논리 회로를 구성하는 기본 기억 소자로 &lt;strong&gt;1비트를 기억&lt;/strong&gt;할 수 있는 &lt;strong&gt;2진 Cell&lt;/strong&gt;을 의미&lt;/p&gt;

&lt;h4 id=&quot;rs-플립플롭&quot;&gt;RS 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/rs-filp-flop.png&quot; title=&quot;https://www.electronicsengineering.nbcafe.in/rs-flip-flop/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/rs-filp-flop.png&quot; alt=&quot;&quot; title=&quot;RS 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;보통 NAND 게이트를 이용해서 구성&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SET&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt;) &lt;strong&gt;단자와&lt;/strong&gt; RESET(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;) 단자를 갖으며, &lt;strong&gt;모두 1인 경우는 허용되지 않는다&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;jk-플립플롭&quot;&gt;JK 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/jk-flip-flop.png&quot; title=&quot;https://www.javatpoint.com/j-k-flip-flop&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/jk-flip-flop.png&quot; alt=&quot;&quot; title=&quot;JK 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RS 플립플롭에서 S와 R이 모두 1일 때 &lt;strong&gt;허용되지 않는 것을 보완&lt;/strong&gt;해서 이것이 허용되도록 고안된 플립플롭&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RS 플립플롭&lt;/strong&gt;의 내부 상태와 입력 상태를 &lt;strong&gt;AND 게이트&lt;/strong&gt;로 처리하여 입력하는 플립플롭&lt;/p&gt;

&lt;h4 id=&quot;d-플립플롭&quot;&gt;D 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/d-flip-flop.png&quot; title=&quot;https://www.javatpoint.com/d-flip-flop&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/d-flip-flop.png&quot; alt=&quot;&quot; title=&quot;D 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RS나 JK 플립플롭에서 &lt;strong&gt;서로 베타적인 경우만 이용&lt;/strong&gt;되도록 고안된 플립플롭, &lt;strong&gt;1비트 지연 소자&lt;/strong&gt;로 사용된다&lt;br /&gt;
(S가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;이면 R은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;, S가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;이면 R은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&quot;t-플립플롭&quot;&gt;T 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/t-flip-flop.png&quot; title=&quot;https://www.javatpoint.com/t-flip-flop&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/t-flip-flop.png&quot; alt=&quot;&quot; title=&quot;T 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;JK 플립플롭에서 J, K가 같은 값이 입력될 때만 이용할 수 있도록 고안된 플립플롭, &lt;strong&gt;토글(Toggle) 기능&lt;/strong&gt;을 이용하고자 할 때 사용된다&lt;br /&gt;
(J가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;이면 K는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;, J가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;이면 K는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&quot;마스터-슬레이브master-slave-주종-플립플롭&quot;&gt;마스터 슬레이브(Master-Slave, 주종) 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/master-slave-flipflop.png&quot; title=&quot;http://www.barrywatson.se/dd/dd_sr_flip_flop_master_slave.html&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/master-slave-flipflop.png&quot; alt=&quot;&quot; title=&quot;마스터 슬레이브 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Race 현상&lt;/strong&gt;&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt;을 해결하기 위해 고안된 플립플롭&lt;/p&gt;

&lt;p class=&quot;notice--success&quot;&gt;&lt;strong&gt;Race 현상&lt;/strong&gt; : 출력이 입력에 피드백되어 플립플롭의 내부 상태가 변화되면 출력 상태가 변할 때 입력도 변하게 되므로 &lt;strong&gt;오동작이 발생&lt;/strong&gt;하게 되는 현상&lt;/p&gt;

&lt;p&gt;하나의 플립플롭(&lt;strong&gt;주 플립플롭&lt;/strong&gt;)이 주인 역할을 하고, 다른 하나의 플립플롭(&lt;strong&gt;종 플립플롭&lt;/strong&gt;)이 종속되어 동작하도록 두 개 이상의 플립플롭 회로를 결합한 것&lt;/p&gt;

&lt;p&gt;주 플립플롭은 &lt;strong&gt;시간 펄스가 상승&lt;/strong&gt;할 때 동작하고, 종 플립플롭은 &lt;strong&gt;시간 펄스가 하강&lt;/strong&gt;할 때 동작&lt;/p&gt;

&lt;h3 id=&quot;카운터counter&quot;&gt;카운터(Counter)&lt;/h3&gt;
&lt;p&gt;시간 펄스의 수를 카운트하거나 제어 장치에서 각종 회로의 동작을 제어하는데 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;리플 카운터(Ripple Counter)&lt;/strong&gt;&lt;br /&gt;
가장 기본이 되는 비동기형(Asynchronous) 카운터. 플립플롭의 수를 n이라 할 때, 2&lt;sup&gt;n&lt;/sup&gt;개까지의 독립된 수 전부를 표현&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;모드 카운터(MOD Counter)&lt;/strong&gt;&lt;br /&gt;
N개의 서로 다른 출력상태를 갖는 카운터. N개의 서로 다른 출력상태를 나타낸 후 다시 원래의 상태로 복귀해 다시 N개의 출력상태를 반복&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;레지스터register&quot;&gt;레지스터(Register)&lt;/h3&gt;
&lt;p&gt;연산에 사용될 데이터가 대기하거나 연산된 결과&lt;strong&gt;데이터가 임시적으로 대기&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;시프트 레지스터(Shift Register)&lt;/strong&gt;&lt;br /&gt;
현재 레지스터에 있는 내용을 왼쪽이나 오른쪽의 연결된 플립플롭을 &lt;strong&gt;1비트씩 이동&lt;/strong&gt;시켜 &lt;strong&gt;밀어내기와 같은 동작을 수행&lt;/strong&gt;하는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;병렬 시프트 레지스터(Parallel Shift Register)&lt;/strong&gt;&lt;br /&gt;
N개의 비트로 구성된 레지스터의 내용을 연결된 다른 레지스터로 &lt;strong&gt;한 번에 이동&lt;/strong&gt;시킬 수 있는 레지스터&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 28 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-sequential-logic/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-sequential-logic/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 조합 논리 회로(Combinational Logic Circuit)</title>
        <description>&lt;h2 id=&quot;조합-논리-회로&quot;&gt;조합 논리 회로&lt;/h2&gt;
&lt;p&gt;논리 게이트의 조합으로 만들어지는 회로로 현재의 입력에 의해서만 출력이 결정되는 회로를 의미&lt;/p&gt;

&lt;h3 id=&quot;반가산기half-adder&quot;&gt;반가산기(Half Adder)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/half-adder.png&quot; title=&quot;https://www.researchgate.net/figure/Half-adder-circuit-diagram_fig1_272015389&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/half-adder.png&quot; alt=&quot;&quot; title=&quot;반가산기&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2개의 2진 입력 변수 A와 B를 더한 합 &lt;strong&gt;S&lt;/strong&gt;(Sum)와 자리 올림 수 &lt;strong&gt;C&lt;/strong&gt;(Carry)를 얻는 회로&lt;/p&gt;

&lt;p&gt;하나의 &lt;strong&gt;AND 게이트&lt;/strong&gt;와 &lt;strong&gt;XOR&lt;/strong&gt;(eXclusive OR) 게이트를 조합해서 구성&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;S&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;합(Sum)&lt;/strong&gt; : S = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·B + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; = A ⊕ B&lt;br /&gt;
&lt;strong&gt;캐리(Carry)&lt;/strong&gt; : C = A · B&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;반감산기half-subtracter&quot;&gt;반감산기(Half Subtracter)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/half-subtracter.png&quot; title=&quot;https://www.engineersgarage.com/vhdl/vhdl-tutorial-11-designing-half-and-full-subtractor-circuits/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/half-subtracter.png&quot; alt=&quot;&quot; title=&quot;반감산기&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2개의 2진 입력 변수 X에서 Y를 뺀 차 D와 빌려온 수(자리 내림 수) B를 얻는 회로&lt;/p&gt;

&lt;p&gt;하나의 &lt;strong&gt;NOT 게이트&lt;/strong&gt; 및 &lt;strong&gt;AND 게이트&lt;/strong&gt;와 &lt;strong&gt;XOR 게이트&lt;/strong&gt;를 조합해서 구성&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;X&lt;/th&gt;
      &lt;th&gt;Y&lt;/th&gt;
      &lt;th&gt;D&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;차(Difference)&lt;/strong&gt; : D = X·&lt;span style=&quot;text-decoration:overline&quot;&gt;Y&lt;/span&gt; + &lt;span style=&quot;text-decoration:overline&quot;&gt;X&lt;/span&gt;·Y  = X ⊕ Y&lt;br /&gt;
&lt;strong&gt;빌려온 수(자리 내림, Borrow)&lt;/strong&gt; : B = &lt;span style=&quot;text-decoration:overline&quot;&gt;X&lt;/span&gt; · Y&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;전가산기full-adder&quot;&gt;전가산기(Full Adder)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/full-adder.png&quot; title=&quot;https://electronics.stackexchange.com/questions/492236/why-is-the-last-carry-blocks-gate-in-a-full-adder-an-or-gate-and-not-a-xor&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/full-adder.png&quot; alt=&quot;&quot; title=&quot;전가산기&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2진수 가산을 완전히 하기 위하여 아래 자리로부터 자리 올림된 수도 고려하여 3개의 2진수를 더할 수 있게 만든 회로&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;반가산기 2개&lt;/strong&gt;와 &lt;strong&gt;OR 게이트 1개&lt;/strong&gt;를 연결하여 구성&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
      &lt;th&gt;S&lt;/th&gt;
      &lt;th&gt;C&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;합(Sum)&lt;/strong&gt; : S = A⊕B⊕C&lt;br /&gt;
&lt;strong&gt;캐리(Carry)&lt;/strong&gt; : C&lt;sub&gt;0&lt;/sub&gt; = (A⊕B)·C + A·B = A·B + B·C + A·C&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;전감산기full-subtracter&quot;&gt;전감산기(Full Subtracter)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/full-subtractor.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/full-subtractor.png&quot; alt=&quot;&quot; title=&quot;전감산기&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2진수 감산을 완전히 하기 위하여 아래 자리로부터 자리 내림수도 고려하여 3개의 2진수를 감산할 수 있게 만든 회로&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;반감산기 2개&lt;/strong&gt;와 &lt;strong&gt;OR 게이트 1개&lt;/strong&gt;를 연결하여 구성&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;X&lt;/th&gt;
      &lt;th&gt;Y&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;D&lt;/th&gt;
      &lt;th&gt;B&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;차(Difference)&lt;/strong&gt; : D = X⊕Y⊕B&lt;br /&gt;
&lt;strong&gt;빌려온 수(Borrow)&lt;/strong&gt; : B&lt;sub&gt;1&lt;/sub&gt; = &lt;span style=&quot;text-decoration:overline&quot;&gt;(X⊕Y)&lt;/span&gt;·B + &lt;span style=&quot;text-decoration:overline&quot;&gt;X&lt;/span&gt;·Y&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;병렬-가산기parallel-adder&quot;&gt;병렬 가산기(Parallel Adder)&lt;/h3&gt;
&lt;p&gt;여러 비트를 가산하기 위한 회로&lt;/p&gt;

&lt;p&gt;반가산기 또는 전가산기를 여러 개 합쳐서 만들어진다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;전가산기로 구성&lt;/strong&gt;하여 N비트 병렬 가산기를 만들 경우&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;개의 전가산기 필요&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;반가산기로 구성&lt;/strong&gt;하여 N비트 병렬 가산기를 만들 경우&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(2N-1)&lt;/code&gt;개의 반가산기와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(N-1)&lt;/code&gt;개의 &lt;strong&gt;OR 게이트&lt;/strong&gt; 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/parallel-adder.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/parallel-adder.png&quot; alt=&quot;&quot; title=&quot;4비트 병렬 가산기의 여러 가지 블록 다이어그램&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;디코더decoder&quot;&gt;디코더(Decoder)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/decoder.png&quot; title=&quot;https://www.tutorialspoint.com/computer_logical_organization/combinational_circuits.htm&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/decoder.png&quot; alt=&quot;&quot; title=&quot;디코더&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;컴퓨터 내부에서 2진수로 코드화된 데이터를 해독하여 대응되는 한 개의 신호로 바꿔주기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;해독기&lt;/code&gt;라고도 한다&lt;br /&gt;
&lt;strong&gt;N개의 입력&lt;/strong&gt;으로 &lt;strong&gt;최대 2&lt;sup&gt;N&lt;/sup&gt;개의 출력&lt;/strong&gt;을 얻을 수 있다&lt;br /&gt;
AND 게이트로 만들어진다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;3&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;인코더encoder&quot;&gt;인코더(Encoder)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/encoder.png&quot; title=&quot;https://en.wikipedia.org/wiki/Encoder_(digital)&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/encoder.png&quot; alt=&quot;&quot; title=&quot;인코더&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;입력 정보를 여러 자리의 2진수로 코드화하여 전달하는 회로&lt;br /&gt;
해독기와 정반대의 동작을 수행&lt;br /&gt;
&lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;개의 입력&lt;/strong&gt;을 받아 &lt;strong&gt;N개를 출력&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;입력&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;멀티플렉서multiplexer&quot;&gt;멀티플렉서(Multiplexer)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/multiplexer.png&quot; title=&quot;https://www.tutorialspoint.com/digital_circuits/digital_circuits_multiplexers.htm&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/multiplexer.png&quot; alt=&quot;&quot; title=&quot;멀티플렉서&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;개의 입력선&lt;/strong&gt;에서 &lt;strong&gt;N개의 선택선&lt;/strong&gt;을 가지고 &lt;strong&gt;하나의 출력&lt;/strong&gt;을 얻도록 구성&lt;br /&gt;
&lt;strong&gt;여러 개의 입력 회선&lt;/strong&gt;이 들어가서 &lt;strong&gt;하나의 특정 회선을 선택&lt;/strong&gt;하도록 하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선택기&lt;/code&gt;라고도 한다&lt;br /&gt;
공통적인 &lt;strong&gt;버스 라인을 구성&lt;/strong&gt;하는데 많이 사용&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;S&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;S&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;Y&lt;sub&gt;선택 회선&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;sub&gt;0&lt;/sub&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;I&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;sub&gt;2&lt;/sub&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;I&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;디멀티플렉서demultiplexer&quot;&gt;디멀티플렉서(Demultiplexer)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/demultiplexer.png&quot; title=&quot;https://electricalfundablog.com/demultiplexer-demux/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/demultiplexer.png&quot; alt=&quot;&quot; title=&quot;디멀티플렉서&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하나의 입력 정보&lt;/strong&gt;를 &lt;strong&gt;N개의 선택선&lt;/strong&gt;을 가지고 2&lt;sup&gt;N&lt;/sup&gt;개의 출력을 얻도록 구성&lt;br /&gt;
중앙 처리 장치에서 어떤 내용을 특정 장치로 출력시킬 때 많이 사용&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;S&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;S&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;3&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;비교기comparator&quot;&gt;비교기(Comparator)&lt;/h3&gt;
&lt;p&gt;논리적으로 두 수를 비교한다면 ‘같다’, ‘같지 않다’만 판별하면 되므로 두 수 A, B를 &lt;strong&gt;XNOR 게이트로 연결&lt;/strong&gt;하여 1이 얻어지면 ‘같다’고 판별할 수 있다&lt;/p&gt;

&lt;p&gt;N비트 논리 비교기를 만들기 위해서는 XNOR 게이트 N개가 필요&lt;/p&gt;

&lt;h3 id=&quot;3-상태-버퍼tri-state-buffer&quot;&gt;3-상태 버퍼(Tri-State Buffer)&lt;/h3&gt;
&lt;p&gt;3가지 상태 중&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;의 상태는 전기적으로 &lt;strong&gt;하이 레벨(H)&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;의 상태는 &lt;strong&gt;로우 레벨(L)&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;또 다른 상태&lt;/code&gt;는 &lt;strong&gt;고 임피던스&lt;/strong&gt;(회로가 끊어진 상태) 상태를 의미한다.&lt;/p&gt;

&lt;p&gt;3-상태 버퍼 회로는 인에이블(1) 또는 디스에이블(0) 단자에 의하여 데이터의 &lt;strong&gt;전송 방향을 하드웨어적으로 제어&lt;/strong&gt;하는 데 사용&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-combinational-logic/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-combinational-logic/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 논리 회로</title>
        <description>&lt;h2 id=&quot;불-대수&quot;&gt;불 대수&lt;/h2&gt;
&lt;p&gt;논리 회로를 분석하고 수학적으로 그 연산을 표현하고자 사용하는 대수식으로 논리 대수라고도 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;논리 변수 사이의 진리표를 대수 형식으로 표시&lt;/li&gt;
  &lt;li&gt;논리 변수를 조작하여 주어진 회로 기능을 수행하는데 있어 가장 간단한 회로를 결정하고자 사용&lt;/li&gt;
  &lt;li&gt;불 대수의 모든 변수는 0과 1의 값을 가질 수 있다&lt;/li&gt;
  &lt;li&gt;논리 회로의 입출력 관계를 대수 형식으로 표시&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;불 대수의 연산
    &lt;ul&gt;
      &lt;li&gt;논리 부정(NOT, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;￣&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;＇&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;논리곱(AND, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;·&lt;/code&gt; )&lt;/li&gt;
      &lt;li&gt;논리합(OR, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A + A = A&lt;/td&gt;
      &lt;td&gt;A · A = A&lt;/td&gt;
      &lt;td&gt;A · 0 = 0&lt;/td&gt;
      &lt;td&gt;A + 0 = A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A + 1 = 1&lt;/td&gt;
      &lt;td&gt;A · 1 = A&lt;/td&gt;
      &lt;td&gt;0 + 0 = 0&lt;/td&gt;
      &lt;td&gt;0 · 0 = 0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1 + 0 = 1&lt;/td&gt;
      &lt;td&gt;1 · 0 = 0&lt;/td&gt;
      &lt;td&gt;1 + 1 = 1&lt;/td&gt;
      &lt;td&gt;1 · 1 = 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A + A·B = A&lt;/td&gt;
      &lt;td&gt;A·(A + B) = A&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;논리-게이트&quot;&gt;논리 게이트&lt;/h2&gt;
&lt;p&gt;논리 회로를 구성하는 기본 소자, 2진 정보를 취급하는 기본 논리 회로&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/logic-gate.png&quot; title=&quot;https://www.pinterest.co.kr/pin/674203006705758186/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/logic-gate.png&quot; alt=&quot;&quot; title=&quot;논리 게이트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;AND&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 모두 1일 때만 1 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;OR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 모두 0일 때만 0 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;NOT&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 0이면 1을 출력하고 1이면 0을 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;NAND&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 모두 1일 때만 0 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;NOR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 모두 0일 때만 1 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;XOR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;A, B 입력 값이 서로 다를 때는 1 출력, 같을 때는 0 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;XNOR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;A, B 입력 값이 서로 같을 때는 1 출력, 같을 때는 1 출력&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;결선-게이트&quot;&gt;결선 게이트&lt;/h2&gt;
&lt;p&gt;필요할 때 게이트의 선을 연결하고, 단절하고 &lt;strong&gt;조절함으로써 다양한 기능&lt;/strong&gt;을 할 수 있도록 만든 게이트를 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;게이트들의 출력 단자를 논리적으로 직접 연결하여 논리 기능을 발휘할 수 있도록 했다&lt;/li&gt;
  &lt;li&gt;회로 비용을 절감할 수 있다&lt;/li&gt;
  &lt;li&gt;하나의 인쇄기판보다 많은 논리 기능을 포함시킬 수 있다&lt;/li&gt;
  &lt;li&gt;Open Collector TTL(Transistor-Transistor Logic)로 게이트들의 출력 단자를 묶어서 사용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;불-대수에-의한-최소화&quot;&gt;불 대수에 의한 최소화&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;최소항&lt;/strong&gt; : 진리표상에서 결과가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;인 부분을 표시할 때 사용하는 방식으로 불식을 형성하는 입력 변수 모두를 포함하는 &lt;strong&gt;논리곱&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;·&lt;/code&gt;)으로 나타내는 경우를 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;최대항&lt;/strong&gt; : 진리표상에서 결과가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;인 부분을 표시할 때 사용하는 방식으로 불식을 형성하는 입력 변수 모두를 포함하는 &lt;strong&gt;논리합&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;)으로 나타내는 경우를 의미&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A   B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;F&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;최소항&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;수치 표현&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0   0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0   1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1   0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1   1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A · B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;최소항의 합 표현은 위 표에서와 같이 결과가 1이 되는 부분만을 논리곱으로 표현하여 이 논리곱들을 논리합으로 연결하면 된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;최소항의 합&lt;/strong&gt; : F = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · B&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;수치 표현&lt;/strong&gt; : F(A, B) = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · B = $\Sigma(0,2,3)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불 대수식의 최소화&lt;/strong&gt;&lt;br /&gt;
F = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · B&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; · (&lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; + A) + A · B
= &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · B&lt;br /&gt;
= (&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A) · (&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + B)&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;입력(A, B, C)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;출력&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;최소항&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;수치 표현&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0 0 0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0 0 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0 1 0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · B · &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0 1 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 0 0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 0 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 1 0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A · B · &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 1 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;최소항의 합&lt;/strong&gt; : Y = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·B·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·B·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수치 표현&lt;/strong&gt; : Y(A, B, C) = $\Sigma(0, 2, 4, 6)$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불 대수식의 최소화&lt;/strong&gt;&lt;br /&gt;
Y = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·B·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·B·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;·(&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;+B) + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;·(&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;+B)&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;카르노-맵karnaugh-map에-의한-최소화&quot;&gt;카르노 맵(Karnaugh Map)에 의한 최소화&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/karnaugh-map.png&quot; title=&quot;https://www.eetimes.com/karnaugh-maps-101/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/karnaugh-map.png&quot; alt=&quot;&quot; title=&quot;카르노 맵에 의한 최소화&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-logic-circuit/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-logic-circuit/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 컴퓨터 시스템</title>
        <description>&lt;h2 id=&quot;컴퓨터-시스템-구조&quot;&gt;컴퓨터 시스템 구조&lt;/h2&gt;

&lt;h3 id=&quot;sisdsingle-instruction-single-data&quot;&gt;SISD(Single Instruction Single Data)&lt;/h3&gt;
&lt;p&gt;단일 처리기 컴퓨터로서 한 번에 한 명령어만 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1명의 사용자가 1개의 CPU를 사용한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다수의 기계어 명령들이 동시에 서로 다른 단계에서 수행&lt;/strong&gt;할 수 있게 하는 &lt;strong&gt;파이프라인&lt;/strong&gt; 기법에 응용할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;simdsingle-instruction-multiple-data&quot;&gt;SIMD(Single Instruction Multiple Data)&lt;/h3&gt;
&lt;p&gt;다중 처리기 컴퓨터로서 한 번에 한 명령어만을 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1명의 사용자가 여러 개의 CPU를 사용&lt;/li&gt;
  &lt;li&gt;슈퍼 컴퓨터, 과학 기술용 컴퓨터 급 수준&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;어레이 처리 기법&lt;/strong&gt;에 응용할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;misdmultiple-instruction-single-data&quot;&gt;MISD(Multiple Instruction Single Data)&lt;/h3&gt;
&lt;p&gt;단일 처리기 컴퓨터로서 한 번에 여러 개의 명령어를 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 명의 사용자가 1개의 CPU를 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mimdmultiple-instruction-multiple-data&quot;&gt;MIMD(Multiple Instruction Multiple Data)&lt;/h3&gt;
&lt;p&gt;다중 처리기 컴퓨터로서 한 번에 여러 개의 명령어를 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 명의 사용자가 여러 개의 CPU를 사용&lt;/li&gt;
  &lt;li&gt;일반적으로 다중 처리기 혹은 다중 컴퓨터라고도 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;다중-처리기multi-processor&quot;&gt;다중 처리기(Multi-Processor)&lt;/h4&gt;
&lt;p&gt;여러 개의 CPU가 &lt;strong&gt;하나의 메모리를 공유&lt;/strong&gt;하는 형태로 CPU 끼리의 결합력이 강하며, &lt;strong&gt;병렬 처리&lt;/strong&gt;에 적합한 컴퓨터 시스템 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;강 결합(Tightly-Coupled)&lt;/strong&gt; 시스템&lt;/li&gt;
  &lt;li&gt;전송 지연이 짧고 데이터 처리율이 높다&lt;/li&gt;
  &lt;li&gt;프로세스간 통신은 공유 메모리를 통해 이루어진다&lt;/li&gt;
  &lt;li&gt;공유 메모리를 차지하려는 &lt;strong&gt;프로세스 간의 경쟁&lt;/strong&gt;이 발생&lt;/li&gt;
  &lt;li&gt;기억 장소가 하나이므로 운영체제도 &lt;strong&gt;종속적&lt;/strong&gt;으로 사용&lt;/li&gt;
  &lt;li&gt;모든 CPU는 하나의 운영체제에서 통제되는 &lt;strong&gt;대칭적인 구조&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;다중-컴퓨터multi-computer&quot;&gt;다중 컴퓨터(Multi-Computer)&lt;/h4&gt;
&lt;p&gt;여러 개의 CPU가 자신만의 &lt;strong&gt;독립적인 메모리를 사용&lt;/strong&gt;하는 형태로 CPU 끼리 결합력이 약하며, &lt;strong&gt;분산 처리&lt;/strong&gt;에 적합한 컴퓨터 시스템 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;약 결합(Loosely-Coupled)&lt;/strong&gt; 시스템&lt;/li&gt;
  &lt;li&gt;전송 지연이 길고 데이터 처리율이 낮다&lt;/li&gt;
  &lt;li&gt;프로세스 간의 통신은 통신망에 &lt;strong&gt;메시지 전달로 통신&lt;/strong&gt; 가능&lt;/li&gt;
  &lt;li&gt;구성 요소의 &lt;strong&gt;추가 또는 삭제가 용이&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;기억 장소가 CPU와 독립적으로 사용되므로 운영체제도 독립적으로 사용하는 &lt;strong&gt;분리 수행 구조&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mimd의-위상에-따른-분류&quot;&gt;MIMD의 위상에 따른 분류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;다중 처리기의 위상
    &lt;ul&gt;
      &lt;li&gt;버스형&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;교환형
&lt;a href=&quot;../../assets/images/OS/multi-processor-topology.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/multi-processor-topology.png&quot; alt=&quot;&quot; title=&quot;다중 처리기의 위상&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;크로스바 교환 행렬 &lt;strong&gt;(a)&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;오메가 교환 행렬 &lt;strong&gt;(b)&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다중 컴퓨터의 위상
    &lt;ul&gt;
      &lt;li&gt;버스형&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;교환형
&lt;a href=&quot;../../assets/images/OS/multi-computer-topology.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/multi-computer-topology.png&quot; alt=&quot;&quot; title=&quot;다중 컴퓨터의 위상&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;그리드 교환형 &lt;strong&gt;(a)&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;하이퍼 큐브 교환형 &lt;strong&gt;(b)&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;다중-처리기와-운영체제-구성&quot;&gt;다중 처리기와 운영체제 구성&lt;/h2&gt;
&lt;h3 id=&quot;주종-프로세서-구조&quot;&gt;주/종 프로세서 구조&lt;/h3&gt;
&lt;p&gt;하나의 컴퓨터 시스템에 두 개의 프로세서가 있을 경우 입출력과 연산을 각각 독립적으로 수행하지 않고 &lt;strong&gt;주 프로세서는 입출력과 연산&lt;/strong&gt;, &lt;strong&gt;종 프로세서는 연산을 일부&lt;/strong&gt; 담당하게 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주 프로세서가 중단되면 시스템이 중지&lt;/strong&gt;되지만 종 프로세서가 중단되면 컴퓨터 시스템은 계속 동작할 수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;주 프로세서&lt;/strong&gt;만이 &lt;strong&gt;운영체제&lt;/strong&gt;를 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;종 프로세서&lt;/strong&gt;는 &lt;strong&gt;사용자 프로그램&lt;/strong&gt;만을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분리-수행개별적-관리자-separate-excution&quot;&gt;분리 수행(개별적 관리자, Separate-Excution)&lt;/h3&gt;
&lt;p&gt;각 프로세서가 &lt;strong&gt;독립적인 운영체제&lt;/strong&gt;를 가진다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 프로세서에서 발생하는 인터럽트도 해당 프로세스에서 독립적으로 수행&lt;/li&gt;
  &lt;li&gt;각 프로세서는 자신만의 파일과 입출력 장치를 제어&lt;/li&gt;
  &lt;li&gt;프로세서가 독립적이므로 &lt;strong&gt;프로세서에 따라&lt;/strong&gt; 유휴 상태이거나 매우 바쁠 수 있다&lt;/li&gt;
  &lt;li&gt;한 프로세서의 고장으로 전 &lt;strong&gt;시스템이 중지되지 않으&lt;/strong&gt;므로 &lt;strong&gt;신뢰성이 우수&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;대칭적symmetric-구조&quot;&gt;대칭적(Symmetric) 구조&lt;/h3&gt;
&lt;p&gt;여러 프로세서가 하나의 운영체제에서 동시에 운영&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가장 강력한 시스템이나 매우 복잡한 구조&lt;/li&gt;
  &lt;li&gt;운영체제는 동등한 프로세서의 Pool(프로세서 정보 테이블)을 가진다&lt;/li&gt;
  &lt;li&gt;하나의 프로세서가 중단되면 &lt;strong&gt;능력이 다소 낮아지지만 중단 없이&lt;/strong&gt; 계속 진행&lt;/li&gt;
  &lt;li&gt;프로세서의 수를 늘린다고 해도 시스템 효율은 향상되지 않는다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;분산-운영체제&quot;&gt;분산 운영체제&lt;/h2&gt;
&lt;p&gt;각 호스트에 고유한 운영체제가 있는 것이 아니라 전체 네트워크에 공통적으로 단일 운영체제가 실행되는 시스템으로 &lt;strong&gt;원격에 있는 자원을 마치 지역 자원인 것처럼 쉽게 접근&lt;/strong&gt;하여 사용할 수 있는 방식&lt;/p&gt;

&lt;h3 id=&quot;분산-운영체제의-목적&quot;&gt;분산 운영체제의 목적&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;자원 공유의 증대성&lt;/strong&gt;&lt;br /&gt;
각 시스템이 통신망을 통해 연결되어 있으므로 유용한 자원을 공유하여 사용할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;연산 속도의 향상&lt;/strong&gt;&lt;br /&gt;
하나의 일을 여러 시스템에 분산하여 처리하기 때문에 연산 속도가 향상된다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;신뢰성 향상&lt;/strong&gt;&lt;br /&gt;
하나의 시스템에 오류가 발생하더라도 다른 시스템은 계속 작업을 수행할 수 있기 때문에 신뢰도가 향상된다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;컴퓨터 통신&lt;/strong&gt;&lt;br /&gt;
지리적으로 떨어진 시스템에 통신망을 두어 정보를 교환할 수 있다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-운영체제의-장점&quot;&gt;분산 운영체제의 장점&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CPU의 처리 능력 한계를 극복할 수 있다&lt;/li&gt;
  &lt;li&gt;CPU의 처리 능력을 한 단계 높이려면 현재 가격의 제곱만큼 비싸다. 따라서 &lt;strong&gt;처리 속도가 낮은 여러 개의 CPU를 연결&lt;/strong&gt;하여 처리 속도를 향상시킬 수 있기 때문에 &lt;strong&gt;경제적&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;반응 시간이 빠르면 계산 능력, 처리량, 신뢰성, 가용성 모두 향상&lt;/li&gt;
  &lt;li&gt;특정한 시스템의 병목 현상을 제거하기 위해 필요한 자원을 추가할 수 있으므로 &lt;strong&gt;확장성이 우수&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;부하를 균등하게 배분&lt;/strong&gt;할 수 있어 처리 효율이 향상&lt;/li&gt;
  &lt;li&gt;다수의 사용자가 데이터를 &lt;strong&gt;공유&lt;/strong&gt;할 수 있으며 통신이 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-운영체제의-단점&quot;&gt;분산 운영체제의 단점&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여러 개의 컴퓨터 시스템이 연결되어 있으므로 &lt;strong&gt;보안이 매우 취약&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;여러 개의 컴퓨터를 하나의 컴퓨터처럼 운영해야 하므로 소프트웨어 &lt;strong&gt;개발이 매우 어렵다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;적응성이&lt;/strong&gt; 하나의 CPU를 사용할 때보다는 &lt;strong&gt;떨어진다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;에러 발생 시 &lt;strong&gt;원인 파악이 힘들다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-운영체제의-결함&quot;&gt;분산 운영체제의 결함&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;링크 결함&lt;/strong&gt; - 두 개의 사이트 간에 연결이 잘못되어 발생하는 결함&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;사이트 결함&lt;/strong&gt; - 사이트 자체에서 발생할 수 있는 결함&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메시지의 분실&lt;/strong&gt; - 통신 회선을 통해 해당 사이트로 메시지가 전달되는 과정에서 시간 지연이나 다른 이유로 메시지를 잃어버리는 결함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-운영체제의-위상&quot;&gt;분산 운영체제의 위상&lt;/h3&gt;
&lt;h4 id=&quot;성형-연결star-connected-구조&quot;&gt;성형 연결(Star Connected) 구조&lt;/h4&gt;
&lt;p&gt;각 노드가 점 대 점 형태로 중앙 컴퓨터에 연결되고 중앙 컴퓨터를 경유한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제어가 집중되고 모든 동작이 중앙 컴퓨터에 의해 감시&lt;/li&gt;
  &lt;li&gt;중앙 컴퓨터에 과부하가 걸리면 성능이 현저히 감소&lt;/li&gt;
  &lt;li&gt;중앙 컴퓨터에 장애가 발생되면 전체 시스템 마비&lt;/li&gt;
  &lt;li&gt;한 노드의 고장은 다른 노드에 영향을 주지 않는다&lt;/li&gt;
  &lt;li&gt;터미널의 증가에 따라 통신 회선 수도 증가&lt;/li&gt;
  &lt;li&gt;최소 두 개의 노드만 사용할 수 있으므로 통신 비용이 저렴&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;환형-연결ring-connected-구조&quot;&gt;환형 연결(Ring Connected) 구조&lt;/h4&gt;
&lt;p&gt;각 사이트는 정확히 다른 두 사이트와 물리적으로 연결되어 있는 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정보 전달 방향은 단방향 혹은 양방향일 수 있다&lt;/li&gt;
  &lt;li&gt;기본 비용은 사이트의 수에 비례&lt;/li&gt;
  &lt;li&gt;메시지가 링을 순환할 경우 통신 비용은 증가&lt;/li&gt;
  &lt;li&gt;근거리 네트워크 구조로 가장 많이 채택&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;다중-접근-버스-연결multi-access-bus-connected-구조&quot;&gt;다중 접근 버스 연결(Multi-access Bus Connected) 구조&lt;/h4&gt;
&lt;p&gt;공유되는 하나의 버스가 시스템 내의 모든 노드와 연결되어 있는 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한 사이트의 고장은 나머지 사이트들 간의 통신에 아무런 영향을 주지 않는다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;버스에 이상이 생기면 전체 시스템이 마비&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;한 시점에 단지 하나의 전송&lt;/strong&gt;만이 가능&lt;/li&gt;
  &lt;li&gt;처리기나 기타 장치의 증설 절차가 &lt;strong&gt;단순&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;버스의 사용을 위한 &lt;strong&gt;경쟁 상태&lt;/strong&gt;가 발생하여 시스템 성능의 심각한 저해를 가져올 수 있다&lt;/li&gt;
  &lt;li&gt;시스템의 전체 통신량이 전송률에 의한 제한을 받는다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;완전-연결fully-connected-구조&quot;&gt;완전 연결(Fully Connected) 구조&lt;/h4&gt;
&lt;p&gt;네트워크의 각 사이트는 시스템 내의 다른 모든 사이트와 직접 연결된 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본 &lt;strong&gt;비용이 매우 높다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;사이트 간의 메시지는 매우 &lt;strong&gt;빠르게 전달&lt;/strong&gt; 가능&lt;/li&gt;
  &lt;li&gt;하나의 링크가 고장나도 다른 링크를 이용할 수 있으므로 &lt;strong&gt;신뢰성이 우수&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;부분-연결partially-connected-구조&quot;&gt;부분 연결(Partially Connected) 구조&lt;/h4&gt;
&lt;p&gt;시스템 내의 사이트 간에만 부분적으로 연결된 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본 비용이 완전 연결보다는 낮다&lt;/li&gt;
  &lt;li&gt;메시지 전달이 중간 사이트를 경유할 수 있으므로 늦어질 수 있다&lt;/li&gt;
  &lt;li&gt;완전 연결에 비해 신뢰성이 낮다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;계층-연결hierarchy-connected-구조&quot;&gt;계층 연결(Hierarchy Connected) 구조&lt;/h4&gt;
&lt;p&gt;사이트들이 트리 형태로 구성된 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;루트 사이트와 서브 사이트가 존재&lt;/li&gt;
  &lt;li&gt;루트 사이트를 제외한 다른 사이트는 하나의 부모 사이트와 여러 개의 자식 사이트를 갖는다&lt;/li&gt;
  &lt;li&gt;마지막 사이트를 제외한 사이트의 고장은 &lt;strong&gt;자식 사이트의 중단을 초래&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-운영체제의-투명성transparency&quot;&gt;분산 운영체제의 투명성(Transparency)&lt;/h3&gt;
&lt;p&gt;네트워크 상에 분산된 컴퓨팅 자원을 여러 다른 컴퓨터에서 이용하는 기술로써 중앙집중형과 달리 네트워크 상에 여러 컴퓨팅 플랫폼에 프로세스를 분산시키고, 분산된 프로세스를 &lt;strong&gt;논리적으로 마치 하나의 프로세스처럼 수행하도록 하는 기술&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;위치 투명성&lt;/strong&gt;&lt;br /&gt;
사용자가 원하는 파일이나 데이터베이스, 프린터 등의 자원들이 지역 컴퓨터 또는 네트워크 내의 다른 원격지 컴퓨터에 존재하더라도 &lt;strong&gt;위치에 관계없이 그의 사용을 보장&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이주 투명성&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;자원들이 이동하여도&lt;/strong&gt; 사용자는 자원의 이름이나 위치를 &lt;strong&gt;고려할 필요가 없다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;복제 투명성&lt;/strong&gt;&lt;br /&gt;
사용자에게 통보없이 파일들과 자원들의 &lt;strong&gt;부가적인 복사를 자유롭게&lt;/strong&gt; 할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;병행(동시) 투명성&lt;/strong&gt;&lt;br /&gt;
다중 사용자들이 자원을 자동으로 공유할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;병렬 투명성&lt;/strong&gt;&lt;br /&gt;
몇 개의 처리기가 사용되는지 알 필요가 없다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;접근 투명성&lt;/strong&gt;&lt;br /&gt;
각 프로세서의 로그인처럼 지역이나 원격 자원에 접근할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;성능 투명성&lt;/strong&gt;&lt;br /&gt;
여러 부하에 대해 성능을 증가시키기 위해 시스템을 재구성할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;규모 투명성&lt;/strong&gt;&lt;br /&gt;
시스템이나 응용프로그램이 시스템 구조나 응용 알고리즘에 대한 변경없이 규모에 따라 확장이 가능하다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;고장 투명성&lt;/strong&gt;&lt;br /&gt;
분산 시스템 내의 구성요소(트랜잭션, DBMS, 네트워크, 컴퓨터)가 장애를 발생시켜도 영속성을 제공할 수 있다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스레드thread&quot;&gt;스레드(Thread)&lt;/h2&gt;
&lt;p&gt;어떠한 프로그램 내에서, 특히 프로세스 내에서 &lt;strong&gt;실행되는 흐름의 단위&lt;/strong&gt;를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 &lt;strong&gt;둘 이상의 스레드를 동시&lt;/strong&gt;에 실행할 수 있다. 이러한 실행 방식을 &lt;strong&gt;멀티스레드&lt;/strong&gt;(Multithread)라고 한다.&lt;/p&gt;

&lt;p&gt;스레드는 &lt;strong&gt;순차적 실행&lt;/strong&gt;과 프로세스 상태 &lt;strong&gt;전이의 병렬성&lt;/strong&gt;을 접속하기 위해 개발되었다. 다중 프로그래밍 기법에서 여러 개의 프로세스는 하나의 시스템을 공유한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단일 프로세스를 다수의 스레드로 생성하여 &lt;strong&gt;병행성을 증진&lt;/strong&gt;시킬 수 있다&lt;/li&gt;
  &lt;li&gt;실행 환경을 공유시켜 &lt;strong&gt;기억 장소의 낭비가 줄어든다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;프로세스의 생성이나 문맥 교환 등의 &lt;strong&gt;오버헤드를 줄여&lt;/strong&gt; 운영체제의 성능을 향상&lt;/li&gt;
  &lt;li&gt;프로세스 내부에 포함되는 스레드는 공통적으로 &lt;strong&gt;접근 가능한 기억 장치를 통해 효율적으로 통신&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;스레드를 사용하면 하드웨어, 운영체제의 성능과 응용프로그램의 처리율을 향상시클 수 있다&lt;/li&gt;
  &lt;li&gt;하나의 프로세스에 여러 개의 스레드가 존재&lt;/li&gt;
  &lt;li&gt;스레드는 동일 프로세스 환경에서 &lt;strong&gt;서로 독립적인 다중 수행이 가능&lt;/strong&gt;하다&lt;/li&gt;
  &lt;li&gt;스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당한다&lt;/li&gt;
  &lt;li&gt;생성된 프로세스가 자신을 생성한 프로세스의 텍스트와 데이터 영역을 그대로 공유하고 &lt;strong&gt;스택만 따로 갖는&lt;/strong&gt; 새로운 프로세스 모델이다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;커널사용자-수준의-스레드&quot;&gt;커널/사용자 수준의 스레드&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;사용자 수준&lt;/th&gt;
      &lt;th&gt;커널 수준&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;- 커널 개입이 작다&lt;br /&gt;- 런 타임 시스템이 필요하다&lt;br /&gt;- 속도가 빠르다&lt;br /&gt;- 문맥 교환이 적다&lt;br /&gt;- 독자적 알고리즘이 필요&lt;br /&gt;- 대형 시스템에 적당&lt;br /&gt;- 구현이 어렵다&lt;br /&gt;- 커널을 스스로 호출하지 못한다&lt;br /&gt;- CPU 사용을 해제하지 못하면 시스템이 중단&lt;/td&gt;
      &lt;td&gt;- 커널 개입이 크다&lt;br /&gt;- 런 타임 시스템이 필요없고 커널이 직접한다&lt;br /&gt;- 속도가 느리다&lt;br /&gt;- 문맥 교환이 많다&lt;br /&gt;- 독자적 알고리즘이 필요 없다&lt;br /&gt;- 대형 시스템에 부적합&lt;br /&gt;- 구현이 쉽다&lt;br /&gt;- 커널을 스스로 호출한다&lt;br /&gt;- CPU 사용을 해제하지 못하면 운영체제가 지원한다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Wed, 21 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-computer-system/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-computer-system/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 파일 시스템</title>
        <description>&lt;h2 id=&quot;파일-시스템&quot;&gt;파일 시스템&lt;/h2&gt;
&lt;p&gt;컴퓨터 시스템의 &lt;strong&gt;편리한 사용을 위해 정보를 저장하고 관리&lt;/strong&gt;하는 시스템&lt;/p&gt;

&lt;p&gt;저장 장치의 &lt;strong&gt;물리적인 특성을 고려하여 논리적으로 저장하고 사용&lt;/strong&gt;하는 체계&lt;/p&gt;

&lt;p&gt;컴퓨터에서 사용되는 파일들을 다루는 운영체제의 파일 관리 체계&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;성능 판단 요소
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;소멸성(Volatility)&lt;/strong&gt; - 파일의 추가나 삭제의 빈도수&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;활성율(Activity)&lt;/strong&gt; - 주어진 시간에 접근한 파일 레코드의 백분율&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;크기(Size)&lt;/strong&gt; - 저장된 정보의 양&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일 시스템 요구사항
    &lt;ul&gt;
      &lt;li&gt;대량의 정보를 파일로 저장할 수 있어야 한다&lt;/li&gt;
      &lt;li&gt;파일로 저장된 정보가 사용 중에 파괴되어서는 안 된다&lt;/li&gt;
      &lt;li&gt;하나 이상의 프로세스가 공동으로 사용할 수 있어야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일 시스템 기능
    &lt;ul&gt;
      &lt;li&gt;사용자가 파일을 &lt;strong&gt;생성, 변경, 제거&lt;/strong&gt;할 수 있다&lt;/li&gt;
      &lt;li&gt;파일 간의 정보 &lt;strong&gt;전송&lt;/strong&gt;을 할 수 있어야 한다&lt;/li&gt;
      &lt;li&gt;파일을 &lt;strong&gt;공유&lt;/strong&gt;한다&lt;/li&gt;
      &lt;li&gt;여러 종류의 &lt;strong&gt;접근 제어 방법&lt;/strong&gt;을 제공&lt;/li&gt;
      &lt;li&gt;다양한 응용 처리 수행&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;백업 및 복구&lt;/strong&gt; 수행&lt;/li&gt;
      &lt;li&gt;사용자가 물리적 이름을 사용하는 대신 &lt;strong&gt;기호형 이름을 사용&lt;/strong&gt;하여 자신의 파일을 참조할 수 있도록 &lt;strong&gt;장치 독립성 제공&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파일-구조&quot;&gt;파일 구조&lt;/h2&gt;
&lt;h3 id=&quot;순차-접근-파일sequential-access-file&quot;&gt;순차 접근 파일(Sequential Access File)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/sequential-access-file.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/sequential-access-file.png&quot; alt=&quot;&quot; title=&quot;순차 접근 파일&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;입력되는 데이터의 논리적인 순서에 따라 물리적으로 연속적인 위치에 기록하는 파일 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;저장 &lt;strong&gt;매체의 효율이 높다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;물리적으로 연속적인 저장이 되기 때문에 &lt;strong&gt;접근 시간이 가장 빠르다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;특정한 데이터를 &lt;strong&gt;검색하는데 비교 횟수가 많아&lt;/strong&gt;지므로 &lt;strong&gt;검색 시간이 느리다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;저장 정보를 따로 구성하지 않아도 되므로 &lt;strong&gt;공간의 낭비가 없다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;구현이 쉽기&lt;/strong&gt; 때문에 어떤 매체라도 쉽게 사용 가능&lt;/li&gt;
  &lt;li&gt;대화식 처리보다 &lt;strong&gt;일괄 처리에 적합&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;순차 파일은 테이프를 모형화한 것이다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;직접-접근-파일direct-access-file&quot;&gt;직접 접근 파일(Direct Access File)&lt;/h3&gt;
&lt;p&gt;데이터 내의 키 필드를 &lt;strong&gt;해싱 사상 함수에 의해 물리적인 주소로 변환&lt;/strong&gt;하여 데이터를 기록하거나 검색하는 방식의 파일&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DASD(Direct Access Storage Device)의 물리적 주소를 통하여 직접 액세스&lt;/li&gt;
  &lt;li&gt;특정 레코드를 검색하기 위하여 키와 보조 기억 장치 사이의 물리적인 주소로 변환할 수 있는 &lt;strong&gt;사상 함수(Mapping Function)가 필요&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;해싱 사상 함수&lt;/strong&gt;를 사용하므로 &lt;strong&gt;검색 속도가 가장 빠르다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;한 번 파일을 개방&lt;/strong&gt;하면 읽거나 쓰기를 &lt;strong&gt;자유롭게 가능&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;어떤 레코드라도 &lt;strong&gt;평균 접근 시간 내에 접근 가능&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;키 변환법에 따라 &lt;strong&gt;공간의 낭비를 초래&lt;/strong&gt;할 수 있다&lt;/li&gt;
  &lt;li&gt;일반적으로 디스크 기억 장치에 많이 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;색인-순차-접근-파일isam-indexed-sequential-access-file&quot;&gt;색인 순차 접근 파일(ISAM, Indexed Sequential Access File)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/indexed-sequential-access-file.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/indexed-sequential-access-file.png&quot; alt=&quot;&quot; title=&quot;색인 순차 접근 파일&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;순차 파일과 직접 파일에서 지원하는 편성 방법이 결합된 형태로 순차 처리와 직접 처리가 모두 가능한 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디스크 기억 장치에 많이 이용&lt;/li&gt;
  &lt;li&gt;각 레코드는 레코드 키 값에 따라 논리적으로 배열&lt;/li&gt;
  &lt;li&gt;시스템은 각 레코드의 실제 주소가 저장된 인덱스를 관리한다&lt;/li&gt;
  &lt;li&gt;순차 접근과 직접 접근을 병행할 수 있기 때문에 &lt;strong&gt;융통성이 우수&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;레코드를 &lt;strong&gt;추가 및 삽입하는 경우, 파일 전체를 복사할 필요가 없다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;실제 데이터 처리 외에 &lt;strong&gt;인덱스를 처리하는 추가적인 시간&lt;/strong&gt;이 소모되므로 파일 처리 &lt;strong&gt;속도가 느리다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;인덱스를 저장하기 위한 공간과 오버플로 처리를 위한 &lt;strong&gt;별도의 공간이 필요하므로 기억 공간의 낭비&lt;/strong&gt;가 있다&lt;/li&gt;
  &lt;li&gt;파일을 구성하는 블록의 번호는 절대 블록 번호여야 사용자가 자신의 파일이 아닌 부분에 접근하는 것을 방지할 수 있다&lt;/li&gt;
  &lt;li&gt;파일이 정렬되어 있어야 하므로 &lt;strong&gt;추가, 삭제가 많으면 효율이 낮아&lt;/strong&gt;진다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;삽입, 삭제가 많아&lt;/strong&gt;지면 파일에 대한 &lt;strong&gt;재편성&lt;/strong&gt;이 이뤄져야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;인덱스와 순차 데이터 파일을 구성하는 방법에 따라 정적 인덱스 방법과 동적 인덱스 방법으로 구분되며, 탐색 횟수를 줄이기 위해서 다단계 인덱스를 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ISAM(Index Sequential Access Method)&lt;/strong&gt;&lt;br /&gt;
데이터 파일에 레코드가 삽입되거나 삭제될 때 인덱스의 내용은 변하지만 &lt;strong&gt;인덱스 구조 자체는 변경되지 않는&lt;/strong&gt; 방법으로 &lt;strong&gt;정적 인덱스&lt;/strong&gt; 방법이라고도 한다
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;기본 데이터 구역(Prime Data Area)&lt;/strong&gt; : 실제 데이터가 기록된 구역&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;3단계 색인 구역(Index Area)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;Master Index&lt;/strong&gt; : 실린더 색인 구역의 정보가 많을 경우 그것을 일정한 크기의 블록으로 구성하는데 이 때 해당 레코드가 어느 실린더 색인 구역에 기록되어 있는 지를 기록하는 색인&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Cylinder Index&lt;/strong&gt; : 각 트랙 색인의 최대키 값과 해당 레코드가 기록된 실린더의 정보가 기록되는 색인으로 한 파일당 한 개씩 만들어진다&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Track Index&lt;/strong&gt; : 처리할 레코드가 실제로 어느 트랙에 기록되어 있는지를 판별하는 구역&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;오버플로 구역(Overflow Area)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;Cylinder Overflow&lt;/strong&gt; : 각 실린더마다 만들어지는 오버플로 구역으로 해당 실린더의 기본 구역에서 오버플로된 데이터를 기록&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Independent Overflow&lt;/strong&gt; : 실린더 오버플로 구역에 더 이상 오버플로된 데이터를 기록할 수 없을 때 사용할 수 있는 예비 공간으로 실린더 오버플로 구역과는 별도로 만들어진다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;VSAM(Virtual Storage Access Method)&lt;/strong&gt;&lt;br /&gt;
인덱스나 데이터 파일을 블록으로 구성하고 각 블록에는 추가로 &lt;strong&gt;삽입될 레코드를 감안하여 빈 공간을 미리 예비&lt;/strong&gt;해두는 방법으로 &lt;strong&gt;동적 인덱스&lt;/strong&gt; 방법이라고도 한다
    &lt;ul&gt;
      &lt;li&gt;제어 구간(Control Interval) : 데이터 레코드가 저장되는 부분&lt;/li&gt;
      &lt;li&gt;제어 구역(Control Area) : 몇 개의 제어 구간을 모아 놓은 구역&lt;/li&gt;
      &lt;li&gt;순차 세트(Sequence Set) : 제어 구역에 대한 인덱스를 저장하는 구역&lt;/li&gt;
      &lt;li&gt;인덱스 세트(Index Set) : 순차 세트의 상위 요소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파일-제어-블록fcb-file-control-block-file-descriptor&quot;&gt;파일 제어 블록(FCB, File Control Block, File Descriptor)&lt;/h2&gt;
&lt;p&gt;파일을 관리하기 위해 운영체제가 필요로 하는 정보를 갖고 있는 제어 블록으로 파일마다 독립적으로 갖고 있다. 프로세스가 필요에 따라 파일을 Open하면 FCB의 항목은 주기억 장치로 옮겨진다. FCB는 운영체제 시스템에 따라 다른 자료 구조를 가질 수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일명&lt;/li&gt;
  &lt;li&gt;보조 기억 장치의 파일 위치&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;파일의 구조&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;보조 기억 장치 유형&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;접근 제어 정보&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;파일 유형&lt;/li&gt;
  &lt;li&gt;제거 시기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;생성 날짜, 시간&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;제거 날짜&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최종 수정 날짜&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;접근 횟수&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파일의-디스크-공간-할당과-회수&quot;&gt;파일의 디스크 공간 할당과 회수&lt;/h2&gt;
&lt;p&gt;파일의 데이터를 디스크에 물리적으로 저장하고 삭제하는 방법을 의미&lt;/p&gt;

&lt;h3 id=&quot;연속-블록-할당contiguous-block-allocation&quot;&gt;연속 블록 할당(Contiguous Block Allocation)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/contiguous-block-allocation.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/contiguous-block-allocation.png&quot; alt=&quot;&quot; title=&quot;연속 블록 할당&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;물리적으로 연속적인 공간에 저장되고 &lt;strong&gt;저장할 크기를 미리 지정&lt;/strong&gt;하는 방식으로 파일마다 &lt;strong&gt;크기가 다르고&lt;/strong&gt; &lt;strong&gt;추가, 삭제가 빈번히 발생&lt;/strong&gt;할 경우에 &lt;strong&gt;단편화 현상이 많이 발생&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;따라서 디스크 활용을 최대화하기 위한 &lt;strong&gt;통합, 집약, Garbage Collection 필요&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일의 크기보다 큰 연속 공간이 없을 경우에는 파일을 생성할 수 없다&lt;/li&gt;
  &lt;li&gt;다중 프로그래밍에 적용하기 어렵다&lt;/li&gt;
  &lt;li&gt;가상 기억 장치를 응용하여 사용할 수 없다&lt;/li&gt;
  &lt;li&gt;용적률이 줄어든다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;불연속-블록-할당링크-블록-할당&quot;&gt;불연속 블록 할당(링크 블록 할당)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/link-block-allocation.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/link-block-allocation.png&quot; alt=&quot;&quot; title=&quot;링크 블록 할당&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;디스크 공간을 일정한 길이를 갖는 &lt;strong&gt;단위(섹터/블록)로 나누어 할당&lt;/strong&gt;하는 기법. 분할된 영역은 독립적으로 취급되며 파일의 데이터들은 분할된 영역에 &lt;strong&gt;순차적, 분산적으로 저장&lt;/strong&gt;할 수 있는 방법이다. 분할 저장된 파일의 각 데이터들은 파일 Open 시에 &lt;strong&gt;연결된 정보를 이용해 사용&lt;/strong&gt;된다.&lt;/p&gt;

&lt;p&gt;실제 데이터를 저장하는 공간 외에 분할된 정보와 파일의 연결된 데이터 정보를 저장해야 하는 영역이 필요하므로 &lt;strong&gt;부가적인 저장 공간&lt;/strong&gt;이 연속 블록 할당보다는 많이 사용되고 그에 따른 &lt;strong&gt;구현 방법도 복잡&lt;/strong&gt;하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;섹터 단위&lt;/strong&gt;&lt;br /&gt;
디스크 섹터 단위로 파일의 데이터가 분산되어 저장되며 각 섹터는 연결 리스트 구조 형태로 연결. 파일의 크기가 커지면 비어있는 섹터를 사용하고 작아지면 사용하지 않은 섹터를 반납한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;블록 단위&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;블록 체인 기법&lt;/strong&gt; : 여러 개의 섹터를 묶은 블록을 체인처럼 연결한 방식&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;인덱스 블록 체인 기법&lt;/strong&gt; : 인덱스에 블록의 주소를 링크시켜 사용 - Unix&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;블록 단위 파일 사상 기법&lt;/strong&gt; : 파일 정보의 해당 블록을 사상시켜 연결하여 사용한다 - Windows, MS-DOS&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일의 크기보다 큰 연속 공간이 없을 경우라도 파일을 생성할 수 있다&lt;/li&gt;
  &lt;li&gt;다중 프로그래밍에 유용하게 사용&lt;/li&gt;
  &lt;li&gt;가상 기억 장치를 응용하여 사용&lt;/li&gt;
  &lt;li&gt;용적률이 좋아진다&lt;/li&gt;
  &lt;li&gt;액세스 시간이 증가한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;디렉터리&quot;&gt;디렉터리&lt;/h2&gt;
&lt;p&gt;파일 시스템 내부에 있는 기능으로 디스크 내에 존재하는 많은 파일을 쉽게 사용(저장/검색/관리)할 수 있도록 하는 조직화된 기법&lt;/p&gt;

&lt;h3 id=&quot;단일-단계-디렉터리&quot;&gt;단(일) 단계 디렉터리&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/single-level-directory.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/single-level-directory.png&quot; alt=&quot;&quot; title=&quot;단일 단계 디렉터리&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디렉터리 시스템에 보관된 모든 파일의 정보를 포함해야 한다&lt;/li&gt;
  &lt;li&gt;파일이 같은 디렉터리 내에 있어야 하므로 &lt;strong&gt;유일한 파일명&lt;/strong&gt;으로 작성해야 한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;파일명의 길이를 제한&lt;/strong&gt;한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-단계-디렉터리&quot;&gt;2 단계 디렉터리&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/two-level-directory.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/two-level-directory.png&quot; alt=&quot;&quot; title=&quot;2 단계 디렉터리&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;중앙에 &lt;strong&gt;마스터 디렉터리&lt;/strong&gt;가 존재하며 그 아래 &lt;strong&gt;사용자 디렉터리&lt;/strong&gt;가 있는 구조&lt;/li&gt;
  &lt;li&gt;다른 사용자와의 &lt;strong&gt;파일 공유가 어렵다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;파일명의 길이가 길어 사용하기 매우 어렵다&lt;/li&gt;
  &lt;li&gt;2단계 이상으로 깊어지면 트리 구조 디렉터리가 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;트리-구조-디렉터리&quot;&gt;트리 구조 디렉터리&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/tree-structured-directory.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/tree-structured-directory.png&quot; alt=&quot;&quot; title=&quot;트리 구조 디렉터리&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나의 루트 디렉터리와 여러 개의 부 디렉터리로 구성&lt;/li&gt;
  &lt;li&gt;부 디렉터리는 그 하위로 또 다른 디렉터리를 구성할 수 있다&lt;/li&gt;
  &lt;li&gt;각 디렉터리의 생성과 파괴가 용이&lt;/li&gt;
  &lt;li&gt;동일한 이름의 여러 디렉터리 생성이 가능&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Unix&lt;/strong&gt;, &lt;strong&gt;MS-DOS&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt; 운영체제에서 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비순환주기-그래프-디렉터리&quot;&gt;비순환(주기) 그래프 디렉터리&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/acyclic-graph-directory.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/acyclic-graph-directory.png&quot; alt=&quot;&quot; title=&quot;비순환 그래프 디렉터리&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본적으로 트리 구조와 유사하나 &lt;strong&gt;사이클을 허용하지 않는다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;하나의 파일이나 디렉터리를 &lt;strong&gt;상위 디렉터리에서 공유할 수 없다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;링크 수만큼 파일을 공유하고 있으며 &lt;strong&gt;링크 수가 0이면 완전히 제거할 수 있다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;하나의 파일을 여러 사용자가 공유하기 때문에 &lt;strong&gt;삭제 시 문제점이 많이 발생&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;융통성이 있으며 기억 공간을 절약할 수 있으나 복잡하다&lt;/li&gt;
  &lt;li&gt;공용된 파일이나 디렉터리는 물리적으로 한 개만 존재한다&lt;/li&gt;
  &lt;li&gt;하나의 파일이 다수의 이름으로 존재할 수 있다&lt;/li&gt;
  &lt;li&gt;공유하고 있는 파일 제거 시 &lt;strong&gt;Dangling Pointer&lt;/strong&gt;(사용할 수 없는 해제된 주소를 가리키는 것)가 발생할 수 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Unix&lt;/strong&gt; 운영체제에서 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;일반-그래프-디렉터리&quot;&gt;일반 그래프 디렉터리&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/general-graph-directory.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/general-graph-directory.png&quot; alt=&quot;&quot; title=&quot;일반 그래프 디렉터리&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;사이클을 인정&lt;/strong&gt;하므로 파일 접근이 용이하다&lt;/li&gt;
  &lt;li&gt;그래프 탐색 알고리즘이 간단&lt;/li&gt;
  &lt;li&gt;하나의 파일이나 디렉터리를 상위 디렉터리에서 &lt;strong&gt;공용&lt;/strong&gt;할 수 있다&lt;/li&gt;
  &lt;li&gt;상위 파일이나 디렉터리를 자신의 파일이나 하위 디렉터리로 구성할 수 있다&lt;/li&gt;
  &lt;li&gt;파일을 제거하기 위한 Garbage-Collection을 위한 &lt;strong&gt;참조 계수기&lt;/strong&gt;가 필요&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 20 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-file-system/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-file-system/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
  </channel>
</rss>
