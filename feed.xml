<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://many258.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://many258.github.io/" rel="alternate" type="text/html" /><updated>2021-03-27T12:33:42+09:00</updated><id>https://many258.github.io/feed.xml</id><title type="html">My LifeChronicle</title><subtitle>Be a Imagineer.</subtitle><author><name>SG Yoo.</name></author><entry><title type="html">[데이터통신] 데이터 통신 시스템의 기본</title><link href="https://many258.github.io/study/data-communication-base/" rel="alternate" type="text/html" title="[데이터통신] 데이터 통신 시스템의 기본" /><published>2021-03-27T00:00:00+09:00</published><updated>2021-03-27T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdata-communication-base%7D</id><content type="html" xml:base="https://many258.github.io/study/data-communication-base/">&lt;h1 id=&quot;통신의-3요소&quot;&gt;통신의 3요소&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;정보원(Source)&lt;/li&gt;
  &lt;li&gt;수신원(Destination)&lt;/li&gt;
  &lt;li&gt;전송매체(Transmission Media)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-통신-시스템의-발달-과정&quot;&gt;데이터 통신 시스템의 발달 과정&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SAGE&lt;/strong&gt;(Semi-Automatic Ground Enviroment)
    &lt;ul&gt;
      &lt;li&gt;미국의 군사용 반자동 방공 시스테믕로 사용된 &lt;strong&gt;최초의 데이터 통신&lt;/strong&gt; 시스템&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SABRE&lt;/strong&gt;(Semi-Automatic Business Research Enviroment)
    &lt;ul&gt;
      &lt;li&gt;항공기 좌석 예약 시스템으로 &lt;strong&gt;최초의 상업용&lt;/strong&gt; 통신 시스템&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CTSS&lt;/strong&gt;(Compatible Time Sharing System)
    &lt;ul&gt;
      &lt;li&gt;대학 내 대형컴퓨터 공동 이용을 목적으로 시행한 &lt;strong&gt;최초의 시분할&lt;/strong&gt; 시스템&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ARPANET&lt;/strong&gt;(Advanced Research Project Agency Network)
    &lt;ul&gt;
      &lt;li&gt;최소의 &lt;strong&gt;유선 패킷 시스템&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;인터넷 기술의 모체&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ALOHA&lt;/strong&gt;(Additive Links On-line Hawaii Area)
    &lt;ul&gt;
      &lt;li&gt;최초의 &lt;strong&gt;무선 패킷&lt;/strong&gt; 네트워크 시스템&lt;/li&gt;
      &lt;li&gt;공유 회선 점유방식 중 &lt;strong&gt;경쟁방식(CSMA, CSMA/CD)의 모체&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SNA&lt;/strong&gt;(System Network Architecture)
    &lt;ul&gt;
      &lt;li&gt;IBM 사에서 발표한 컴퓨터 간 접속 &lt;strong&gt;네트워크 시스템 표준&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-통신-시스템&quot;&gt;데이터 통신 시스템&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 전송계
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;단말장치&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTE&lt;/code&gt;: Data Terminal Equipment)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;데이터 전송 회선&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;신호 변환기&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DCE&lt;/code&gt;: Data Circuit Equipment)&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;통신 회선&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;통신 제어 장치&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CCU&lt;/code&gt;: Communication Control Unit)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 처리계
    &lt;ul&gt;
      &lt;li&gt;컴퓨터
        &lt;ul&gt;
          &lt;li&gt;하드웨어&lt;/li&gt;
          &lt;li&gt;통신 소프트웨어&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;통신&lt;/code&gt; 시스템의 3대 구성요소
    &lt;ul&gt;
      &lt;li&gt;단말장치&lt;/li&gt;
      &lt;li&gt;통신 제어 장치&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;전송 장치&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전송&lt;/code&gt; 시스템의 3대 구성요소
    &lt;ul&gt;
      &lt;li&gt;단말장치&lt;/li&gt;
      &lt;li&gt;통신 제어 장치&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;데이터 전송 회선&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;단말장치dte-data-terminal-equipment&quot;&gt;단말장치(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTE&lt;/code&gt;: Data Terminal Equipment)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;통신 시스템과 사용자의 접점에 위치하여 데이터를 입력하거나 처리된 결과를 출력하는 기능 담당&lt;/li&gt;
  &lt;li&gt;전송 제어 기능(입출력 제어, 오류 제어, 송수신 제어) 수행&lt;/li&gt;
  &lt;li&gt;통신 회선을 통하여 송수신될 때 속도의 차이를 극복시켜 주는 임시 기억 장치의 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-전송-회선&quot;&gt;데이터 전송 회선&lt;/h2&gt;
&lt;p&gt;전송 신호를 송/수신하기 위한 통로&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전송로에 적합한 신호로 변경&lt;/li&gt;
  &lt;li&gt;데이터 송수신 시에 동기(시간 맞춤 행위)를 제어&lt;/li&gt;
  &lt;li&gt;오류를 검출하거나 정정&lt;/li&gt;
  &lt;li&gt;전송 조작 절차를 제어&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;신호-변환기dce-data-circuit-equipment&quot;&gt;신호 변환기(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DCE&lt;/code&gt;: Data Circuit Equipment)&lt;/h3&gt;
&lt;p&gt;단말장치와 통신 회선 사이에서 적합한 신호나 데이터로 변환시켜주는 장치로서 데이터 회선 종단 장치라고도 한다.&lt;br /&gt;
&lt;strong&gt;MODEM, CODEC, DSU&lt;/strong&gt;가 존재&lt;/p&gt;

&lt;h3 id=&quot;통신-회선&quot;&gt;통신 회선&lt;/h3&gt;
&lt;p&gt;데이터가 실질적으로 전송되는 선로.&lt;br /&gt;
&lt;strong&gt;꼬임선/동축케이블/광섬유 케이블&lt;/strong&gt; 등 전송 매체 존재&lt;/p&gt;

&lt;h2 id=&quot;통신-제어-장치ccu-communication-control-unit&quot;&gt;통신 제어 장치(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CCU&lt;/code&gt;: Communication Control Unit)&lt;/h2&gt;
&lt;p&gt;데이터 전송회선과 컴퓨터를 연결하는 장치. 컴퓨터가 데이터 처리에 전념할 수 있도록 컴퓨터를 대신해 데이터 전송에 관한 전반적인 제어 기능을 수행&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;통신 회선을 통하여 송수신되는 자료를 제어하고 감시&lt;/li&gt;
  &lt;li&gt;통신 회선의 전송 속도와 CPU의 처리 속도 사이에서 조정을 수행&lt;/li&gt;
  &lt;li&gt;통신 회선과 전기적으로 결합&lt;/li&gt;
  &lt;li&gt;통신 방식과 다중 접속을 제어&lt;/li&gt;
  &lt;li&gt;전송 문자 및 메시지를 조립 또는 분해&lt;/li&gt;
  &lt;li&gt;동기 제어 : 컴퓨터의 처리 속도와 통신 회선 상의 전송 속도 차이 조정&lt;/li&gt;
  &lt;li&gt;오류 제어 : 통신 회선과 단말장치에서 발생하는 오류 제어&lt;/li&gt;
  &lt;li&gt;흐름 제어 : 수신 가능한 데이터의 양을 송신측에 알려 원할한 정보 전송이 가능하도록 조정&lt;/li&gt;
  &lt;li&gt;응답 제어 : 수신 정보 확인&lt;/li&gt;
  &lt;li&gt;투과성 : 전송할 실제 데이터에 대한 비트 열에 확장 비트를 부가 또는 소거&lt;/li&gt;
  &lt;li&gt;우선권 제어&lt;/li&gt;
  &lt;li&gt;제어 정보 식별 : 일반 데이터와 제어 정보 구분&lt;/li&gt;
  &lt;li&gt;기밀 보호 : 암호화 등 제어&lt;/li&gt;
  &lt;li&gt;관리 기능 : 통신에 관한 통계 정보 수집&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="데이터통신" /><summary type="html">통신의 3요소 정보원(Source) 수신원(Destination) 전송매체(Transmission Media)</summary></entry><entry><title type="html">[데이터통신] 데이터 전송</title><link href="https://many258.github.io/study/data-communication-transmission/" rel="alternate" type="text/html" title="[데이터통신] 데이터 전송" /><published>2021-03-27T00:00:00+09:00</published><updated>2021-03-09T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdata-communication-transmission%7D</id><content type="html" xml:base="https://many258.github.io/study/data-communication-transmission/">&lt;h1 id=&quot;데이터-전송-방식&quot;&gt;데이터 전송 방식&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;아날로그 전송&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;전송 매체를 통해 전달되는 신호가 아날로그 형태인 것(사람의 음성, 화상)&lt;/li&gt;
      &lt;li&gt;신호의 감쇠 현상이 심하기 때문에 증폭기에 의해 신호를 중간에 다시 증폭하여 전송해야 하는데 신호에 포함된 잡음까지 같이 증폭&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디지털 전송&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;전송 매체를 통해 전달되는 신호가 디지털 형태인 것&lt;/li&gt;
      &lt;li&gt;신호에 포함된 잡음은 제거하고 0과 1만을 추출하여 증폭되므로 왜곡 현상이 없다&lt;/li&gt;
      &lt;li&gt;아날로그 전송과 비교하여 유지 비용이 적다&lt;/li&gt;
      &lt;li&gt;디지털 신호 변환에 의해 아날로그나 디지털 정보의 암호화가 쉽게 구현 가능&lt;/li&gt;
      &lt;li&gt;전송 용량을 다중화함으로써 효율성이 높음&lt;/li&gt;
      &lt;li&gt;아날로그 전송보다 훨씬 &lt;strong&gt;많은 대역폭을 필요&lt;/strong&gt;로 하고, 전송 거리가 짧기 때문에 증폭기가 많이 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-비트의-전송-방법&quot;&gt;데이터 비트의 전송 방법&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;직렬 전송
    &lt;ul&gt;
      &lt;li&gt;정보를 구성하는 각 비트들이 하나의 전송 매체를 통해 한 비트씩 순서적으로 전송되는 형태&lt;/li&gt;
      &lt;li&gt;하나의 전송 매체만 사용하므로 &lt;strong&gt;속도는 느리지만&lt;/strong&gt; 구성 비용이 적다&lt;/li&gt;
      &lt;li&gt;원거리 전송에 적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;병렬 전송
    &lt;ul&gt;
      &lt;li&gt;정보를 구성하는 각 비트들이 여러 개의 전송 매체를 통해 동시에 전송되는 형태&lt;/li&gt;
      &lt;li&gt;여러 개의 전송 매체를 사용하므로 전송 속도는 &lt;strong&gt;빠르지만&lt;/strong&gt; 구성 비용이 많이 소요&lt;/li&gt;
      &lt;li&gt;근거리 전송에 적합하며 주로 컴퓨터와 주변장치 사이의 데이터 전송에 사용&lt;/li&gt;
      &lt;li&gt;흐름 제어 필요 :
        &lt;ul&gt;
          &lt;li&gt;수신측이 현재 데이터 수신중임을 알리기 위해 Busy 신호 사용&lt;/li&gt;
          &lt;li&gt;문자와 문자 단위를 식별하기 위해 Strobe 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-전송-방향&quot;&gt;데이터 전송 방향&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;단방향 전송(Simplex)&lt;br /&gt;
한쪽 방향으로만 데이터 전송이 이루어지는 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;양방향 전송(Duplex)&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;반이중 전송(Half-Duplex)
        &lt;ul&gt;
          &lt;li&gt;한쪽에서 데이터 전송이 되면 다른 한쪽에서는 전송이 끝나기를 기다리는 방식&lt;/li&gt;
          &lt;li&gt;전송 &lt;strong&gt;방향을 바꾸는 시간&lt;/strong&gt;이 필요&lt;/li&gt;
          &lt;li&gt;통신 회선이 비교적 적을 때 사용&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;2선식 선로&lt;/strong&gt;를 두어 송신과 수신을 번갈아 전송&lt;/li&gt;
          &lt;li&gt;전송 지연에 문제가 있으며 &lt;strong&gt;반환 시간(Turn-Around Time)이 길다&lt;/strong&gt;.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;전이중 전송(Full-Duplex)
        &lt;ul&gt;
          &lt;li&gt;전송 시간에 구애를 받지 않는다&lt;/li&gt;
          &lt;li&gt;전송량이 많고 통신 회선의 용량이 클 때 사용&lt;/li&gt;
          &lt;li&gt;통신 회선의 &lt;strong&gt;효율이 높다&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;4선식 선로&lt;/strong&gt;를 두어 송신과 수신을 별도로 전송&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;동기화&quot;&gt;동기화&lt;/h1&gt;
&lt;p&gt;송신 측과 수신 측이 정확히 데이터를 주고 받을 수 있도록 양측에 시간을 맞추는 것을 의미. 이 때 양측의 &lt;strong&gt;시간을 일치&lt;/strong&gt;시키는 것을 &lt;strong&gt;동기식 전송&lt;/strong&gt;, 송신 측에 관계없이 수신 측에서 &lt;strong&gt;수신 신호로 시간을 식별&lt;/strong&gt;하는 것을 &lt;strong&gt;비동기식 전송&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;비동기식-전송&quot;&gt;비동기식 전송&lt;/h2&gt;
&lt;p&gt;시작 비트, 전송 문자(정보 비트), 정지 비트로 구성된 한 문자를 단위로 전송하며, 오류 검출을 위한 패리티 비트를 추가하기도 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;간헐적으로 시간을 맞춘다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;독립적, 문자 단위&lt;/strong&gt; 전송&lt;/li&gt;
  &lt;li&gt;문자와 문자 사이의 &lt;strong&gt;휴지 기간&lt;/strong&gt;이 존재&lt;/li&gt;
  &lt;li&gt;한꺼번에 많은 데이터를 보내면 프레이밍 에러의 가능성이 높아진다&lt;/li&gt;
  &lt;li&gt;약 2Kbps 이하의 &lt;strong&gt;저속&lt;/strong&gt;, &lt;strong&gt;단거리&lt;/strong&gt; 전송에 사용&lt;/li&gt;
  &lt;li&gt;대화용 전송에 적당&lt;/li&gt;
  &lt;li&gt;버퍼를 적게 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ASK, FSK&lt;/strong&gt; 방식에 적합&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;전송 효율 = $\frac{정보 비트}{전송 비트} \times 100\%$&lt;br /&gt;
&lt;sub&gt;전송 비트 = 정보 비트 + 제어 비트(동기 문자, 오류 검출 비트)&lt;/sub&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;프레이밍 에러&lt;/strong&gt;(Framing Error) : 송신 측과 수신 측의 샘플링 시점이 달라서 발생하는 오류. 비동기 전송에서 start bit 와 stop bit 사이에 더 많은 비트들을 전송함으로써 오버헤드 비율을 줄일 수 있으나 비트들이 많을 수록 프레이밍 에러가 발생할 가능성이 높아진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;동기식-전송&quot;&gt;동기식 전송&lt;/h2&gt;
&lt;p&gt;미리 정해진 수만큼의 문자열을 한 블록(프레임)으로 만들어 일시에 전송하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;연속적&lt;/strong&gt;으로 시간을 맞춘다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;종속적, 블록(프레임) 단위&lt;/strong&gt; 전송&lt;/li&gt;
  &lt;li&gt;송신, 수신 양쪽의 동기를 유지하기 위해 타이밍 신호를 계속적으로 공급하거나 동기 문자를 전송&lt;/li&gt;
  &lt;li&gt;프레임 단위로 전송하므로 속도가 빠르다&lt;/li&gt;
  &lt;li&gt;시작/종료 비트로 인한 오버헤드가 없고, 휴지 기간이 없으므로 &lt;strong&gt;전송 효율이 좋다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;단말기는 반드시 버퍼 기억장치에 내장하여야 한다&lt;/li&gt;
  &lt;li&gt;PSK, QAM 방식에 적당&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;문자 동기 방식&lt;/strong&gt; : SYN 등의 전송 제어 문자에 의해 동기를 맞추는 방식으로 BSC 프로토콜에서 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비트 동기 방식&lt;/strong&gt; : 데이터 블록의 처음과 끝에 8비트의 플래그 비트를 표시하여 동기를 맞추는 방식으로, HDLC/SDLC/ADCCP 프로토콜에서 사용(전송 에러 검출을 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FSC&lt;/code&gt;(Frame Check Sequence) 이용)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-전송-형태&quot;&gt;데이터 전송 형태&lt;/h1&gt;
&lt;h2 id=&quot;베이스밴드-전송기저-대역-전송-baseband-transmission&quot;&gt;베이스밴드 전송(기저 대역 전송, Baseband Transmission)&lt;/h2&gt;
&lt;p&gt;원래의 신호를 다른 주파수 대역으로 변조하지 않고 전송하거나 정보를 0과 1로 표시하고 이것을 직류의 전기 신호로 전송하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;보통 하나의 회선에 하나의 채널을 사용&lt;/li&gt;
  &lt;li&gt;10Mbps 이하의 전송 속도&lt;/li&gt;
  &lt;li&gt;소규모 데이터 전송에 적합&lt;/li&gt;
  &lt;li&gt;신호는 양방향으로 진행&lt;/li&gt;
  &lt;li&gt;모뎀이 필요 없어 비용이 저렴하나 전송거리가 짧음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단극 RZ, 양극 NRZ-L, NRZ-M, Bipolar, Manchester&lt;/strong&gt; 등이 있다&lt;/li&gt;
  &lt;li&gt;CSMA/CD 방식, Token Ring 방식에서 채택&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;브로드밴드-전송반송-대역-전송-broadband-transmission&quot;&gt;브로드밴드 전송(반송 대역 전송, Broadband Transmission)&lt;/h2&gt;
&lt;p&gt;디지털 신호를 반송파의 진폭, 주파수, 위상 등으로 변환하여 아날로그를 전송하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;회선당 20 ~ 30개의 채널을 사용&lt;/li&gt;
  &lt;li&gt;150Mbps 이하의 전송속도&lt;/li&gt;
  &lt;li&gt;대규모의 멀티미디어에 적합한 방식&lt;/li&gt;
  &lt;li&gt;신호는 단방향으로 진행&lt;/li&gt;
  &lt;li&gt;Token Bus 방식에서 채택&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-전송-속도&quot;&gt;데이터 전송 속도&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 신호 속도(bps)&lt;br /&gt;
부호를 구성하는 데이터의 비트 수가 1초 동안에 얼마나 전송되었는가를 나타내는 단위
    &lt;blockquote&gt;
      &lt;p&gt;데이터 신호 속도(bps) = 변조 속도(Baud) X 변조 시 상태 변화 수&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;변조 속도(Baud)&lt;br /&gt;
신호의 변조 과정에서 1초 동안 몇 회의 변조가 행해졌는가를 나타내는 것을 의미.
    &lt;blockquote&gt;
      &lt;p&gt;B = $\frac{1}{T}$ &lt;sub&gt;T: 단위 시간당 펄스의 수&lt;/sub&gt;&lt;br /&gt;
$= \frac{bps}{변조 시 상태 변화 수}$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;베어러 속도&lt;br /&gt;
보통 베어러 속도를 반송 속도라고 하며 데이터 신호에 동기 신호와 상태 신호를 합한 속도(단위 bps = bit/sec)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Nyquist의 공식&lt;br /&gt;
잡음이 없는 채널의 전송 속도(bps)와 주파수(W)의 관계식
    &lt;blockquote&gt;
      &lt;p&gt;$C = 2W\log_2L$&lt;br /&gt;
&lt;sub&gt;C : bps / W : 대역폭 / L : 신호 레벨&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Shannon의 공식&lt;br /&gt;
잡음이 있는 채널의 전송 속도(bps)와 주파수(W)의 관계식
    &lt;blockquote&gt;
      &lt;p&gt;$C=W\log_2(1+S/N)$&lt;br /&gt;
&lt;sub&gt;C : bps / W : 대역폭 / S/N : 신호 대 잡음비&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-전송-코드&quot;&gt;데이터 전송 코드&lt;/h1&gt;
&lt;h2 id=&quot;baudot-코드&quot;&gt;Baudot 코드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;초기의 전송용 코드로 5비트로 구성&lt;/li&gt;
  &lt;li&gt;오류 검출 코드가 없다&lt;/li&gt;
  &lt;li&gt;코드의 확장 기능이 있다&lt;/li&gt;
  &lt;li&gt;텔렉스(최초의 문자 전송 시스템으로 문자 정보를 텔렉스 교환기를 사용해서 전송하는 시스템) 코드로 이용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ascii-code&quot;&gt;ASCII Code&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;(American Standard Code for Information Interchange)&lt;/li&gt;
  &lt;li&gt;ISO에서 제정한 코드이며 7비트(패리티 비트 추가 시 8비트)로 구성된 데이터 통신용 코드&lt;/li&gt;
  &lt;li&gt;순차적인 코드(알파벳이나 숫자가 순서적 코드로 되어 있다)&lt;/li&gt;
  &lt;li&gt;정보 문자와 제어 문자로 구분&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ascii-코드-제어-문자&quot;&gt;ASCII 코드 제어 문자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;전송 제어 : 통신 선로의 데이터 흐름을 제어
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;SOH&lt;/strong&gt;(Start Of Head) : 머리말의 시작&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;STX&lt;/strong&gt;(Start of TeXt) : 본문의 시작 혹은 머리말의 종료&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ETX&lt;/strong&gt;(End of TeXt) : 본문을 종료&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;EOT&lt;/strong&gt;(End Of Transmission) : 전송의 종료, 링크 해제를 요청&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ENQ&lt;/strong&gt;(ENQuire) : 링크 설정 요청, 상대국의 응답을 요청한다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt;(ACKnowledge) : 긍정적인 응답, 다음 프레임을 요청&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;DLE&lt;/strong&gt;(Data Link Escape) : 보조적인 제어 문자, 통신망에서 전송 제어 문자를 구분&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;NAK&lt;/strong&gt;(Negative AcKnowledge) : 부정적인 응답 및 재전송 요구&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SYN&lt;/strong&gt;(SYNchronous) : 시간 맞춤 행위를 위한 동기 문자&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ETB&lt;/strong&gt;(End of Transmission Block) : 블록의 종료를 표시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;포멧 제어 : 데이터의 출력 및 정보의 레이아웃을 제어
    &lt;ul&gt;
      &lt;li&gt;BS(Back Space)&lt;/li&gt;
      &lt;li&gt;HT(Horizontal Tabulation)&lt;/li&gt;
      &lt;li&gt;LF(Line Feed)&lt;/li&gt;
      &lt;li&gt;VT(Vertical Tab)&lt;/li&gt;
      &lt;li&gt;FF(Form Feed)&lt;/li&gt;
      &lt;li&gt;CR(Carriage Return)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장치 제어 : 단말기의 보조 장치를 제어&lt;/li&gt;
  &lt;li&gt;정보 분리 : 데이터의 논리적 요소를 분리
    &lt;ul&gt;
      &lt;li&gt;US(Unit Separator)&lt;/li&gt;
      &lt;li&gt;RS(Record Separator)&lt;/li&gt;
      &lt;li&gt;GS(Group Separator)&lt;/li&gt;
      &lt;li&gt;FS(File Separator)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bcdbinary-coded-decimal&quot;&gt;BCD(Binary Coded Decimal)&lt;/h2&gt;
&lt;p&gt;컴퓨터 내부 코드로 10진수를 표현하기 위하여 주로 사용&lt;br /&gt;
데이터 비트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6비트&lt;/code&gt;로 구성되므로 총 64개의 문자 표현이 가능&lt;/p&gt;

&lt;h2 id=&quot;ebcdicextended-binary-coded-decimal-interchange-code&quot;&gt;EBCDIC(Extended Binary Coded Decimal Interchange Code)&lt;/h2&gt;
&lt;p&gt;IBM 컴퓨터의 내부 코드로 사용되며 컴퓨터와 컴퓨터 사이에 데이터 전송 코드로 사용&lt;/p&gt;

&lt;p&gt;8비트로 구성되며 총 256문자 표현이 가능&lt;/p&gt;

&lt;h2 id=&quot;unicode&quot;&gt;UNICODE&lt;/h2&gt;
&lt;p&gt;서로 다른 언어를 사용하는 컴퓨터들이 문제없이 통신하도록 모든 문자 체계를 하나의 문자 집합으로 만든 것. 숫자와 글자(키와 값)가 1:1 매핑된 형태의 코드&lt;/p&gt;

&lt;p&gt;Character set = UTF(Unicode Transformation Format) : 포함시키고자 하는 문자 집합을 정의&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UTF-8
    &lt;ul&gt;
      &lt;li&gt;하나의 문자를 1 ~ 4바이트의 가변 길이로 표현&lt;/li&gt;
      &lt;li&gt;현재 인터넷에서 가장 많이 쓰이면 인코딩이며 뛰어난 크로스 플랫폼 호환성을 지님&lt;/li&gt;
      &lt;li&gt;웹, 데이터베이스에서 주로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UTF-16
    &lt;ul&gt;
      &lt;li&gt;모든 문자를 2바이트의 고정 길이로 표현&lt;/li&gt;
      &lt;li&gt;바이트 순서가 정해지지 않아 리틀/빅 에디안 문제가 발생하기 때문에 인터넷 상에서의 사용을 권고하지 않음&lt;/li&gt;
      &lt;li&gt;윈도우 계열에서 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UTF-32
    &lt;ul&gt;
      &lt;li&gt;모든 문자를 4바이트의 고정 길이로 표현&lt;/li&gt;
      &lt;li&gt;저장 공간의 낭비가 심하다는 단점이 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="데이터통신" /><summary type="html">데이터 전송 방식 아날로그 전송 전송 매체를 통해 전달되는 신호가 아날로그 형태인 것(사람의 음성, 화상) 신호의 감쇠 현상이 심하기 때문에 증폭기에 의해 신호를 중간에 다시 증폭하여 전송해야 하는데 신호에 포함된 잡음까지 같이 증폭 디지털 전송 전송 매체를 통해 전달되는 신호가 디지털 형태인 것 신호에 포함된 잡음은 제거하고 0과 1만을 추출하여 증폭되므로 왜곡 현상이 없다 아날로그 전송과 비교하여 유지 비용이 적다 디지털 신호 변환에 의해 아날로그나 디지털 정보의 암호화가 쉽게 구현 가능 전송 용량을 다중화함으로써 효율성이 높음 아날로그 전송보다 훨씬 많은 대역폭을 필요로 하고, 전송 거리가 짧기 때문에 증폭기가 많이 사용</summary></entry><entry><title type="html">[소프트웨어공학] 미들웨어(Middleware)</title><link href="https://many258.github.io/study/software-engineering-middleware/" rel="alternate" type="text/html" title="[소프트웨어공학] 미들웨어(Middleware)" /><published>2021-03-26T00:00:00+09:00</published><updated>2021-03-26T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-middleware%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-middleware/">&lt;h1 id=&quot;미들웨어middleware&quot;&gt;미들웨어(Middleware)&lt;/h1&gt;
&lt;p&gt;운영체제와 사용자 응용 프로그램 사이에 또는 다른 종류의 사용자 응용프로그램 사이에서 조정 및 &lt;strong&gt;중개 역할&lt;/strong&gt;을 하는 프로그램&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;두 개 이상의 응용 프로그램 간 데이터를 공유시킨다&lt;/li&gt;
  &lt;li&gt;표준화된 인터페이스 제공 가능&lt;/li&gt;
  &lt;li&gt;서버와 클라이언트 사이에서 작업량의 감소, 부하 분산, 트랜잭션 처리, 보안 등 역할을 담당&lt;/li&gt;
  &lt;li&gt;분산된 업무를 동시에 처리 가능하여 자료의 일관성 유지&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;종류&quot;&gt;종류&lt;/h2&gt;
&lt;h3 id=&quot;rpcremote-procedure-call--원격-프로시져-호출&quot;&gt;RPC(Remote Procedure Call) : 원격 프로시져 호출&lt;/h3&gt;
&lt;p&gt;원격 프로시져를 마치 로컬 프로시져처럼 호출하는 방식의 미들웨어&lt;/p&gt;

&lt;p&gt;한 프로그램이 네트워크 상의 다른 컴퓨터에 위치하고 있는 프로그램에 서비스를 요청하는데 사용되는 프로토콜로서, 이때 서비스를 요청하는 프로그램은 네트워크에 대한 상세 내용을 알 필요가 없다&lt;/p&gt;

&lt;p&gt;제품 종류 : Entera(이큐브시스템), ONC/RPC(OSF)&lt;/p&gt;

&lt;h3 id=&quot;mommessage-oriented-middleware--메시지-지향-미들웨어&quot;&gt;MOM(Message Oriented Middleware) : 메시지 지향 미들웨어&lt;/h3&gt;
&lt;p&gt;주로 &lt;strong&gt;비동기형 메시지 처리를 전달&lt;/strong&gt;하는 미들웨어.&lt;br /&gt;
이 기종 분산 데이터 시스템의 데이터 동기를 위해 주로 사용&lt;br /&gt;
제품 종류 : MQ(IBM), Message Q(Oracle), JMS(JCP)&lt;/p&gt;

&lt;h3 id=&quot;tp-모니터&quot;&gt;TP-모니터&lt;/h3&gt;
&lt;p&gt;온라인 트랜잭션 업무에서 트랜잭션을 처리, 감시하는 미들웨어.&lt;br /&gt;
사용자 수가 증가하여도 빠른 응답속도를 유지해야 하는 OLTP성의 업무에 적합
제품 종류 : Tuxedo(Oracle), Tmax(Tmax Soft)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;OLTP&lt;/strong&gt;(Online Transaction Processing)&lt;br /&gt;
네트워크 상의 여러 이용자가 실시간으로 데이터베이스의 데이터를 갱신하거나 조회하는 등의 단위 작업을 처리하는 방식&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OLAP&lt;/strong&gt;(Online Analytical Processing)&lt;br /&gt;
사용자가 다양한 각도에서 직접 대화식으로 정보를 분석하는 과정.&lt;br /&gt;
데이터웨어하우스 등의 시스템과 연관되어 자료를 분석하고 의미있는 정보로 치환하거나, 복잡한 모델링을 가능하게끔 하는 분석 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;corbacommon-object-request-broker-architecture&quot;&gt;CORBA(Common Object Request Broker Architecture)&lt;/h3&gt;
&lt;p&gt;네트워크에서 분산 프로그램 객체를 생성, 배포, 관리하기 위한 규격으로 네트워크 상의 서로 다른 장소에 있는 프로그램들이 “인터페이스 브로커”를 통해 통신이 가능하도록 해준다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OMG&lt;/strong&gt;(Object Management Group)&lt;br /&gt;
여러 대의 컴퓨터를 연결하여 사용하는 환경하에서 응용 프로그램 간에 기술적인 문제를 지원하고 표준을 위해 설립된 비영리 단체.&lt;br /&gt;
분산 네트워크 시스템에서 하드웨어나 운영체제에 영향을 받지 않고 응용 프로그램을 통합할 수 있는 공통된 작업 환경을 제공한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OMA&lt;/strong&gt;(Object Management Architecture)&lt;br /&gt;
OMG의 활동 방향과 목적에 부합되는 모델로서 ORB, 객체 서비스, 공통 기능, 응용 인터페이스, 도메인 인터페이스 등으로 구성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ORB&lt;/strong&gt;(Object Request Broker)&lt;br /&gt;
객체지향 시스템에서 객체 및 서비스를 요청하고 전송할 수 있도록 지원하는 미들웨어로 CORBA 표준 스펙을 구현한 미들웨어&lt;br /&gt;
제품 종류 : Orbix(Micro Focus), CORBA(OMG)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;comcomponent-object-model&quot;&gt;COM(Component Object Model)&lt;/h3&gt;
&lt;p&gt;MS사가 개발한 객체 응용 프로그램 간의 통신 방식으로 응용 프로그램의 컴포넌트 객체들을 개발하고 지원하기 위한 미들웨어.&lt;/p&gt;

&lt;p&gt;모든 기능을 여러 개의 &lt;strong&gt;단위 프로그램으로 분할&lt;/strong&gt;함으로써
코드의 재사용성을 극대화하고 효율적인 유지보수를 보장한다. 단위 소프트웨어, 컴포넌트들을 재사용하기 위해서는 &lt;strong&gt;표준화된 방법&lt;/strong&gt;이 필요했는데 단위 소프트웨어,컴포넌트들이 서로 통신할 수 있게 마이크로소프트가 표준화를 규정하였다.&lt;/p&gt;

&lt;p&gt;객체를 재사용하는 개념이 없기 때문에 객체지향의 이점은 누릴 수 없지만 다양한 응용 프로그램을 관리하는 면에서는 CORBA보다 우월&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IPC&lt;/strong&gt;(Inter Process Communication)&lt;br /&gt;
두 프로세스가 상호 통신하며 정보를 교환하는 방법&lt;/p&gt;

    &lt;p&gt;멀티태스킹 환경에서는 여러가지 프로그램들이 동시에 실행된다. 각 프로세스들은 메모리와 CPU를 공유하고 있을 뿐, 독립된 일을 하며 상호 간섭하지 않고 간섭할 수도 없다. 하지만 필요에 따라 프로세스간의 정보를 교환해야 하는 경우가 생기는데 이 때 사용한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dcomdistributed-component-object-model&quot;&gt;DCOM(Distributed Component Object Model)&lt;/h3&gt;
&lt;p&gt;인터넷이나 LAN환경에서 서로 다른 컴퓨터끼리의 통신을 지원하는 분산확장형 COM&lt;/p&gt;

&lt;p&gt;사용자 응용 프로그램 객체는 파일 이름 대신에 URL을 사용하여 서버 객체를 사용할 수 있으므로 인터넷에서 분산 처리를 실현할 수 있다&lt;/p&gt;

&lt;h3 id=&quot;comcomponent-object-model-1&quot;&gt;COM+(Component Object Model+)&lt;/h3&gt;
&lt;p&gt;분산형 트랜잭션을 동시 처리할 목적으로 출현&lt;/p&gt;

&lt;p&gt;COM/DCOM과 약간 다른 개념으로 MTS라고 불리는 일종에 서비스.&lt;br /&gt;
쉽게 말하자면 COM을 네트워크에서 사용가능하도록 해주는 서비스&lt;/p&gt;

&lt;h3 id=&quot;wasweb-application-server--웹-애플리케이션-서버&quot;&gt;WAS(Web Application Server) : 웹 애플리케이션 서버&lt;/h3&gt;
&lt;p&gt;정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어&lt;br /&gt;
종류 : 아파치 톰캣(Apache Tomcat), JBoss, Jetty, WebLogic, JRun, Jeus, WebSphere&lt;/p&gt;

&lt;h3 id=&quot;esbenterprise-service-bus--엔터프라이즈-서비스-버스&quot;&gt;ESB(Enterprise Service Bus) : 엔터프라이즈 서비스 버스&lt;/h3&gt;
&lt;p&gt;메시지 기반으로 느슨한 결합형태의 표준 인터페이스 통신을 통해 전사 시스템 환경을 연동하는 미들웨어&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SOA에서 사용되는 개념&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EAI와 유사하게 사용된다. 기관 간, 서비스 간 연계가 이루어진다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SOA&lt;/strong&gt;(서비스 지향 아키텍쳐 : Service Oritented Architecture)&lt;br /&gt;
대규모 컴퓨터 시스템을 구축할 때의 개념으로 업무상에 일 처리에 해당하는 소프트웨어 기능을 서비스로 판단하여 그 서비스를 네트워크 상에 연동하여 시스템 전체를 구축해 나가는 방법론&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;EAI&lt;/strong&gt;(기업 응용 프로그램 통합 : Enterprise Application Integration)&lt;br /&gt;
DW, ERP, CRM, SCM, B2B 등 기업에서 운영하는 서로 다른 어플리케이션 및 시스템을 통합시키는 것을 의미.&lt;br /&gt;
업무의 효율성, 확장성 향상, 유지보수 및 비용 절감, 편의성 증대시키는 솔루션&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">미들웨어(Middleware) 운영체제와 사용자 응용 프로그램 사이에 또는 다른 종류의 사용자 응용프로그램 사이에서 조정 및 중개 역할을 하는 프로그램</summary></entry><entry><title type="html">[소프트웨어공학] 소프트웨어 유지보수</title><link href="https://many258.github.io/study/software-engineering-maintenance/" rel="alternate" type="text/html" title="[소프트웨어공학] 소프트웨어 유지보수" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-09T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-maintenance%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-maintenance/">&lt;h1 id=&quot;소프트웨어-유지보수&quot;&gt;소프트웨어 유지보수&lt;/h1&gt;
&lt;p&gt;소프트웨어가 사용자에게 인수, 설치된 이후에 발생하는 모든 공학적인 작업 활동을 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소프트웨어 비용 중 &lt;strong&gt;유지보수 비용이 가장 큰 비중&lt;/strong&gt;을 차지&lt;/li&gt;
  &lt;li&gt;명세서의 유지보수란 명세서를 항상 최신의 상태로 만드는 것을 의미&lt;/li&gt;
  &lt;li&gt;소프트웨어는 계속 수정, 보완되기 때문에 명세서도 따라서 보완되지 않으면 일관성을 유지하기 어려움&lt;/li&gt;
  &lt;li&gt;소프트웨어 유지보수의 과정은 유지보수 요구, 현 시스템에 대한 이해, 수정 및 시험순으로 반복하여 일어남&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문서화documentation&quot;&gt;문서화(Documentation)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;유지보수와 시스템 개발을 위한 분석 설계가 용이하고, 확장성이 좋다&lt;/li&gt;
  &lt;li&gt;여러 사람이 알아보기 쉽고, 유지보수 작업이 용이하려면 문서화 작업이 표준화되어야 한다&lt;/li&gt;
  &lt;li&gt;문서의 표준화가 되었다고 해서 신뢰성이 높아지거나 &lt;strong&gt;프로그램 처리 속도가 향상되거나 개발 인력이 감소하는 것은 아니다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;유지보수-작업의-종류&quot;&gt;유지보수 작업의 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;수리보수&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Corrective&lt;/code&gt; Maintenance, 수정보수)
    &lt;ul&gt;
      &lt;li&gt;밝혀지지 않은 모든 잠재적인 오류를 찾아 수정하는 활동&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;완전보수&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Perfective&lt;/code&gt; Maintenance, 기능개선/향상보수)
    &lt;ul&gt;
      &lt;li&gt;기능의 수정, 새 기능의 추가, 전반적인 기능 개선 등&lt;/li&gt;
      &lt;li&gt;유지보수 유형 중 제일 많은 비용이 소요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;적응보수&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Adaptive&lt;/code&gt; Maintenance, 환경적응)
    &lt;ul&gt;
      &lt;li&gt;환경 변화에 대응하여 소프트웨어를 변경하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;예방보수&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Preventive&lt;/code&gt; Maintenance, 예비조치)
    &lt;ul&gt;
      &lt;li&gt;프로그램의 변경을 미리 예측하여 준비하는 활동&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;유지보수-비용-측정-방법&quot;&gt;유지보수 비용 측정 방법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;BL(Belady와 Lehman) 방법&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;M=$P+K\cdot e^{(c-d)}$&lt;br /&gt;
&lt;sub&gt;M:유지보수를 위한 노력(인원/월)&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;P:생산적인 활동에 드는 비용(개발 비용)&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;K:통계값에 구한 상수(주관적평가)&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;c:복잡도&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;d:소프트웨어에 대한 지식 정도&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;COCOMO 방법&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;M = $ACT \times DE \times EAF$&lt;br /&gt;
&lt;sub&gt;ACT:유지보수 비율&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;DE:생산적인 활동에 드는 비용(개발 비용)&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;EAF:노력 조정 수치(주관적 평가)&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Vessey &amp;amp; Webber 방법&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;M = $ACT \times 2.4 \times [KDSI]^{1.05}$&lt;br /&gt;
&lt;sub&gt;M:생산적인 활동에 드는 비용(개발 비용)&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;ACT:유지보수 비율&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;KDSI:1000당 명령어 라인 수&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;소프트웨어-품질-목표-항목&quot;&gt;소프트웨어 품질 목표 항목&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;정확성&lt;/li&gt;
  &lt;li&gt;신뢰성&lt;/li&gt;
  &lt;li&gt;효율성&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;무결성&lt;/strong&gt; : 허용하지 않은 사용이나 자료의 변경을 제어하는 정도&lt;/li&gt;
  &lt;li&gt;유지보수 용이성&lt;/li&gt;
  &lt;li&gt;사용 용이성&lt;/li&gt;
  &lt;li&gt;검사 용이성&lt;/li&gt;
  &lt;li&gt;이식성&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상호 운용성&lt;/strong&gt; : 다른 소프트웨어와 정보를 교환할 수 있는 정도&lt;/li&gt;
  &lt;li&gt;유연성 : 소프트웨어 품질 목표 중 새로운 요구사항에 접하여 쉽게 수정될 수 있는 시스템 능력을 요구하는 것의 정도&lt;/li&gt;
  &lt;li&gt;재사용성&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;소프트웨어-신뢰성&quot;&gt;소프트웨어 신뢰성&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;신뢰성&lt;/strong&gt;(Reliability) : 주어진 시간 동안 주어진 환경에서 프로그램이 &lt;strong&gt;고장 없이 운영될 확률&lt;/strong&gt;을 의미&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;가용성&lt;/strong&gt;(Availability) : 프로그램이 주어진 시점에서 요구사항을 수행하는 확률&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;평균 사용 시간&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTBF&lt;/code&gt; : Mean Time Between Failures)&lt;br /&gt;
고장 수리가 끝난 시간부터 다음 고장이 발생할 때까지의 시간 평균치
    &lt;blockquote&gt;
      &lt;p&gt;$\frac{(사용1 + 사용2 + … + 사용n)}{n}$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;평균 수리 시간&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTTR&lt;/code&gt; : Mean Time to Repair)&lt;br /&gt;
고장이 일어난 시점부터 고장 수리가 완료되는 시점까지의 평균치
    &lt;blockquote&gt;
      &lt;p&gt;$\frac{(고장1 + 고장2 + … + 고장n)}{n}$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;평균 고장 시간&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTTF&lt;/code&gt; : Mean Time To Failures)&lt;br /&gt;
고장이 발생한 시점부터 다음 고장이 발생할 때까지의 평균치
    &lt;blockquote&gt;
      &lt;p&gt;MTBF + MTTR&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;가용도&lt;/strong&gt; : 전체 시간 중에서 설계 가동하여 사용 중인 시간을 의미
    &lt;blockquote&gt;
      &lt;p&gt;$\frac{MTBF}{MTTF}$ = $\frac{MTBF}{MTBF+MTTR}$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;소프트웨어-재사용sw-reuse&quot;&gt;소프트웨어 재사용(S/W Reuse)&lt;/h1&gt;
&lt;p&gt;이미 개발된 소프트웨어를 반복 사용하여 생산성을 향상시키는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;생성 중심&lt;/strong&gt;(Generation Based, 모듈화)&lt;br /&gt;
재사용 단위를 찾아 발전시키는 기술&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;합성 중심&lt;/strong&gt;(Composition Based, 모듈화)&lt;br /&gt;
모듈을 생산성있게 조립하는 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;모듈의 크기는 작을수록 재사용 비율이 높다&lt;/li&gt;
      &lt;li&gt;개발시간과 비용을 단축&lt;/li&gt;
      &lt;li&gt;개발 지식을 공유할 수 있다&lt;/li&gt;
      &lt;li&gt;소프트웨어 품질과 생산성을 향상&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;소프트웨어-재공학sw-re-engineering&quot;&gt;소프트웨어 재공학(S/W Re-Engineering)&lt;/h1&gt;
&lt;p&gt;과거에 사용하던 소프트웨어를 수명 연장을 위해 효과적으로 사용할 수 있도록 접근하는 기술&lt;/p&gt;

&lt;h2 id=&quot;출현-배경&quot;&gt;출현 배경&lt;/h2&gt;
&lt;p&gt;소프트웨어의 위기를 개발의 생산성이 아닌 &lt;strong&gt;유지보수의 생산성&lt;/strong&gt;으로 해결하기 위해 출현&lt;/p&gt;

&lt;p&gt;문서화 하는 과정에서 소프트웨어의 문제점들이 발견되고 이런 문제점을 수정 보완하여 다시금 소프트웨어를 수정하게 된 것이 재공학이 출현된 배경이다&lt;/p&gt;

&lt;p&gt;이미 개발된 소프트웨어를 보고 문서화했으므로 역으로 진행했다하여 역공학의 개념이 출현하였고, 재공학은 역공학 이후에 출현된 기술 개념&lt;/p&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;
&lt;p&gt;기존의 있던 소프트웨어를 &lt;strong&gt;파기하지 않고&lt;/strong&gt; 변경된 사용자의 요구사항이나 수정된 환경으로 &lt;strong&gt;기존 소프트웨어를 수정&lt;/strong&gt;, 보완하여 재구축하는 기술&lt;/p&gt;

&lt;p&gt;노후된 시스템에 대한 재분석/문서화 작업을 통해 공학적으로 우수한 시스템을 만드는 것을 의미&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;재구조화&lt;/strong&gt;(Restructuring) : 재공학의 한 유형으로 사용자의 요구사항이나 기술적인 변경 없이 프로그램을 개선&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;역공학&lt;/strong&gt;(Reverse Engineering) : 기존 소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 &lt;strong&gt;분석 및 설계 정보를 재발견&lt;/strong&gt;하거나 다시 만들어 내는 작업.&lt;br /&gt;
원시 프로그램으로부터 데이터, 아키텍처, 절차에 관한 분석 및 설계 정보를 추출하는 기술&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;코드&lt;/strong&gt;의 역공학 : 소스 코드로부터 &lt;strong&gt;자료 흐름도&lt;/strong&gt;를 추출하고 분석하여 변경&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터&lt;/strong&gt;의 역공학 : 소스 코드로부터 &lt;strong&gt;자료 사전&lt;/strong&gt;을 추출하고 분석하여 변경&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;재공학은 유지보수 중 &lt;strong&gt;예비 조치&lt;/strong&gt;(Preventive)의 문제를 해결하기 위한 학문이다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자동화된 도구&lt;/strong&gt;를 사용하여 소프트웨어를 분석하고 수정하는 과정을 포함&lt;/li&gt;
  &lt;li&gt;재공학 활동은 분석, 재구성, 역공학, 이식 활동 등으로 구분&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;목표&quot;&gt;목표&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;유지보수성, 생산성, 품질&lt;/strong&gt;의 향상이 목적&lt;/li&gt;
  &lt;li&gt;소프트웨어 사용 기간을 연장시키고 비용을 감소시킨다&lt;/li&gt;
  &lt;li&gt;고수준의 추상을 합성할 수 있다&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">소프트웨어 유지보수 소프트웨어가 사용자에게 인수, 설치된 이후에 발생하는 모든 공학적인 작업 활동을 의미</summary></entry><entry><title type="html">[소프트웨어공학] 소프트웨어 검사</title><link href="https://many258.github.io/study/software-engineering-testing/" rel="alternate" type="text/html" title="[소프트웨어공학] 소프트웨어 검사" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-09T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-testing%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-testing/">&lt;h1 id=&quot;검사-관련-용어정의&quot;&gt;검사 관련 용어정의&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;검사&lt;/strong&gt;(Testing)&lt;br /&gt;
오류를 찾는 작업&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;검증&lt;/strong&gt;(Verification)&lt;br /&gt;
개발된 소프트웨어와 사용자의 요구분석 명세서와의 차이를 확인하는 작업&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디버깅&lt;/strong&gt;(Debugging)&lt;br /&gt;
검사로 찾아낸 오류를 수정하는 작업&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;검토 회의&lt;/strong&gt;(Walk-through)&lt;br /&gt;
소프트웨어 생명주기의 단계마다 산출된 명세서를 가지고 다음 단계로 넘어가기 전에 오류를 찾아내는 작업&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;정형 기술 검토&lt;/strong&gt;(FTR)&lt;br /&gt;
소프트웨어에 관련된 여러 사람이 모여 회의하는 정형화된 오류 검토 회의&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;검사방법&quot;&gt;검사방법&lt;/h1&gt;
&lt;h2 id=&quot;화이트-박스-검사&quot;&gt;화이트 박스 검사&lt;/h2&gt;
&lt;p&gt;상자 안을 들여다 볼 수 있다는 뜻으로 &lt;strong&gt;원시 프로그램을 직접 보면서&lt;/strong&gt; 프로그램 상 허용되는 논리적인 모든 경로를 직접 검사하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 모듈의 논리적 구조를 체계적으로 점검하는 구조 검사&lt;/li&gt;
  &lt;li&gt;원시 코드의 모든 문장을 &lt;strong&gt;한 번 이상 수행함&lt;/strong&gt;으로써 진행되는 구조 검사&lt;/li&gt;
  &lt;li&gt;검사 대상의 가능한 경로를 어느 정도 통과하는 지의 적용 범위성을 측정 기준으로 한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램의 제어 구조에 따라 &lt;strong&gt;선택, 반복 등의 부분들을 수행&lt;/strong&gt;함으로써 논리적인 경로를 검사&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;기초 경로 검사&lt;/strong&gt;(Basic Path Testing)&lt;br /&gt;
모든 논리적인 경로를 복잡도로 계산하여 구한 후 경로를 수행할 수 있는 검사 경우를 직접 입력하여 오류를 검출하는 방법
        &lt;blockquote&gt;
          &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오일러의 공식&lt;/code&gt; : V - E + R = 2&lt;br /&gt;
&lt;sub&gt;V: 노드의 수, E: 간선의 수, R:영역의 수&lt;/sub&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;루프 검사&lt;/strong&gt;(Loop Testing)&lt;br /&gt;
반복문 관련 오류 검출&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;데이터 흐름 검사&lt;/strong&gt;(Data Flow Testing)&lt;br /&gt;
제어 흐름 그래프에 데이터 사용 현황(정의, 소멸, 사용)을 테스트&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;조건 검사&lt;/strong&gt;(Condition Testing)&lt;br /&gt;
조건문 관련 오류 검출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;찾을 수 있는 오류
    &lt;ul&gt;
      &lt;li&gt;자세하고 세부적 오류 검출 가능&lt;/li&gt;
      &lt;li&gt;반복문, 참거짓을 판단할 수 있는 논리 구조 상의 오류 검출 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;블랙-박스-검사&quot;&gt;블랙 박스 검사&lt;/h2&gt;
&lt;p&gt;상자 안을 볼 수 없다는 뜻으로 원시 프로그램은 보지 않고 프로그램만 실행시켜 데이터 입력에 대한 결과만을 보고 오류를 판단하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;균등 분할&lt;/strong&gt;(Equivalence Partitioning)&lt;br /&gt;
입력 자료에 초점을 맞춰 검사 사례를 만드는 방법.&lt;br /&gt;
타당한 자료와 타당하지 않은 자료의 개수를 균등하게 하여 정함&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;한계값 분석&lt;/strong&gt;(Boundary Value Analysis)&lt;br /&gt;
입력조건의 중간값에서 보다 &lt;strong&gt;경계값에서 에러가 발생될 확률이 높다&lt;/strong&gt;는 점을 이용하여 이를 실행하는 테스크 케이스를 만드는 방법&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;원인-결과 그래프&lt;/strong&gt;(Cause-Effect Graphing)&lt;br /&gt;
입력 데이터 간의 관계가 출력에 미치는 영향을 그래프로 표현하여 오류 검출&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;오류 예측&lt;/strong&gt;(Error Guessing)&lt;br /&gt;
각 시험기법들이 놓치기 쉬운 오류들을 감각 및 경험으로 찾아보는 것&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;비교 검사&lt;/strong&gt;(Comparison Testing)&lt;br /&gt;
여러 버전의 프로그램에 동일한 검사 자료를 제공하여 동일한 결과가 출력되는 지 비교 및 확인하는 검사&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;페어 와이즈 조합 테스트&lt;/strong&gt;&lt;br /&gt;
모든 가능한 입력 값들의 조합들을 테스트하는 대신에 모든 Pair의 조합을 테스트하는 방법&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;상태 전이 검사&lt;/strong&gt;&lt;br /&gt;
시스템의 상태가 변화함에 따른 검사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비정상적인 자료를 입력해도 오류 처리를 수행하지 않은 경우의 오류 검출 가능&lt;/li&gt;
  &lt;li&gt;정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우의 오류를 검출 가능&lt;/li&gt;
  &lt;li&gt;성능 오류, 자료 구조 상의 오류, 인터페이스, 시작과 종결 상의 오류를 찾을 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;검사-순서&quot;&gt;검사 순서&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;단위(코드) 검사&lt;/li&gt;
  &lt;li&gt;통합(설계) 검사&lt;/li&gt;
  &lt;li&gt;검증(요구사항) 검사&lt;/li&gt;
  &lt;li&gt;시스템 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;단위-검사&quot;&gt;단위 검사&lt;/h2&gt;
&lt;p&gt;원시 프로그램의 모듈을 대상으로 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;화이트 검사&lt;/code&gt;를 실시&lt;/strong&gt;하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인터페이스 검사&lt;/li&gt;
  &lt;li&gt;자료 구조 검사&lt;/li&gt;
  &lt;li&gt;경로 검사&lt;/li&gt;
  &lt;li&gt;오류 처리 검사&lt;/li&gt;
  &lt;li&gt;한계값 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;통합-검사&quot;&gt;통합 검사&lt;/h2&gt;
&lt;p&gt;단위 검사를 성공적으로 실시한 후에 단위별로 &lt;strong&gt;결합하면서 오류를 검출&lt;/strong&gt;하는 방법&lt;/p&gt;

&lt;h3 id=&quot;하향식top-down-통합-검사&quot;&gt;하향식(Top-Down) 통합 검사&lt;/h3&gt;
&lt;p&gt;상위 모듈에서 하위 모듈로 결합하면서 오류를 찾는 방법으로 가짜 모듈(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stub&lt;/code&gt;)이 필요하다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;전체 프로그램을 매번 실행하고 종속적인 모듈은 &lt;strong&gt;가짜 모듈(Stub)로 대치&lt;/strong&gt;한다&lt;/li&gt;
  &lt;li&gt;통합 방법에 따라 가짜 모듈을 &lt;strong&gt;실제 모듈로 대치&lt;/strong&gt;한다&lt;/li&gt;
  &lt;li&gt;각 모듈이 &lt;strong&gt;통합되면 검사&lt;/strong&gt;를 실시&lt;/li&gt;
  &lt;li&gt;통합될 때마다 &lt;strong&gt;회귀 검사&lt;/strong&gt;를 실시&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 전체를 실행하면서 검사 가능&lt;/li&gt;
  &lt;li&gt;중요 모듈을 우선 검사할 때에는 부적합&lt;/li&gt;
  &lt;li&gt;독립적인 구조로 검사할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;상향식bottom-up-통합-검사&quot;&gt;상향식(Bottom-Up) 통합 검사&lt;/h3&gt;
&lt;p&gt;최하위의 모듈부터 상위로 진행하면서 통합하는 방식으로 가짜 모듈은 필요없지만 통합 시에 통합된 클러스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cluster&lt;/code&gt;)를 실행할 수 있는 시험 가동기(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Driver&lt;/code&gt;)가 필요하다&lt;/p&gt;

&lt;p&gt;&lt;sub&gt;
클러스터 : 여러 개의 모듈을 하나로 묶어 놓은 단위&lt;br /&gt;
드라이버 : 임시로 실행시켜 검사해 보기 위한 임시 프로그램 모듈
&lt;/sub&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;낮은 수준의 모듈들을 클러스터로 &lt;strong&gt;결합&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;검사 사례 입/출력을 조정하기 위해 &lt;strong&gt;드라이버&lt;/strong&gt; 작성&lt;/li&gt;
  &lt;li&gt;클러스터 &lt;strong&gt;검사&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;드라이버 제거하고 클러스터를 &lt;strong&gt;상위&lt;/strong&gt;로 결합&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;중요 모듈을 우선 검사할 때 유리&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;혼합식mixed-통합-검사&quot;&gt;혼합식(Mixed) 통합 검사&lt;/h3&gt;
&lt;p&gt;하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 검사하는 방법. &lt;strong&gt;샌드위치식 통합 방식&lt;/strong&gt;이라고도 한다.&lt;/p&gt;

&lt;h2 id=&quot;검증-검사&quot;&gt;검증 검사&lt;/h2&gt;
&lt;p&gt;소프트웨어가 사용자의 &lt;strong&gt;요구사항을 충족시키는가&lt;/strong&gt;에 중점을 두고 검사하는 방법. 요구사항 명세서를 토대로 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블랙 박스 테스트&lt;/code&gt;를 사용&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;형상 검사&lt;/strong&gt; : 소프트웨어 구성요소, 목록, 유지보수를 지원하기 위해 필요한 사항 표현 검사&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;알파 검사&lt;/strong&gt; : 개발자의 장소에서 사용자가 개발자 앞에서 실행하는 검사&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;베타 검사&lt;/strong&gt; : 다수의 사용자를 제한되지 않은 환경에서 프로그램을 사용하게 하고 오류가 발견되면 개발자에게 통보하는 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시스템-검사&quot;&gt;시스템 검사&lt;/h2&gt;
&lt;p&gt;개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 검사&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;확인 검사 : 이해관계가 있는 모든 사람이 참석하여 오류 검출하는 방법&lt;/li&gt;
  &lt;li&gt;보안 검사&lt;/li&gt;
  &lt;li&gt;무결성 검사&lt;/li&gt;
  &lt;li&gt;스트레스 검사&lt;/li&gt;
  &lt;li&gt;부피 검사&lt;/li&gt;
  &lt;li&gt;메모리 검사&lt;/li&gt;
  &lt;li&gt;성능 검사&lt;/li&gt;
  &lt;li&gt;호환성 검사&lt;/li&gt;
  &lt;li&gt;신뢰성 검사&lt;/li&gt;
  &lt;li&gt;회복 검사&lt;/li&gt;
  &lt;li&gt;사용 용이성 검사&lt;/li&gt;
  &lt;li&gt;유지보수 용이성 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정형-기술-검토ftr--formal-technical-review&quot;&gt;정형 기술 검토(FTR : Formal Technical Review)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;목적
    &lt;ul&gt;
      &lt;li&gt;소프트웨어가 요구사항에 일치되는 정도를 확인&lt;/li&gt;
      &lt;li&gt;소프트웨어가 &lt;strong&gt;표준화되었는지 검토&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;정형화된 소프트웨어가 개발되도록 지원&lt;/li&gt;
      &lt;li&gt;프로젝트 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;검토 지침
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;제품 검토의 집중성&lt;/strong&gt; : 수정이 아닌 제품의 검토에 집중&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;사전 준비성&lt;/strong&gt; : 검토를 위한 자료를 사전에 배포하여 검토&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;의제의 제한성&lt;/strong&gt; : 의견을 제한하되 충분히 받아들인다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;안건 고수성&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;논쟁 반박의 제한성&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;문제 공개성&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;참가 인원의 제한성&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;문서성&lt;/strong&gt; : 발견된 오류는 문서화한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;오류-증폭-모형&quot;&gt;오류 증폭 모형&lt;/h2&gt;
&lt;p&gt;소프트웨어 개발 생명주기 중 검사 단계에서 오류를 찾는 것보다 &lt;strong&gt;생명주기의 단계마다 확인하고 검사&lt;/strong&gt;하면 많은 양의 오류 검출 및 수정이 가능하다.&lt;/p&gt;

&lt;p&gt;이러한 방법을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;검토 회의&lt;/code&gt;(Walk-through)라고 하며 검토 회의를 할 경우에 예측할 수 있는 &lt;strong&gt;오류 감소 비율을 이론적으로 정립한 것&lt;/strong&gt;을 &lt;strong&gt;오류 증폭 모델&lt;/strong&gt;이라 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(전달된 오류수 + 오류 증폭수 + 생성된 오류수) X (100% - 오류 제거 비율)&lt;br /&gt;
오류 증폭수 = (이전 단계에서 전달된 오류수 - 전달된 오류 수) X 오류 증폭 비율&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">검사 관련 용어정의 검사(Testing) 오류를 찾는 작업 검증(Verification) 개발된 소프트웨어와 사용자의 요구분석 명세서와의 차이를 확인하는 작업 디버깅(Debugging) 검사로 찾아낸 오류를 수정하는 작업 검토 회의(Walk-through) 소프트웨어 생명주기의 단계마다 산출된 명세서를 가지고 다음 단계로 넘어가기 전에 오류를 찾아내는 작업 정형 기술 검토(FTR) 소프트웨어에 관련된 여러 사람이 모여 회의하는 정형화된 오류 검토 회의</summary></entry><entry><title type="html">[소프트웨어공학] 객체지향 개발 방법론</title><link href="https://many258.github.io/study/software-engineering-object-oriented/" rel="alternate" type="text/html" title="[소프트웨어공학] 객체지향 개발 방법론" /><published>2021-03-24T00:00:00+09:00</published><updated>2021-03-24T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-object-oriented%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-object-oriented/">&lt;h1 id=&quot;객체지향-개발-방법론&quot;&gt;객체지향 개발 방법론&lt;/h1&gt;
&lt;h2 id=&quot;객체지향-방법론의-정의&quot;&gt;객체지향 방법론의 정의&lt;/h2&gt;
&lt;p&gt;현실 세계의 개체(Entity)를 속성(Attribute)과 메소드(Method)가 결합된 형태의 객체(Object)로 표현하는 개념으로 객체간의 메시지 통신을 통해 시스템을 구현하는 개발 방법&lt;/p&gt;

&lt;h2 id=&quot;객체지향-기술의-장점&quot;&gt;객체지향 기술의 장점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;규모가 큰 대형 프로젝트에 적합&lt;/li&gt;
  &lt;li&gt;소프트웨어의 재사용률/확장성/유지보수 향상&lt;/li&gt;
  &lt;li&gt;신속하게 개발이 가능&lt;/li&gt;
  &lt;li&gt;사용자 타입 중심&lt;/li&gt;
  &lt;li&gt;대화식 프로그램 개발에 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체지향-기술의-단점&quot;&gt;객체지향 기술의 단점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;설계의 어려움&lt;/li&gt;
  &lt;li&gt;규모가 크기 때문에 실행속도 저하&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구성요소&quot;&gt;구성요소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;클래스&lt;/strong&gt;(Class)&lt;br /&gt;
같은 종류(또는 문제 해결을 위한)의 집단에 속한 속성(attribute)과 행위(behavior)를 정의한 것&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;객체&lt;/strong&gt;(Object)&lt;br /&gt;
자신 고유의 데이터(attribute)를 가지며 클래스에서 정의한 행위(behavior)를 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인스턴스&lt;/strong&gt;(Instance)&lt;br /&gt;
어떤 클래스에 속하는 구체적인 객체를 의미하며 클래스로 정의된 객체의 요소로 객체의 복사본이라 할 수 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;어트리뷰트&lt;/strong&gt;(Attribute)&lt;br /&gt;
객체 안에 존재하는 절대적 자료형.&lt;br /&gt;
객체에 존재하는 함수들이 동작하게 될 경우 같은 객체에 존재하는 어트리뷰트 값을 변경한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메서드&lt;/strong&gt;(Method)&lt;br /&gt;
객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메시지&lt;/strong&gt;(Message)&lt;br /&gt;
Sender와 Receiver객체들간의 상호작용의 수단으로 다른 객체에 특정 작업을 요청하는 신호&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주요-특징&quot;&gt;주요 특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;캡슐화&lt;/strong&gt;(Encapsulation)&lt;br /&gt;
연관된 속성(데이터)과 메소드(연산)을 하나로 묶어서 객체로 구성&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;추상화&lt;/strong&gt;(Abstraction)&lt;br /&gt;
하위 객체의 공통된 특성을 묘사하기 위한 객체를 추상적인 객체. 이러한 추상적인 객체는 문제 대상의 공통 특성을 추출하여 객체를 정의하기에 유용하고 편리함을 제공한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다형성&lt;/strong&gt;(Polymorphism)&lt;br /&gt;
같은 상위 객체에서 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;정보은닉&lt;/strong&gt;(Information Hiding)&lt;br /&gt;
캡슐화된 객체 내부에 자료 구조나 함수의 기능을 외부의 영향을 받거나 주지 않도록 설계하는 방법&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상속성&lt;/strong&gt;(Inheritance)&lt;br /&gt;
상위클래스가 갖는 속성과 연산을 그대로 물려받는 것을 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체지향-개발-순서&quot;&gt;객체지향 개발 순서&lt;/h2&gt;
&lt;p&gt;전통적인 구조적 개발 순서 구분처럼 단계가 분명하게 구분되지는 않는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;계획&lt;/li&gt;
  &lt;li&gt;분석(OOA)
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;객체&lt;/code&gt; 모델링&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동적&lt;/code&gt; 모델링&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기능&lt;/code&gt; 모델링&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;설계(OOD)
    &lt;ul&gt;
      &lt;li&gt;객체 설계&lt;/li&gt;
      &lt;li&gt;시스템 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구현(OOP)&lt;/li&gt;
  &lt;li&gt;테스트 및 검증
    &lt;ul&gt;
      &lt;li&gt;단위 테스트&lt;/li&gt;
      &lt;li&gt;통합 테스트&lt;/li&gt;
      &lt;li&gt;검증과 시스템 테스팅&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;객체지향-분석ooa--object-oriented-analysis&quot;&gt;객체지향 분석(OOA : Object Oriented Analysis)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;특징&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;문제 영역의 분석 대상을 &lt;strong&gt;형식적인 전략&lt;/strong&gt;으로 기술하는 단계&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;E-R 다이어그램&lt;/strong&gt;은 객체지향 분석의 표기법으로 적합&lt;/li&gt;
      &lt;li&gt;클래스, 객체, 속성, 연산들을 표현해서 문제를 &lt;strong&gt;모형화&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해내는 기법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체지향 분석의 순서(OMT : Object Modeling Technique, 람바우 방법)
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;객체 모델링&lt;/strong&gt;(Object Modeling)&lt;br /&gt;
객체를 찾아내고 객체의 속성, 연산을 식별하는 단계&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;동적 모델링&lt;/strong&gt;(Dynamic Modeling)&lt;br /&gt;
객체 모형들의 행위/상태/조건을 파악하는 단계&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;기능 모델링&lt;/strong&gt;(Functional Modeling)
        &lt;ul&gt;
          &lt;li&gt;입출력 결정&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자료 흐름도&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;객체들의 제어 흐름, 상호 반응 연산 순서를 나타내주는 과정&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;기능의 내용을 상세히 기술&lt;/li&gt;
          &lt;li&gt;제약사항을 결정하고 최소화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;객체지향-설계ood--object-oriented-design&quot;&gt;객체지향 설계(OOD : Object Oriented Design)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;특징&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;문제 영역의 분석 모형을 구체적인 절차로 표현&lt;/li&gt;
      &lt;li&gt;사용자 중심, 대화식 프로그램의 개발에 적합&lt;/li&gt;
      &lt;li&gt;시스템을 구성하는 클래스와 속성, 연산을 인식하여 클래스를 객체로, 속성을 자료 구조로, 연산을 알고리즘으로 표현하는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체지향 설계의 순서
    &lt;ul&gt;
      &lt;li&gt;문제의 정의&lt;/li&gt;
      &lt;li&gt;요구 명세화&lt;/li&gt;
      &lt;li&gt;객체 연산자 정의(객체 설계)&lt;br /&gt;
객체 분석에서 정의된 요구 명세서를 기반으로 객체 연산자를 정의하여 설계&lt;/li&gt;
      &lt;li&gt;객체 인터페이스 결정(시스템 설계)&lt;br /&gt;
객체 설계 단계에서 정의된 객체 간의 인터페이스를 정하여 전체적인 시스템을 설계&lt;br /&gt;
데이터, 자원 관리 방법을 결정&lt;br /&gt;
객체는 순차적으로 또는 동시적으로 제어할지를 결정&lt;/li&gt;
      &lt;li&gt;객체 구현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체지향 설계의 계층
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Responsibilities&lt;/strong&gt; Layer&lt;br /&gt;
속성과 연산들에 대한 메타 데이터와 알고리즘을 표현&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Message&lt;/strong&gt; Layer&lt;br /&gt;
객체와 객체 간의 인터페이스를 표현&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Class &amp;amp; Object&lt;/strong&gt; Layer&lt;br /&gt;
전체 객체를 구체적으로 표현&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Subsystem&lt;/strong&gt; Layer&lt;br /&gt;
요구사항을 지원하는 기술적인 기반 구조를 구현&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;객체지향-테스트&quot;&gt;객체지향 테스트&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;쓰레드 기반 테스트(Thread-Based Testing)&lt;br /&gt;
시스템에 대한 하나의 입력이나 이벤트에 응답하는데 요구되는 클래스들의 집합을 통합(구조적 검사 기법의 &lt;strong&gt;하향식 통합 검사&lt;/strong&gt; 방법과 유사)&lt;/li&gt;
  &lt;li&gt;사용-기반 테스트(Use-Based Testing)&lt;br /&gt;
상위 클래스와 관계를 갖지 않는 수준에서 클래스들을 독립적으로 검사한 후 상위 클래스와 결합(구조적 검사 기법의 &lt;strong&gt;상향식 통합 방법&lt;/strong&gt;과 유사)&lt;/li&gt;
  &lt;li&gt;검증과 시스템 테스트&lt;br /&gt;
사용자의 요구가 객체에 정확히 반영되었는지, 성능이나 인터페이스상 오류는 없는지 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체지향-분석-방법론의-종류&quot;&gt;객체지향 분석 방법론의 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;람바우(Rumbaugh) Method&lt;/strong&gt;&lt;br /&gt;
객체 모형, 동적 모형, 기능 모형으로 분리하여 접근하는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;E-R 다이어그램&lt;/strong&gt;&lt;br /&gt;
데이터 구조들과 그들 간의 관계를 표현하고 객체 모형을 만드는 방법론&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Booch Method&lt;/strong&gt;&lt;br /&gt;
미시적 개발 프로세스, 거시적 개발 프로세스로 접근하는 방법.&lt;br /&gt;
각 작업에 대한 다이어그램, 클래스 계층 정의, 클래스들의 클러스터링 작업 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Coad &amp;amp; Yourdon Method&lt;/strong&gt;&lt;br /&gt;
E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성되는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jacobson Method&lt;/strong&gt;&lt;br /&gt;
사용자가 제품 또는 시스템과 어떻게 상호 작용하는지를 서술한 시나리오로 접근&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Wirfs-Brocks Method&lt;/strong&gt;&lt;br /&gt;
분석과 설계 프로세스 간에 뚜렷한 구분이 없고, 고객 명세의 평가로 시작하여 설계로 끝나는 연속적인 프로세스로 접근한 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><category term="(구)정보처리기사" /><summary type="html">객체지향 개발 방법론 객체지향 방법론의 정의 현실 세계의 개체(Entity)를 속성(Attribute)과 메소드(Method)가 결합된 형태의 객체(Object)로 표현하는 개념으로 객체간의 메시지 통신을 통해 시스템을 구현하는 개발 방법</summary></entry><entry><title type="html">[소프트웨어공학] 비용 산정 방법론</title><link href="https://many258.github.io/study/software-engineering-cost-model/" rel="alternate" type="text/html" title="[소프트웨어공학] 비용 산정 방법론" /><published>2021-03-24T00:00:00+09:00</published><updated>2021-03-24T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-cost-model%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-cost-model/">&lt;h1 id=&quot;소프트웨어-개발비용-산정기법&quot;&gt;소프트웨어 개발비용 산정기법&lt;/h1&gt;

&lt;h2 id=&quot;상향식&quot;&gt;상향식&lt;/h2&gt;
&lt;p&gt;단계별로 측정한 결과들을 모아서 총비용을 측정하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LOC 기법 (원시 코드 라인 수 : Line Of Code)&lt;br /&gt;
프로젝트의 각 기능별 라인 수를 측정(&lt;strong&gt;비관치, 기대치, 낙관치&lt;/strong&gt;)하여 비용을 산정하는 방법
    &lt;ul&gt;
      &lt;li&gt;비관치 : 기능을 코딩할 때, 가장 많이 측정된 라인 수&lt;/li&gt;
      &lt;li&gt;기대치 : 기능을 코딩할 때, 제시한 측정된 라인 수의 평균&lt;/li&gt;
      &lt;li&gt;낙관치 : 기능을 코딩할 때, 가장 적게 측정된 라인 수&lt;/li&gt;
      &lt;li&gt;예측치 : $\frac{(비관치 + 4 \cdot 기대치 + 낙관치)}{6}$&lt;/li&gt;
      &lt;li&gt;평방 편차 : $({\frac{(비관치-낙관치)}6})^2$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개발 단계별 인월 수 방법&lt;br /&gt;
LOC 기법을 보완하기 위한 방법으로, 각 기능을 구현시키는데 필요한 노력을 생명주기의 각 단계별로 산정&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;수학적-산정-기법&quot;&gt;수학적 산정 기법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Walston Felix 모형&lt;/strong&gt;&lt;br /&gt;
60여 개 개발 업체의 다양한 규모의 프로젝트 비용 측정 자료를 모아 통계적으로 분석한 &lt;strong&gt;공식&lt;/strong&gt;으로 개발 비용을 측정하는 방법&lt;br /&gt;
인월 수를 계산하는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KDSI&lt;/code&gt;(원시코드에서 주석라인, 라이브러리 루틴, 공백을 제외한 실제 수행 코드 라인 수)를 사용한다
    &lt;ul&gt;
      &lt;li&gt;COCOMO 비용 산정 공식의 모체이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;COCOMO&lt;/strong&gt;(COnstructive COst MOdel)&lt;br /&gt;
Boehm이 제시한 원시 프로그램의 규모에 의한 비용 예측 모형
변화 모형과 규모 유형이 존재한다
    &lt;ul&gt;
      &lt;li&gt;변화 모형
        &lt;ul&gt;
          &lt;li&gt;Basic : S/W 크기 + 개발 유형&lt;/li&gt;
          &lt;li&gt;Intermediate : Basic Model + 가중치&lt;/li&gt;
          &lt;li&gt;Detailed : Intermediate Model + 시스템 세분화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;규모 모형
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;Organic&lt;/strong&gt;(유기형)
            &lt;blockquote&gt;
              &lt;p&gt;인월(MM) = $2.4 \times [KDSI]^{1.05}$&lt;br /&gt;
개발기간(TDEV) = $2.5 \times [KDSI]^{0.38}$&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Semi-detached&lt;/strong&gt;(준 분리형)
            &lt;blockquote&gt;
              &lt;p&gt;인월(MM) = $3.0 \times [KDSI]^{1.12}$&lt;br /&gt;
개발기간(TDEV) = $2.5 \times [KDSI]^{0.35}$&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Embedded&lt;/strong&gt;(내재형)
            &lt;blockquote&gt;
              &lt;p&gt;인월(MM) = $3.6 \times [KDSI]^{1.20}$&lt;br /&gt;
개발기간(TDEV) = $2.5 \times [KDSI]^{0.32}$&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PUTNAM&lt;/strong&gt;&lt;br /&gt;
시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 한다&lt;br /&gt;
개발 기간이 연장될수록 프로젝트 적용 인원의 노력이 감소하므로 &lt;strong&gt;대형 프로젝트&lt;/strong&gt;의 노력 분포 산정으로 적당&lt;br /&gt;
Putnam 모형을 기초로 해서 만든 자동화 추정 도구는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SLIM&lt;/code&gt;이다&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;MM = $\frac{DSI^3}{[개발 기술 지수]^3 \times [개발 기간]^4\frac{3}{4}}$&lt;br /&gt;
LOC =  $[개발 기술 지수] \times[총인월]^{\frac{1}{3}} \times [개발 기간]^{\frac{3}{4}}$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Albrecht&lt;/strong&gt; 모형(&lt;strong&gt;기능점수, FP&lt;/strong&gt;)&lt;br /&gt;
프로젝트를 기능 별로 &lt;strong&gt;분해&lt;/strong&gt;하고 경험을 바탕으로 단순/보통/복잡한 정도에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가중치&lt;/code&gt;를 부여&lt;br /&gt;
요인별 가중치를 합산하여 총 기능점수 산출&lt;br /&gt;
총 기능점수와 영향도를 이용하여 실질 기능 점수를 구한 후 최종 비용 산정&lt;br /&gt;
FP 모형을 기초로 하여 개발된 자동화 도구는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESTIMACS&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;실질 기능 점수(FP) = $총기능점수 \times [0.65+ (0.1 \times 총영향도)]$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;하향식&quot;&gt;하향식&lt;/h2&gt;
&lt;p&gt;프로젝트의 총비용을 측정한 후 단계별로 비용을 세분화하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전문가 감정 기법
    &lt;ul&gt;
      &lt;li&gt;조직 내 경험이 많은 두명 이상의 전문가에게 비용산정 의뢰&lt;/li&gt;
      &lt;li&gt;의뢰자로부터 신뢰를 얻을 수 있다&lt;/li&gt;
      &lt;li&gt;새로운 프로젝트와 유사한 프로젝트에 대한 경험이 없을 수 있고 개인직이고 주관적일 가능성이 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;델파이 기법
    &lt;ul&gt;
      &lt;li&gt;많은 전문가의 의견을 종합 후 산정하는 방법으로 전문가 감정 기법의 단점을 보완&lt;/li&gt;
      &lt;li&gt;전문가들의 의견을 중재하는 중재자가 반드시 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">소프트웨어 개발비용 산정기법</summary></entry><entry><title type="html">[소프트웨어공학] 소프트웨어 설계</title><link href="https://many258.github.io/study/software-engineering-sw-design/" rel="alternate" type="text/html" title="[소프트웨어공학] 소프트웨어 설계" /><published>2021-03-23T00:00:00+09:00</published><updated>2021-03-23T23:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-sw-design%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-sw-design/">&lt;h1 id=&quot;설계의-기본-개념&quot;&gt;설계의 기본 개념&lt;/h1&gt;
&lt;h2 id=&quot;소프트웨어-설계-절차&quot;&gt;소프트웨어 설계 절차&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DFD, DD 분석&lt;/li&gt;
  &lt;li&gt;외부 설계&lt;br /&gt;
파일 설계, 입출력 설계 등 S/W의 내적인 기능보다는 외부적은 특성을 설계&lt;/li&gt;
  &lt;li&gt;내부 설계(기본설계)&lt;br /&gt;
S/W의 내부 설계이며 주로 모듈의 기능을 정의하거나 모듈 간의 관계를 정의하는 설계&lt;/li&gt;
  &lt;li&gt;내부 설계(상세설계)&lt;br /&gt;
모듈 내부의 알고리즘을 정의&lt;/li&gt;
  &lt;li&gt;설계 명세서&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;설계-모형&quot;&gt;설계 모형&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;문서량 기준
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;데이터(Data) 설계&lt;br /&gt;
요구분석의 자료 사전(DD, 메타 데이터)을 분석&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;구조(Architectural) 설계&lt;br /&gt;
구조도 작성(외부 설계)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;관계(Interface) 설계&lt;br /&gt;
모듈 간의 관계를 표현(기본 설계)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;절차(Procedure) 설계&lt;br /&gt;
PDL로 알고리즘을 작성(상세 설계)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;노력 기준
    &lt;ul&gt;
      &lt;li&gt;절차 설계&lt;/li&gt;
      &lt;li&gt;관계 설계&lt;/li&gt;
      &lt;li&gt;구조 설계&lt;/li&gt;
      &lt;li&gt;데이터 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;설계의-종류&quot;&gt;설계의 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;상위 설계(High-Level Design) : 아키텍처/예비 설계, 하위 설계를 위한 바탕
    &lt;ul&gt;
      &lt;li&gt;구조 설계&lt;/li&gt;
      &lt;li&gt;DB 설계&lt;/li&gt;
      &lt;li&gt;인터페이스 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하위 설계(Low-Level Design) : 시스템 수준에서의 소프트웨어 구성 컴포넌트 간의 관계
    &lt;ul&gt;
      &lt;li&gt;컴포넌트 설계&lt;/li&gt;
      &lt;li&gt;자료구조 설계&lt;/li&gt;
      &lt;li&gt;알고리즘 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구조적-설계의-원칙&quot;&gt;구조적 설계의 원칙&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;모듈화(Modularization)&lt;/strong&gt;&lt;br /&gt;
단일 기능을 갖출 수 있도록 부분적으로 묶어서 처리하는 기술&lt;br /&gt;
단위 프로그램, 함수, 서브 프로그램을 작성하기 위한 설계 기법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;추상화(Abstraction)&lt;/strong&gt;&lt;br /&gt;
세부적은 설계를 배제하고 전체 흐름과 구조를 알아볼 수 있도록 개관적인 설계부터 점차 세부적으로 진행하는 설계 기법
    &lt;ul&gt;
      &lt;li&gt;기능 추상화 : 수행의 흐름만을 정의&lt;/li&gt;
      &lt;li&gt;제어 추상화 : 선택, 반복, 분기 등의 설계를 추상화&lt;/li&gt;
      &lt;li&gt;자료 추상화 : 변수 및 레코드 등을 추상화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구조화(Structured)&lt;/strong&gt;&lt;br /&gt;
모듈을 수행하기 위한 위치나 시기를 전체 구조에 적절하게 배치시키는 설계 기법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;정보 은닉(Information Hiding)&lt;/strong&gt;&lt;br /&gt;
모듈 간의 관계성을 최소화시키는 설계 기법.(S/W 변경 용이)&lt;br /&gt;
설계상의 결정 사항들이 각 모듈 안에 숨겨져 있어 다른 모듈이 접근하거나 변경을 못한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;분할과 정복&lt;/strong&gt;&lt;br /&gt;
Bottom-Up 방식으로 작은 시스템을 개발하고, 이를 합쳐 큰 시스템을 만든다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단계적 분해&lt;/strong&gt;&lt;br /&gt;
하향식 설계에서 사용. 문제를 상위 수준에서 점증적으로 더 구체적인 하위 수준으로 분할하는 기법
    &lt;ul&gt;
      &lt;li&gt;문제를 하위 수준의 독립된 단위로 나눈다&lt;/li&gt;
      &lt;li&gt;구분된 문제의 자세한 내용은 가능한 뒤로 미룬다&lt;/li&gt;
      &lt;li&gt;점증적으로 구체화 작업을 계속한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;좋은-설계&quot;&gt;좋은 설계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;요구사항을 모두 표현(완전성)&lt;/li&gt;
  &lt;li&gt;유지보수하기 쉽고(변경이 용이) 가독성이 좋고 객관성 있게 작성&lt;/li&gt;
  &lt;li&gt;구현 관점에서 데이터/기능/행위 영역을 설명하는 완전한 그림을 제공&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모듈적이어야 하며, 두 모듈 간의 상호 의존도는 약하게 해야 한다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모듈화&quot;&gt;모듈화&lt;/h1&gt;
&lt;h2 id=&quot;모듈의-특징&quot;&gt;모듈의 특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;구현, 컴파일, 설계는 독립적으로 수행, 실행은 종속적으로 수행&lt;/li&gt;
  &lt;li&gt;다른 모듈을 호출할 수도, 호출당할 수 있다&lt;/li&gt;
  &lt;li&gt;모듈 호출 시 매개변수를 전달하거나 전달받을 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;모듈화의-장점&quot;&gt;모듈화의 장점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;단위 프로그램을 독립적으로 설계할 수 있기 때문에 설계가 용이&lt;/li&gt;
  &lt;li&gt;모듈만을 구분하면 되므로 프로그램의 복잡도를 감소&lt;/li&gt;
  &lt;li&gt;다른 모듈에 영향을 주지 않을 수 있으므로 수정이 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;공유도--제어도&quot;&gt;공유도 / 제어도&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;공유도(Fan-in)
얼마나 많은 모듈이 주어진 모듈을 호출하는가를 나타내는 척도.&lt;/li&gt;
  &lt;li&gt;제어도(Fan-out)
주어진 모듈이 호출하는 모듈의 개수&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모듈의-응집력cohesion&quot;&gt;모듈의 응집력(Cohesion)&lt;/h1&gt;
&lt;p&gt;모듈 안의 요소들이 서로 관련되어 있는 정도로 강할수록 좋은 설계(좋은 설계 순서)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;기능적(Functional)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부가 하나의 단일 기능으로 존재하는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;순차적(Sequential)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 이전의 명령어로부터 나온 출력 결과를 그 다음 명령어의 입력자료로 사용하는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;교환적(Communication)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 작업 대상이 같은 기능끼리 존재하는 경우나 동일한 입력과 출력을 사용하는 작업들이 모인 경우&lt;br /&gt;
예시) 하나의 파일을 대상으로 갱신 작업을 하는 루틴끼리 묶인 루틴&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;절차적(Procedural)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 수행 시기에 순위가 있는 기능끼리 존재하는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;시간적(Temporal)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 시간상으로 수행 시기가 같은 기능끼리 존재&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;논리적(Logical)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 같은 범주에 속하는 기능끼리 묶은 모듈.&lt;br /&gt;
유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 하나의 모듈로 형성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;우연적(Coincidental)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 뚜렷한 관계없이 묶인 경우&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모듈의-결합도coupling&quot;&gt;모듈의 결합도(Coupling)&lt;/h1&gt;
&lt;p&gt;두 모듈 간의 관계성(상호 의존성)의 척도로, 약할수록 좋은 설계(좋은 설계 순서)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;자료(Data)&lt;/strong&gt; 결합도&lt;br /&gt;
두 모듈 간의 인터페이스가 자료 요소만으로 구성된 결합도&lt;br /&gt;
Call By Value 기법으로 결합된 모듈&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구조(Stamp)&lt;/strong&gt; 결합도&lt;br /&gt;
두 모듈 간의 인터페이스로 배열이나 레코드같은 자료 구조가 전달&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제어(Control)&lt;/strong&gt; 결합도&lt;br /&gt;
호출 모듈에서 전달된 자료에 의해서 운용되는 피 호출 모듈의 관계(종속적인 관계)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;외부(Extern)&lt;/strong&gt; 결합도&lt;br /&gt;
외부 변수에 의해 영향을 받는 두 모듈이 결합된 관계. 전역 변수 관련&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;공통(Common)&lt;/strong&gt; 결합도&lt;br /&gt;
공유되는 공통 데이터 영역을 여러 모듈이 사용하는 모듈 관계.&lt;br /&gt;
Call By Referrence, 메모리 번지의 공유&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;내용(Content)&lt;/strong&gt; 결합도&lt;br /&gt;
모듈이 다른 모듈 내부 기능 및 그 내부 자료를 참조하는 형태의 결합&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;구조적-설계-표기법&quot;&gt;구조적 설계 표기법&lt;/h1&gt;
&lt;h2 id=&quot;n-snassi-schneiderman-chart&quot;&gt;N-S(Nassi-Schneiderman) Chart&lt;/h2&gt;
&lt;p&gt;IBM사에 의해 개발되었으며 입출력 자료와 소프트웨어 모듈들 사이의 관계를 표현하는 뛰어난 능력을 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;고려사항
    &lt;ul&gt;
      &lt;li&gt;도표는 항상 직사각형&lt;/li&gt;
      &lt;li&gt;도표의 제어 흐름은 맨 위에서 시작&lt;/li&gt;
      &lt;li&gt;제어 흐름은 위에서 아래로 흐른다(하향식)&lt;/li&gt;
      &lt;li&gt;수평으로 그어진 줄은 모두 평행이 되어야 한다&lt;/li&gt;
      &lt;li&gt;사각형 안의 내용이 수행된 후에는 아래 방향으로 빠져나온다&lt;/li&gt;
      &lt;li&gt;사각형에 빈 공간이 있을 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/sw-engineering/n-s-chart.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;논리적 기술에 중점을 둔 도형을 이용한 표현 방법&lt;/li&gt;
      &lt;li&gt;연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현&lt;/li&gt;
      &lt;li&gt;임의의 제어 이동이 어렵다&lt;/li&gt;
      &lt;li&gt;상자 도표라고도 하며 프로그램으로 구현이 쉽다&lt;/li&gt;
      &lt;li&gt;조건이 복합된 곳의 처리를 시각적으로 명확히 식별하는데 적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hipohierarchy-plus-input-process-output&quot;&gt;HIPO(Hierarchy plus Input Process Output)&lt;/h2&gt;
&lt;p&gt;IBM에서 개발한 방법으로 프로그램을 기능 위주로 문서화하는 하향식 설계 기법.&lt;/p&gt;

&lt;p&gt;입력/처리/출력으로 구성되어 시각적으로 알아보기 쉽게 표현할 수 있으며 구조화된 방법으로 구현될 수 있도록 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;도식 목차(가시적 도표, Visual Table of Contents)&lt;br /&gt;
전체적인 흐름과 구조를 나타내는 도표&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;총괄 도표(총체적 도표, Overview Diagram)&lt;br /&gt;
입력/처리/출력 등의 기능을 명확히 표현한 도표(&lt;strong&gt;사용자관점&lt;/strong&gt;)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;상세 도표(세부적 도표, Detail Diagram)&lt;br /&gt;
총괄 도표의 일부 기능을 구체적으로 표현한 모듈 도표(&lt;strong&gt;개발자관점&lt;/strong&gt;)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;분석 및 설계 도구로 사용&lt;/li&gt;
      &lt;li&gt;하향식(Top-Down) 개발에 적당&lt;/li&gt;
      &lt;li&gt;수정 및 유지보수가 용이&lt;/li&gt;
      &lt;li&gt;소규모 프로젝트에 적합&lt;/li&gt;
      &lt;li&gt;기능과 자료의 관계를 동시에 표현할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;설계-방법론&quot;&gt;설계 방법론&lt;/h1&gt;
&lt;h2 id=&quot;구조적-설계-방법론&quot;&gt;구조적 설계 방법론&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기본구조
    &lt;ul&gt;
      &lt;li&gt;순차(Sequence) 구조&lt;/li&gt;
      &lt;li&gt;선택(Condition) 구조&lt;/li&gt;
      &lt;li&gt;반복(Repetition) 구조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;단일 입출력으로 처리&lt;/li&gt;
      &lt;li&gt;실행 효율성을 중시할 때 한정된 범위 내에서 GOTO문을 사용&lt;/li&gt;
      &lt;li&gt;프로그램의 이해가 쉽고 유지보수와 검증이 용이&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자료-흐름-중심-설계-방법론&quot;&gt;자료 흐름 중심 설계 방법론&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;자료 흐름 설계 과정
    &lt;ul&gt;
      &lt;li&gt;정보 &lt;strong&gt;흐름의 유형&lt;/strong&gt;을 설정&lt;/li&gt;
      &lt;li&gt;흐름의 &lt;strong&gt;경계&lt;/strong&gt;(Flow Boundaries)를 표시&lt;/li&gt;
      &lt;li&gt;자료 흐름도를 프로그램 구조로 &lt;strong&gt;사상&lt;/strong&gt; → &lt;strong&gt;변환 사상&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;제어 계층을 분해&lt;/strong&gt;시켜서 정의&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;경험적 방법&lt;/strong&gt;을 구체화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;변환 사상(Transform Mapping)&lt;/strong&gt;&lt;br /&gt;
변환 흐름에 특성을 갖는 &lt;strong&gt;DFD(Data Flow Diagram)&lt;/strong&gt; 을 전체 혹은 일부를 분할해서 &lt;strong&gt;구조도&lt;/strong&gt;로 변화하는 작업&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자료-구조-중심-설계-방법론&quot;&gt;자료 구조 중심 설계 방법론&lt;/h2&gt;
&lt;p&gt;입출력 자료의 구조 파악으로 소프트웨어 구조를 추출&lt;/p&gt;

&lt;h3 id=&quot;dssd-방법론-warnier-orr-기법&quot;&gt;DSSD 방법론 (Warnier-Orr 기법)&lt;/h3&gt;
&lt;p&gt;Warnier가 개발한 LCP(Logical of Program)를 Orr와 공동으로 개발한 자료 구조 지향 설계 방법으로 출력 자료를 중심으로 입력 자료를 설계하고 제어 구조도 설계하는 방법&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;출력 자료 정의 : 출력할 자료를 파악하여 배열&lt;/li&gt;
  &lt;li&gt;논리적 레코드 정의 : 출력할 레코드의 구조를 정의&lt;/li&gt;
  &lt;li&gt;사건 분석 : 출력할 레코드 항목을 기준으로 입력 항목을 정의&lt;/li&gt;
  &lt;li&gt;물리적 레코드 정의 : 입력할 레코드의 구조를 정의&lt;/li&gt;
  &lt;li&gt;논리적 절차 정의 : 입력/처리/출력 모듈로 구분하여 Warnier-Orr 도표를 그림&lt;/li&gt;
  &lt;li&gt;물리적 절차 정의 : 명시된 도표를 보고 알고리즘 기술&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;jsd-방법론-jackson-기법&quot;&gt;JSD 방법론 (Jackson 기법)&lt;/h3&gt;
&lt;p&gt;프로그램의 입력과 출력 자료의 구조를 대응시켜서 설계하는 자료 구조 지향 설계 방법론으로 자료 구조를 정의하면서 제어 구조를 유도하는 방식&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;자료 구조 정의&lt;br /&gt;
입출력 구조를 정의하여 일치되지 않는 부분을 처리 루틴으로 모듈화하고 일치하는 부분은 입력과 출력 루틴으로 모듈화&lt;/li&gt;
  &lt;li&gt;구조도 작성&lt;br /&gt;
입력/처리/출력으로 분류하여 잭슨 표기법으로 구조도를 세분화하여 작성&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;연산 목록 작성&lt;br /&gt;
  구조도를 보고 필요한 제어 구조 명시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;구조문 작성&lt;br /&gt;
  명시된 제어 구조를 보고 알고리즘 기술&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;소프트웨어-설계-solid-원칙&quot;&gt;소프트웨어 설계 SOLID 원칙&lt;/h1&gt;
&lt;h2 id=&quot;single-responsibility-priciple단일-책임-원칙--srp&quot;&gt;Single Responsibility Priciple(단일 책임 원칙 : SRP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;소프트웨어의 설계 부품은 반드시 한 개의 책임을 가져야 한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;책임 대신 기능이라 해석해도 무방하다.&lt;/p&gt;

&lt;h2 id=&quot;open-closed-principle개방-폐쇠-원칙--ocp&quot;&gt;Open-Closed Principle(개방 폐쇠 원칙 : OCP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;한 번 설계가 되고 단위 테스트가 완료된 객체는 향후 외부에 변경 사항이 발생하더라도 객체 자체는 변경되지 않아야 한다는 것을 의미&lt;/p&gt;

&lt;h2 id=&quot;liskov-substitution-principle리스코프-치환-원칙--lsp&quot;&gt;Liskov Substitution Principle(리스코프 치환 원칙 : LSP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;자식 클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MIT 컴퓨터 사이언스 교수인 리스코프가 제안한 설계 원칙으로 상속관계에 있는 두 객체에 있어서 부모 클래스의 인스턴스가 사용된 자리에 자식 클래스의 인스턴스를 넣어도 &lt;strong&gt;코드의 맥락이 변하지 않아야&lt;/strong&gt; 한다는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;자식 클래스가 부모 클래스를 대체하기 위해서는 부모의 기능에 대해 오버라이드되지 않도록 하면 된다. 즉, 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않과 &lt;strong&gt;확장만 수행&lt;/strong&gt;하도록 해야 LSP를 만족하게 된다.&lt;/p&gt;

&lt;p&gt;LSP의 만족 여부는 [자식 클래스 &lt;strong&gt;is a kind of&lt;/strong&gt; 부모 클래스]의 참/거짓으로 간단히 파악이 가능&lt;/p&gt;

&lt;h2 id=&quot;interface-segregation-principle인터페이스-분리-원칙--isp&quot;&gt;Interface Segregation Principle(인터페이스 분리 원칙 : ISP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;객체 자신이 사용하지 않을 인터페이스는 구현하면 안된다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 자신이 &lt;strong&gt;사용하지 않는 기능에는 영향을 받지 말아야 한다&lt;/strong&gt;는 것을 의미한다&lt;/p&gt;

&lt;p&gt;가능한 경우라면, 범용 인터페이스를 구현하는 것보다 객체에 &lt;strong&gt;특화된 인터페이스를 분리&lt;/strong&gt;해내어 구현한다.&lt;/p&gt;

&lt;h2 id=&quot;dependency-inversion-principle의존-역전-원칙--dip&quot;&gt;Dependency Inversion Principle(의존 역전 원칙 : DIP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;의존 관계를 맺을 때, 변화하기 쉬운 것(구체화)보다 변화하기 어려운 것(추상화)에 의존해야 한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;구체적인 클래스보다 &lt;strong&gt;추상성이 높은 인터페이스나 추상클래스와 관계&lt;/strong&gt;를 맺는다는 것을 의미. 일반적으로 Interface를 활용 시 이 원칙을 준수할 수 있다.&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">설계의 기본 개념 소프트웨어 설계 절차 DFD, DD 분석 외부 설계 파일 설계, 입출력 설계 등 S/W의 내적인 기능보다는 외부적은 특성을 설계 내부 설계(기본설계) S/W의 내부 설계이며 주로 모듈의 기능을 정의하거나 모듈 간의 관계를 정의하는 설계 내부 설계(상세설계) 모듈 내부의 알고리즘을 정의 설계 명세서 설계 모형 문서량 기준 데이터(Data) 설계 요구분석의 자료 사전(DD, 메타 데이터)을 분석</summary></entry><entry><title type="html">[데이터보안] 재해복구시스템(DRS:Disater Recovery System)</title><link href="https://many258.github.io/study/disaster-recovery-system/" rel="alternate" type="text/html" title="[데이터보안] 재해복구시스템(DRS:Disater Recovery System)" /><published>2021-03-22T00:00:00+09:00</published><updated>2021-03-22T20:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdisaster-recovery-system%7D</id><content type="html" xml:base="https://many258.github.io/study/disaster-recovery-system/">&lt;h1 id=&quot;재해복구시스템drs--disaster-recovery-system&quot;&gt;재해복구시스템(DRS : Disaster Recovery System)&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/DRS/disaster-recovery-system-intro.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;천재지변이나 해킹 등 각종 재난/재해로 인해 IT 인프라에 장애가 발생하여 제 기능을 수행하지 못하게 되었을 경우, 서비스 연속성을 보장하기 위해 이를 대체하거나 복구하여 제 기능을 수행할 수 있도록 하는 시스템&lt;/p&gt;

&lt;p&gt;재해복구 대책에 대한 법적인 규제 추세(금융감독원 권고안 발표)이다&lt;/p&gt;

&lt;h2 id=&quot;구성-요소&quot;&gt;구성 요소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;BIA(Business Impact Analysis)&lt;br /&gt;
재해가 비지니스에 영향을 미치는 정도를 분석하는 작업&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DOMAIN&lt;br /&gt;
영향도 별 그룹화(복구 우선순위 별 그룹화)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RTO(Recovery Time Object)&lt;br /&gt;
재해 상황에서 서비스가 복구되어야 할 최대 시간&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RPO(Recovery Point Objective)&lt;br /&gt;
재해 상황에서 수용할 수 있는 최대 허용 데이터 손실&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DR 센터 선정&lt;br /&gt;
주 센터와 복구 센터 위치 선정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;백업 방안&lt;br /&gt;
Hot Standby, DB Shadowing, 원격 백업, OS 백업, 단순백업&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;운영 방안&lt;br /&gt;
조직체계, 평상시/재해시 운영절차, 모의 훈련 절차&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기술적-요소&quot;&gt;기술적 요소&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/images/security/DRS/disaster-recovery-system.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;HA&lt;/strong&gt;(&lt;strong&gt;고가용성&lt;/strong&gt; : High Availability)&lt;br /&gt;
서버와 네트워크 등의 정보 시스템이 지속적으로 정상 운영이 가능한 성질&lt;br /&gt;
2개의 서버 중 1대의 서버에서 장애가 발생하면 다른 서버가 대처&lt;br /&gt;
레이드(RAID) 방식과 샌(SAN) 방식을 주로 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;결함 허용&lt;/strong&gt;(FT)&lt;br /&gt;
시스템을 구성하는 푸품의 일부에서 결함(Fault) 또는 고장(Failure)이 발생하여도 정상적 혹은 부분적으로 기능을 수행할 수 있는 시스템&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SAN&lt;/strong&gt;(Storage Area Network)&lt;br /&gt;
대량의 데이터를 집중시켜 보관하고 이를 구성하는 장비들을 이용, 공유하여 사용할 수 있도록 하는 기술.&lt;br /&gt;
다만, 별도의 Fibre Channel 네트워크를 구성해야 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IP-SAN&lt;/strong&gt;&lt;br /&gt;
기존의 TCP/IP 망을 그대로 이용하여 별도의 Fibre Channel 네트워크를 구성해야하는 기존 SAN의 단점을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보완&lt;/code&gt;, 속도는 크게 떨어지지 않는 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fibre Channel&lt;/strong&gt;(파이버 채널 : FC)&lt;br /&gt;
주로 스토리지 네트워킹에 쓰이는 기가 비트 속도의 네트워크 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;WDM&lt;/strong&gt;(파장 분할 다중화 :Wavelength Division Multiplexing)&lt;br /&gt;
한 가닥의 광섬유에 여러 채널을 통해 파장을 동시에 전송하는 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DWDM&lt;/strong&gt;(Dense WDM)&lt;br /&gt;
일정 파장 대역에 걸쳐  수십, 수백개의 파장의 광 신호를 동시에 변조시켜서 하나의 광섬유를 통해 전송하는 WDM의 발전된 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CWDM&lt;/strong&gt;(Coarse WDM)&lt;br /&gt;
DWDM과 유사하나, 파장 간격이 보다 넓고(~10nm 이상) 광증폭기를 잘 사용하지 않는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단거리&lt;/code&gt; 전송에 주로 사용&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;재해복구-구축-절차&quot;&gt;재해복구 구축 절차&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;업무 영향 분석&lt;br /&gt;
&lt;strong&gt;BIA, DOMAIN, RTO, RPO&lt;/strong&gt; 등의 적용과정&lt;br /&gt;
재해로 인한 핵심 프로그램 들의 가동 중단 시 파급영향 분석 및 그에 따른 복구 우선순위를 설정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;재해복구 전략 수립&lt;br /&gt;
대상 별 복구 전략, 복구 솔루션 선전 및 재해복구센터 선정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;시스템 구축 및 복구 계획 수립&lt;br /&gt;
재해복구 시스템 구축 및 업무와 전산시스템의 복구를 위한 상세 계획 수립&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;운영 및 모의 훈련&lt;br /&gt;
수립된 계획의 주기적 테스트를 통한 미비점 파악 및 보완&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;계획-수립-시-고려사항&quot;&gt;계획 수립 시 고려사항&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RSO&lt;/strong&gt;(복구 목표 대상/범위 : Recovery Scope Objective)&lt;br /&gt;
정보의 중요성과 복구 우선순위 지정의 기본 지표가 된다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RTO&lt;/strong&gt;(복구 목표 시간 : Recovery Time Objective)&lt;br /&gt;
시스템 복구까지 허용할 수 있는 최대 시간&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RPO&lt;/strong&gt;(복구 목표 지점 : Recovery Point Objective)&lt;br /&gt;
목표 복구 시점, 데이터 손실을 시간으로 환산한 개념&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RCO&lt;/strong&gt;(통신 복구 목표 : Recovery Communications Objective)&lt;br /&gt;
네트워크 복구 수준&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BCO&lt;/strong&gt;(목표 백업 센터 : Backup Center Objective)&lt;br /&gt;
백업 센터 구축 및 관리 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구축-형태&quot;&gt;구축 형태&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;독자구축&lt;/strong&gt;&lt;br /&gt;
단일 기관 전용의 DRS를 독자적으로 구축&lt;br /&gt;
보안 유지 및 복구의 신뢰성이 가장 높음&lt;br /&gt;
구축 및 유지비용이 가장 많이 소요&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;공동구축&lt;/strong&gt;&lt;br /&gt;
두 개 이상의 기관이 DRS를 공동으로 구축 및 이용&lt;br /&gt;
비교적 적은 구축 및 유지비용&lt;br /&gt;
보안 및 운용 측면에서 고려할 사항이 많고, 광역재해 발생 시 공동이용기관간의 동시 재해복구 불가&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;상호구축&lt;/strong&gt;&lt;br /&gt;
단일 기관의 여러 개 사이트 또는 두 개 이상 기관의 사이트 상호간 DRS의 역할을 수행&lt;br /&gt;
가장 적은 구축 및 유지 비용&lt;br /&gt;
상호 기관 작업에 종속&lt;br /&gt;
서로 다른 기관간의 보안성 및 재해복구에 대한 신뢰성이 낮음&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;외부위탁&lt;/strong&gt;&lt;br /&gt;
재해 복구 전문 서비스 업체에 위탁하여 운영&lt;br /&gt;
전문기술 지원 가능&lt;br /&gt;
정보 유출, 보안 및 신뢰성 문제&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시스템-구성요소-별-복제방식&quot;&gt;시스템 구성요소 별 복제방식&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;H/W (Disk) 복제&lt;/strong&gt;&lt;br /&gt;
디스크 간 복제&lt;br /&gt;
안정성/고성능, 높은비용&lt;br /&gt;
Shadow Copy, True Copy&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;S/W (OS) 복제&lt;/strong&gt;&lt;br /&gt;
OS 수준 솔루션&lt;br /&gt;
안정성/효율성, 비교적 낮은 비용&lt;br /&gt;
Shareplex, Oracle Golden Gate&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;S/W (DBMS) 복제&lt;/strong&gt;&lt;br /&gt;
DBMS 기능 기용&lt;br /&gt;
안정성/효율성, 비교적 낮은 비용&lt;br /&gt;
Orcle RAC&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-동기화-기법&quot;&gt;데이터 동기화 기법&lt;/h2&gt;
&lt;h3 id=&quot;스토리지-데이터-복제-방식&quot;&gt;스토리지 데이터 복제 방식&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Active-Active 스토리지 방식&lt;/strong&gt;&lt;br /&gt;
동기방식으로 스토리지 1, 2가 하나의 저장공간으로 ㄷ오작하며 웹서버1(Active), 웹서버2(Active)가 각각 로컬 스토리지에 Write/Read가 가능&lt;/p&gt;

&lt;p&gt;구성 시 CWDM/DWDM으로 구현, 지연시간에 따라 센터간 50KM이내 권장&lt;/p&gt;

&lt;h3 id=&quot;스토리지-데이터-동기-복제-기법&quot;&gt;스토리지 데이터 동기 복제 기법&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;실시간 동기 방식&lt;/strong&gt;(Synchronous Data Replication)&lt;br /&gt;
서버가 로컬 스토리지에 저장 시 원격 스토리지에도 저장 후 응답을 받고 나서 서버에게 최종 응답을 전달 - Zero RPO, 거리 제약(50Km ~ 300Km)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동기 복제&lt;/code&gt; : SCSI(FC)는 한 번 동작이 메시지를 2차례를 주고 받는다.
즉, 50KM 거리에서 SCSI 한 번 동작 시 1ms 지연 발생&lt;/p&gt;

&lt;h3 id=&quot;스토리지-데이터-비동기-복제-기법&quot;&gt;스토리지 데이터 비동기 복제 기법&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;비동기 방식&lt;/strong&gt;(Asynchronous Data Replication)&lt;br /&gt;
서버가 로컬 스토리지에 저장 이후 리모트 스토리지에 저장 - 거리 제약 없음&lt;/p&gt;

&lt;h2 id=&quot;수준별-유형&quot;&gt;수준별 유형&lt;/h2&gt;
&lt;h3 id=&quot;미러사이트mirror-site&quot;&gt;미러사이트(Mirror Site)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주 센터와 동일한 수준의 정보기술자원을 원격지에 구축, Active Active 상태로 실시간 동시 서비스 제공&lt;/li&gt;
  &lt;li&gt;복구소요시간(RTO) : 즉시&lt;/li&gt;
  &lt;li&gt;데이터 최신성, 높은 안정성, 신속한 업무 재개&lt;/li&gt;
  &lt;li&gt;높은 초기투자비용, 높은 유지보수 비용, 데이터 업데이트가 많은 경우 과부하 야기&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;핫사이트hot-site&quot;&gt;핫사이트(Hot Site)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주센터와 동일한 수준의 정보기술자원을 원격지에 구축 후 Active Stanby 상태로 유지&lt;/li&gt;
  &lt;li&gt;재해 발생 시 Active 상태로 전환&lt;/li&gt;
  &lt;li&gt;데이터는 동기적 또는 비동기적 방식으로 실시간 미러링을 통하여 최신상태 유지&lt;/li&gt;
  &lt;li&gt;복구소요시간(RTO) : 수 시간 이내&lt;/li&gt;
  &lt;li&gt;데이터 최신성, 높은 안정성, 신속한 업무 재개, 데이터 업데이트가 많은 경우 적합&lt;/li&gt;
  &lt;li&gt;높은 초기투자비용, 높은 유지보수비용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;웜사이트warm-site&quot;&gt;웜사이트(Warm Site)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;중요성이 높은 정보기술자원만 부분적으로 재해복수센터에 보유&lt;/li&gt;
  &lt;li&gt;데이터는 주기적으로 백업&lt;/li&gt;
  &lt;li&gt;복구소요시간(RTO) : 일 단위 ~ 주 단위&lt;/li&gt;
  &lt;li&gt;구축 및 유지비용이 핫사이트에 비해 저렴&lt;/li&gt;
  &lt;li&gt;데이터 손실 다소 발생, 초기복구수준이 부분적, 복구소요시간이 길다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;콜드사이트cold-site&quot;&gt;콜드사이트(Cold Site)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터만 원격지에 보관하고 이의 서비스를 위한 정보자원은 확보하지 않거나 장소 등 최소한으로 확보&lt;/li&gt;
  &lt;li&gt;재해 발생 시 데이터를 근간으로 필요한 정보자원을 조달하여 정보시스템의 복구 개시&lt;/li&gt;
  &lt;li&gt;데이터는 주기적으로 원격지에 백업&lt;/li&gt;
  &lt;li&gt;복구소요시간(RTO) : 주 단위 ~ 달 단위&lt;/li&gt;
  &lt;li&gt;구축 및 유지비용이 가장 저렴&lt;/li&gt;
  &lt;li&gt;데이터 손실 발생, 복구에 매우 긴 시간 소요, 복구 신뢰성이 낮다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;drs-도입-효과&quot;&gt;DRS 도입 효과&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;재무적 관점&lt;/strong&gt;&lt;br /&gt;
ROI, TCO&lt;br /&gt;
서비스 연속성을 통한 투자 대비 효과&lt;br /&gt;
비용 증가 대비 가시성 효과 증대&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;고객 관점&lt;/strong&gt;&lt;br /&gt;
위험 대비 체계적 고품질 서비스&lt;br /&gt;
서비스 안정화로 고객 만족&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로세스 관점&lt;/strong&gt;&lt;br /&gt;
서비스 안정성 기반 생산성 증대&lt;br /&gt;
체계적 관리로 업무 효율성 향상&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;bcpbusiness-continuous-planning과의-비교&quot;&gt;BCP(Business Continuous Planning)과의 비교&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;구분&lt;/th&gt;
      &lt;th&gt;DRS&lt;/th&gt;
      &lt;th&gt;BCP&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;적용시점&lt;/td&gt;
      &lt;td&gt;재해 사후&lt;/td&gt;
      &lt;td&gt;재해 사전/후(평시, 비상시 연속)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;목적&lt;/td&gt;
      &lt;td&gt;정보시스템 인프라와 사업 운영에 필수적인 정보자산의 복구를 촉직하기 위한 상세한 절차를 제공&lt;/td&gt;
      &lt;td&gt;심각한 중단 상황에서 복구가 진행되는 동안에 필수적인 사업을 유지하기 위한 절차를 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;범위&lt;/td&gt;
      &lt;td&gt;IT서비스 중심. BIA에 따른 RTO, RPO를 고려한 서버, 스토리지, 네트워크 구축&lt;/td&gt;
      &lt;td&gt;실제의 업무 프로세스와 업무 프로세스를 지원하기 위한 IT 영역에 집중&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;실행 주체&lt;/td&gt;
      &lt;td&gt;정보시스템 부서가 절차중심으로 수행&lt;/td&gt;
      &lt;td&gt;각 비지니스 부서가 계획중심으로 수행&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;대상&lt;/td&gt;
      &lt;td&gt;IT운영팀을 중심으로 운영시설을 사업단위 중심으로 수행&lt;/td&gt;
      &lt;td&gt;업무는 물론 사람, 물리적 사무공간, 중요 문서등을 포함하여 사전에 준비하기 어려운 수많은 항목이 대상&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;구축 결과물&lt;/td&gt;
      &lt;td&gt;DRP(Disaster Recovery Plan)과 사전 계획 문서&lt;/td&gt;
      &lt;td&gt;재해복구계획, 업무복구계획, 대체프로세스계획, 업무비상계획&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;레퍼런스&quot;&gt;레퍼런스&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.skby.net/drs-disaster-recovery-system/&quot;&gt;도리의 디지털 라이프&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.naver.com/seilius/130189038043&quot;&gt;바보상자의 개발 블로그&lt;/a&gt;&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="데이터 보안" /><summary type="html">재해복구시스템(DRS : Disaster Recovery System)</summary></entry><entry><title type="html">[프로그래밍] 함수형 프로그래밍</title><link href="https://many258.github.io/study/functional-programming/" rel="alternate" type="text/html" title="[프로그래밍] 함수형 프로그래밍" /><published>2021-03-22T00:00:00+09:00</published><updated>2021-03-23T22:37:34+09:00</updated><id>https://many258.github.io/study/%7Bfunctional-programming%7D</id><content type="html" xml:base="https://many258.github.io/study/functional-programming/">&lt;h1 id=&quot;함수형-프로그래밍&quot;&gt;함수형 프로그래밍&lt;/h1&gt;
&lt;p&gt;함수의 동작에 의한 변수의 부수적인 값 변경을 원천 배제함으로써 오류를 방지하는 패러다임&lt;/p&gt;

&lt;p&gt;함수 내부에 상태가 존재하지 않으며, 함수의 출력 값은 항상 함수의 입력 값의 영향만 받는다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;높은 표현력을 통해 불필요한 코드를 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;함수형 프로그래밍의 언어군은 프로그래밍 언어론의 최신 연구 결과를 반영하고 있다&lt;/li&gt;
  &lt;li&gt;불변성(Immutability)으로 인해 다양한 최적화 및 검증이 용이&lt;/li&gt;
  &lt;li&gt;이전에 계산한 함수의 값을 캐싱해 두었다가 필요할 때 다시 사용하는 메모이제이션이 가능&lt;/li&gt;
  &lt;li&gt;함수형 프로그래밍 언어에서는 변경 가능한 상태를 원천적으로 배제하기 때문에 멀티프로세서, 멀티스레드 환경에서 동작하는 동시성 프로그램을 개발할 때 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대표 함수형 프로그래밍 언어 : &lt;strong&gt;Scala, LISP, Haskell, F#, Erlang&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;일급-객체&quot;&gt;일급 객체&lt;/h2&gt;
&lt;p&gt;다음 조건을 만족하면 일급 객체라고 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;변수나 데이터에 할당할 수 있어야 한다&lt;/li&gt;
  &lt;li&gt;객체의 인자로 넘길 수 있어야 한다&lt;/li&gt;
  &lt;li&gt;객체의 리턴값으로 리턴할 수 있어야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, 객체처럼 동작할 수 있는 함수를 지칭한다&lt;/p&gt;

&lt;h2 id=&quot;순수-함수&quot;&gt;순수 함수&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;항상 같은 인풋에는 항상 같은 아웃풋(멱등성, 참조 투명성)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;외부의 인자를 변화시키지 않고 최대한 지역변수만을 사용해서 구현되는 함수&lt;/p&gt;

&lt;h2 id=&quot;고차-함수--고계-함수&quot;&gt;고차 함수 = 고계 함수&lt;/h2&gt;
&lt;p&gt;함수를 값이라 생각하고 &lt;strong&gt;함수를 인자값&lt;/strong&gt;으로 넣어주는 형태&lt;/p&gt;

&lt;p&gt;인자로 다른 함수를 받아 결과값을 내보내는 함수를 의미&lt;/p&gt;

&lt;h2 id=&quot;커링&quot;&gt;커링&lt;/h2&gt;
&lt;p&gt;여러 인자를 받는 함수에 &lt;strong&gt;일부 인자만&lt;/strong&gt; 넣어서 나머지 인자를 받는 다른 함수를 만들어낼 수 있는 함수형 프로그래밍 기법을 의미&lt;/p&gt;

&lt;h2 id=&quot;함수-합성&quot;&gt;함수 합성&lt;/h2&gt;
&lt;p&gt;함수형 프로그래밍을 위한 라이브러리들에는 컬렉션 내 요소들을 다양하게, 연속적으로 처리할 수 있는 많은 도구&lt;/p&gt;

&lt;p&gt;새로운 함수를 생성하거나 어떤 계산을 수행하기 위해 &lt;strong&gt;둘 이상의 함수를 결합&lt;/strong&gt;하는 프로세스이다&lt;/p&gt;

&lt;h2 id=&quot;재귀와-꼬리-재귀-최적화&quot;&gt;재귀와 꼬리 재귀 최적화&lt;/h2&gt;

&lt;h2 id=&quot;모나드monad&quot;&gt;모나드(Monad)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;모나드는 값을 캡슐화하고, 추가 기능을 더해 새로운 타입을 생성하는 구조체&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모나드는 하나의 타입이며 인자를 Type 타입으로 받아 값을 캡슐화하여 값을 가공할 수 있는 추가기능 오퍼레이터를 사용할 수 있는 Functor를 사용하여 최종적으로 이러한 프로세스를 구현하는 구조를 새롭게 생성하는 특징을 가지고 있다.&lt;/p&gt;

&lt;p&gt;다음 세 가지를 충족하면 모나드라 할 수 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;타입을 인자로 받는 타입&lt;/li&gt;
  &lt;li&gt;unit(return) 오퍼레이터가 있어야 한다&lt;/li&gt;
  &lt;li&gt;bind 오퍼레이터가 있어야 한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;모나드가 필요한 이유 ? &lt;br /&gt;
비동기 연산 처리, NULL 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;br /&gt;
컬렉션의 원소를 순회하는 방법의 의미보다&lt;br /&gt;
&lt;strong&gt;T 타입의 Functor를 R 타입의 Functor로 바꾸는 기능&lt;/strong&gt;이라고 생각하는 중요!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;flatMap&lt;/strong&gt;&lt;br /&gt;
위 맵의 역할을 하지만 캡슐화가 된 자료구조를 Serialize했다고 생각하면 편하다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.function.Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;함수를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;인자를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;받는&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;메소드만&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;가진다&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;인자&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;가짐&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;전달인자인&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;함수&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f는&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;값을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;받아&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;값을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환하는&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;함수&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor는&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map함수를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;거쳐&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입의&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;map메소드로 값을 변경하는 것 뿐인데 왜 Functor를 사용할까?&lt;br /&gt;
=&amp;gt; Functor를 이용하면 &lt;strong&gt;일반적으로 모델링할 수 없는 상황을 모델링 할 수 있다&lt;/strong&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;타입안정성을 유지하면서 NULL을 인코딩하는 방법&lt;/li&gt;
  &lt;li&gt;아직 값을 가지고 있지 않아도 동일하게 map 메소드를 적용할 수 있음
(문법적으로나 의미적으로 완전 동일)&lt;/li&gt;
  &lt;li&gt;비동기 로직을 동기 로직을 구현하는 것과 동일한 형태로 구현하면서도, 함수의 합성 및 완전한 Non-Blocking Pipeline을 구현 가능&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Functor의 문제점&lt;br /&gt;
=&amp;gt; Functor가 Functor안에 감싸져 있으면, 함수의 합성과 체이닝을 저해하므로 제 기능을 하지 못하게 될 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Monad = Functor + flatMap&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;{&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;지연-연산lazy-evaluation&quot;&gt;지연 연산(Lazy Evaluation)&lt;/h2&gt;
&lt;p&gt;어떤 값이 실제로 쓰이기 전까지 그 값의 계산을 최대한 연기하는 것을 의미.&lt;/p&gt;

&lt;p&gt;값을 미리 계산하여 저장하지 않기때문에 공간을 절약할 수 있고 값이 꼭 필요할 때만 계산하기 때문에 프로그램 성능에도 긍정적인 영향을 준다.&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="Programming" /><summary type="html">함수형 프로그래밍 함수의 동작에 의한 변수의 부수적인 값 변경을 원천 배제함으로써 오류를 방지하는 패러다임</summary></entry></feed>