<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My LifeChronicle</title>
    <description>Be a Imagineer.</description>
    <link>https://many258.github.io/</link>
    <atom:link href="https://many258.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 29 Apr 2021 00:20:10 +0900</pubDate>
    <lastBuildDate>Thu, 29 Apr 2021 00:20:10 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>[전자계산기] 순서 논리 회로(Sequential Logic Circuit)</title>
        <description>&lt;h2 id=&quot;순서-논리-회로&quot;&gt;순서 논리 회로&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;기억 능력&lt;/strong&gt;을 갖추면서 &lt;strong&gt;입력과 내부 상태의 조합&lt;/strong&gt;에 의해 출력이 결정되는 회로&lt;/p&gt;

&lt;p&gt;플립플롭이나 레지스터 장치로 구성된다&lt;/p&gt;

&lt;h3 id=&quot;플립플롭flip-flop&quot;&gt;플립플롭(Flip-Flop)&lt;/h3&gt;
&lt;p&gt;순서 논리 회로를 구성하는 기본 기억 소자로 &lt;strong&gt;1비트를 기억&lt;/strong&gt;할 수 있는 &lt;strong&gt;2진 Cell&lt;/strong&gt;을 의미&lt;/p&gt;

&lt;h4 id=&quot;rs-플립플롭&quot;&gt;RS 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/rs-filp-flop.png&quot; title=&quot;https://www.electronicsengineering.nbcafe.in/rs-flip-flop/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/rs-filp-flop.png&quot; alt=&quot;&quot; title=&quot;RS 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;보통 NAND 게이트를 이용해서 구성&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SET&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt;) &lt;strong&gt;단자와&lt;/strong&gt; RESET(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;) 단자를 갖으며, &lt;strong&gt;모두 1인 경우는 허용되지 않는다&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;jk-플립플롭&quot;&gt;JK 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/jk-flip-flop.png&quot; title=&quot;https://www.javatpoint.com/j-k-flip-flop&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/jk-flip-flop.png&quot; alt=&quot;&quot; title=&quot;JK 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RS 플립플롭에서 S와 R이 모두 1일 때 &lt;strong&gt;허용되지 않는 것을 보완&lt;/strong&gt;해서 이것이 허용되도록 고안된 플립플롭&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RS 플립플롭&lt;/strong&gt;의 내부 상태와 입력 상태를 &lt;strong&gt;AND 게이트&lt;/strong&gt;로 처리하여 입력하는 플립플롭&lt;/p&gt;

&lt;h4 id=&quot;d-플립플롭&quot;&gt;D 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/d-flip-flop.png&quot; title=&quot;https://www.javatpoint.com/d-flip-flop&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/d-flip-flop.png&quot; alt=&quot;&quot; title=&quot;D 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RS나 JK 플립플롭에서 &lt;strong&gt;서로 베타적인 경우만 이용&lt;/strong&gt;되도록 고안된 플립플롭, &lt;strong&gt;1비트 지연 소자&lt;/strong&gt;로 사용된다&lt;br /&gt;
(S가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;이면 R은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;, S가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;이면 R은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&quot;t-플립플롭&quot;&gt;T 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/t-flip-flop.png&quot; title=&quot;https://www.javatpoint.com/t-flip-flop&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/t-flip-flop.png&quot; alt=&quot;&quot; title=&quot;T 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;JK 플립플롭에서 J, K가 같은 값이 입력될 때만 이용할 수 있도록 고안된 플립플롭, &lt;strong&gt;토글(Toggle) 기능&lt;/strong&gt;을 이용하고자 할 때 사용된다
(J가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;이면 K는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;, J가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;이면 K는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&quot;마스터-슬레이브master-slave-플립플롭&quot;&gt;마스터 슬레이브(Master-Slave) 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/master-slave-flipflop.png&quot; title=&quot;http://www.barrywatson.se/dd/dd_sr_flip_flop_master_slave.html&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/master-slave-flipflop.png&quot; alt=&quot;&quot; title=&quot;마스터 슬레이브 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Race 현상&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt;을 해결하기 위해 고안된 플립플롭&lt;/p&gt;

&lt;p class=&quot;notice--success&quot;&gt;&lt;strong&gt;Race 현상&lt;/strong&gt; : 출력이 입력에 피드백되어 플립플롭의 내부 상태가 변화되면 출력 상태가 변할 때 입력도 변하게 되므로 &lt;strong&gt;오동작이 발생&lt;/strong&gt;하게 되는 현상&lt;/p&gt;

&lt;p&gt;하나의 플립플롭(&lt;strong&gt;주 플립플롭&lt;/strong&gt;)이 주인 역할을 하고, 다른 하나의 플립플롭(&lt;strong&gt;종 플립플롭&lt;/strong&gt;)이 종속되어 동작하도록 두 개 이상의 플립플롭 회로를 결합한 것&lt;/p&gt;

&lt;p&gt;주 플립플롭은 &lt;strong&gt;시간 펄스가 상승&lt;/strong&gt;할 때 동작하고, 종 플립플롭은 &lt;strong&gt;시간 펄스가 하강&lt;/strong&gt;할 때 동작&lt;/p&gt;

&lt;h3 id=&quot;카운터counter&quot;&gt;카운터(Counter)&lt;/h3&gt;
&lt;p&gt;시간 펄스의 수를 카운트하거나 제어 장치에서 각종 회로의 동작을 제어하는데 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;리플 카운터(Ripple Counter)&lt;/strong&gt;&lt;br /&gt;
가장 기본이 되는 비동기형(Asynchronous) 카운터. 플립플롭의 수를 n이라 할 때, 2&lt;sup&gt;n&lt;/sup&gt;개까지의 독립된 수 전부를 표현&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;모드 카운터(MOD Counter)&lt;/strong&gt;&lt;br /&gt;
N개의 서로 다른 출력상태를 갖는 카운터. N개의 서로 다른 출력상태를 나타낸 후 다시 원래의 상태로 복귀해 다시 N개의 출력상태를 반복&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;레지스터register&quot;&gt;레지스터(Register)&lt;/h3&gt;
&lt;p&gt;연산에 사용될 데이터가 대기하거나 연산된 결과&lt;strong&gt;데이터가 임시적으로 대기&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;시프트 레지스터(Shift Register)&lt;/strong&gt;&lt;br /&gt;
현재 레지스터에 있는 내용을 왼쪽이나 오른쪽의 연결된 플립플롭을 &lt;strong&gt;1비트씩 이동&lt;/strong&gt;시켜 &lt;strong&gt;밀어내기와 같은 동작을 수행&lt;/strong&gt;하는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;병렬 시프트 레지스터(Parallel Shift Register)&lt;/strong&gt;&lt;br /&gt;
N개의 비트로 구성된 레지스터의 내용을 연결된 다른 레지스터로 &lt;strong&gt;한 번에 이동&lt;/strong&gt;시킬 수 있는 레지스터&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 28 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-sequential-logic/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-sequential-logic/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 조합 논리 회로(Combinational Logic Circuit)</title>
        <description>&lt;h2 id=&quot;조합-논리-회로&quot;&gt;조합 논리 회로&lt;/h2&gt;
&lt;p&gt;논리 게이트의 조합으로 만들어지는 회로로 현재의 입력에 의해서만 출력이 결정되는 회로를 의미&lt;/p&gt;

&lt;h3 id=&quot;반가산기half-adder&quot;&gt;반가산기(Half Adder)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/half-adder.png&quot; title=&quot;https://www.researchgate.net/figure/Half-adder-circuit-diagram_fig1_272015389&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/half-adder.png&quot; alt=&quot;&quot; title=&quot;반가산기&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2개의 2진 입력 변수 A와 B를 더한 합 &lt;strong&gt;S&lt;/strong&gt;(Sum)와 자리 올림 수 &lt;strong&gt;C&lt;/strong&gt;(Carry)를 얻는 회로&lt;/p&gt;

&lt;p&gt;하나의 &lt;strong&gt;AND 게이트&lt;/strong&gt;와 &lt;strong&gt;XOR&lt;/strong&gt;(eXclusive OR) 게이트를 조합해서 구성&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;S&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;합(Sum)&lt;/strong&gt; : S = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·B + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; = A ⊕ B&lt;br /&gt;
&lt;strong&gt;캐리(Carry)&lt;/strong&gt; : C = A · B&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;반감산기half-subtracter&quot;&gt;반감산기(Half Subtracter)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/half-subtracter.png&quot; title=&quot;https://www.engineersgarage.com/vhdl/vhdl-tutorial-11-designing-half-and-full-subtractor-circuits/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/half-subtracter.png&quot; alt=&quot;&quot; title=&quot;반감산기&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2개의 2진 입력 변수 X에서 Y를 뺀 차 D와 빌려온 수(자리 내림 수) B를 얻는 회로&lt;/p&gt;

&lt;p&gt;하나의 &lt;strong&gt;NOT 게이트&lt;/strong&gt; 및 &lt;strong&gt;AND 게이트&lt;/strong&gt;와 &lt;strong&gt;XOR 게이트&lt;/strong&gt;를 조합해서 구성&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;X&lt;/th&gt;
      &lt;th&gt;Y&lt;/th&gt;
      &lt;th&gt;D&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;차(Difference)&lt;/strong&gt; : D = X·&lt;span style=&quot;text-decoration:overline&quot;&gt;Y&lt;/span&gt; + &lt;span style=&quot;text-decoration:overline&quot;&gt;X&lt;/span&gt;·Y  = X ⊕ Y&lt;br /&gt;
&lt;strong&gt;빌려온 수(자리 내림, Borrow)&lt;/strong&gt; : B = &lt;span style=&quot;text-decoration:overline&quot;&gt;X&lt;/span&gt; · Y&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;전가산기full-adder&quot;&gt;전가산기(Full Adder)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/full-adder.png&quot; title=&quot;https://electronics.stackexchange.com/questions/492236/why-is-the-last-carry-blocks-gate-in-a-full-adder-an-or-gate-and-not-a-xor&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/full-adder.png&quot; alt=&quot;&quot; title=&quot;전가산기&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2진수 가산을 완전히 하기 위하여 아래 자리로부터 자리 올림된 수도 고려하여 3개의 2진수를 더할 수 있게 만든 회로&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;반가산기 2개&lt;/strong&gt;와 &lt;strong&gt;OR 게이트 1개&lt;/strong&gt;를 연결하여 구성&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
      &lt;th&gt;S&lt;/th&gt;
      &lt;th&gt;C&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;합(Sum)&lt;/strong&gt; : S = A⊕B⊕C&lt;br /&gt;
&lt;strong&gt;캐리(Carry)&lt;/strong&gt; : C&lt;sub&gt;0&lt;/sub&gt; = (A⊕B)·C + A·B = A·B + B·C + A·C&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;전감산기full-subtracter&quot;&gt;전감산기(Full Subtracter)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/full-subtractor.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/full-subtractor.png&quot; alt=&quot;&quot; title=&quot;전감산기&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2진수 감산을 완전히 하기 위하여 아래 자리로부터 자리 내림수도 고려하여 3개의 2진수를 감산할 수 있게 만든 회로&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;반감산기 2개&lt;/strong&gt;와 &lt;strong&gt;OR 게이트 1개&lt;/strong&gt;를 연결하여 구성&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;X&lt;/th&gt;
      &lt;th&gt;Y&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;D&lt;/th&gt;
      &lt;th&gt;B&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;차(Difference)&lt;/strong&gt; : D = X⊕Y⊕B&lt;br /&gt;
&lt;strong&gt;빌려온 수(Borrow)&lt;/strong&gt; : B&lt;sub&gt;1&lt;/sub&gt; = &lt;span style=&quot;text-decoration:overline&quot;&gt;(X⊕Y)&lt;/span&gt;·B + &lt;span style=&quot;text-decoration:overline&quot;&gt;X&lt;/span&gt;·Y&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;병렬-가산기parallel-adder&quot;&gt;병렬 가산기(Parallel Adder)&lt;/h3&gt;
&lt;p&gt;여러 비트를 가산하기 위한 회로&lt;/p&gt;

&lt;p&gt;반가산기 또는 전가산기를 여러 개 합쳐서 만들어진다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;전가산기로 구성&lt;/strong&gt;하여 N비트 병렬 가산기를 만들 경우&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;개의 전가산기 필요&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;반가산기로 구성&lt;/strong&gt;하여 N비트 병렬 가산기를 만들 경우&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(2N-1)&lt;/code&gt;개의 반가산기와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(N-1)&lt;/code&gt;개의 &lt;strong&gt;OR 게이트&lt;/strong&gt; 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/parallel-adder.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/parallel-adder.png&quot; alt=&quot;&quot; title=&quot;4비트 병렬 가산기의 여러 가지 블록 다이어그램&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;디코더decoder&quot;&gt;디코더(Decoder)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/decoder.png&quot; title=&quot;https://www.tutorialspoint.com/computer_logical_organization/combinational_circuits.htm&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/decoder.png&quot; alt=&quot;&quot; title=&quot;디코더&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;컴퓨터 내부에서 2진수로 코드화된 데이터를 해독하여 대응되는 한 개의 신호로 바꿔주기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;해독기&lt;/code&gt;라고도 한다&lt;br /&gt;
&lt;strong&gt;N개의 입력&lt;/strong&gt;으로 &lt;strong&gt;최대 2&lt;sup&gt;N&lt;/sup&gt;개의 출력&lt;/strong&gt;을 얻을 수 있다&lt;br /&gt;
AND 게이트로 만들어진다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;3&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;인코더encoder&quot;&gt;인코더(Encoder)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/encoder.png&quot; title=&quot;https://en.wikipedia.org/wiki/Encoder_(digital)&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/encoder.png&quot; alt=&quot;&quot; title=&quot;인코더&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;입력 정보를 여러 자리의 2진수로 코드화하여 전달하는 회로&lt;br /&gt;
해독기와 정반대의 동작을 수행&lt;br /&gt;
&lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;개의 입력&lt;/strong&gt;을 받아 &lt;strong&gt;N개를 출력&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;입력&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;멀티플렉서multiplexer&quot;&gt;멀티플렉서(Multiplexer)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/multiplexer.png&quot; title=&quot;https://www.tutorialspoint.com/digital_circuits/digital_circuits_multiplexers.htm&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/multiplexer.png&quot; alt=&quot;&quot; title=&quot;멀티플렉서&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;개의 입력선&lt;/strong&gt;에서 &lt;strong&gt;N개의 선택선&lt;/strong&gt;을 가지고 &lt;strong&gt;하나의 출력&lt;/strong&gt;을 얻도록 구성&lt;br /&gt;
&lt;strong&gt;여러 개의 입력 회선&lt;/strong&gt;이 들어가서 &lt;strong&gt;하나의 특정 회선을 선택&lt;/strong&gt;하도록 하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선택기&lt;/code&gt;라고도 한다&lt;br /&gt;
공통적인 &lt;strong&gt;버스 라인을 구성&lt;/strong&gt;하는데 많이 사용&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;S&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;S&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;Y&lt;sub&gt;선택 회선&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;sub&gt;0&lt;/sub&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;I&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;sub&gt;2&lt;/sub&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;I&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;디멀티플렉서demultiplexer&quot;&gt;디멀티플렉서(Demultiplexer)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/demultiplexer.png&quot; title=&quot;https://electricalfundablog.com/demultiplexer-demux/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/demultiplexer.png&quot; alt=&quot;&quot; title=&quot;디멀티플렉서&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하나의 입력 정보&lt;/strong&gt;를 &lt;strong&gt;N개의 선택선&lt;/strong&gt;을 가지고 2&lt;sup&gt;N&lt;/sup&gt;개의 출력을 얻도록 구성&lt;br /&gt;
중앙 처리 장치에서 어떤 내용을 특정 장치로 출력시킬 때 많이 사용&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;S&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;S&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;3&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;비교기comparator&quot;&gt;비교기(Comparator)&lt;/h3&gt;
&lt;p&gt;논리적으로 두 수를 비교한다면 ‘같다’, ‘같지 않다’만 판별하면 되므로 두 수 A, B를 &lt;strong&gt;XNOR 게이트로 연결&lt;/strong&gt;하여 1이 얻어지면 ‘같다’고 판별할 수 있다&lt;/p&gt;

&lt;p&gt;N비트 논리 비교기를 만들기 위해서는 XNOR 게이트 N개가 필요&lt;/p&gt;

&lt;h3 id=&quot;3-상태-버퍼tri-state-buffer&quot;&gt;3-상태 버퍼(Tri-State Buffer)&lt;/h3&gt;
&lt;p&gt;3가지 상태 중&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;의 상태는 전기적으로 &lt;strong&gt;하이 레벨(H)&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;의 상태는 &lt;strong&gt;로우 레벨(L)&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;또 다른 상태&lt;/code&gt;는 &lt;strong&gt;고 임피던스&lt;/strong&gt;(회로가 끊어진 상태) 상태를 의미한다.&lt;/p&gt;

&lt;p&gt;3-상태 버퍼 회로는 인에이블(1) 또는 디스에이블(0) 단자에 의하여 데이터의 &lt;strong&gt;전송 방향을 하드웨어적으로 제어&lt;/strong&gt;하는 데 사용&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-combinational-logic/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-combinational-logic/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 논리 회로</title>
        <description>&lt;h2 id=&quot;불-대수&quot;&gt;불 대수&lt;/h2&gt;
&lt;p&gt;논리 회로를 분석하고 수학적으로 그 연산을 표현하고자 사용하는 대수식으로 논리 대수라고도 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;논리 변수 사이의 진리표를 대수 형식으로 표시&lt;/li&gt;
  &lt;li&gt;논리 변수를 조작하여 주어진 회로 기능을 수행하는데 있어 가장 간단한 회로를 결정하고자 사용&lt;/li&gt;
  &lt;li&gt;불 대수의 모든 변수는 0과 1의 값을 가질 수 있다&lt;/li&gt;
  &lt;li&gt;논리 회로의 입출력 관계를 대수 형식으로 표시&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;불 대수의 연산
    &lt;ul&gt;
      &lt;li&gt;논리 부정(NOT, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;￣&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;＇&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;논리곱(AND, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;·&lt;/code&gt; )&lt;/li&gt;
      &lt;li&gt;논리합(OR, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A + A = A&lt;/td&gt;
      &lt;td&gt;A · A = A&lt;/td&gt;
      &lt;td&gt;A · 0 = 0&lt;/td&gt;
      &lt;td&gt;A + 0 = A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A + 1 = 1&lt;/td&gt;
      &lt;td&gt;A · 1 = A&lt;/td&gt;
      &lt;td&gt;0 + 0 = 0&lt;/td&gt;
      &lt;td&gt;0 · 0 = 0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1 + 0 = 1&lt;/td&gt;
      &lt;td&gt;1 · 0 = 0&lt;/td&gt;
      &lt;td&gt;1 + 1 = 1&lt;/td&gt;
      &lt;td&gt;1 · 1 = 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A + A·B = A&lt;/td&gt;
      &lt;td&gt;A·(A + B) = A&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;논리-게이트&quot;&gt;논리 게이트&lt;/h2&gt;
&lt;p&gt;논리 회로를 구성하는 기본 소자, 2진 정보를 취급하는 기본 논리 회로&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/logic-gate.png&quot; title=&quot;https://www.pinterest.co.kr/pin/674203006705758186/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/logic-gate.png&quot; alt=&quot;&quot; title=&quot;논리 게이트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;AND&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 모두 1일 때만 1 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;OR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 모두 0일 때만 0 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;NOT&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 0이면 1을 출력하고 1이면 0을 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;NAND&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 모두 1일 때만 0 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;NOR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 모두 0일 때만 1 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;XOR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;A, B 입력 값이 서로 다를 때는 1 출력, 같을 때는 0 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;XNOR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;A, B 입력 값이 서로 같을 때는 1 출력, 같을 때는 1 출력&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;결선-게이트&quot;&gt;결선 게이트&lt;/h2&gt;
&lt;p&gt;필요할 때 게이트의 선을 연결하고, 단절하고 &lt;strong&gt;조절함으로써 다양한 기능&lt;/strong&gt;을 할 수 있도록 만든 게이트를 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;게이트들의 출력 단자를 논리적으로 직접 연결하여 논리 기능을 발휘할 수 있도록 했다&lt;/li&gt;
  &lt;li&gt;회로 비용을 절감할 수 있다&lt;/li&gt;
  &lt;li&gt;하나의 인쇄기판보다 많은 논리 기능을 포함시킬 수 있다&lt;/li&gt;
  &lt;li&gt;Open Collector TTL(Transistor-Transistor Logic)로 게이트들의 출력 단자를 묶어서 사용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;불-대수에-의한-최소화&quot;&gt;불 대수에 의한 최소화&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;최소항&lt;/strong&gt; : 진리표상에서 결과가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;인 부분을 표시할 때 사용하는 방식으로 불식을 형성하는 입력 변수 모두를 포함하는 &lt;strong&gt;논리곱&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;·&lt;/code&gt;)으로 나타내는 경우를 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;최대항&lt;/strong&gt; : 진리표상에서 결과가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;인 부분을 표시할 때 사용하는 방식으로 불식을 형성하는 입력 변수 모두를 포함하는 &lt;strong&gt;논리합&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;)으로 나타내는 경우를 의미&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A   B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;F&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;최소항&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;수치 표현&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0   0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0   1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1   0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1   1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A · B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;최소항의 합 표현은 위 표에서와 같이 결과가 1이 되는 부분만을 논리곱으로 표현하여 이 논리곱들을 논리합으로 연결하면 된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;최소항의 합&lt;/strong&gt; : F = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · B&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;수치 표현&lt;/strong&gt; : F(A, B) = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · B = $\Sigma(0,2,3)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불 대수식의 최소화&lt;/strong&gt;&lt;br /&gt;
F = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · B&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; · (&lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; + A) + A · B
= &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · B&lt;br /&gt;
= (&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A) · (&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + B)&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;입력(A, B, C)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;출력&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;최소항&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;수치 표현&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0 0 0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0 0 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0 1 0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · B · &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0 1 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 0 0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 0 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 1 0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A · B · &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 1 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;최소항의 합&lt;/strong&gt; : Y = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·B·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·B·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수치 표현&lt;/strong&gt; : Y(A, B, C) = $\Sigma(0, 2, 4, 6)$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불 대수식의 최소화&lt;/strong&gt;&lt;br /&gt;
Y = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·B·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·B·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;·(&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;+B) + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;·(&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;+B)&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;카르노-맵karnaugh-map에-의한-최소화&quot;&gt;카르노 맵(Karnaugh Map)에 의한 최소화&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/karnaugh-map.png&quot; title=&quot;https://www.eetimes.com/karnaugh-maps-101/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/karnaugh-map.png&quot; alt=&quot;&quot; title=&quot;카르노 맵에 의한 최소화&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-logic-circuit/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-logic-circuit/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 컴퓨터 시스템</title>
        <description>&lt;h2 id=&quot;컴퓨터-시스템-구조&quot;&gt;컴퓨터 시스템 구조&lt;/h2&gt;

&lt;h3 id=&quot;sisdsingle-instruction-single-data&quot;&gt;SISD(Single Instruction Single Data)&lt;/h3&gt;
&lt;p&gt;단일 처리기 컴퓨터로서 한 번에 한 명령어만 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1명의 사용자가 1개의 CPU를 사용한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다수의 기계어 명령들이 동시에 서로 다른 단계에서 수행&lt;/strong&gt;할 수 있게 하는 &lt;strong&gt;파이프라인&lt;/strong&gt; 기법에 응용할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;simdsingle-instruction-multiple-data&quot;&gt;SIMD(Single Instruction Multiple Data)&lt;/h3&gt;
&lt;p&gt;다중 처리기 컴퓨터로서 한 번에 한 명령어만을 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1명의 사용자가 여러 개의 CPU를 사용&lt;/li&gt;
  &lt;li&gt;슈퍼 컴퓨터, 과학 기술용 컴퓨터 급 수준&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;어레이 처리 기법&lt;/strong&gt;에 응용할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;misdmultiple-instruction-single-data&quot;&gt;MISD(Multiple Instruction Single Data)&lt;/h3&gt;
&lt;p&gt;단일 처리기 컴퓨터로서 한 번에 여러 개의 명령어를 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 명의 사용자가 1개의 CPU를 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mimdmultiple-instruction-multiple-data&quot;&gt;MIMD(Multiple Instruction Multiple Data)&lt;/h3&gt;
&lt;p&gt;다중 처리기 컴퓨터로서 한 번에 여러 개의 명령어를 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 명의 사용자가 여러 개의 CPU를 사용&lt;/li&gt;
  &lt;li&gt;일반적으로 다중 처리기 혹은 다중 컴퓨터라고도 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;다중-처리기multi-processor&quot;&gt;다중 처리기(Multi-Processor)&lt;/h4&gt;
&lt;p&gt;여러 개의 CPU가 &lt;strong&gt;하나의 메모리를 공유&lt;/strong&gt;하는 형태로 CPU 끼리의 결합력이 강하며, &lt;strong&gt;병렬 처리&lt;/strong&gt;에 적합한 컴퓨터 시스템 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;강 결합(Tightly-Coupled)&lt;/strong&gt; 시스템&lt;/li&gt;
  &lt;li&gt;전송 지연이 짧고 데이터 처리율이 높다&lt;/li&gt;
  &lt;li&gt;프로세스간 통신은 공유 메모리를 통해 이루어진다&lt;/li&gt;
  &lt;li&gt;공유 메모리를 차지하려는 &lt;strong&gt;프로세스 간의 경쟁&lt;/strong&gt;이 발생&lt;/li&gt;
  &lt;li&gt;기억 장소가 하나이므로 운영체제도 &lt;strong&gt;종속적&lt;/strong&gt;으로 사용&lt;/li&gt;
  &lt;li&gt;모든 CPU는 하나의 운영체제에서 통제되는 &lt;strong&gt;대칭적인 구조&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;다중-컴퓨터multi-computer&quot;&gt;다중 컴퓨터(Multi-Computer)&lt;/h4&gt;
&lt;p&gt;여러 개의 CPU가 자신만의 &lt;strong&gt;독립적인 메모리를 사용&lt;/strong&gt;하는 형태로 CPU 끼리 결합력이 약하며, &lt;strong&gt;분산 처리&lt;/strong&gt;에 적합한 컴퓨터 시스템 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;약 결합(Loosely-Coupled)&lt;/strong&gt; 시스템&lt;/li&gt;
  &lt;li&gt;전송 지연이 길고 데이터 처리율이 낮다&lt;/li&gt;
  &lt;li&gt;프로세스 간의 통신은 통신망에 &lt;strong&gt;메시지 전달로 통신&lt;/strong&gt; 가능&lt;/li&gt;
  &lt;li&gt;구성 요소의 &lt;strong&gt;추가 또는 삭제가 용이&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;기억 장소가 CPU와 독립적으로 사용되므로 운영체제도 독립적으로 사용하는 &lt;strong&gt;분리 수행 구조&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mimd의-위상에-따른-분류&quot;&gt;MIMD의 위상에 따른 분류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;다중 처리기의 위상
    &lt;ul&gt;
      &lt;li&gt;버스형&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;교환형
&lt;a href=&quot;../../assets/images/OS/multi-processor-topology.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/multi-processor-topology.png&quot; alt=&quot;&quot; title=&quot;다중 처리기의 위상&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;크로스바 교환 행렬 &lt;strong&gt;(a)&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;오메가 교환 행렬 &lt;strong&gt;(b)&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다중 컴퓨터의 위상
    &lt;ul&gt;
      &lt;li&gt;버스형&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;교환형
&lt;a href=&quot;../../assets/images/OS/multi-computer-topology.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/multi-computer-topology.png&quot; alt=&quot;&quot; title=&quot;다중 컴퓨터의 위상&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;그리드 교환형 &lt;strong&gt;(a)&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;하이퍼 큐브 교환형 &lt;strong&gt;(b)&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;다중-처리기와-운영체제-구성&quot;&gt;다중 처리기와 운영체제 구성&lt;/h2&gt;
&lt;h3 id=&quot;주종-프로세서-구조&quot;&gt;주/종 프로세서 구조&lt;/h3&gt;
&lt;p&gt;하나의 컴퓨터 시스템에 두 개의 프로세서가 있을 경우 입출력과 연산을 각각 독립적으로 수행하지 않고 &lt;strong&gt;주 프로세서는 입출력과 연산&lt;/strong&gt;, &lt;strong&gt;종 프로세서는 연산을 일부&lt;/strong&gt; 담당하게 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주 프로세서가 중단되면 시스템이 중지&lt;/strong&gt;되지만 종 프로세서가 중단되면 컴퓨터 시스템은 계속 동작할 수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;주 프로세서&lt;/strong&gt;만이 &lt;strong&gt;운영체제&lt;/strong&gt;를 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;종 프로세서&lt;/strong&gt;는 &lt;strong&gt;사용자 프로그램&lt;/strong&gt;만을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분리-수행개별적-관리자-separate-excution&quot;&gt;분리 수행(개별적 관리자, Separate-Excution)&lt;/h3&gt;
&lt;p&gt;각 프로세서가 &lt;strong&gt;독립적인 운영체제&lt;/strong&gt;를 가진다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 프로세서에서 발생하는 인터럽트도 해당 프로세스에서 독립적으로 수행&lt;/li&gt;
  &lt;li&gt;각 프로세서는 자신만의 파일과 입출력 장치를 제어&lt;/li&gt;
  &lt;li&gt;프로세서가 독립적이므로 &lt;strong&gt;프로세서에 따라&lt;/strong&gt; 유휴 상태이거나 매우 바쁠 수 있다&lt;/li&gt;
  &lt;li&gt;한 프로세서의 고장으로 전 &lt;strong&gt;시스템이 중지되지 않으&lt;/strong&gt;므로 &lt;strong&gt;신뢰성이 우수&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;대칭적symmetric-구조&quot;&gt;대칭적(Symmetric) 구조&lt;/h3&gt;
&lt;p&gt;여러 프로세서가 하나의 운영체제에서 동시에 운영&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가장 강력한 시스템이나 매우 복잡한 구조&lt;/li&gt;
  &lt;li&gt;운영체제는 동등한 프로세서의 Pool(프로세서 정보 테이블)을 가진다&lt;/li&gt;
  &lt;li&gt;하나의 프로세서가 중단되면 &lt;strong&gt;능력이 다소 낮아지지만 중단 없이&lt;/strong&gt; 계속 진행&lt;/li&gt;
  &lt;li&gt;프로세서의 수를 늘린다고 해도 시스템 효율은 향상되지 않는다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;분산-운영체제&quot;&gt;분산 운영체제&lt;/h2&gt;
&lt;p&gt;각 호스트에 고유한 운영체제가 있는 것이 아니라 전체 네트워크에 공통적으로 단일 운영체제가 실행되는 시스템으로 &lt;strong&gt;원격에 있는 자원을 마치 지역 자원인 것처럼 쉽게 접근&lt;/strong&gt;하여 사용할 수 있는 방식&lt;/p&gt;

&lt;h3 id=&quot;분산-운영체제의-목적&quot;&gt;분산 운영체제의 목적&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;자원 공유의 증대성&lt;/strong&gt;&lt;br /&gt;
각 시스템이 통신망을 통해 연결되어 있으므로 유용한 자원을 공유하여 사용할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;연산 속도의 향상&lt;/strong&gt;&lt;br /&gt;
하나의 일을 여러 시스템에 분산하여 처리하기 때문에 연산 속도가 향상된다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;신뢰성 향상&lt;/strong&gt;&lt;br /&gt;
하나의 시스템에 오류가 발생하더라도 다른 시스템은 계속 작업을 수행할 수 있기 때문에 신뢰도가 향상된다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;컴퓨터 통신&lt;/strong&gt;&lt;br /&gt;
지리적으로 떨어진 시스템에 통신망을 두어 정보를 교환할 수 있다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-운영체제의-장점&quot;&gt;분산 운영체제의 장점&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CPU의 처리 능력 한계를 극복할 수 있다&lt;/li&gt;
  &lt;li&gt;CPU의 처리 능력을 한 단계 높이려면 현재 가격의 제곱만큼 비싸다. 따라서 &lt;strong&gt;처리 속도가 낮은 여러 개의 CPU를 연결&lt;/strong&gt;하여 처리 속도를 향상시킬 수 있기 때문에 &lt;strong&gt;경제적&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;반응 시간이 빠르면 계산 능력, 처리량, 신뢰성, 가용성 모두 향상&lt;/li&gt;
  &lt;li&gt;특정한 시스템의 병목 현상을 제거하기 위해 필요한 자원을 추가할 수 있으므로 &lt;strong&gt;확장성이 우수&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;부하를 균등하게 배분&lt;/strong&gt;할 수 있어 처리 효율이 향상&lt;/li&gt;
  &lt;li&gt;다수의 사용자가 데이터를 &lt;strong&gt;공유&lt;/strong&gt;할 수 있으며 통신이 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-운영체제의-단점&quot;&gt;분산 운영체제의 단점&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여러 개의 컴퓨터 시스템이 연결되어 있으므로 &lt;strong&gt;보안이 매우 취약&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;여러 개의 컴퓨터를 하나의 컴퓨터처럼 운영해야 하므로 소프트웨어 &lt;strong&gt;개발이 매우 어렵다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;적응성이&lt;/strong&gt; 하나의 CPU를 사용할 때보다는 &lt;strong&gt;떨어진다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;에러 발생 시 &lt;strong&gt;원인 파악이 힘들다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-운영체제의-결함&quot;&gt;분산 운영체제의 결함&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;링크 결함&lt;/strong&gt; - 두 개의 사이트 간에 연결이 잘못되어 발생하는 결함&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;사이트 결함&lt;/strong&gt; - 사이트 자체에서 발생할 수 있는 결함&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메시지의 분실&lt;/strong&gt; - 통신 회선을 통해 해당 사이트로 메시지가 전달되는 과정에서 시간 지연이나 다른 이유로 메시지를 잃어버리는 결함&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-운영체제의-위상&quot;&gt;분산 운영체제의 위상&lt;/h3&gt;
&lt;h4 id=&quot;성형-연결star-connected-구조&quot;&gt;성형 연결(Star Connected) 구조&lt;/h4&gt;
&lt;p&gt;각 노드가 점 대 점 형태로 중앙 컴퓨터에 연결되고 중앙 컴퓨터를 경유한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제어가 집중되고 모든 동작이 중앙 컴퓨터에 의해 감시&lt;/li&gt;
  &lt;li&gt;중앙 컴퓨터에 과부하가 걸리면 성능이 현저히 감소&lt;/li&gt;
  &lt;li&gt;중앙 컴퓨터에 장애가 발생되면 전체 시스템 마비&lt;/li&gt;
  &lt;li&gt;한 노드의 고장은 다른 노드에 영향을 주지 않는다&lt;/li&gt;
  &lt;li&gt;터미널의 증가에 따라 통신 회선 수도 증가&lt;/li&gt;
  &lt;li&gt;최소 두 개의 노드만 사용할 수 있으므로 통신 비용이 저렴&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;환형-연결ring-connected-구조&quot;&gt;환형 연결(Ring Connected) 구조&lt;/h4&gt;
&lt;p&gt;각 사이트는 정확히 다른 두 사이트와 물리적으로 연결되어 있는 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정보 전달 방향은 단방향 혹은 양방향일 수 있다&lt;/li&gt;
  &lt;li&gt;기본 비용은 사이트의 수에 비례&lt;/li&gt;
  &lt;li&gt;메시지가 링을 순환할 경우 통신 비용은 증가&lt;/li&gt;
  &lt;li&gt;근거리 네트워크 구조로 가장 많이 채택&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;다중-접근-버스-연결multi-access-bus-connected-구조&quot;&gt;다중 접근 버스 연결(Multi-access Bus Connected) 구조&lt;/h4&gt;
&lt;p&gt;공유되는 하나의 버스가 시스템 내의 모든 노드와 연결되어 있는 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;한 사이트의 고장은 나머지 사이트들 간의 통신에 아무런 영향을 주지 않는다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;버스에 이상이 생기면 전체 시스템이 마비&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;한 시점에 단지 하나의 전송&lt;/strong&gt;만이 가능&lt;/li&gt;
  &lt;li&gt;처리기나 기타 장치의 증설 절차가 &lt;strong&gt;단순&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;버스의 사용을 위한 &lt;strong&gt;경쟁 상태&lt;/strong&gt;가 발생하여 시스템 성능의 심각한 저해를 가져올 수 있다&lt;/li&gt;
  &lt;li&gt;시스템의 전체 통신량이 전송률에 의한 제한을 받는다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;완전-연결fully-connected-구조&quot;&gt;완전 연결(Fully Connected) 구조&lt;/h4&gt;
&lt;p&gt;네트워크의 각 사이트는 시스템 내의 다른 모든 사이트와 직접 연결된 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본 &lt;strong&gt;비용이 매우 높다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;사이트 간의 메시지는 매우 &lt;strong&gt;빠르게 전달&lt;/strong&gt; 가능&lt;/li&gt;
  &lt;li&gt;하나의 링크가 고장나도 다른 링크를 이용할 수 있으므로 &lt;strong&gt;신뢰성이 우수&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;부분-연결partially-connected-구조&quot;&gt;부분 연결(Partially Connected) 구조&lt;/h4&gt;
&lt;p&gt;시스템 내의 사이트 간에만 부분적으로 연결된 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본 비용이 완전 연결보다는 낮다&lt;/li&gt;
  &lt;li&gt;메시지 전달이 중간 사이트를 경유할 수 있으므로 늦어질 수 있다&lt;/li&gt;
  &lt;li&gt;완전 연결에 비해 신뢰성이 낮다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;계층-연결hierarchy-connected-구조&quot;&gt;계층 연결(Hierarchy Connected) 구조&lt;/h4&gt;
&lt;p&gt;사이트들이 트리 형태로 구성된 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;루트 사이트와 서브 사이트가 존재&lt;/li&gt;
  &lt;li&gt;루트 사이트를 제외한 다른 사이트는 하나의 부모 사이트와 여러 개의 자식 사이트를 갖는다&lt;/li&gt;
  &lt;li&gt;마지막 사이트를 제외한 사이트의 고장은 &lt;strong&gt;자식 사이트의 중단을 초래&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분산-운영체제의-투명성transparency&quot;&gt;분산 운영체제의 투명성(Transparency)&lt;/h3&gt;
&lt;p&gt;네트워크 상에 분산된 컴퓨팅 자원을 여러 다른 컴퓨터에서 이용하는 기술로써 중앙집중형과 달리 네트워크 상에 여러 컴퓨팅 플랫폼에 프로세스를 분산시키고, 분산된 프로세스를 &lt;strong&gt;논리적으로 마치 하나의 프로세스처럼 수행하도록 하는 기술&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;위치 투명성&lt;/strong&gt;&lt;br /&gt;
사용자가 원하는 파일이나 데이터베이스, 프린터 등의 자원들이 지역 컴퓨터 또는 네트워크 내의 다른 원격지 컴퓨터에 존재하더라도 &lt;strong&gt;위치에 관계없이 그의 사용을 보장&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이주 투명성&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;자원들이 이동하여도&lt;/strong&gt; 사용자는 자원의 이름이나 위치를 &lt;strong&gt;고려할 필요가 없다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;복제 투명성&lt;/strong&gt;&lt;br /&gt;
사용자에게 통보없이 파일들과 자원들의 &lt;strong&gt;부가적인 복사를 자유롭게&lt;/strong&gt; 할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;병행(동시) 투명성&lt;/strong&gt;&lt;br /&gt;
다중 사용자들이 자원을 자동으로 공유할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;병렬 투명성&lt;/strong&gt;&lt;br /&gt;
몇 개의 처리기가 사용되는지 알 필요가 없다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;접근 투명성&lt;/strong&gt;&lt;br /&gt;
각 프로세서의 로그인처럼 지역이나 원격 자원에 접근할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;성능 투명성&lt;/strong&gt;&lt;br /&gt;
여러 부하에 대해 성능을 증가시키기 위해 시스템을 재구성할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;규모 투명성&lt;/strong&gt;&lt;br /&gt;
시스템이나 응용프로그램이 시스템 구조나 응용 알고리즘에 대한 변경없이 규모에 따라 확장이 가능하다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;고장 투명성&lt;/strong&gt;&lt;br /&gt;
분산 시스템 내의 구성요소(트랜잭션, DBMS, 네트워크, 컴퓨터)가 장애를 발생시켜도 영속성을 제공할 수 있다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스레드thread&quot;&gt;스레드(Thread)&lt;/h2&gt;
&lt;p&gt;어떠한 프로그램 내에서, 특히 프로세스 내에서 &lt;strong&gt;실행되는 흐름의 단위&lt;/strong&gt;를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 &lt;strong&gt;둘 이상의 스레드를 동시&lt;/strong&gt;에 실행할 수 있다. 이러한 실행 방식을 &lt;strong&gt;멀티스레드&lt;/strong&gt;(Multithread)라고 한다.&lt;/p&gt;

&lt;p&gt;스레드는 &lt;strong&gt;순차적 실행&lt;/strong&gt;과 프로세스 상태 &lt;strong&gt;전이의 병렬성&lt;/strong&gt;을 접속하기 위해 개발되었다. 다중 프로그래밍 기법에서 여러 개의 프로세스는 하나의 시스템을 공유한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;단일 프로세스를 다수의 스레드로 생성하여 &lt;strong&gt;병행성을 증진&lt;/strong&gt;시킬 수 있다&lt;/li&gt;
  &lt;li&gt;실행 환경을 공유시켜 &lt;strong&gt;기억 장소의 낭비가 줄어든다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;프로세스의 생성이나 문맥 교환 등의 &lt;strong&gt;오버헤드를 줄여&lt;/strong&gt; 운영체제의 성능을 향상&lt;/li&gt;
  &lt;li&gt;프로세스 내부에 포함되는 스레드는 공통적으로 &lt;strong&gt;접근 가능한 기억 장치를 통해 효율적으로 통신&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;스레드를 사용하면 하드웨어, 운영체제의 성능과 응용프로그램의 처리율을 향상시클 수 있다&lt;/li&gt;
  &lt;li&gt;하나의 프로세스에 여러 개의 스레드가 존재&lt;/li&gt;
  &lt;li&gt;스레드는 동일 프로세스 환경에서 &lt;strong&gt;서로 독립적인 다중 수행이 가능&lt;/strong&gt;하다&lt;/li&gt;
  &lt;li&gt;스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당한다&lt;/li&gt;
  &lt;li&gt;생성된 프로세스가 자신을 생성한 프로세스의 텍스트와 데이터 영역을 그대로 공유하고 &lt;strong&gt;스택만 따로 갖는&lt;/strong&gt; 새로운 프로세스 모델이다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;커널사용자-수준의-스레드&quot;&gt;커널/사용자 수준의 스레드&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;사용자 수준&lt;/th&gt;
      &lt;th&gt;커널 수준&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;- 커널 개입이 작다&lt;br /&gt;- 런 타임 시스템이 필요하다&lt;br /&gt;- 속도가 빠르다&lt;br /&gt;- 문맥 교환이 적다&lt;br /&gt;- 독자적 알고리즘이 필요&lt;br /&gt;- 대형 시스템에 적당&lt;br /&gt;- 구현이 어렵다&lt;br /&gt;- 커널을 스스로 호출하지 못한다&lt;br /&gt;- CPU 사용을 해제하지 못하면 시스템이 중단&lt;/td&gt;
      &lt;td&gt;- 커널 개입이 크다&lt;br /&gt;- 런 타임 시스템이 필요없고 커널이 직접한다&lt;br /&gt;- 속도가 느리다&lt;br /&gt;- 문맥 교환이 많다&lt;br /&gt;- 독자적 알고리즘이 필요 없다&lt;br /&gt;- 대형 시스템에 부적합&lt;br /&gt;- 구현이 쉽다&lt;br /&gt;- 커널을 스스로 호출한다&lt;br /&gt;- CPU 사용을 해제하지 못하면 운영체제가 지원한다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Wed, 21 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-computer-system/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-computer-system/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 파일 시스템</title>
        <description>&lt;h2 id=&quot;파일-시스템&quot;&gt;파일 시스템&lt;/h2&gt;
&lt;p&gt;컴퓨터 시스템의 &lt;strong&gt;편리한 사용을 위해 정보를 저장하고 관리&lt;/strong&gt;하는 시스템&lt;/p&gt;

&lt;p&gt;저장 장치의 &lt;strong&gt;물리적인 특성을 고려하여 논리적으로 저장하고 사용&lt;/strong&gt;하는 체계&lt;/p&gt;

&lt;p&gt;컴퓨터에서 사용되는 파일들을 다루는 운영체제의 파일 관리 체계&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;성능 판단 요소
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;소멸성(Volatility)&lt;/strong&gt; - 파일의 추가나 삭제의 빈도수&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;활성율(Activity)&lt;/strong&gt; - 주어진 시간에 접근한 파일 레코드의 백분율&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;크기(Size)&lt;/strong&gt; - 저장된 정보의 양&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일 시스템 요구사항
    &lt;ul&gt;
      &lt;li&gt;대량의 정보를 파일로 저장할 수 있어야 한다&lt;/li&gt;
      &lt;li&gt;파일로 저장된 정보가 사용 중에 파괴되어서는 안 된다&lt;/li&gt;
      &lt;li&gt;하나 이상의 프로세스가 공동으로 사용할 수 있어야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일 시스템 기능
    &lt;ul&gt;
      &lt;li&gt;사용자가 파일을 &lt;strong&gt;생성, 변경, 제거&lt;/strong&gt;할 수 있다&lt;/li&gt;
      &lt;li&gt;파일 간의 정보 &lt;strong&gt;전송&lt;/strong&gt;을 할 수 있어야 한다&lt;/li&gt;
      &lt;li&gt;파일을 &lt;strong&gt;공유&lt;/strong&gt;한다&lt;/li&gt;
      &lt;li&gt;여러 종류의 &lt;strong&gt;접근 제어 방법&lt;/strong&gt;을 제공&lt;/li&gt;
      &lt;li&gt;다양한 응용 처리 수행&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;백업 및 복구&lt;/strong&gt; 수행&lt;/li&gt;
      &lt;li&gt;사용자가 물리적 이름을 사용하는 대신 &lt;strong&gt;기호형 이름을 사용&lt;/strong&gt;하여 자신의 파일을 참조할 수 있도록 &lt;strong&gt;장치 독립성 제공&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파일-구조&quot;&gt;파일 구조&lt;/h2&gt;
&lt;h3 id=&quot;순차-접근-파일sequential-access-file&quot;&gt;순차 접근 파일(Sequential Access File)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/sequential-access-file.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/sequential-access-file.png&quot; alt=&quot;&quot; title=&quot;순차 접근 파일&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;입력되는 데이터의 논리적인 순서에 따라 물리적으로 연속적인 위치에 기록하는 파일 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;저장 &lt;strong&gt;매체의 효율이 높다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;물리적으로 연속적인 저장이 되기 때문에 &lt;strong&gt;접근 시간이 가장 빠르다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;특정한 데이터를 &lt;strong&gt;검색하는데 비교 횟수가 많아&lt;/strong&gt;지므로 &lt;strong&gt;검색 시간이 느리다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;저장 정보를 따로 구성하지 않아도 되므로 &lt;strong&gt;공간의 낭비가 없다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;구현이 쉽기&lt;/strong&gt; 때문에 어떤 매체라도 쉽게 사용 가능&lt;/li&gt;
  &lt;li&gt;대화식 처리보다 &lt;strong&gt;일괄 처리에 적합&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;순차 파일은 테이프를 모형화한 것이다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;직접-접근-파일direct-access-file&quot;&gt;직접 접근 파일(Direct Access File)&lt;/h3&gt;
&lt;p&gt;데이터 내의 키 필드를 &lt;strong&gt;해싱 사상 함수에 의해 물리적인 주소로 변환&lt;/strong&gt;하여 데이터를 기록하거나 검색하는 방식의 파일&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DASD(Direct Access Storage Device)의 물리적 주소를 통하여 직접 액세스&lt;/li&gt;
  &lt;li&gt;특정 레코드를 검색하기 위하여 키와 보조 기억 장치 사이의 물리적인 주소로 변환할 수 있는 &lt;strong&gt;사상 함수(Mapping Function)가 필요&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;해싱 사상 함수&lt;/strong&gt;를 사용하므로 &lt;strong&gt;검색 속도가 가장 빠르다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;한 번 파일을 개방&lt;/strong&gt;하면 읽거나 쓰기를 &lt;strong&gt;자유롭게 가능&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;어떤 레코드라도 &lt;strong&gt;평균 접근 시간 내에 접근 가능&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;키 변환법에 따라 &lt;strong&gt;공간의 낭비를 초래&lt;/strong&gt;할 수 있다&lt;/li&gt;
  &lt;li&gt;일반적으로 디스크 기억 장치에 많이 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;색인-순차-접근-파일isam-indexed-sequential-access-file&quot;&gt;색인 순차 접근 파일(ISAM, Indexed Sequential Access File)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/indexed-sequential-access-file.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/indexed-sequential-access-file.png&quot; alt=&quot;&quot; title=&quot;색인 순차 접근 파일&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;순차 파일과 직접 파일에서 지원하는 편성 방법이 결합된 형태로 순차 처리와 직접 처리가 모두 가능한 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디스크 기억 장치에 많이 이용&lt;/li&gt;
  &lt;li&gt;각 레코드는 레코드 키 값에 따라 논리적으로 배열&lt;/li&gt;
  &lt;li&gt;시스템은 각 레코드의 실제 주소가 저장된 인덱스를 관리한다&lt;/li&gt;
  &lt;li&gt;순차 접근과 직접 접근을 병행할 수 있기 때문에 &lt;strong&gt;융통성이 우수&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;레코드를 &lt;strong&gt;추가 및 삽입하는 경우, 파일 전체를 복사할 필요가 없다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;실제 데이터 처리 외에 &lt;strong&gt;인덱스를 처리하는 추가적인 시간&lt;/strong&gt;이 소모되므로 파일 처리 &lt;strong&gt;속도가 느리다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;인덱스를 저장하기 위한 공간과 오버플로 처리를 위한 &lt;strong&gt;별도의 공간이 필요하므로 기억 공간의 낭비&lt;/strong&gt;가 있다&lt;/li&gt;
  &lt;li&gt;파일을 구성하는 블록의 번호는 절대 블록 번호여야 사용자가 자신의 파일이 아닌 부분에 접근하는 것을 방지할 수 있다&lt;/li&gt;
  &lt;li&gt;파일이 정렬되어 있어야 하므로 &lt;strong&gt;추가, 삭제가 많으면 효율이 낮아&lt;/strong&gt;진다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;삽입, 삭제가 많아&lt;/strong&gt;지면 파일에 대한 &lt;strong&gt;재편성&lt;/strong&gt;이 이뤄져야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;인덱스와 순차 데이터 파일을 구성하는 방법에 따라 정적 인덱스 방법과 동적 인덱스 방법으로 구분되며, 탐색 횟수를 줄이기 위해서 다단계 인덱스를 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ISAM(Index Sequential Access Method)&lt;/strong&gt;&lt;br /&gt;
데이터 파일에 레코드가 삽입되거나 삭제될 때 인덱스의 내용은 변하지만 &lt;strong&gt;인덱스 구조 자체는 변경되지 않는&lt;/strong&gt; 방법으로 &lt;strong&gt;정적 인덱스&lt;/strong&gt; 방법이라고도 한다
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;기본 데이터 구역(Prime Data Area)&lt;/strong&gt; : 실제 데이터가 기록된 구역&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;3단계 색인 구역(Index Area)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;Master Index&lt;/strong&gt; : 실린더 색인 구역의 정보가 많을 경우 그것을 일정한 크기의 블록으로 구성하는데 이 때 해당 레코드가 어느 실린더 색인 구역에 기록되어 있는 지를 기록하는 색인&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Cylinder Index&lt;/strong&gt; : 각 트랙 색인의 최대키 값과 해당 레코드가 기록된 실린더의 정보가 기록되는 색인으로 한 파일당 한 개씩 만들어진다&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Track Index&lt;/strong&gt; : 처리할 레코드가 실제로 어느 트랙에 기록되어 있는지를 판별하는 구역&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;오버플로 구역(Overflow Area)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;Cylinder Overflow&lt;/strong&gt; : 각 실린더마다 만들어지는 오버플로 구역으로 해당 실린더의 기본 구역에서 오버플로된 데이터를 기록&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Independent Overflow&lt;/strong&gt; : 실린더 오버플로 구역에 더 이상 오버플로된 데이터를 기록할 수 없을 때 사용할 수 있는 예비 공간으로 실린더 오버플로 구역과는 별도로 만들어진다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;VSAM(Virtual Storage Access Method)&lt;/strong&gt;&lt;br /&gt;
인덱스나 데이터 파일을 블록으로 구성하고 각 블록에는 추가로 &lt;strong&gt;삽입될 레코드를 감안하여 빈 공간을 미리 예비&lt;/strong&gt;해두는 방법으로 &lt;strong&gt;동적 인덱스&lt;/strong&gt; 방법이라고도 한다
    &lt;ul&gt;
      &lt;li&gt;제어 구간(Control Interval) : 데이터 레코드가 저장되는 부분&lt;/li&gt;
      &lt;li&gt;제어 구역(Control Area) : 몇 개의 제어 구간을 모아 놓은 구역&lt;/li&gt;
      &lt;li&gt;순차 세트(Sequence Set) : 제어 구역에 대한 인덱스를 저장하는 구역&lt;/li&gt;
      &lt;li&gt;인덱스 세트(Index Set) : 순차 세트의 상위 요소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파일-제어-블록fcb-file-control-block-file-descriptor&quot;&gt;파일 제어 블록(FCB, File Control Block, File Descriptor)&lt;/h2&gt;
&lt;p&gt;파일을 관리하기 위해 운영체제가 필요로 하는 정보를 갖고 있는 제어 블록으로 파일마다 독립적으로 갖고 있다. 프로세스가 필요에 따라 파일을 Open하면 FCB의 항목은 주기억 장치로 옮겨진다. FCB는 운영체제 시스템에 따라 다른 자료 구조를 가질 수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일명&lt;/li&gt;
  &lt;li&gt;보조 기억 장치의 파일 위치&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;파일의 구조&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;보조 기억 장치 유형&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;접근 제어 정보&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;파일 유형&lt;/li&gt;
  &lt;li&gt;제거 시기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;생성 날짜, 시간&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;제거 날짜&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최종 수정 날짜&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;접근 횟수&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;파일의-디스크-공간-할당과-회수&quot;&gt;파일의 디스크 공간 할당과 회수&lt;/h2&gt;
&lt;p&gt;파일의 데이터를 디스크에 물리적으로 저장하고 삭제하는 방법을 의미&lt;/p&gt;

&lt;h3 id=&quot;연속-블록-할당contiguous-block-allocation&quot;&gt;연속 블록 할당(Contiguous Block Allocation)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/contiguous-block-allocation.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/contiguous-block-allocation.png&quot; alt=&quot;&quot; title=&quot;연속 블록 할당&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;물리적으로 연속적인 공간에 저장되고 &lt;strong&gt;저장할 크기를 미리 지정&lt;/strong&gt;하는 방식으로 파일마다 &lt;strong&gt;크기가 다르고&lt;/strong&gt; &lt;strong&gt;추가, 삭제가 빈번히 발생&lt;/strong&gt;할 경우에 &lt;strong&gt;단편화 현상이 많이 발생&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;따라서 디스크 활용을 최대화하기 위한 &lt;strong&gt;통합, 집약, Garbage Collection 필요&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일의 크기보다 큰 연속 공간이 없을 경우에는 파일을 생성할 수 없다&lt;/li&gt;
  &lt;li&gt;다중 프로그래밍에 적용하기 어렵다&lt;/li&gt;
  &lt;li&gt;가상 기억 장치를 응용하여 사용할 수 없다&lt;/li&gt;
  &lt;li&gt;용적률이 줄어든다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;불연속-블록-할당링크-블록-할당&quot;&gt;불연속 블록 할당(링크 블록 할당)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/link-block-allocation.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/link-block-allocation.png&quot; alt=&quot;&quot; title=&quot;링크 블록 할당&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;디스크 공간을 일정한 길이를 갖는 &lt;strong&gt;단위(섹터/블록)로 나누어 할당&lt;/strong&gt;하는 기법. 분할된 영역은 독립적으로 취급되며 파일의 데이터들은 분할된 영역에 &lt;strong&gt;순차적, 분산적으로 저장&lt;/strong&gt;할 수 있는 방법이다. 분할 저장된 파일의 각 데이터들은 파일 Open 시에 &lt;strong&gt;연결된 정보를 이용해 사용&lt;/strong&gt;된다.&lt;/p&gt;

&lt;p&gt;실제 데이터를 저장하는 공간 외에 분할된 정보와 파일의 연결된 데이터 정보를 저장해야 하는 영역이 필요하므로 &lt;strong&gt;부가적인 저장 공간&lt;/strong&gt;이 연속 블록 할당보다는 많이 사용되고 그에 따른 &lt;strong&gt;구현 방법도 복잡&lt;/strong&gt;하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;섹터 단위&lt;/strong&gt;&lt;br /&gt;
디스크 섹터 단위로 파일의 데이터가 분산되어 저장되며 각 섹터는 연결 리스트 구조 형태로 연결. 파일의 크기가 커지면 비어있는 섹터를 사용하고 작아지면 사용하지 않은 섹터를 반납한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;블록 단위&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;블록 체인 기법&lt;/strong&gt; : 여러 개의 섹터를 묶은 블록을 체인처럼 연결한 방식&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;인덱스 블록 체인 기법&lt;/strong&gt; : 인덱스에 블록의 주소를 링크시켜 사용 - Unix&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;블록 단위 파일 사상 기법&lt;/strong&gt; : 파일 정보의 해당 블록을 사상시켜 연결하여 사용한다 - Windows, MS-DOS&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일의 크기보다 큰 연속 공간이 없을 경우라도 파일을 생성할 수 있다&lt;/li&gt;
  &lt;li&gt;다중 프로그래밍에 유용하게 사용&lt;/li&gt;
  &lt;li&gt;가상 기억 장치를 응용하여 사용&lt;/li&gt;
  &lt;li&gt;용적률이 좋아진다&lt;/li&gt;
  &lt;li&gt;액세스 시간이 증가한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;디렉터리&quot;&gt;디렉터리&lt;/h2&gt;
&lt;p&gt;파일 시스템 내부에 있는 기능으로 디스크 내에 존재하는 많은 파일을 쉽게 사용(저장/검색/관리)할 수 있도록 하는 조직화된 기법&lt;/p&gt;

&lt;h3 id=&quot;단일-단계-디렉터리&quot;&gt;단(일) 단계 디렉터리&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/single-level-directory.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/single-level-directory.png&quot; alt=&quot;&quot; title=&quot;단일 단계 디렉터리&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디렉터리 시스템에 보관된 모든 파일의 정보를 포함해야 한다&lt;/li&gt;
  &lt;li&gt;파일이 같은 디렉터리 내에 있어야 하므로 &lt;strong&gt;유일한 파일명&lt;/strong&gt;으로 작성해야 한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;파일명의 길이를 제한&lt;/strong&gt;한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-단계-디렉터리&quot;&gt;2 단계 디렉터리&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/two-level-directory.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/two-level-directory.png&quot; alt=&quot;&quot; title=&quot;2 단계 디렉터리&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;중앙에 &lt;strong&gt;마스터 디렉터리&lt;/strong&gt;가 존재하며 그 아래 &lt;strong&gt;사용자 디렉터리&lt;/strong&gt;가 있는 구조&lt;/li&gt;
  &lt;li&gt;다른 사용자와의 &lt;strong&gt;파일 공유가 어렵다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;파일명의 길이가 길어 사용하기 매우 어렵다&lt;/li&gt;
  &lt;li&gt;2단계 이상으로 깊어지면 트리 구조 디렉터리가 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;트리-구조-디렉터리&quot;&gt;트리 구조 디렉터리&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/tree-structured-directory.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/tree-structured-directory.png&quot; alt=&quot;&quot; title=&quot;트리 구조 디렉터리&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나의 루트 디렉터리와 여러 개의 부 디렉터리로 구성&lt;/li&gt;
  &lt;li&gt;부 디렉터리는 그 하위로 또 다른 디렉터리를 구성할 수 있다&lt;/li&gt;
  &lt;li&gt;각 디렉터리의 생성과 파괴가 용이&lt;/li&gt;
  &lt;li&gt;동일한 이름의 여러 디렉터리 생성이 가능&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Unix&lt;/strong&gt;, &lt;strong&gt;MS-DOS&lt;/strong&gt;, &lt;strong&gt;Windows&lt;/strong&gt; 운영체제에서 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비순환주기-그래프-디렉터리&quot;&gt;비순환(주기) 그래프 디렉터리&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/acyclic-graph-directory.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/acyclic-graph-directory.png&quot; alt=&quot;&quot; title=&quot;비순환 그래프 디렉터리&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본적으로 트리 구조와 유사하나 &lt;strong&gt;사이클을 허용하지 않는다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;하나의 파일이나 디렉터리를 &lt;strong&gt;상위 디렉터리에서 공유할 수 없다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;링크 수만큼 파일을 공유하고 있으며 &lt;strong&gt;링크 수가 0이면 완전히 제거할 수 있다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;하나의 파일을 여러 사용자가 공유하기 때문에 &lt;strong&gt;삭제 시 문제점이 많이 발생&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;융통성이 있으며 기억 공간을 절약할 수 있으나 복잡하다&lt;/li&gt;
  &lt;li&gt;공용된 파일이나 디렉터리는 물리적으로 한 개만 존재한다&lt;/li&gt;
  &lt;li&gt;하나의 파일이 다수의 이름으로 존재할 수 있다&lt;/li&gt;
  &lt;li&gt;공유하고 있는 파일 제거 시 &lt;strong&gt;Dangling Pointer&lt;/strong&gt;(사용할 수 없는 해제된 주소를 가리키는 것)가 발생할 수 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Unix&lt;/strong&gt; 운영체제에서 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;일반-그래프-디렉터리&quot;&gt;일반 그래프 디렉터리&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/general-graph-directory.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/general-graph-directory.png&quot; alt=&quot;&quot; title=&quot;일반 그래프 디렉터리&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;사이클을 인정&lt;/strong&gt;하므로 파일 접근이 용이하다&lt;/li&gt;
  &lt;li&gt;그래프 탐색 알고리즘이 간단&lt;/li&gt;
  &lt;li&gt;하나의 파일이나 디렉터리를 상위 디렉터리에서 &lt;strong&gt;공용&lt;/strong&gt;할 수 있다&lt;/li&gt;
  &lt;li&gt;상위 파일이나 디렉터리를 자신의 파일이나 하위 디렉터리로 구성할 수 있다&lt;/li&gt;
  &lt;li&gt;파일을 제거하기 위한 Garbage-Collection을 위한 &lt;strong&gt;참조 계수기&lt;/strong&gt;가 필요&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 20 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-file-system/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-file-system/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 디스크 관리</title>
        <description>&lt;h2 id=&quot;디스크-구조&quot;&gt;디스크 구조&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/disk-structure.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/disk-structure.png&quot; alt=&quot;&quot; title=&quot;디스크 구조&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Track(트랙)&lt;/strong&gt;&lt;br /&gt;
디스크의 회전축을 중심으로 데이터가 기록되는 동심원으로 디스크의 종류마다 개수가 다르다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Sector(섹터)&lt;/strong&gt;&lt;br /&gt;
하나의 트랙을 몇 개로 분할한 블록으로 한 개의 섹터는 보통 512~1024Byte 용량으로 기록할 수 있다. &lt;strong&gt;데이터를 기록하는 단위를 클러스터&lt;/strong&gt;라고 하며 1개 또는 여러 개의 섹터로 구성된다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IPL(Initial Program Loader)&lt;/strong&gt;&lt;br /&gt;
디스크 드라이브가 디스크에 접근할 때 디스크의 물리적인 정보를 제공하는 것으로 보통 &lt;strong&gt;부트 섹터&lt;/strong&gt;라고 한다.&lt;/p&gt;

    &lt;p&gt;이 섹터에는 다음의 정보를 가진다&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;부팅 시스템의 위치&lt;/li&gt;
      &lt;li&gt;제작사 명칭&lt;/li&gt;
      &lt;li&gt;버전&lt;/li&gt;
      &lt;li&gt;섹터 당 바이트 수&lt;/li&gt;
      &lt;li&gt;클러스터 당 섹터 수&lt;/li&gt;
      &lt;li&gt;FAT의 수&lt;/li&gt;
      &lt;li&gt;FAT에 할당된 섹터 수&lt;/li&gt;
      &lt;li&gt;디스크면 수 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FAT(File Allocation Table)&lt;/strong&gt;&lt;br /&gt;
사용자가 해당 블록의 포인트를 &lt;strong&gt;실수로 지워지게 하는 것을 예방&lt;/strong&gt;하고 &lt;strong&gt;블록 접근을 빠르게&lt;/strong&gt; 하기 위하여 &lt;strong&gt;포인터를 모아 놓은 곳&lt;/strong&gt;으로 디스크 데이터 영역에 위치를 1:1로 사상한 정보들을 갖고 있다&lt;/p&gt;

    &lt;p&gt;보통 2개 이상의 복사본을 갖고 있으며, 디스크에 문제가 발생하면 언제든지 &lt;strong&gt;복사본을 이용해 복구&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Directory&lt;/strong&gt;&lt;br /&gt;
디스크에 저장된 파일의 기본적인 정보를 수록하는 공간으로 다음 정보를 가진다&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;파일명&lt;/li&gt;
      &lt;li&gt;파일 속성&lt;/li&gt;
      &lt;li&gt;작성 날짜&lt;/li&gt;
      &lt;li&gt;작성 시간&lt;/li&gt;
      &lt;li&gt;파일 위치&lt;/li&gt;
      &lt;li&gt;파일의 크기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;디스크-접근-시간&quot;&gt;디스크 접근 시간&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/disk-access-time.png&quot; title=&quot;http://osr507doc.sco.com/en/PERFORM/disk_IO_mech.html&quot;&gt;&lt;img src=&quot;../../assets/images/OS/disk-access-time.png&quot; alt=&quot;&quot; title=&quot;디스크 접근 시간&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;탐색 시간(Seek Time)&lt;/strong&gt;&lt;br /&gt;
디스크 상의 원하는 &lt;strong&gt;데이터를 액세스&lt;/strong&gt;하기 위해 &lt;strong&gt;트랙 또는 실린더에 헤드를 위치&lt;/strong&gt;시키는데 소요되는 시간을 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;회전 지연 시간(Latency Time&lt;/strong&gt;, Rotational Delay, RPM 지연 시간)&lt;br /&gt;
지정된 &lt;strong&gt;트랙에 위치한 헤드가 원하는 섹터에 도달하는데 소요&lt;/strong&gt;되는 시간&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;전송 시간(Transmission Time)&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;디스크로부터 주기억 장치로 데이터가 이동&lt;/strong&gt;하는 시간&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;디스크-스케줄링&quot;&gt;디스크 스케줄링&lt;/h2&gt;
&lt;p&gt;디스크에 존재하는 파일의 데이터들은 연속되지 않은 많은 섹터에 저장되어 있다. 물리적으로 회적하는 디스크에서 어떻게 하면 신속하게 많은 양의 데이터를 가져오느냐를 운영체제는 고민하고 계획하는 과정을 의미&lt;/p&gt;

&lt;p&gt;디스크는 &lt;strong&gt;한쪽 방향으로 회전시키면서 사용해야 기계적인 부담이 없다&lt;/strong&gt;. 회전 지연 시간이 빠르다해서 디스크를 양쪽 방향으로 회전시킨다면 디스크 드라이브는 오래 사용할 수 없을 것이다.&lt;/p&gt;

&lt;p&gt;해당 섹터에서 데이터를 주기적 장치로 가져오는 &lt;strong&gt;전송 시간&lt;/strong&gt;은 &lt;strong&gt;CPU의 성능과 관계&lt;/strong&gt;가 있으므로 &lt;strong&gt;스케줄링의 영향을 받지 못&lt;/strong&gt;한다. 따라서 디스크 상의 원하는 데이터를 액세스하기 위해 트랙 또는 실린더에 헤드를 위치시키는데 걸리는 &lt;strong&gt;탐색 시간을 중심&lt;/strong&gt;으로 스케줄링을 수행한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;목적
    &lt;ul&gt;
      &lt;li&gt;처리량을 최대화&lt;/li&gt;
      &lt;li&gt;응답 시간을 최소화&lt;/li&gt;
      &lt;li&gt;응답 시간의 편차를 최소화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;디스크-스케줄링-종류&quot;&gt;디스크 스케줄링 종류&lt;/h3&gt;
&lt;h4 id=&quot;fcfsfirst-come-first-served-fifo&quot;&gt;FCFS(First Come First Served, FIFO)&lt;/h4&gt;
&lt;p&gt;가장 간단한 스케줄링 형태로 대기 큐에 들어온 작업에 CPU를 할당하는 기법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;도착 순서에 따라 실행 순서가 고정된다는 점에서 공평하다&lt;/li&gt;
  &lt;li&gt;요청한 순서대로 진행하기 때문에 순서가 변경되는 일이 없다&lt;/li&gt;
  &lt;li&gt;디스크의 부하가 적을 때 유리&lt;/li&gt;
  &lt;li&gt;디스크의 부하가 커지면 응답 시간이 길어진다&lt;/li&gt;
  &lt;li&gt;탐색 시간을 최적화하려는 시도가 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sstfshortest-seek-time-first&quot;&gt;SSTF(Shortest Seek Time First)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/disk-scheduling-sstf.png&quot; title=&quot;https://webeduclick.com/disk-scheduling-algorithms-with-examples/&quot;&gt;&lt;img src=&quot;../../assets/images/OS/disk-scheduling-sstf.png&quot; alt=&quot;&quot; title=&quot;SSTF 스케줄링&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;헤드의 탐색 거리가 가장 짧은 요청을 먼저 서비스하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;가운데 트랙&lt;/strong&gt;이 안쪽이나 바깥쪽보다 &lt;strong&gt;서비스받을 확률이 높다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;헤드에서 멀리 떨어진 요청은 &lt;strong&gt;기아 상태가 발생&lt;/strong&gt;할 수 있다&lt;/li&gt;
  &lt;li&gt;FCFS보다 처리량이 많고 &lt;strong&gt;평균 응답 시간이 짧다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;처리량이 많기 때문에 &lt;strong&gt;일괄 처리에 적합&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;응답 시간의 편차가 크기 때문에 &lt;strong&gt;대화형 시스템에는 부적합&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;scan&quot;&gt;SCAN&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/disk-scheduling-scan.png&quot; title=&quot;https://anupambhaglania.blogspot.com/2013/11/scan-scheduling_24.html&quot;&gt;&lt;img src=&quot;../../assets/images/OS/disk-scheduling-scan.png&quot; alt=&quot;&quot; title=&quot;SCAN 스케줄링&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SSTF의 문제점인 응답 시간의 편차를 극복&lt;/strong&gt;하기 위해 Denning이 개발한 방법으로 헤드가 디스크 표면을 양방향(안쪽/바깥쪽)으로 이동하면서 I/O 요청을 서비스. 이 때 헤드는 이동하는 방향의 앞쪽에 I/O 요청이 없을 경우에만 후퇴가 가능하다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;진행 방향상의 &lt;strong&gt;가장 짧은 거리에 있는 요청을 먼저&lt;/strong&gt; 수행&lt;/li&gt;
  &lt;li&gt;진행 방향으로 &lt;strong&gt;끝까지&lt;/strong&gt; 진행&lt;/li&gt;
  &lt;li&gt;부하가 적은 경우 가장 좋은 결과&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;c-scan&quot;&gt;C-SCAN&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/disk-scheduling-c-scan.png&quot; title=&quot;https://www.gatevidyalay.com/c-scan-disk-scheduling-disk-scheduling/&quot;&gt;&lt;img src=&quot;../../assets/images/OS/disk-scheduling-c-scan.png&quot; alt=&quot;&quot; title=&quot;C-SCAN 스케줄링&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SCAN의 문제점인 안쪽과 바깥쪽의 차별 대우를 모두 없애&lt;/strong&gt;기 위해 항상 &lt;strong&gt;바깥쪽 실린더에서 안쪽&lt;/strong&gt;으로 움직이면서 가장 짧은 탐색 시간을 가진 요청을 우선 서비스&lt;/p&gt;

&lt;p&gt;헤드는 트랙의 안쪽으로 한방향으로만 이동하며 안쪽에 &lt;strong&gt;더 이상 I/O 요청이 없으면 다시 바깥쪽&lt;/strong&gt;에서 안쪽으로 이동하면서 I/O 요청을 서비스한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;안쪽 방향으로 끝까지 진행&lt;/li&gt;
  &lt;li&gt;응답 시간의 편차가 매우 작다&lt;/li&gt;
  &lt;li&gt;부하가 많을 경우 C-SCAN 기법이 가장 좋은 결과를 가진다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;look--c-look&quot;&gt;LOOK / C-LOOK&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/disk-scheduling-look.png&quot; title=&quot;https://www.tutorialandexample.com/look-disk-scheduling/&quot;&gt;&lt;img src=&quot;../../assets/images/OS/disk-scheduling-look.png&quot; alt=&quot;&quot; title=&quot;LOOK 스케줄링&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SCAN과 C-SCAN은 헤드를 디스크의 끝까지 이동한다. 요청이 없는 경우에도 끝까지 진행한다는 것은 시간 낭비이다.&lt;/p&gt;

&lt;p&gt;따라서 헤드는 각 방향으로 요청에 따르는 거리만큼을 이동하고, 현재 방향에서 더 이상의 요청이 없다면 헤드의 이동 방향이 바뀌는 방법이 효과적이다&lt;/p&gt;

&lt;p&gt;SCAN, C-SCAN에서 이런 형태를 추가한 것이 LOOK, C-LOOK이다. &lt;strong&gt;진행 방향에 더 이상의 요청이 있는지를 확인&lt;/strong&gt;한다는 의미로 “&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOOK&lt;/code&gt;“이란 단어를 사용하였다. 엘리베이터 운행 방식과 동일하여 &lt;strong&gt;엘리베이터 스케줄링&lt;/strong&gt;이라고도 한다&lt;/p&gt;

&lt;h4 id=&quot;n-step-scan&quot;&gt;N-Step SCAN&lt;/h4&gt;
&lt;p&gt;어떤 방향의 진행이 시작될 당시 대기 중이던 요청들만 서비스하고, 진행 도중 도착한 요청들은 한데 모아서 다음 진행 때 최적으로 서비스할 수 있도록 배열된다.&lt;/p&gt;

&lt;p&gt;대기 중에 있는 요청들을 1차적으로 받아서 진행시키고, &lt;strong&gt;진행을 시작하고 들어온 요청은 받아들이지 않는다&lt;/strong&gt;. &lt;strong&gt;진행이 모두 끝나고 난 후에 2차적으로 서비스&lt;/strong&gt;한다&lt;/p&gt;

&lt;h4 id=&quot;eschenbach에센바흐&quot;&gt;Eschenbach(에센바흐)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;부하가 매우 큰 항공 예약 시스템&lt;/strong&gt;을 위해 개발되었으며 &lt;strong&gt;탐색 시간&lt;/strong&gt;뿐만 아니라 &lt;strong&gt;회전 지연 시간&lt;/strong&gt;의 &lt;strong&gt;최적화&lt;/strong&gt;를 위해 개발된 기법&lt;/p&gt;

&lt;p&gt;헤드는 C-SCAN처럼 움직이며 예외적으로 모든 실런더는 그 실린더에 요청이 있거나 없어도 전체 트랙이 한 바퀴 회전할 동안의 서비스를 받는다. 탐색 시간, 회전 지연 시간을 모두 고려해서 개발된 스케줄링이나 디스크 드라이브의 물리적인 성질 때문에 오히려 &lt;strong&gt;응답시간이 늘어나서 거의 사용하지 않는 기법&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;sector-queuing-sltfshortest-latency-time-first&quot;&gt;Sector Queuing, SLTF(Shortest Latency Time First)&lt;/h4&gt;
&lt;p&gt;탐색 시간과 &lt;strong&gt;회전 지연 시간&lt;/strong&gt;을 줄이는 스케줄링.&lt;/p&gt;

&lt;p&gt;회전 지연 시간을 최적화하기 위한 스케줄링 기법은 탐색 시간이 필요하지 않는 &lt;strong&gt;고정 헤드 디스크&lt;/strong&gt; 시스템이나 &lt;strong&gt;트랙마다 헤드를 갖는 드럼&lt;/strong&gt; 등의 보조 기억 장치에서 사용&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-disk-management/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-disk-management/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 기억 장치의 관리 전략</title>
        <description>&lt;h1 id=&quot;기억-장치-관리-전략의-종류&quot;&gt;기억 장치 관리 전략의 종류&lt;/h1&gt;
&lt;h2 id=&quot;반입-전략fetch-strategy&quot;&gt;반입 전략(Fetch Strategy)&lt;/h2&gt;
&lt;p&gt;프로그램/데이터를 주기억 장치로 가져오는 시기를 결정하는 전략(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;When&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;요구demand-반입&quot;&gt;요구(Demand) 반입&lt;/h3&gt;
&lt;p&gt;요구가 있을 때마다 주기억 장치로 옮기는 방식(응용 프로그램을 실행하는 것은 사용자의 요구에 의해 주기억 장치에 적재하는 것)&lt;/p&gt;

&lt;h3 id=&quot;예상anticipatory반입&quot;&gt;예상(Anticipatory)반입&lt;/h3&gt;
&lt;p&gt;앞으로 요구될 가능성이 큰 데이터 또는 프로그램을 예상하여 주기억 장치로 미리 옮기는 방법&lt;/p&gt;

&lt;p&gt;가상 기억 장치를 사용하게 될 때 주로 사용되며 자주 사용하는 페이지는 미리 주기억 장치에 가져다 놓는다(&lt;strong&gt;워킹 셋, Working Set&lt;/strong&gt;). 앞으로 사용할 가능성이 높은 페이지를 가져다 놓는다(&lt;strong&gt;지역성, Locality&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;예상이 성공하면 프로그램의 &lt;strong&gt;실행 속도가 빨라&lt;/strong&gt;지지만 &lt;strong&gt;실패하면 오버헤드가 발생&lt;/strong&gt;한다&lt;/p&gt;

&lt;h2 id=&quot;배치-전략placement-strategy&quot;&gt;배치 전략(Placement Strategy)&lt;/h2&gt;
&lt;p&gt;주기억 장치에 프로그램/데이터의 위치를 정하는 전략(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Where&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/placement-strategy.png&quot; title=&quot;https://www.researchgate.net/profile/Qasim-Hussein/publication/279060822_Operating_system_questions_with_their_answers_Memory_management_Virtual_memory_Processes_synchronization_Part_two/links/5589610308ae273b2876b4c6/Operating-system-questions-with-their-answers-Memory-management-Virtual-memory-Processes-synchronization-Part-two.pdf&quot;&gt;&lt;img src=&quot;../../assets/images/OS/placement-strategy.png&quot; alt=&quot;&quot; title=&quot;배치 전략 종류&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;최초-적합first-fit&quot;&gt;최초 적합(First Fit)&lt;/h3&gt;
&lt;p&gt;입력된 작업을 주기억 장치 내에서 &lt;strong&gt;작업을 수용할 수 있는 첫 번째 공백&lt;/strong&gt;에 배치&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;초기 &lt;strong&gt;결정력이 가장 빠르나&lt;/strong&gt;, 내부 단편화의 크기에 상관없이 &lt;strong&gt;단편화가 많이 발생&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;최적-적합best-fit&quot;&gt;최적 적합(Best Fit)&lt;/h3&gt;
&lt;p&gt;입력된 작업을 주기억 장치 내의 공백 중에서 &lt;strong&gt;작업에 가장 잘 맞는 공백&lt;/strong&gt;에 배치(주기억 장치 내의 여러 공백에 대해서 &lt;strong&gt;프로세스 크기를 차감하여 그 결과값이 가장 작은&lt;/strong&gt; 공백에 배치)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내부 &lt;strong&gt;단편화가 가장 적게 발생&lt;/strong&gt;하나, &lt;strong&gt;검색 시간이 길어&lt;/strong&gt; 결정력이 가장 느리다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;최악-적합worst-fit&quot;&gt;최악 적합(Worst Fit)&lt;/h3&gt;
&lt;p&gt;입력된 작업을 주기억 장치 내에서 가장 잘 맞지 않는 공백에 배치(주기억 장치 내의 여러 공백 각각에 대해서 &lt;strong&gt;프로세스 크기를 차감하여 그 결과값이 가장 큰 공백에 배치&lt;/strong&gt;)&lt;/p&gt;

&lt;h2 id=&quot;교체재배치-전략replacement-strategy&quot;&gt;교체(재배치) 전략(Replacement Strategy)&lt;/h2&gt;
&lt;p&gt;주기억 장치 내의 빈 공간 확보를 위해 제거할 프로그램/데이터를 선택하는 전략(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;What/How&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;optoptimal-replacement-최적&quot;&gt;OPT(OPTimal Replacement, 최적)&lt;/h3&gt;
&lt;p&gt;페이지 사용 횟수를 정확히 예측하여 교체하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;앞으로 가장 오랫동안 사용되지 않을 페이지와 교체한다(이론상 페이지 부재 횟수가 가장 적으므로 성공률이 크다)&lt;/li&gt;
  &lt;li&gt;Belady의 알고리즘으로 &lt;strong&gt;가장 이상적이지만 실현 가능성이 희박&lt;/strong&gt;하다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fifofirst-input-first-out&quot;&gt;FIFO(First Input First Out)&lt;/h3&gt;
&lt;p&gt;주기억 장치에 들어와 있는 페이지에 &lt;strong&gt;타임 스탬프&lt;/strong&gt;를 찍어 그 시간을 기억하고 있다가 가장 &lt;strong&gt;먼저 들어와 있던 페이지를 교체&lt;/strong&gt;하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주기억 장치 내에 &lt;strong&gt;가장 오래된 페이지와 교체&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;알고리즘이 가장 &lt;strong&gt;간단&lt;/strong&gt;하지만 &lt;strong&gt;페이지 교체가 가장 많다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Belady 모순&lt;/strong&gt; : 프로세스에 할당된 페이지 프레임 수가 증가하면 페이지 부재의 수가 감소하는 것이 당연하지만 &lt;strong&gt;페이지 프레임 수가 증가&lt;/strong&gt;할 때, 오히려 현실적으로 &lt;strong&gt;페이지 부재가 더 증가&lt;/strong&gt;하는 모순 현상이 발생한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lruleast-recently-used&quot;&gt;LRU(Least Recently Used)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;참조된 지 가장 오래된 페이지&lt;/strong&gt;를 대체 대상으로 선정하여 현 시점에서 가장 오랫동안 사용하지 않은 페이지와 교체한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 페이지마다 &lt;strong&gt;계수기(시간 기억 영역)&lt;/strong&gt;를 두어 사용하는 기법&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lfuleast-frequently-used&quot;&gt;LFU(Least Frequently Used)&lt;/h3&gt;
&lt;p&gt;페이지별로 사용된 횟수를 기억할 참조 변수를 확보한 후에 페이지가 참조될 때마다 1씩 증가한다. 주기억 장치에 기억된 페이지 중 하나를 교체하려고 할 때 참조 변수에 기억된 값이 가장 적은 페이지를 교체 대상으로 선정하는 기법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;사용한 횟수&lt;/strong&gt;가 &lt;strong&gt;가장 적은&lt;/strong&gt; 페이지와 교체&lt;/li&gt;
  &lt;li&gt;사용한 횟수가 기억될 &lt;strong&gt;참조 변수&lt;/strong&gt;를 각 페이지에 두어 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nurnot-used-recently&quot;&gt;NUR(Not Used Recently)&lt;/h3&gt;
&lt;p&gt;페이지 당 두 개의 &lt;strong&gt;정보비트(참조 비트, 변형 비트)&lt;/strong&gt;를 이용하여 교체하는 방법&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;참조 비트&lt;/strong&gt;는 &lt;strong&gt;해당 페이지를 호출했는가를 파악&lt;/strong&gt;하는 비트이고, &lt;strong&gt;변형 비트&lt;/strong&gt;는 &lt;strong&gt;주기억 장치 내에 있던 페이지를 사용&lt;/strong&gt;했는가의 의미로 사용하는 비트이다. 비트 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;이면 &lt;strong&gt;최근에&lt;/strong&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;이면 &lt;strong&gt;오래전&lt;/strong&gt;으로 판단한다&lt;/p&gt;

&lt;h3 id=&quot;pffpage-fault-frequently&quot;&gt;PFF(Page Fault Frequently)&lt;/h3&gt;
&lt;p&gt;자주 사용하는 페이지들은 주기억 장치에 미리 적재하여 페이지 폴트가 최소가 되도록 해야 한다.&lt;/p&gt;

&lt;p&gt;자주 사용하는 페이지의 집합을 &lt;a href=&quot;/study/os-memory/#작업-집합working-set&quot;&gt;&lt;strong&gt;워킹 셋&lt;/strong&gt;&lt;/a&gt;이라고 하는데 PFF는 워킹 셋에 존재하는 페이지들을 관찰하여 최근에 자주 사용되고 있지 않은 페이지와 &lt;strong&gt;워킹 셋에 속하지 않은 페이지&lt;/strong&gt; 중에 &lt;strong&gt;최근에 자주 사용하는 페이지와 교체&lt;/strong&gt;하여 교체 효율을 향상시키는 기법&lt;/p&gt;

&lt;h3 id=&quot;second-chancefifo의-2차-기회-부여&quot;&gt;Second Chance(FIFO의 2차 기회 부여)&lt;/h3&gt;
&lt;p&gt;가장 먼저 입력되었던 페이지를 제거 대상으로 삼는 &lt;strong&gt;FIFO의 단점을 보완&lt;/strong&gt;한 것으로 가장 오래된 페이지를 제거하기 전에 &lt;strong&gt;한 번의 기회를 더 주는&lt;/strong&gt; 방식&lt;/p&gt;

&lt;p&gt;각 페이지에 프레임을 &lt;strong&gt;FIFO 순&lt;/strong&gt;으로 유지시키면서 LRU 근사 알고리즘처럼 &lt;strong&gt;참조 비트&lt;/strong&gt;를 갖게 한다. 또한 가장 오래된 페이지를 다시 &lt;strong&gt;처음에 입력된 페이지로 되돌리기 위해서는 LRU의 계수기를 필요&lt;/strong&gt;로 하게 된다.
(&lt;strong&gt;FIFO + LRU&lt;/strong&gt;)&lt;/p&gt;

&lt;h2 id=&quot;주기억-장치의-할당과-회수&quot;&gt;주기억 장치의 할당과 회수&lt;/h2&gt;
&lt;p&gt;주기억 장치에 프로그램이 적재될 때 빈 공간이 있는지 또는 크기는 어느 정도인지 우선 파악해야 한다. 이러한 &lt;strong&gt;정보를 파악하여 표시&lt;/strong&gt;해두면 프로그램이 &lt;strong&gt;신속하게 적재&lt;/strong&gt;할 수 있게 된다&lt;/p&gt;

&lt;h3 id=&quot;비트-맵bit-map&quot;&gt;비트 맵(Bit Map)&lt;/h3&gt;
&lt;p&gt;분할된 기억 장치 영역의 &lt;strong&gt;정보를 0(사용하지 않음),1(영역 사용중)&lt;/strong&gt;로 구분하며 &lt;strong&gt;분할된 블록의 크기가 크면 비트 맵 용량이 줄어&lt;/strong&gt;든다&lt;/p&gt;

&lt;p&gt;사용되지 않는 영역이 있거나 단편화가 발생해도 &lt;strong&gt;합병, 집약이 어려우며&lt;/strong&gt; 사용 여부를 알아내기 위해 &lt;strong&gt;순차 검색만을 수행&lt;/strong&gt;하므로 검색 &lt;strong&gt;속도가 느리다&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;연결된-리스트linked-list&quot;&gt;연결된 리스트(Linked List)&lt;/h3&gt;
&lt;p&gt;분할된 영역의 정보를 구조적인 변수로 확보하여 동적인 연결 구조인 링크드 리스트 구조로 관리&lt;/p&gt;

&lt;p&gt;구조적 변수의 항목으로 P(프로그램이 존재, Process), H(비어 있음, Hole), 시작 위치, 크기, 연결 정보로 구성&lt;/p&gt;

&lt;p&gt;배치 전략에서 사용하기 적합하며 &lt;strong&gt;추가 삭제가 용이하므로 통합, 압축에 효과&lt;/strong&gt;적으로 이용될 수 있지만 &lt;strong&gt;검색 속도는 비트 맴보다 다소 느리다&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;버디-시스템buddy-system&quot;&gt;버디 시스템(Buddy System)&lt;/h3&gt;
&lt;p&gt;큰 버퍼들을 반복적으로 반으로 나누어 작은 버퍼들을 만들며(버디 : 버퍼가 나누어질 때 각 공간을 의미), 가능할 때마다 인접한 자유로운 버퍼들을 합치는 과정을 반복(&lt;strong&gt;2의 거듭제곱 값으로 메모리를 할당&lt;/strong&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;약간의 &lt;strong&gt;외부 단편화와 메모리 간결화를 하는 오버헤드&lt;/strong&gt;를 가지고 있다&lt;/li&gt;
  &lt;li&gt;요청된 메모리가 &lt;strong&gt;작은 블록보다 조금 더 크면 메모리가 낭비&lt;/strong&gt;된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기억-장치의-주소-사상-방법&quot;&gt;기억 장치의 주소 사상 방법&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/address-mapping.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/address-mapping.png&quot; alt=&quot;&quot; title=&quot;기억 장치의 주소 사상 방법&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;블록 사상(페이지, 세그먼트) 주소 양식
    &lt;blockquote&gt;
      &lt;p&gt;V = (B, D)&lt;br /&gt;
B: Page, Segment 번호&lt;br /&gt;
D: Displacement(Offset)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;블록페이지-세그먼트-주소-사상-기법-종류&quot;&gt;블록(페이지, 세그먼트) 주소 사상 기법 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;직접 사상(Direct Mapping)&lt;/strong&gt;&lt;br /&gt;
페이지 번호와 변위로 구성된 가상 주소 중 페이지 번호로 페이지 사상 표에서 구한 실기억 장치의 주소와 가상 주소 중의 변위를 실제 주소로 변환하는 방법을 갖는 페이지 사상 기법&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;모든 페이지 항목은 페이지 사상 테이블에 존재&lt;/li&gt;
      &lt;li&gt;총 2번의 메모리 접근이 필요(주소 변환에 시간을 많이 소비하게 되는 방식)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;연관 사상(Associative Mapping)&lt;/strong&gt;&lt;br /&gt;
직접 사상은 페이지의 분할 개수가 많을수록 해당 페이지를 검색하는 시간이 많은 소요되며, 프로그램을 가상 기억 장치로 실행하게 될 때 페이지 교체 속도가 늦어져 전체 프로그램 실행 속도에 영향을 주게 된다&lt;/p&gt;

    &lt;p&gt;이러한 단점을 보완하기 위해 &lt;strong&gt;고속의 연관 메모리에 자주 사용하는 페이지만&lt;/strong&gt; 혹은 현재 적재된 페이지 만을 기억시켜 속도를 향상시키는 방법&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;매핑된 값들을 캐쉬 메모리에 저장(프로세스 번호, 페이지 번호, 매칭된 메인 메모리의 주소가 함께 매칭되어 입력)&lt;/li&gt;
      &lt;li&gt;연관 기억장치에 저장한 연관 사상표를 이용&lt;/li&gt;
      &lt;li&gt;빠른 주소 변환 수행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;연관/직접 사상(Set Associative Mapping)&lt;/strong&gt;&lt;br /&gt;
연관 사상 기법으로 사용하게 될 때 모든 페이지의 정보를 기억하려면 값비싼 고속의 메모리를 많이 사용해야 하므로 비용의 낭비가 많다. 따라서 &lt;strong&gt;우선 연관 사상 기법&lt;/strong&gt;으로 해당 페이지를 찾고, &lt;strong&gt;페이지가 존재하지 않으면 직접 사상 기법&lt;/strong&gt;으로 검색하여 사용하는 방법&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;저렴한 비용으로 캐쉬나 연관 기억 장치의 장점을 이용하는 방식&lt;/li&gt;
      &lt;li&gt;국부성에 근거하여 최근에 가장 많이 참조된 페이지만 유지&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 18 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-memory-strategy/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-memory-strategy/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 기억 장치</title>
        <description>&lt;h1 id=&quot;기억-장치&quot;&gt;기억 장치&lt;/h1&gt;
&lt;h2 id=&quot;기억-장치-계층-구조&quot;&gt;기억 장치 계층 구조&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/memory-structure.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/memory-structure.png&quot; alt=&quot;&quot; title=&quot;기억 장치 계층 구조&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;기억-장치의-사용-용도&quot;&gt;기억 장치의 사용 용도&lt;/h2&gt;
&lt;h3 id=&quot;가상-기억-장치virtual-memory&quot;&gt;가상 기억 장치(Virtual Memory)&lt;/h3&gt;
&lt;p&gt;프로그램 전체가 주기억 장치에 상주하면서 실행되는 것보다는 느리겠지만 &lt;strong&gt;주기억 장치를 효과적으로 사용&lt;/strong&gt;할 수 있다는 측면에서는 최고의 기술이며 현재 대부분 이러한 방식을 채택하고 있다&lt;/p&gt;

&lt;h3 id=&quot;가상-디스크virual-disk&quot;&gt;가상 디스크(Virual Disk)&lt;/h3&gt;
&lt;p&gt;보조 기억 장치인 디스크 기술이 발전되기 전에는 &lt;strong&gt;주기억 장치의 일부를 디스크 드라이브로 분리&lt;/strong&gt;하여 디스크처럼 사용했던 기술로, MS-DOS에서는 주기억 장치에 가상 디스크를 만들어 하드 디스크처럼 활용할 수 있게 하는 장치 제어기로 RAMDRIVE.SYS를 사용하며 지금은 보통 고장한 하드 디스크를 복구할 때 주로 사용&lt;/p&gt;

&lt;h3 id=&quot;인터리빙interleaving&quot;&gt;인터리빙(Interleaving)&lt;/h3&gt;
&lt;p&gt;주기억 장치의 &lt;strong&gt;액세스 속도를 빠르게&lt;/strong&gt; 하기 위한 기술로 기억 장치의 &lt;strong&gt;연속된 위치를 서로 다른 뱅크로 구성&lt;/strong&gt;하여 하나의 주소로 여러 개의 위치에 해당하는 기억 장치를 접근할 수 있도록 하는 방법&lt;/p&gt;

&lt;p&gt;하나의 장치가 독립적인 기능을 하는 다른 장치의 상태를 검사할 수 있도록 허가하는 기법을 &lt;strong&gt;Polling&lt;/strong&gt;이라 한다&lt;/p&gt;

&lt;h3 id=&quot;dmadirect-memory-access&quot;&gt;DMA(Direct Memory Access)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;사이클 스틸링&lt;/strong&gt;&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt;(Cycle Stealing) 기법을 사용하여 &lt;strong&gt;중앙 처리 장치를 거치지 않고&lt;/strong&gt; 직접 &lt;strong&gt;주기억 장치와 주변 장치 사이에서 데이터를 주고받는&lt;/strong&gt; 입출력 제어기로 입출력에 대한 CPU의 부담을 줄이는 동시에 액세스 속도를 향상시킨다&lt;/p&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;strong&gt;사이클 스틸링&lt;/strong&gt; : 중앙 처리 장치와 입출력 장치가 동시에 주기억 장치에 접근하려고 하는 경우, &lt;strong&gt;입출력 장치에 우선순위를 부여&lt;/strong&gt;하는 것으로 적은 양의 사이클을 필요로 하는 채널에 우선순위를 높여주면 입출력 장비의 효율이 높아진다.&lt;/p&gt;

&lt;h2 id=&quot;기억-장치의-관리-기법&quot;&gt;기억 장치의 관리 기법&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/memory-management.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/memory-management.png&quot; alt=&quot;&quot; title=&quot;기억 장치의 관리 기법 분류&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;주기억-장치의-다중-프로그래밍-사용-방식&quot;&gt;주기억 장치의 다중 프로그래밍 사용 방식&lt;/h3&gt;
&lt;p&gt;제한된 주기억 장치 크기에서 다중 프로그래밍을 원만히 수행하기 위해서는 크게 두 가지 전제 조건이 있어야 한다. 하나는 주기억 장치를 여러 개의 독립적인 프로그램으로 분리해서 사용할 수 있도록 &lt;strong&gt;주기억 장치를 분할&lt;/strong&gt;해야 한다는 것과 프로그램의 크기를 분할된 최대 크기보다 작거나 같도록 해야 한다는 것이다.&lt;/p&gt;

&lt;p&gt;프로그램의 크기가 제한이 없어진 것은 가상 기억 장치를 사용하면서부터였고 &lt;strong&gt;주기억 장치만을 사용하는 시기에는 크기에 제한&lt;/strong&gt;을 두었다.&lt;/p&gt;

&lt;h4 id=&quot;고정정적-분할&quot;&gt;고정(정적) 분할&lt;/h4&gt;
&lt;p&gt;주기억 장치의 크기를 다르게 분할하되 항상 고정된 크기를 갖는 형태로 분할하는 방식. 대부분 프로그램들의 크기가 다르기 때문에 분할된 영역의 크기는 항상 고정시키되 분할 크기를 다르게 하는 것이 유리하다.&lt;/p&gt;

&lt;p&gt;문제는 &lt;strong&gt;프로그램들의 크기와 분할된 주기억 장치의 크기가 항상 같을 수는 없다&lt;/strong&gt;는 것인데, 이런 크기 차이로 남거나 부족한 현상을 &lt;strong&gt;단편화&lt;/strong&gt;(Fragmentation)라고 하며 이렇게 단편화된 주기억 장치의 영역은 통합과 집약을 통해서 재사용되어야 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;내부(Internal) 단편화&lt;/strong&gt;&lt;br /&gt;
정해진 크기에 프로그램을 &lt;strong&gt;할당하고 남은 기억 공간&lt;/strong&gt;으로 사용되지 못하는 공간&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;외부(Eternal) 단편화&lt;/strong&gt;&lt;br /&gt;
정해진 크기는 아니지만, &lt;strong&gt;프로그램의 크기가 커서&lt;/strong&gt; 기억할 수 없게 된 공간&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;가변동적-분할&quot;&gt;가변(동적) 분할&lt;/h4&gt;
&lt;p&gt;고정 분할의 문제점을 보완한 방법으로 프로그램의 크기에 따라 주기억 장치 분할 크기를 동적으로 분할하는 방식.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;내부 단편화 현상은 발생하지 않지&lt;/strong&gt;만 &lt;strong&gt;외부 단편화는 계속 발생&lt;/strong&gt;하며 &lt;strong&gt;차폐 레지스터&lt;/strong&gt;의 값을 매번 변경해야 하기 때문에 고정 분할 방식보다 복잡하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;베이스 레지스터(Base Register)&lt;/strong&gt;&lt;br /&gt;
주기억 장치가 분할된 영역으로 나뉘어 관리될 때, 프로그램이 한 영역에서 &lt;strong&gt;다른 영역으로 옮겨지더라도 명령의 주소 부분을 바꾸지 않고 정상적으로 수행될 수 있도록&lt;/strong&gt; 하기 위한 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;차폐 레지스터(Fence Register)&lt;/strong&gt;&lt;br /&gt;
주기억 장치가 분할된 영역으로 나뉘어 관리될 때, 분할된 영역을 다른 프로그램이 사용하지 못하도록 분할 영역의 위치를 기억하고 있어야 한다. 이를 차폐 레지스터라고 하며 고정 분할일 경우에는 차폐 레지스터에 기억된 값이 변하지 않지만 가변 분할 방식에서는 동적으로 변하게 된다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;경계 레지스터(Boundary Register)&lt;/strong&gt;&lt;br /&gt;
주기억 장치가 분할된 영역으로 나뉘어 관리될 때, 주기억 장치 내에 존재하는 프로그램은 크게 운영체제와 사용자 영역에 존재하는 프로그램으로 나뉜다. 이 때 &lt;strong&gt;사용자 영역에 존재하는 프로그램이 운영체제 영역을 침범하지 못하도록&lt;/strong&gt; 하는 것이 경계 레지스터의 역할이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;기억 장치 보호 키(Storage Protection Key)&lt;/strong&gt;&lt;br /&gt;
기억 장치 관리 기법 중 &lt;strong&gt;세그먼트 기법&lt;/strong&gt;에서 사용하는 기억 장치 보호 방법이다. 주기억 장치 내에 하나의 프로그램이 여러 개의 &lt;strong&gt;분할된 프로그램 조각들로 분리&lt;/strong&gt;되어 사용할 때 여러 개의 분할된 프로그램 조각들은 &lt;strong&gt;같은 종류의 프로그램이라는 것을 표시&lt;/strong&gt;해야만 한다. 이러한 구분 표시는 &lt;strong&gt;다른 프로그램과 섞이지 않고 보호&lt;/strong&gt;하게 된다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;주기억-장치-재사용-기술&quot;&gt;주기억 장치 재사용 기술&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;통합(Coalescing)&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;인접한 공백들을 더 큰 하나의 공백&lt;/strong&gt;으로 만드는 과정으로 &lt;strong&gt;차폐 레지스터의 값을 변경&lt;/strong&gt;하여 분할 영역의 크기를 변경하게 된다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;집약(압축, Compaction)&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;서로 떨어져 있는 여러 개의 낭비 공간&lt;/strong&gt;을 모아서 하나의 큰 기억 공간을 만드는 과정으로 사용되지 않은 기억 장치를 주기억 장치의 한 쪽 끝으로 옮기는 것이다. 압축 후에는 하나의 커다란 공백이 생기게 된다. 디스크에서의 집약은 보통 &lt;strong&gt;Garbage-Collection&lt;/strong&gt;이라고 한다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;가상-기억-장치의-사용-방식&quot;&gt;가상 기억 장치의 사용 방식&lt;/h3&gt;
&lt;p&gt;보조 기억 장치를 주기억 장치처럼 사용하는 것으로, 주기억 장치보다 용량이 큰 프로그램도 처리가 가능하다. 프로그램을 여러 개의 작은 블록 단위로 나누어서 가상 기억 장치에 보관해 놓고 프로그램 실행 시 요구되는 블록만 주기억 장치에 불연속적으로 할당하여 처리한다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기억장치의 이용률&lt;/strong&gt;과 &lt;strong&gt;다중 프로그래밍의 효율&lt;/strong&gt;을 높일 수 있으며 프로그램 크기를 줄이지 않고 순차적으로 수행하는 기법인 &lt;strong&gt;오버레이 문제는 자동적으로 해결&lt;/strong&gt;되나 프로그램 실행 시 &lt;strong&gt;주소 변환 작업이 필요&lt;/strong&gt;하기 때문에 설계가 복잡하다&lt;/p&gt;

&lt;p&gt;가상 기억 장치를 이용하게 되는 것은 여러 개의 프로그램이 동시에 처리되는 다중 프로그래밍 방식에서 대부분 사용하므로 &lt;strong&gt;단일 프로그래밍에서 사용하는 방식은 무의미&lt;/strong&gt;하다&lt;/p&gt;

&lt;h3 id=&quot;가상-기억-장치의-다중-프로그래밍-사용-방식&quot;&gt;가상 기억 장치의 다중 프로그래밍 사용 방식&lt;/h3&gt;
&lt;h4 id=&quot;고정-분할paging&quot;&gt;고정 분할(Paging)&lt;/h4&gt;
&lt;p&gt;디스크에 존재하는 같은 크기로 분할된 프로그램, 즉 페이지와 주기억 장치에 분할된 영역과 페이지가 교체되면서 프로그램이 실행되는데 이러한 기술을 보통 페이지 기법 혹은 페이징이라 한다.&lt;/p&gt;

&lt;p&gt;페이지 기법의 기본적인 이점으로는 &lt;strong&gt;프로그램 크기에 제한이 없으며&lt;/strong&gt; 주기억 장치를 효율적으로 사용할 수 있다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;외부 단편화는 존재하지 않지&lt;/strong&gt;만 &lt;strong&gt;내부 단편화는 발생한다&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 크기가 &lt;strong&gt;작을 수록&lt;/strong&gt; &lt;i class=&quot;fas fa-search-minus&quot;&gt;&lt;/i&gt;
    &lt;ul&gt;
      &lt;li&gt;많은 페이지 사상 테이블 필요&lt;/li&gt;
      &lt;li&gt;내부 단편화는 줄어든다&lt;/li&gt;
      &lt;li&gt;자주 사용하는 페이지의 집합을 효율적으로 운영할 수 있다&lt;/li&gt;
      &lt;li&gt;특정한 참조 구역성만을 포함하기 때문에 기억 장치 효율이 높을 수 있다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;총 입출력 시간&lt;/strong&gt; 증가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;페이지 크기가 &lt;strong&gt;클 수록&lt;/strong&gt; &lt;i class=&quot;fas fa-search-plus&quot;&gt;&lt;/i&gt;
    &lt;ul&gt;
      &lt;li&gt;페이지 테이블의 크기가 작아지므로 주기억 장치의 공간이 절약&lt;/li&gt;
      &lt;li&gt;참조되는 정보와는 무관한 많은 양의 정보가 주기억 장치에 남는다&lt;/li&gt;
      &lt;li&gt;페이지 테이블이 복잡하지 않으므로 관리가 용이&lt;/li&gt;
      &lt;li&gt;디스크로부터 &lt;strong&gt;입출력 전송&lt;/strong&gt;에 소모되는 시간은 커진다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;동적-분할segmentation&quot;&gt;동적 분할(Segmentation)&lt;/h4&gt;
&lt;p&gt;프로그램을 &lt;strong&gt;여러 개의 다른 크기로 분할&lt;/strong&gt;하고 주기억 장치에서는 분할된 크기에 맞게 동적으로 분할하여 적재시키는 방법&lt;/p&gt;

&lt;p&gt;크기가 다른 모듈을 고정된 길이를 갖는 페이지로 구분하여 사용할 경우, 고정된 페이지의 크기보다 작거나 큰 모듈은 주기억 장치에서 사용하지 않는 부분이 많이 발생될 것이다. 이로 인해 메모리 효율과 전체적인 성능은 낮아진다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;세그먼트 사상 테이블&lt;/strong&gt;과 &lt;strong&gt;기억 장치 보호 키&lt;/strong&gt;가 필요하며 &lt;strong&gt;외부 단편화&lt;/strong&gt;만 발생한다. 세그먼트 기법에서 &lt;strong&gt;빈 공간이 생기는 현상을 체커 보딩(Checker-boarding)&lt;/strong&gt;이라 한다&lt;/p&gt;

&lt;p&gt;각 프로그램은 분할된 &lt;strong&gt;자신만의 영역이 없으&lt;/strong&gt;므로 다른 프로그램의 세그먼트들은 &lt;strong&gt;같은 기억 공간을 공유&lt;/strong&gt;한다&lt;/p&gt;

&lt;h2 id=&quot;가상-기억-장치-주요-기술&quot;&gt;가상 기억 장치 주요 기술&lt;/h2&gt;
&lt;h3 id=&quot;오버레이overlay&quot;&gt;오버레이(Overlay)&lt;/h3&gt;
&lt;p&gt;단일 사용자 시스템에서 프로그램의 크기가 주기억 장치의 용량보다 클 수 없다. 하지만 더 이상 사용하지 않는 프로그램을 보조 기억 장치로 옮긴 후 그 기억 공간을 다른 프로그램이 사용하게 하면 실제 영역보다 더 큰 프로그램을 실행할 수 있다. 오버레이는 &lt;strong&gt;분할된 프로그램들을 순차적으로 적재&lt;/strong&gt;하여 실행한다.&lt;/p&gt;

&lt;h3 id=&quot;스와핑swapping&quot;&gt;스와핑(Swapping)&lt;/h3&gt;
&lt;p&gt;실행되어야 할 작업의 크기가 커서 사용자 기억 공간에 수용될 수 없을 때 작업의 모든 부분들이 동시에 주기억 장치에 상주해 있을 필요가 없다. 이 때 &lt;strong&gt;작업을 분할하여 필요한 부분만 교체&lt;/strong&gt;하여 실행할 수 있다&lt;/p&gt;

&lt;h3 id=&quot;페이지-부재page-fault&quot;&gt;페이지 부재(Page Fault)&lt;/h3&gt;
&lt;p&gt;가상 기억 장치 시스템에서 가상 페이지 주소를 사용하여 데이터를 접근하는 프로그램이 실행될 때, 프로그램에서 &lt;strong&gt;접근하려고 하는 페이지가 주기억 장치에 있지 않은 경우 발생&lt;/strong&gt;하는 현상&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;실행하고자 하는 페이지가 주기억 장치 내에 존재하지 않는 경우 운영체제에게 &lt;strong&gt;트랩(Trap)&lt;/strong&gt;을 요청&lt;/li&gt;
  &lt;li&gt;운영체제는 현재 진행 중인 사용자 레지스트라와 프로그램 상태를 저장&lt;/li&gt;
  &lt;li&gt;현재 사용 가능한 페이지를 페이지 사상 테이블에서 검색&lt;/li&gt;
  &lt;li&gt;가상 기억 장치에 존재하는 해당 페이지를 주기억 장치로 가져온다&lt;/li&gt;
  &lt;li&gt;페이지 사상 테이블을 조정&lt;/li&gt;
  &lt;li&gt;프로그램 실행을 계속&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;스레싱thrashing&quot;&gt;스레싱(Thrashing)&lt;/h3&gt;
&lt;p&gt;다중 프로그래밍 시스템 또는 가상 기억 장치를 사용하는 시스템에서 하나의 프로세스가 작업 수행 과정 중 &lt;strong&gt;지나치게 페이지 부재가 발생&lt;/strong&gt;함으로 인하여 전체 &lt;strong&gt;시스템의 성능이 저하&lt;/strong&gt;되는 현상&lt;/p&gt;

&lt;h3 id=&quot;구역성locality&quot;&gt;구역성(Locality)&lt;/h3&gt;
&lt;p&gt;프로그램이 실행할 때 기억 장치 내의 모든 정보를 균일하게 참조하는 것이 아니라 어느 한 순간에 특정 부문을 집중적으로 참조하는 프로그램의 순차적인 성질.&lt;/p&gt;

&lt;p&gt;디스크로부터 주기억 장치에 읽어들일 수 있는 블록의 크기로 &lt;strong&gt;여러 개의 페이지를 주기억 장치에 가져올 수&lt;/strong&gt; 있다. 그중에 한 개의 페이지만이 필요하다면 이왕이면 &lt;strong&gt;앞으로 사용할 가능성이 높은 페이지들을 같이 읽어&lt;/strong&gt;들이는 것이 좋다는 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;시간(Temporal) 구역성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;최근에 참조된 기억 장소가 &lt;strong&gt;가까운 장래에도 계속 참조&lt;/strong&gt;될 가능성이 높음을 의미&lt;/li&gt;
      &lt;li&gt;반복, 부 프로그램, 스택, 집계 시 사용되는 변수들&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;공간(Spatial) 구역성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;하나의 기억 장소가 참조되면 그 &lt;strong&gt;근처의 기억 장소가 계속 참조&lt;/strong&gt;될 가능성이 높음을 의미&lt;/li&gt;
      &lt;li&gt;배열 순회, 프로그램의 순차적 코드 실행, 프로그램에서 관련된 변수들을 서로 근처에 선언하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;작업-집합working-set&quot;&gt;작업 집합(Working Set)&lt;/h3&gt;
&lt;p&gt;프로세스를 효과적으로 실행하기 위해서는 &lt;strong&gt;주기억 장치에 유지되어야 하는 페이지들의 집합&lt;/strong&gt;을 의미한다. 자주 참조되는 페이지의 집합은 &lt;strong&gt;주기억 장치에 미리 적재&lt;/strong&gt;해두면 &lt;strong&gt;페이지 폴트를 최소화&lt;/strong&gt;할 수 있고 효율적인 실행이 가능&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-memory/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-memory/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 병행 프로세스 동기화 유형</title>
        <description>&lt;h1 id=&quot;임계-구역critical-section&quot;&gt;임계 구역(Critical Section)&lt;/h1&gt;
&lt;p&gt;다중 프로그래밍 운영체제에서 한순간에 여러 개의 프로세스에 의하여 공유되는 데이터 및 자원에 대하여 &lt;strong&gt;반드시 하나의 프로세스에 의해서만 자원 또는 데이터가 사용되도록&lt;/strong&gt;하는 것으로 자원이 프로세스에 의하여 반납된 후, 비로소 다른 프로세스에서 자원을 이용하거나 데이터를 접근할 수 있도록 지정된 영역이다.&lt;/p&gt;

&lt;p&gt;하나의 컴퓨터 시스템에서 여러 개의 프로세스가 운영되고 있을 때 각 프로세스는 &lt;strong&gt;동시에 접근해서는 안 되는 공유 자원&lt;/strong&gt;을 임계 구역이라 할 수 있으며 여기에는 메모리, 프린터, 디스크, CD-ROM이 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;두 개 이상의 프로세스가 동시에 사용할 수 없다&lt;/li&gt;
  &lt;li&gt;순서를 지키면서 신속하게 사용&lt;/li&gt;
  &lt;li&gt;하나의 프로세스가 독점하게 해서는 안된다&lt;/li&gt;
  &lt;li&gt;사용 중에 중단, 무한 반복되어서는 안된다&lt;/li&gt;
  &lt;li&gt;인터럽트가 불가능한 상태로 만들어야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;상호-배제mutual-exclusion&quot;&gt;상호 배제(Mutual Exclusion)&lt;/h1&gt;
&lt;p&gt;임계 구역을 어느 시점에서 단지 &lt;strong&gt;한 개의 프로세스만이 사용할 수 있도록&lt;/strong&gt; 하며, 다른 프로세스가 현재 사용 중인 임계 구역에 대하여 &lt;strong&gt;접근하려고 할 때 금지하는 행위&lt;/strong&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상호배제&lt;/code&gt;라고 한다. 상호배제 알고리즘은 인터럽트 불능 처리, 잠금, 엄격한 교대, TSL, 세마포어 등이 있다&lt;/p&gt;

&lt;h2 id=&quot;상호-배제-알고리즘&quot;&gt;상호 배제 알고리즘&lt;/h2&gt;
&lt;h3 id=&quot;인터럽트-불능-처리&quot;&gt;인터럽트 불능 처리&lt;/h3&gt;
&lt;p&gt;하나의 프로세스가 하나의 공유 자원을 점유하게 되면 &lt;strong&gt;인터럽트를 발생하지 않도록 봉쇄&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;인터럽트를 봉쇄한다는 것은 현시점에서 어떠한 프로세스도 새롭게 &lt;strong&gt;자원을 점유하기 위한 시도를 할 수 없게 된다&lt;/strong&gt;는 의미히며 즉, 현재 공유 자원을 점유한 프로세스는 아무런 제약 없이 공유 자원을 사용하게 되므로 완벽한 상호배제를 할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 하나의 프로세스가 공유 자원을 점유하고 있는 동안 다른 프로세스는 아무런 작업을 할수 없는 상태이므로 &lt;strong&gt;시스템 효율이 매우 낮아진다&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;잠금lock&quot;&gt;잠금(Lock)&lt;/h3&gt;
&lt;p&gt;공유 자원을 점유하게 되는 경우 그 자원을 어떠한 프로세스도 접근하지 못하도록 하는 방법&lt;/p&gt;

&lt;p&gt;공유 자원을 점유하는 프로세스는 사용을 시작하면서 공유 자원에 접근하려는 모든 프로세스가 사용할 수 없도록 표시를 하게 된다. 이 때 이미 점유되어 있는 공유자원을 사용하기 위해 접근하고 있는 임의의 프로세스들은 표시를 계속 확인하게 되는데 이를 바쁜 대기(Busy Wait) 상태라고 한다&lt;/p&gt;

&lt;h3 id=&quot;엄격한-교대dekker-알고리즘&quot;&gt;엄격한 교대(Dekker 알고리즘)&lt;/h3&gt;
&lt;p&gt;두 개 이상의 프로세스가 &lt;strong&gt;교대로 공유 자원을 점유&lt;/strong&gt;하는 방식&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/dekker-algorithm.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/dekker-algorithm.png&quot; alt=&quot;&quot; title=&quot;데커 알고리즘&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;프로세스 A가 공유 자원을 점유하고 나면 프로세스 B는 프로세스 A가 사용 해제를 통보하길 기다렸다가 사용한다&lt;/p&gt;

&lt;p&gt;한쪽 프로세스가 점유 시간이 길어지면 나머지 프로세스는 사용 가능한가를 계속 감지하는 작업을 반복해야한다. 즉, &lt;strong&gt;바쁜 대기 현상은 계속 발생&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;하나의 프로세스가 &lt;strong&gt;우선권&lt;/strong&gt;을 갖게 해야 하며, 한쪽이 작업량이 많아서 빈번해져도 반드시 교대로 점유해야한다(하나의 프로세스를 &lt;strong&gt;연속적으로 재사용 불가&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;하나의 프로세스가 사용 중에 중단되면 다른 프로세스는 영원히 사용할 수 없는 &lt;strong&gt;교착상태&lt;/strong&gt;에 빠지게 된다&lt;/p&gt;

&lt;h3 id=&quot;tsltest--set-lock-명령어-기법&quot;&gt;TSL(Test &amp;amp; Set Lock) 명령어 기법&lt;/h3&gt;
&lt;p&gt;엄격한 교대의 문제점을 해결하는 방법으로 특수한 하드웨어 자원을 필요로 하지만, 바쁜 대기 상태는 완벽히 해결하지는 못한다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로세스 A,B 모두 각자의 변수 x,y를 갖게 되며 각 프로세스는 x,y값이 모두 0일 때 공유 자원을 사용할 수 있다&lt;/li&gt;
  &lt;li&gt;프로세스 A가 공유 자원을 사용하기 위해서는 y값이 0인가를 확인한다. y값이 1이라면 프로세스 B가 사용 중이다&lt;/li&gt;
  &lt;li&gt;프로세스 B가 공유 자원을 사용하기 위해서는 x값이 0인가를 확인한다. x값이 1이라면 프로세스 A가 사용 중이다&lt;/li&gt;
  &lt;li&gt;상대 프로세스가 가진 변수 값이 0인 경우에만 공유 자원을 점유할 수 있게 되고 점유하자마자 변수를 1로 변경하고 사용 후에는 0으로 변경한다&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Sleep() / Wakeup()&lt;/strong&gt;&lt;br /&gt;
TSL의 교착 상태와 바쁜 대기 현상의 단점 중 &lt;strong&gt;바쁜 대기의 문제점을 보완&lt;/strong&gt;한 방법&lt;/p&gt;

    &lt;p&gt;하나의 공유 자원을 점유하기 위한 시도를 반복하지 않고 사용하려는 공유 자원이 이미 &lt;strong&gt;사용 중이라면 프로세스를 잠시 중단하게 한다&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sleep&lt;/code&gt;, Wait, P, Down), 이후 어느 정도의 시간이 지나서 공유 자원이 사용 가능하다면 잠시 &lt;strong&gt;중단하고 있던 프로세스를 활성화&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Wakeup&lt;/code&gt;, Signal, V, Up)하여 바쁜 대기 현상을 방지하는 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;세마포어semaphore&quot;&gt;세마포어(Semaphore)&lt;/h1&gt;
&lt;p&gt;프로세스 간의 상호배제 및 동기화 문제 해결 방법&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P(S)&lt;/strong&gt;, &lt;strong&gt;V(S)&lt;/strong&gt; 연산을 통해서 프로세스 사이의 동기를 유지하고 상호배제의 원리 보장&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;이진 세마포어&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;세마포어 변수가 오직 &lt;strong&gt;0과 1값&lt;/strong&gt;을 가지며 하나의 임계 구역만을 상호배제하기 위한 알고리즘&lt;/li&gt;
      &lt;li&gt;잠금, 엄격한 교대, TSL&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;산술(계수형 세마포어)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;세마포어 변수가 &lt;strong&gt;0과 양의 정수&lt;/strong&gt;를 값으로 가지며 임계 구역을 여러 개 관리하기 위한 상호배제 알고리즘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 개의 프로세스가 동시에 그값을 수정하지 못한다&lt;/li&gt;
  &lt;li&gt;세마포어에 대한 연산은 처리 중에 인터럽트 되어서는 안된다&lt;/li&gt;
  &lt;li&gt;세마포어데 대한 연산은 소프트웨어나 하드웨어로 구현 가능&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt; 조작은 블록 큐에 &lt;strong&gt;대기 중인 프로세스를 깨우는 신호&lt;/strong&gt;로서, 흔히 &lt;strong&gt;Signal&lt;/strong&gt; 동작이라 한다&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; 조작은 임계 영역을 사용하려는 프로세서들의 &lt;strong&gt;진입 여부를 결정&lt;/strong&gt;하는 것으로, 흔히 &lt;strong&gt;Wait&lt;/strong&gt; 동작이라 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모니터monitor&quot;&gt;모니터(Monitor)&lt;/h1&gt;
&lt;p&gt;상호배제를 위한 데이터 및 프로그램 모듈로 운영체제 내부의 프로그램을 모니터라고 한다. 공유 자원을 사용하기 위해 기다리는 프로세스들은 모니터에 진입해도 좋다는 허가를 기다리며 모니터에서는 &lt;strong&gt;프로세스들의 공유 자원 점유 순서를 제어&lt;/strong&gt;한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;두 개 이상의 프로세스가 특정 공유 자원을 순차적으로 할당하는 데 필요한 데이터 및 프로시저를 포함하는 &lt;strong&gt;병행성 구조&lt;/strong&gt;(Concurrency Construct)이다&lt;/li&gt;
  &lt;li&gt;모니터 내의 자원을 원하는 프로세스는 반드시 해당 &lt;strong&gt;모니터의 진입부를 호출&lt;/strong&gt;해야 한다&lt;/li&gt;
  &lt;li&gt;모니터 외부의 프로세스는 모니터 &lt;strong&gt;내부의 데이터를 직접 접근 불가&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자료 추상화&lt;/strong&gt;와 &lt;strong&gt;정보 은폐&lt;/strong&gt;의 개념을 기초적으로 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스위치 개념&lt;/strong&gt;을 사용하여 한순간에 하나의 프로세스만이 모니터에 진입 가능&lt;/li&gt;
  &lt;li&gt;모니터에서 사용되는 &lt;strong&gt;연산은 Wait와 Signal&lt;/strong&gt;이 있다&lt;/li&gt;
  &lt;li&gt;모니터의 &lt;strong&gt;경계&lt;/strong&gt;에서 상호배제가 시행&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;교착상태dead-lock&quot;&gt;교착상태(Dead-Lock)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/deadlock.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/deadlock.png&quot; alt=&quot;&quot; title=&quot;교착상태(Deadlock)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;두 개 이상의 프로세스가 하나의 자원을 공유하여 사용하고 있을 때 &lt;strong&gt;서로가 사용 중인 자원을 요구&lt;/strong&gt;하지만 &lt;strong&gt;요구를 영원히 들어줄 수 없는&lt;/strong&gt; 상태를 의미&lt;/p&gt;

&lt;h2 id=&quot;교착상태-발생-필수-4대-요소&quot;&gt;교착상태 발생 필수 4대 요소&lt;/h2&gt;
&lt;h3 id=&quot;상호배제mutual-exclusion&quot;&gt;상호배제(Mutual Exclusion)&lt;/h3&gt;
&lt;p&gt;여러 개의 프로세스를 동시에 운영하는 다중 프로그래밍 방식에서는 &lt;strong&gt;제한된 자원을 서로 공유&lt;/strong&gt;하면서 효율적으로 사용해야 하기 때문에 상호배제를 해야 한다. 이러한 상호배제는 여러 개의 프로세스를 동시에 처리하기 위하여 공유 자원을 &lt;strong&gt;순차적 처리하면서, 동시에 접근하지 못하도록&lt;/strong&gt; 해야 한다.&lt;/p&gt;

&lt;p&gt;하지만, 이러한 상호배제가 실패하게 되면 교착상태가 발생할 수 있기 때문에 상호배제는 교착상태 발생의 필수 조건 중 하나가 된다&lt;/p&gt;

&lt;h3 id=&quot;점유와-대기hold--wait&quot;&gt;점유와 대기(Hold &amp;amp; Wait)&lt;/h3&gt;
&lt;p&gt;시스템의 성능을 높이기 위해서는 여러 개의 프로세스를 동시에 운영하면서 사용 중이거나 사용 중이 아닌 공유 자원들을 순차적으로 배분해 주어야 시스템 성능이 향상될 것이다&lt;/p&gt;

&lt;p&gt;따라서 점유와 대기는 존재할 수 밖에 없고 이는 교착상태 발생의 필수 조건 중 하나가 된다&lt;/p&gt;

&lt;h3 id=&quot;비선점non-preemption&quot;&gt;비선점(Non-Preemption)&lt;/h3&gt;
&lt;p&gt;비선점이란, 이미 사용 중인 공유 자원들을 빼앗을 수 없다는 의미&lt;/p&gt;

&lt;p&gt;하나의 프로세스가 특정 공유 자원을 사용하다가 프로그램 루틴의 문제로 임계 구역 내부에서 중단되었을 때 만약 이 자원을 빼앗을 수 없다면 이 자원을 사용하기 위해 대기 중이던 프로세스는 영원히 원하는 자원을 빼앗을 수 없다는 것은 비선점이고 이는 교착상태 발생의 필수 조건 중에 하나가 된다&lt;/p&gt;

&lt;h3 id=&quot;순환-대기circular-wait-환형-대기&quot;&gt;순환 대기(Circular Wait, 환형 대기)&lt;/h3&gt;
&lt;p&gt;공유 자원들을 프로세스에게 분배할 때 입력 순으로 순차적으로 분배한다면 시간이 오래 걸려 성능이 떨어질 뿐 교착상태는 발생하지 않을 것이다. 순차적으로 분배하지 않고 당장 사용하지 않는 자원은 다른 프로세스가 사용하게 한다면 자원을 효율적으로 사용하게 될 것이다.&lt;/p&gt;

&lt;p&gt;이처럼 모든 프로세스와 자원을 순차적으로 사용하지 않고 사용 시기와 순서를 융통성있게 조절하게 될 때 프로세스의 자원의 점유와 대기 상태는 환형 상태가 될 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;교착상태-해결-방안&quot;&gt;교착상태 해결 방안&lt;/h2&gt;
&lt;h3 id=&quot;예방prevention&quot;&gt;예방(Prevention)&lt;/h3&gt;
&lt;p&gt;교착상태가 &lt;strong&gt;절대 발생하지 않도록 사전에 조치를 취하는 방안이지만&lt;/strong&gt;, &lt;strong&gt;성능은 낮아&lt;/strong&gt;질 수 밖에 없다. 교착상태 발생의 &lt;strong&gt;네 가지 조건 중에서 하나를 제거&lt;/strong&gt;함으로서 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;상호배제 부정
&lt;strong&gt;단일 프로그램을 운영&lt;/strong&gt;하거나, &lt;strong&gt;자원을 독립적&lt;/strong&gt;으로 사용하여 임계 구역을 없애고 상호배제를 하지 않는다면 교착상태는 절대 발생하지 않는다. 하지만 &lt;strong&gt;자원의 낭비나 신뢰성이 낮아&lt;/strong&gt;지기 때문에 사용하기에 적절하지 않은 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;점유와 대기 부정
각 프로세스는 &lt;strong&gt;한 번에 자신에게 필요한 모든 자원을 요구&lt;/strong&gt;해야 하며, 이 요구가 &lt;strong&gt;만족되지 않으면 작업을 진행할 수 없다&lt;/strong&gt;. 또한 어떤 자원을 갖고 있는 프로세스가 더 이상 요구가 수용되지 않으면 원래 갖고 있던 자원을 일단 반납하고 필요하다면 다시 그 자원이나 다른 자원을 요구해야 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비선점 부정
프로세스가 점유하고 있는 자원들을 언제든 빼앗을 수 있도록 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순환 대기 부정
한 프로세스가 주어진 유형의 자원을 할당받았으면 그 프로세스는 순서에 따라 나중에 위치하는 유형의 자원말을 요구할 수 있게 한다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;모든 자원을 선형 순서로 분류&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;회피avoidance&quot;&gt;회피(Avoidance)&lt;/h3&gt;
&lt;p&gt;프로세스가 자원을 요구할 때 시스템이 안전(교착상태가 발생하지 않는 범위 내) 상태를 유지할 수 있는 프로세스의 자원 요구만을 할당해주는 방안&lt;/p&gt;

&lt;h4 id=&quot;은행원-알고리즘bankers-algorithm&quot;&gt;은행원 알고리즘(Banker’s Algorithm)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/banker-algorithm.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/banker-algorithm.png&quot; alt=&quot;&quot; title=&quot;은행원 알고리즘&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Dijkstra가 제안한 방식으로 &lt;strong&gt;불안전 상태&lt;/strong&gt;와 &lt;strong&gt;안전 상태&lt;/strong&gt;로 구분한다. &lt;strong&gt;안전 상태에서는 교착상태가 발생하지 않으며&lt;/strong&gt;, 은행원 알고리즘을 적용하기 위해서는 &lt;strong&gt;자원의 양&lt;/strong&gt;과 &lt;strong&gt;사용자의 수&lt;/strong&gt;가 &lt;strong&gt;일정&lt;/strong&gt;해야 한다. 또한 모든 요구를 &lt;strong&gt;정해진 시간 안에 할당하는 것을 보장&lt;/strong&gt;해야 한다.&lt;/p&gt;

&lt;p&gt;하지만, 은행원 알고리즘은 응답 시간이 보장되어야 하는 &lt;strong&gt;대화식 시스템에 적용하기 어렵다&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;은행원 : 운영체제&lt;/li&gt;
  &lt;li&gt;대출자 : 프로세스&lt;/li&gt;
  &lt;li&gt;은행 보유 금액 : 자원 수&lt;/li&gt;
  &lt;li&gt;현재 대출 금액 : 각 프로세스가 점유하고 잇는 자원 수&lt;/li&gt;
  &lt;li&gt;대출 한도 금액 : 프로세스가 완료할 때까지 필요한 총 자원 수&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;발견detection&quot;&gt;발견(Detection)&lt;/h3&gt;
&lt;p&gt;자원 할당 그래프는 시스템이 주된 이유가 교착상태인가를 발견하는 기법. 교착상태임이 발견되면 해당 프로세스와 자원을 선점하거나 중단 시켜 교착상태 해결&lt;/p&gt;

&lt;h3 id=&quot;회복recovery&quot;&gt;회복(Recovery)&lt;/h3&gt;
&lt;p&gt;실행 중인 모든 프로세스가 정상적으로 작업을 완료할 수 없기 때문에 발생한 교착상태이므로 어느 정도의 &lt;strong&gt;희생은 감수&lt;/strong&gt;해야 한다. 즉, 실행을 중단하거나 점유 중인 자원을 빼앗을 프로세스를 찾는 일로 가능한 손실이 적은 쪽을 선택해야 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;선점을 통한 회복&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;보유하고 있는 &lt;strong&gt;자원을 빼앗아&lt;/strong&gt; 교착상태를 해결하고 시스템을 정상으로 회복하는 방법&lt;/li&gt;
      &lt;li&gt;우선순위가 낮은, 진행 상태가 적은, 자원을 적게 사용하고 있는 프로세스의 자원을 선점하여 프로세스를 일시 중단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;복귀(Rollback)를 통한 회복&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;교착상태가 발생하기 이전 상태로 복귀하여 다시 실행하는 방법&lt;/li&gt;
      &lt;li&gt;현재 실행 중인 전체 프로세스를 대상으로 할 수 있지만 더욱 효과적인 방법은 &lt;strong&gt;교착상태를 해결할 만큼의 프로세스들만을 선택하여 처음부터 다시 실행&lt;/strong&gt;하는 것&lt;/li&gt;
      &lt;li&gt;현재까지 실행되고 있는 프로세스와 중단된 프로세스의 정보를 &lt;strong&gt;재구성해야하는 어려움&lt;/strong&gt;이 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;제거(Kill)를 통한 회복&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;우선순위가 낮은, 진행 상태가 적은, 자원을 적게 사용하고 있는 프로세스를 선택하여 제거&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;기아 상태&lt;/strong&gt;나 문제가 있는 프로세스 제거&lt;/li&gt;
      &lt;li&gt;정상 수행이 불가능한 모든 프로세스를 제거하고 다시 시작&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;사용자의 조치 경로(Routing) 선택&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Window OS : Ctrl + Alt + Delete를 입력하면 현재 작동 중인 프로세스 리스트가 나오게 되는데 이 때 문제가 있는 프로세스를 선택하여 제거&lt;/li&gt;
      &lt;li&gt;Unix OS : ps 명령을 입력하면 현재 프로세스들의 리스트가 출력되는데 이 때 문제가 있는 프로세스들을 kill/killall 명령으로 제거&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 16 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-concurrent-process-synchronization/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-concurrent-process-synchronization/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] CPU 스케줄링</title>
        <description>&lt;h1 id=&quot;cpu-스케줄링&quot;&gt;CPU 스케줄링&lt;/h1&gt;
&lt;p&gt;다중 프로그래밍 방식의 운영체제는 하나의 주기억 장소에 여러 개의 프로세스가 실행된다. 여러 개의 프로세스가 실행되지만, 컴퓨터 시스템에서 보유하고 있는 자원들은 극히 &lt;strong&gt;제한적&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;　
이러한 제한된 환경 아래서 최적의 효과를 보기 위해서는 &lt;strong&gt;프로세스의 계획적인 실행 순서&lt;/strong&gt;가 필요하다. 이러한 계획적인 실행 순서를 CPU 스케줄링 혹은 프로세스 스케줄링이라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;스케줄링-목적&quot;&gt;스케줄링 목적&lt;/h2&gt;
&lt;p&gt;CPU나 자원을 효과적이며 생산성 있게 사용하기 위한 소프트웨어적 계획을 의미. 이러한 프로세스 스케줄링은 필요한 하드웨어 레지스터를 설정함으로써 프로세스에게 CPU를 할당하고 &lt;a href=&quot;/study/os-interrupt/#문맥-교환context-switching&quot;&gt;문맥 교환&lt;/a&gt;을 하는 프로세스 관리 기능이다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 프로세스들에게 공정하게 배정해야 한다(&lt;strong&gt;공정성&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;단위 시간당 가능한 &lt;strong&gt;최대한 많은 양이 처리&lt;/strong&gt;될 수 있도록 해야 한다&lt;/li&gt;
  &lt;li&gt;응답 시간이 &lt;strong&gt;신속&lt;/strong&gt;해야 한다&lt;/li&gt;
  &lt;li&gt;같은 종류의 작업은 거의 같은 시간과 비용으로 실행될 수 있어야 한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오버헤드를 최소화&lt;/strong&gt;해야 한다&lt;/li&gt;
  &lt;li&gt;시스템 내 &lt;strong&gt;자원을 사용하지 않는 시간이 없도록 유지&lt;/strong&gt;해야 한다&lt;/li&gt;
  &lt;li&gt;응답 시간과 자원의 활용 간 적절한 균형이 유지되도록 해야 한다&lt;/li&gt;
  &lt;li&gt;프로세스가 무한정 기다리게 하는 것을 피해야 한다&lt;/li&gt;
  &lt;li&gt;프로세스의 상태를 파악하여 우선순위를 부여하는 것이 좋다&lt;/li&gt;
  &lt;li&gt;중요 자원을 차지하고 있는 프로세스에 우선권을 부여해야 한다&lt;/li&gt;
  &lt;li&gt;문제로 인해 불안하지 않은 프로세스에 서비스를 많이 제공하도록 한다&lt;/li&gt;
  &lt;li&gt;부하가 많은 경우 갑자기 체증이 발생하지 않도록 조절해야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스케줄링-평가-기준&quot;&gt;스케줄링 평가 기준&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;시스템 관점
    &lt;ul&gt;
      &lt;li&gt;CPU 이용률 : &lt;i class=&quot;fas fa-search-plus&quot;&gt;&lt;/i&gt;&lt;strong&gt;최대화&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;처리 능력(Throughput) : 단위 시간당 처리할 수 있는 CPU의 작업량 &lt;i class=&quot;fas fa-search-plus&quot;&gt;&lt;/i&gt;&lt;strong&gt;최대화&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스 관점
    &lt;ul&gt;
      &lt;li&gt;대기(Waiting) 시간 : 준비 상태에서 대기하는 시간 &lt;i class=&quot;fas fa-search-minus&quot;&gt;&lt;/i&gt;&lt;strong&gt;최소화&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;응답(Response) 시간 : 입력에 대해 처음 반응하는 시간 &lt;i class=&quot;fas fa-search-minus&quot;&gt;&lt;/i&gt;&lt;strong&gt;최소화&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;반환(Turn-around) 시간 : 작업을 지시하고 결과가 되돌아오는 시간 &lt;i class=&quot;fas fa-search-minus&quot;&gt;&lt;/i&gt;&lt;strong&gt;최소화&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스케줄링-알고리즘&quot;&gt;스케줄링 알고리즘&lt;/h2&gt;
&lt;p&gt;다중 프로그래밍 방식은 메모리에 여러 개의 프로그램을 적재함으로써 CPU와 I/O 장치들의 유휴 시간을 줄여 사용 효율을 높이는 방식이다. 이러한 다중 프로그래밍 방식에서 &lt;strong&gt;CPU의 사용률과 처리율을 최대화 하기 위한 방법&lt;/strong&gt;들을 프로세스 스케줄링 알고리즘이라고 한다&lt;/p&gt;

&lt;h3 id=&quot;비선점형-방식non-preemptive&quot;&gt;비선점형 방식(Non-Preemptive)&lt;/h3&gt;
&lt;p&gt;현재 실행 중인 프로세스가 자발적으로 CPU를 중단하는 경우에만 CPU 스케줄링을 수행하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일괄처리 방식에 적당&lt;/li&gt;
  &lt;li&gt;대화형/시간 분할/실시간 시스템 부적합&lt;/li&gt;
  &lt;li&gt;응답 시간 예측이 어렵다&lt;/li&gt;
  &lt;li&gt;문맥 교환이 적어 오버헤드가 적다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;fcfsfirst-come-first-served-fifo-first-input-first-out&quot;&gt;FCFS(First Come First Served, FIFO: First Input First Out)&lt;/h4&gt;
&lt;p&gt;먼저 입력된 작업을 먼저 처리하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가장 대표적인 비선점형 방식&lt;/li&gt;
  &lt;li&gt;공평하고 구현이 간단하나, 평균 반환 시간이 길다&lt;/li&gt;
  &lt;li&gt;짧은 작업이나 중요한 작업이 지연될 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sjfshortest-job-first-최단-작업-우선&quot;&gt;SJF(Shortest Job First, 최단 작업 우선)&lt;/h4&gt;
&lt;p&gt;작업이 끝나기까지의 실행 시간 추정치가 가장 작은 작업을 먼저 실행시키는 방식. 비선점형이기 때문에 긴 작업일지라도 이미 CPU를 점유하고 있다면 뒤로 밀려나지 않고 처리되고 다음 작업들을 대상으로 재정리를 수행한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;평균 대기 시간을 최소화한다&lt;/li&gt;
  &lt;li&gt;프로세스의 다음 CPU 사용시간을 예측해야하는 어려움이 있다&lt;/li&gt;
  &lt;li&gt;긴 작업의 경우 계속해서 입력되는 짧은 작업들 때문에 우선순위가 계속 밀려나게 되고 &lt;strong&gt;무한 연기 상태&lt;/strong&gt;가 발생하기도 한다&lt;/li&gt;
  &lt;li&gt;위 무한 연기 현상을 방지하기 위해 &lt;strong&gt;에이징(Aging)&lt;/strong&gt;&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt; 기법을 사용하여 해결&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;strong&gt;에이징 기법&lt;/strong&gt; : 자원이 할당되기를 오랜 시간 동안 기다린 프로세스는 기다린 시간에 비례하는 높은 우선순위를 부여하여 가까운 시간 안에 자원이 할당되도록 하는 기법&lt;/p&gt;

&lt;h4 id=&quot;hrnhighest-response-ratio-next&quot;&gt;HRN(Highest Response-ratio Next)&lt;/h4&gt;
&lt;p&gt;실행 시간 추정과 선점 기능 때문에 스케줄러가 복잡해지고 남은 계산 시간들을 저장해 놓아야 한다는 단점을 보완, 서비스 시간(실행 시간 추정치)과 대기 시간의 비율을 고려한 스케줄링 방식&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;우선순위 = $\frac{대기 시간 + 서비스 시간}{서비스 시간}$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;SJF를 개선한 방식&lt;/li&gt;
  &lt;li&gt;우선 순위 계산 공식을 이용하며, 계산된 값이 가장 큰 작업에게 우선권을 부여&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;우선순위priority&quot;&gt;우선순위(Priority)&lt;/h4&gt;
&lt;p&gt;대기 리스트에 있는 프로세스들에게 작업의 우선순위를 부여하여 CPU를 할당하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;고정적 우선순위와 동적 우선순위 방식이 존재&lt;/li&gt;
  &lt;li&gt;기아 현상, 무한 봉쇄 현상 발생 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;기한부deadline&quot;&gt;기한부(Deadline)&lt;/h4&gt;
&lt;p&gt;제한된 시간 내에 반드시 작업이 완료되도록 스케줄링하는 방식. 제한된 시간을 정확히 추정하여 그 시간 만큼에 CPU 사용 시간을 제한한다. 작업이 제한 시간 내에 처리되지 않으면 다시는 해당 작업이 CPU 사용 시간을 합당받을 수 없다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스들이 마감 시간 내에 처리되지 않으면 폐기되거나 처음부터 다시 실행 필요&lt;/li&gt;
  &lt;li&gt;기한부 스케줄링에 필요한 집약적 자원 관리는 많은 오버헤드를 일으킬 수 있다&lt;/li&gt;
  &lt;li&gt;동시에 다수의 기한부 작업이 수행되면 스케줄링은 매우 어려워질 수 있다&lt;/li&gt;
  &lt;li&gt;사용자는 작업에 필요한 자원의 정확한 정보를 시스템에 제시하여야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;선점형-방식preemtive&quot;&gt;선점형 방식(Preemtive)&lt;/h3&gt;
&lt;p&gt;하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대화형, 시간 분할, 실시간 시스템에 적합&lt;/li&gt;
  &lt;li&gt;응답 시간 예측이 용이하다&lt;/li&gt;
  &lt;li&gt;문맥 교환이 많아 오버헤드가 많다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;라운드-로빈rr-round-robin&quot;&gt;라운드 로빈(RR, Round-Robin)&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;/study/os-development-process/#시분할-처리time-sharing-processing-시스템&quot;&gt;시분할 시스템&lt;/a&gt;을 위해 고안되었으며 여러 개의 프로세스가 10 ~ 100msec 정도의 시간 할당량(Quantum, Time Slice)이라는 작은 단위 시간이 정의되어 시간 할당량만큼씩 CPU를 사용하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FIFO 스케줄링을 선점형으로 변환한 방식&lt;/li&gt;
  &lt;li&gt;적절한 응답 시간을 보장해주는 대화식 사용자에게 효과적&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시간 할당량이 클 때, &lt;i class=&quot;fas fa-search-plus&quot;&gt;&lt;/i&gt;
    &lt;ul&gt;
      &lt;li&gt;FIFO 방식과 거의 같은 형태가 된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시간 할당량이 작을 때, &lt;i class=&quot;fas fa-search-minus&quot;&gt;&lt;/i&gt;
    &lt;ul&gt;
      &lt;li&gt;프로세스 간의 전이가 많아지므로 프로세스가 전이되는 과정에서 필요한 문맥 교환 수 증가&lt;/li&gt;
      &lt;li&gt;실행 시간보다 문맥 교환의 교체에 사용되는 부가적인 시간이 증가하게 되므로 오버헤드가 증가&lt;/li&gt;
      &lt;li&gt;프로세서의 교환에서 시간을 소비하고 실제 사용자들의 연산은 거의 못하는 결과를 초래&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;srtshortest-remaining-time&quot;&gt;SRT(Shortest Remaining Time)&lt;/h4&gt;
&lt;p&gt;작업이 끝나기까지 &lt;strong&gt;남아 있는&lt;/strong&gt; 실행 시간의 추정치가 가장 작은 프로세스를 먼저 실행하는 방식으로 &lt;strong&gt;새로 입력되는 작업까지도 포함&lt;/strong&gt;된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실행 시간 추적과 서비스 받은 시간을 기록해야 하므로 오버헤드가 증가&lt;/li&gt;
  &lt;li&gt;임계치(Threshold Value)&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt;를 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;strong&gt;임계치&lt;/strong&gt; : CPU를 사용 중인 프로세스가 거의 마지막에 이르렀을 때 남아 있는 시간보다 조금 작은 프로세스가 입력된다면 &lt;strong&gt;순수 SRT는 조금 작은 프로세스에게 CPU 사용 권한을 넘겨주어야&lt;/strong&gt; 한다. 하지만 이럴 경우 &lt;strong&gt;문맥 교환 횟수나 전체 정황으로 보았을 때&lt;/strong&gt; 현재 현재 작업 중인 프로세스를 모두 마치고 조금 &lt;strong&gt;작은 프로세스를 다음에 처리하는 것이 더 효율적&lt;/strong&gt;일 것이다. 이러한 경우를 &lt;strong&gt;추정해서 공식에 적용시켜 얻어진 수치&lt;/strong&gt;를 의미한다&lt;/p&gt;

&lt;h4 id=&quot;다단계-큐mq-multi-level-queue&quot;&gt;다단계 큐(MQ, Multi-level Queue)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/mulitlevel-queue.png&quot; title=&quot;https://www.includehelp.com/operating-systems/multilevel-queue-scheduling-in-operating-system.aspx&quot;&gt;&lt;img src=&quot;../../assets/images/os/mulitlevel-queue.png&quot; alt=&quot;&quot; title=&quot;다단계(멀티레벨) 큐&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;준비 큐를 여러 종류의 그룹으로 나누고 여러 개의 큐에 다양한 알고리즘을 적용하는 스케줄링 기법. 일반적으로 멀티레벨 큐에서 준비 큐는 대화형 작업을 담기 위한 &lt;strong&gt;전위 큐(Foreground Queue)&lt;/strong&gt;와 계산 위주의 작업을 담기 위한 &lt;strong&gt;후위 큐(Background Queue)&lt;/strong&gt;로 분할되어 프로세스들은 자신의 우선순위 값에 해당하는 큐에 들어가며 우선순위가 낮은 하위 단계 큐의 작업은 실행중이더라도 상위 단계 큐에 프로세스가 도착하면 CPU를 뺏기는 선점 방식이다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선점, 비선점 방식&lt;/li&gt;
  &lt;li&gt;정적 우선순위를 사용하는 스케줄링을 구현 할 때 가장 적합&lt;/li&gt;
  &lt;li&gt;서로 다른 우선순위의 프로세스들을 구별하고 관리하기 위해 우선순위의 개수만큼 큐가 필요&lt;/li&gt;
  &lt;li&gt;큐를 특성별로 여러 개 가지며, 각 독립적인 스케줄링을 가진다&lt;/li&gt;
  &lt;li&gt;큐 간에 &lt;strong&gt;프로세스가 이동이 안된다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;우선순위가 가장 높은 큐에서는 비선점형으로 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;다단계-피드백-큐mfq-multi-level-feedback-queue&quot;&gt;다단계 피드백 큐(MFQ, Multi level Feedback Queue)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/multilevel-feedback-queue.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/multilevel-feedback-queue.png&quot; alt=&quot;&quot; title=&quot;다단계(멀티레벨) 피드백 큐&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;짧은 작업이나 입출력 위주의 작업에 우선권을 부여하기 위해 개발된 방식으로 적응 기법의 개념을 적용. 큐 간에 프로세스가 이동이 불가한 다단계 큐(MQ)의 단점을 보완&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;큐마다 시간 할당량이 존재하며 &lt;strong&gt;낮은 큐일수록 시간 할당량은 커진다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;각각의 큐들은 종속적으로 연결되어 있다&lt;/li&gt;
  &lt;li&gt;CPU를 시간 할당량만큼 사용한 프로세스는 낮은 큐로 이동&lt;/li&gt;
  &lt;li&gt;맨 위에 큐는 &lt;strong&gt;RR방식&lt;/strong&gt;을 사용, 맨 마지막 큐는 &lt;strong&gt;FCFS방식&lt;/strong&gt; 사용&lt;/li&gt;
  &lt;li&gt;우선순위가 낮은 프로세스는 계속 지연되는 &lt;strong&gt;기아(Starvation) 현상&lt;/strong&gt;이 발생할 수 있다 &lt;i class=&quot;far fa-hand-point-right&quot;&gt;&lt;/i&gt; &lt;strong&gt;Aging 기법&lt;/strong&gt; 사용으로 해결&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 15 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-cpu-scheduling/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-cpu-scheduling/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
  </channel>
</rss>
