var store = [{
        "title": "[(구)정처기/컴퓨터일반] (1) 데이터베이스 자주 틀리는 내용 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.     데이터 모델의 구성요소     구조(Structure) : 개념적 / 논리적 구성 형태   연산(Operation) : 개체 인스턴스의 삽입, 삭제, 검색, 갱신 처리 방법   제약사항(Constraint) : 개체 인스턴스의 허용 기준   E-R 관계 모델     원 : 속성 / 사각형 : 객체 / 마름모 : 관계   개념적 설계에서 주로 사용   논리적 데이터 모델     개념적 구조 ⇒ 논리적 구조   네트워크 데이터 모델     오너-멤버 관계, 그래프 구조 형태   연계성이 매우 우월, CODASYL / DBTG   관계 대수     릴레이션으로부터 필요한 릴레이션을 만들어내는 연산자의 집합   릴레이션 조작을 위한 연산   원하는 정보와 그 정보를 어떻게 유도하는가를 기술하는 절차적인 방법   합집합 / 교집합 / 차집합 / 곱집합 / 설렉션 / 프로젝션 / 조인 / 디비젼   관계 해석     수학의 프레디킷 해석에 기반   질의하는 형식, 구하고자 하는 정보가 무엇이라는 것만 명시하는 비절차적 형태   튜플 관계 해석 / 도메인 관계 해석   트랜잭션     Atomicity(원자성) — 일부의 완료는 부재(모두 반영하거나 전혀 반영하지 않는 성질)   Consistency(일관성) —실행 전과 후가 같아야 한다는 성질, 무결성 유지   Isolation(독립성, 격리성) — 실행되는 중간에 다른 트랜잭션 연산이 침범하지 못하는 성질   Durability(지속성, 계속성, 영속성) — 변화된 상태는 계속해서 유지될 수 있어야 한다는 성질   병행 제어 기법     로킹(Locking) : 자원 이용에 대하여 상호배제 기능을 이용하는 기법   타임스탬프 순서(Timestamp Ordering) : 진입하는 트랜잭션 순서대로 타임스탬프를 지정하여 동시성을 제어하는 기법   검증 기법(Validation, 낙관적 기법) : 읽기 단계, 검증 단계, 기록 단계를 이용하여 직렬성 보장하는 기법, 사본에만 갱신 결과를 반영하다 최종적으로 검증과정을 통해 DB반영   다중버전 기법(Multi Version) : 각 트랜잭션은 순서적으로 부여된 버전을 이용  ","categories": ["study"],
        "tags": ["(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database/",
        "teaser": null
      },{
        "title": "[(구)정처기/컴퓨터일반] (2) 전자계산기 자주 틀리는 내용 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.     불 대수 기본 정리                  A + A = A       A · A = A       A · 0 = 0       A + 0 = A                 A + 1 = 1       A · 1 = A       0 + 0 = 0       0 · 0 = 0                 1 + 0 = 1       1 · 0 = 0       1 + 1 = 1       1 · 1 = 1                 A + A·B = A       A·(A + B) = A                           논리게이트     Exclusive OR : A, B 입력 ⇒ 서로 다를 때 1출력, 같을 때 0 출력   Exclusive NOT OR : A,B 입력 값 ⇒ 서로 같을 때 1, 다를 때 0 출력   조합 논리 회로     반가산기(Half Adder) : AND(1) + XOR(1)            S : A ⊕ B / C : A·B            반감산기(Half Subtracter) : NOT(1) + AND(1) + XOR(1)            D : X ⊕ Y / B : X’ · Y            전가산기(Full Adder) : Half Adder(2) + OR(1)            S : A ⊕ B ⊕ C / C : (A ⊕ B) · C + A · B = A · B + B · C + A · C            전감산기(Full Subtracter) : Half Subtracter(2) + OR(1)            D = X ⊕ Y ⊕ B / B = (X ⊕ Y)’·B + X’ · Y            병렬 가산기 :  반가산기(2n-1)개 + OR(n-1)개 / 전가산기(n개)를 여러 개 사용   디코더 = 해독기  N개의 입력 ⇒ 2n개의 출력   인코더  2n개의 입력 ⇒ n개의 출력   멀티플렉서 == 선택기  2n개의 입력선 + n개의 선택선 ⇒ 하나의 출력   디멀티플렉서  하나의 입력 정보 + n개의 선택선 ⇒ 2n 개의 출력   비교기 : Exclusive NOR(n개) 연결   3-상태 버퍼   순서 논리 회로          플립플롭 : 현 상태값에 관계 없이 입력 값을 다음 상태로 전달하는 특징이 있음              RS플립플롭 : S, R 단자가 모두 1인 경우 ⇒ 불허용                   JK 플립플롭 : S, R 단자가 모두 1인 경우 ⇒ 반전(토글)                   D 플립플롭 : 배타적인 경우만 이용, D 입력(1) ⇒ 출력(1)                   T 플립플롭 : 토글 기능만 작동            마스터 슬래이브 플립플롭 : Race 현상 해결하기 위해   카운터   레지스터   자료의 외부 표현     BCD : Zone(2Bit) + Digit(4Bit) ⇒ 6Bit   EBCDIC : Zone(4Bit) + Digit(4Bit) ⇒ 8Bit   ASCII : Zone(3Bit) + Digit(4Bit) ⇒ 7Bit + Parity(1Bit)   고정 소수점 수에서 음수 표현 방식에 따른 특징     수의 표현 범위            부호와 절대치 : -(2^(n-1)-1) ~ 2^(n-1)-1       1의 보수 : -(2^(n-1)-1)~2^(n-1)-1       2의 보수 : -2^(n-1) ~ 2^(n-1)-1           부동 소수점     부호(1), 지수(8), 가수(23)   나눗셈 과정 :            0인지 조사 ⇒       부호 결정 ⇒       피젯수를 위치 조정 ⇒       지수 뺄셈 ⇒       가수 나눗셈 ⇒       결과의 정규화           메가플롭스(MFLOPS) : 1초간에 실행되는 부동 소수점 연산의 수를 100만 단위로 표현   10진 표현     언팩 10진 표현 :  연산 불가, 입출력 작업 시  부호는 맨 마지막 바이트의 존 부분에 표현(+:C(1100), -:D(1101))   팩 10진 표현 :  연산 가능, 부호는 맨 마지막 4비트(+:C(1100), -:D(1101))   코드의 분류     가중치 코드 : 자리 값을 가지고 있는 코드            8421, 2421, 7421, 5421, 5111, Biquinary, Ring Counter           비가중치 코드 : 자리 값이 없는 코드            3초과 코드, 그레이 코드, 2-out-of-5 코드, 3-out-of-5 코드           자기 보수 코드 : 코드의 1의 보수 == 10진수의 9의 보수   3초과 코드, 2421, 5211, 5111, 8421   에러 검출 코드            패리티, 해밍, 2-out-of-5 코드, 3-out-of-5 코드, Biquinary, Ring Counter           Gray 코드 : 기계적인 동작을 제어하는데 적당   수치적 연산     산술 시프트   우측 산술 시프트            부호와 절대치 표현 ⇒ 부호 비트 고정 1의 보수 ⇒ 음수일 경우 1 패딩 2의 보수 ⇒ 음수일 경우 1 패딩            좌측 산술 시프트            부호와 절대치 표현 ⇒ 부호 비트 고정 1의 보수 ⇒ 부호 비트 고정, 음수일 경우 1패딩 2의 보수 ⇒ 부호 비트 고정            명령어의 구조     연산자 = Op-Code : Op-Code (n)Bit ⇒ 명령어 생성 개수 = 2^n   모드 : 직접 주소 / 간접 주소   주소 : 메모리 용량이 2^n ⇒ Operand (n)Bit   연산자(Operation, Op-Code)의 기능     함수 연산 기능, 제어 기능, 전달 기능, 입출력 기능   명령어 세트의 효율성을 향상시키기 위한 고려사항  기억 공간, 사용 빈도, 주기억 장치의 밴드폭 사용, 주소 지정 방식 함수 연산 기능 대 기타 연산 기능의 비율   명령어 설계 과정 고려사항     연산자의 수, 종류 / 주소 지정 방식 / 데이터 구조 / 워드 크기   명령어의 종류     데이터 처리 명령어  ADD / SUB / MUL / DIV INC / DEC AND / OR / XOR / COMPLEMENT / CLEAR 산술, 논리 SHIFT / ROTATE   데이터 전송 명령어  LOAD / STORE / MOVE / PUSH / POP / INPUT / OUTPUT   데이터 제어 명령어  JUMP / SMA / SZC / SKIP / SZA / ISZ / RETI / CALL / RETURN / HALT   명령어 메모리 참조 형식     레지스터 참조 명령(RRI : Register Reference Instruction)   메모리 참조 명령(MRI : Memory Reference Instruction)   입출력 명령(IOI : Input Output Instruction)   주소 지정 방식     즉시 주소(Immediate Address) :  주소 부분에 실제 데이터가 들어있는 방식   직접 주소(Direct Address) :  주소 부분에 실제 데이터가 들어있는 유효주소가 있음   계산에 의한 주소(Calculate Address)   인덱스 주소 지정(Index Register Address) :  인덱스 레지스터, 배열 엑세스 방식   상대 주소 지정(Relative Address) :  PC, 데이터 영역의 배치와 Program 배치 유사, 분기 명령   기준 주소 지정(Base Register Address) :  베이스 레지스터, 프로그램 재배치, 다중 프로그래밍 기법에서 주로 사용   간접 주소(Indirect Address)   CPU의 구분     스택 구조 CPU : 0 주소 명령어 형식, Postfix 표기법   단일 누산기 구조 CPU : 1주소 명령어 형식, Infix 표기법   범용 레지스터 구조 CPU : 2주소 명령어 형식, Prefix 표기법   프로세서의 종류     CISC(Complex Instruction Set Computer)  초창기 컴퓨터, 마이크로 프로그램 제어 방식 사용  메모리 참조 연산   RISC(Reduced Instruction Set Computer)  하드 와이어드 제어 방식  중요 명령어 ROM에 저장  명령어 길이 고정, 명령어의 개수 적음  레지스터 참조 연산   레지스터     AR(Address Register) : 기억용량과 관련, 주기억장치 / 워드 길이   PC(Program Counter)   MAR(Memory Address Register)   DR(Data Register) : 기억 장치의 워드 크기와 관련   MBR(Memory Buffer Register)   Status Register : 프로그램 제어를 위한 상태 정보를 기억   명령어 수행 순서     명령어 인출 ⇒ 명령어 해독 ⇒ 오퍼랜드 인출 ⇒ 실행 ⇒ 인터럽트 조사  Instruction Fetch ⇒ Instruction Decoder ⇒ Operand Fetch ⇒ Exe ⇒ Interrupt Search    마이크로 오퍼레이션     하나의 클록 펄스 동안 실행되는 기본 동작을 의미   CPU에 있는 레지스터와 플래그의 상태 변환을 일으키게 하는 동작   CPU에서 발생시키는 제어 신호에 따라 마이크로 오퍼레이션이 순서적 실행   동기 고정식 마이크로오퍼레이션            마이크로 사이클 타임이 가장 긴 것 == 클록 주기       수행 시간이 차이가 날 때 CPU의 시간 낭비, 구현 간단       여러 종류의 MO 수행 시 CPU 사이클 타임이 실제적인 오퍼레이션 시간보다 김           클럭 사이클 시간  조합 논리 회로 : 세그먼트 중 가장 긴 것 + 가장 짧은 것   메이져 상태     인출 주기   간접 주기   실행 주기            ADD       AND       LOAD       STORE       BUN(JUMP)       BSA(Branch and Save Return Address)       ISZ(Increment and Skip if Zero) : 프로그램의 수행 순서를 조건에 따라 결정           인터럽트 주기   제어 장치     제어 메모리 : 액세스 타임이 빠른 ROM으로 만들어진다    CPU의 제어 데이터                  제어 데이터       인출       간접       실행       인터럽트                       메이저 상태를 변화시키는 데이터       명령어       직/간접 주로 방식을 판별하는 비트       인터럽트 요청 신호       없음                 CPU의 제어점을 제어하는 데이터       명령어       명령어의 연산자 부분       명령어의 연산자 부분       기종에 따라 다름                 명령 수행 순서를 결정하는 제어 데이터       명령어       기억 장치에서 읽어낸 실제 데이터 주소       PC       기종에 따라 다름           마이크로 프로그램     일련의 제어 워드가 특수한 기억 장치 속에 저장되어 기계어 명령어들이 적절히 수행되도록 각종 제어 신호를 발생시키는 프로그램    제어 장치의 구현 방법     고정 배선식 제어 방식(Hard Wired)  하드웨어적, 속도 빠름, 변경 불가, 회로 복잡, 변경이 어려움   마이크로프로그램 제어 방식   제어 메모리에서 번지 결정 방법     순차 수행 : 제어 주소 레지스터의 내용을 +1 결정   무조건 분기 : 마이크로 명령어 상에 있는 분기 주소에 나타난 다음 명령어 수행   조건 분기 : 상태 플래그의 내용에 따라   서브 루틴 : 독립된 서브 마이크로프로그램 호출하여 수행   매크로 : 반복되는 부분을 매크로로 정의하고 직접 제어 메모리로 매핑   주기억 장치     DRAM  재충전 시간이 필요하므로 사이클 시간 &gt; 접근 시간   DRO(파괴성 판독 : Destructive Read Out)            메모리에서 데이터를 읽어내면서 원래의 데이터를 소거하는 판독 방법으로 메모리에서 정보를 보존하려면 읽어낸 뒤 즉시 재기입하여하 하기 때문에       사이클 타임 &gt; 접근 시간           SSD(Solid State Drive) : 메모리 반도체를 사용하는 대용량 저장 장치            SLC / MLC / TLC(속도 빠름/수명 길다 ↔ 속도 느림/수명 짧음)           CPLD(Complex Programmable Logic Device)            LAB, PIA로 구성되어 규칙적이고 빠른 타이밍이 필요하거나 어드레스 디코더 같은 간단한 로직 구현에 사용           보조 기억 장치     자기 디스크            등선 속도(CLV : Constant Linear Velocity)                    디스크의 안쪽, 바깥쪽 회전 속도가 일정하지 않음                       등각 속도(CAV : Constant Angular Velocity)                    외부 면의 저장 밀도가 떨어져 공간 낭비 유발, 접근 속도 빠름                           블루레이  405nm 파장의 청자색 레이저 사용, DVD보다 많이 저장 가능  한 면에 최대 27GB, 듀얼 50GB, MPEG-2 압축 방식   캐시메모리  캐시 메모리 평균 액세스 시간 = 히트 시간 + 미스도 + 미스 패널티  캐시 블록 번호 = 주기억 장치 블록 번호(= 번지 / 블록 크기) MOD 캐시 전체의 블록 수  캐시 메모리에 데이터 저장 시 주기억 장치와의 관계     Write Through : 캐시에 저장이 일어날 때 캐시와 주기억 장치를 동시에 갱신   Write Back : 캐시의 내용만 갱신이 일어나다가 블록이 캐시에서 제거될 때, 주기억에 복사해서 갱신   연관 기억 장치(Associative Memory)     기억된 정보의 일부분을 이용하여 원하는 정보를 검색 ⇒ 주소가 필요 없음   신속한 검색, 병렬판독회로 내장(가격이 비싸다)   작은 용량의 IC메모리를 사용하여 캐시 메모리나 가상 메모리의 주소 탐색에 주로 이용   가상 기억 장치     실제 페이지의 개수 = 주기억 장치 용량 / 하나의 페이지 크기   가상 페이지의 개수 = 가상 주소(nBit ⇒ 2^n) / 하나의 페이지 크기   메모리 인터리빙     독립된 메모리를 2개 이상 나누어 연결하고 CPU에서 각각 독립된 메모리를 번갈아가면서 연속적으로 액세스가 이루어지도록 구현하는 방법   CPU의 처리속도에 비해 사이클 타임이 오래 걸리지만, 접근하는 시간은 효율적   기억 장치 / 입출력 장치     동작 속도 / 정보 단위 / 동작의 자율성 / 에러율    입출력 제어기의 역할     데이터 버퍼링 / 제어 신호의 논리적, 물리적 변환   통신 회선 확보 / 상태 정보 저장 / 주기억 장치 접근 / 데이터 교환   고립형 입출력 포트(I/O Mapped I/O Port)     입출력 포트와 메모리 주소가 독립적인 상태   마이크로프로세서는 뚜렷한 입출력 명령을 가짐 각 명령은 인터페이스 레지스터의 주소를 가짐   메모리 맵 입출력 포트(Memory Mapped I/O Port)     입출력 포트와 메모리 주소가 종속적인 상태   마이크로프로세서가 인터페이스 레지스터를 메모리 시스템의 한 부분으로 인식   DMA(Direct Memory Access)     단어 계수기는 입출력이 일어날 때마다 하나씩 감소하여 0이 되면 인터럽트를 요청하여 블록에 대한 입출력이 완료되었음을 CPU에게 알림   구성요소            인터페이스 회로 :  CPU ↔ 입출력 장치 통신       번지 레지스터 :  기억 장치와 위치 지정을 위한 번지를 기억       워드카운터 레지스터 : 전송되어야 할 워드의 수 표시       제어 레지스터 : 전송 방식을 결정       데이터 버스 버퍼, 주소 버스 버퍼       Data Buffer Register / F Flip-Flop / Status Register / Address Register / Word Counter           사이클 스틸     CPU 상태를 보존할 필요가 없음   CPU가 잠시 쉴 수 있음   아무 사이클이나 상관없이 훔치는 것이 가능   DMA의 우선순위는 메모리 참조의 경우 CPU장치보다 상대적으로 높음   채널     Interlock Channel : 하나 이상의 입출력 요청이 들어올 경우 이를 적절히 수행   Crossbar Channel : 여러 개의 채널 제어기 중 아무거나 사용해서 입출력할 수 있는 방식   버스트 모드 : 하나의 I/O 장치가 데이터 전송을 하고 있는 동안 채널의 기능을 완전히 독점하여 대량의 데이터를 고속으로 전송   멀티플렉서 모드 : 여러 개의 I/O 장치가 채널의 기능을 공유하여 시간 분할 형식으로 데이터를 전송하는 형태, 저속의 I/O 장치 여러 개를 연결하는 방식   입출력 수행 중 어떤 에러 조건에서 CPU에 인터럽트를 걸 수 있음   구성요소            채널 명령어(CCW : Channel Command Word) : 주기억 장치에 있는 하나의 블록 입출력 정보를 가지고 있는 명령어                    Operation Code : I/O 여부 / 분기 / 입출력 장치 제어 / 채널 동작 정보           블록 주소 : 블록의 첫 번째 시작 주소           블록의 단어수 : 입출력하고자 하는 블록 워드의 개수                       다음 채널 명령의 주소 : PC가 없으므로 다음에 수행해야 할 명령어 있음       채널 주소 단어(CAW : Channel Address Word) : 채널 명령어의 시작 주소를 기억       채널 상태 단어(CSW : Channel Status Word) : 채널 정보, I/O 장치 정보 레지스터           인터럽트 종류     페이지 폴트 / 캐시 미스 인터럽트   외부 인터럽트 : 타이머 인터럽트나 조작원의 의도적 동작인 입출력 인터럽트   내부 인터럽트 : 0으로 나누기 / 불법적인 명령어 사용 / 오버, 언더 플로우            트랩 : 어떤 프로세스가 특정 시스템 기능을 사용하려고 할 때 OS에게 요청           I/O 인터럽트 : 의도적으로 인터럽트 발생 가능   SVC(Super Visor Call) : 사용자가 프로그램을 이용하여 직접 인터럽트를 호출   차단 불가능 인터럽트(NMI : Non-Maskable Interrupt)            인터럽트 마스크에 영향을 받지 않는 우선순위가 가장 높은 인터럽트       정전, 심각한 하드웨어 이상 인터럽트에 해당           인터럽트 발생 시 CPU의 처리 사항     PC   프로그램에서 사용한 모든 레지스터의 내용   플래그 상태 조건 내용   스택의 내용 / 메모리 0번지의 내용   인터럽트 우선순위 부여 방식     폴링 = 프로그램에 의한 I/O 제어 방식            CPU와 I/O 장치 사이의 데이터 전달이 프로그램에 의해서 제어되는 방법       프로그램에서 D와 B 상태를 검사하여 데이터를 전송           인터럽트 요청 체인 방식   인터럽트 우선순위 체인 방식   병렬 우선순위 부여 방식            처리 중인 인터럽트보다 우선순위가 낮은 것을 비활성화시키는 마스크 레지스터       인터럽트 처리 루틴 없이 인터럽트 취급 루틴 시작       CPU에 있는 인터럽트 레지스터의 각 비트는 요청 회선과 연결           인터럽트 작동 순서     인터럽트 요청 ⇒ 현 상태 보존 ⇒ 인터럽트 판별 ⇒ 인터럽트 취급 ⇒ 원 상태 복귀    병렬 컴퓨터 구조     파이프라인 클록 타임            T = (k + (N -1)) (k:파이프라인 단계 수, N : 수행할 명령어의 개수)            상호연결 구조     다중 처리기            Bus, 크로스바 스위치, 다단 상호 연결망(오메가 스위치)           다중 컴퓨터            Bus, 그리드, 하이퍼큐브           시스톨릭 배열(Systolic Array)  파이프라인 어레이 구조의 새로운 범주로서 지역적으로 연결된 프로세서들이 규칙적으로 데이터를 계산하고 시스템을 통해 데이터를 전달하는 프로세서 네트워크  벡터 처리기, MISD   파일 보호 기법     파일 명명, 접근 제어, 암호화    보안 유지 방식  부인 방지(Non-repudiation) : 데이터를 송수신한 자가 송수신 사실을 부인할 수 없도록 송수신 증거를 제공하는 것, 공개키 암호 방식 이용   ","categories": ["study"],
        "tags": ["(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/electronic-calculator/",
        "teaser": null
      },{
        "title": "[(구)정처기/컴퓨터일반] (3) 운영체제 자주 틀리는 내용 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.     어셈블리어의 장점     어셈블리어로 작성한 원시 프로그램을 기계어로 번역   기계어보다 쉽고, 이해하기가 쉽다   프로그램의 주소가 기호 번지이다   프로그램에 데이터를 사용하기 쉽다   매크로 프로세서의 기능     매크로 정의 인식 : 매크로를 정의한 부분의 시작과 종료 파악   매크로 정의 저장 : 매크로 호출 시 확장하기 위해 저장   매크로 호출 인식 : 확장하기 위한 준비가 되어 있는 지 확인   매크로 확장 및 인수 : 원시 프로그램 위치에 저장된 내용과 인수를 치환   로더의 종류     절대 로더 : 로더의 역할 축소, 한 번 지정한 주기억 장소의 변경이 어려움            할당, 연결 ⇒ 프로그래머       재배치 ⇒ 번역 프로그램       적재 ⇒ 로더           직접 연결 로더 : 일반적인 로더 형태, 로더가 모두 수행   동적 로더 : CPU가 현재 사용중인 부분만 적재, 미사용 중인 것은 보조기억장치에 보관(Load-on-call)   운영체제의 구성     제어프로그램            감시 프로그램(Supervisor P) : 일명 모니터, 지시/감독       데이터 관리 프로그램(Data Management P) : 주기억 장치, 보조기억 장치 간 작업       작업 제어 프로그램(Job Control P) : 스케쥴 및 시스템 지원 할당 등을 관리           처리 프로그램            언어 번역 프로그램 : 목적 프로그램으로 번역해주는 프로그램       서비스 프로그램 : 모듈이나 프로그램을 사용자가 사용할 수 있도록 제공       문제 프로그램 : 사용자의 응용 처리를 위해 사용           운영체제의 발달 과정     시분할 처리 : 전문적인 처리기가 존재 하지 않음   스풀 vs 버퍼링     스풀(Spool) : 프로그램과 I/O 장치와의 속도 차를 극복하기 위해, HDD가 중재   버퍼링(buffering) : CPU와 I/O 장치와의 속도 차를 극복하기 위해, 주기억 장치가 중재   PCB(Process Control Block) ⇒ 프로세스 생성 정보 없음     식별자, 현재 상태, PC, 우선순위, CPU 레지스터 정보, 계정 정보, 기억 장치 관련 정보   CPU의 각종 레지스터 상태를 가리키는 포인터, 입출력 정보   적재된 기억 장치 부분을 가리키는 포인터, 할당된 자원을 가리키는 포인터   부모/자식 프로세스를 가리키는 포인터   인터럽트 종류     SVC(SuperVisor Call) : 감시 프로그램 호출 시 발생  입출력 수행 루틴 호출 / 기억 장치 할당 루틴 / 오퍼레이터와의 대화   입출력(I/O) : 하드웨어적 인터럽트  입출력 채널 확인, 준비, 할당, 완료, 프로세스 전이(실행 ⇒ 대기)   외부(External) : 운영체제 소속이 아닌 외적인 요인으로부터 발생  인터럽트 시계에 의해 프로세스가 시간 할당량이 종료된 경우,  웹 서버나 프린터 서버를 운영하고 있는 상태에서 외부로부터 인터럽트 처리 신호 올 때   재시작 : 운영체제를 메모리에 다시 상주시킬 때   프로그램 검사 : 명령어를 수행하는 과정에서 부분적으로 발생되는 문제   기계 검사 : 시스템의 기계 고장   CPU 스케줄링     HRN(Highest Response-ratio Next) 스케줄링 기법            (대기 시간 + 서비스 시간) / 서비스 시간            세마포어의 특징     상호배제의 원리 보장   소프트웨어나 하드웨어로 구현 가능   V 조작 : Wake-Up = Up = Signal   P 조작 : Sleep = Down = Wait   교착 상태 해결 방안     예방(Prevention)  상호배제 부정, 대기 제거, 선점 인정, 선형 대기 상태로 변경 ⇒ 효율적이지 못함   회피(Avoidance)  안정상태를 유지할 수 있는 프로세스의 자원 요구만 할당, 은행원 알고리즘   회복(Recovery)  선점 / 복귀 / 제거 / 사용자의 조치   발견(Detection)  자원 할당 그래프는 시스템이 중단된 이유가 교착상태인가를 발견하는 기법   주기억 장치 재사용 기술     통합(Coalescing) : 인접한 공백들을 더 큰 하나의 공백으로 만드는 과정   집약(Compaction, 압축) : 서로 떨어져 있는 여러 개의 낭비 공간을 모아 하나의 공간으로   캐시 기억 장치     주기억 장치 ↔ CPU 간 속도 차이 극복, 버퍼의 기능 수행   분리 캐시 : 캐시 접근 시 충돌을 방지하기 위해 코드와 데이터를 분리해서 기억   쓰기 접근 빈도가 높다 == 캐싱-일관성 문제가 발생할 확률 높음 == 성능 저하   사상 방법            직접 사상       전체 연합 사상                    블록 중 아무 곳이나 하나 정해서 기억           메모리 워드의 번지 + 데이터 함께 저장, RR 방식으로 교체                       세트 연합 사상           페이지 교체 알고리즘     NUR(Not Used Recently)            참조비트, 변형비트 ⇒ ‘1’ 최근 / ‘0’ 예전           파일의 구조     직접 파일(Direct Access File)            해싱 사상 함수에 의해 물리적인 주소로 변환하여 데이터를 기록 / 검색       한 번 파일을 개방하면 읽거나 쓰기를 자유롭게       평균 접근 시간 내 접근       디스크 기억 장치에 많이 이용           파일 시스템의 기능     파일 저장 / 공유 / 생성 / 변경 / 제거 / 응용 처리   백업, 복구, 여러 종류의 접근 제어 방법 제공, 파일 간 정보 전송   기호형 이름을 사용 ⇒ 자신의 파일을 참조할 수 있도록 장치 독립성을 제공   디렉터리     비순환(주기) 그래프 디렉터리            트리구조와 유사, 사이클 불허       하나의 파일을 여러 사용자가 공유하기 때문에 삭제 시 문제점 발생       융통성이 있으며 기억 공간을 절약할 수 있으나 복잡       하나의 파일이 다수의 이름으로 존재       공유하고 있는 파일 제거 시 Dangling Pointer 발생 가능       Unix 운영체제에서 사용           보안 유지 방식     외부 보안 : 천재지변으로부터 컴퓨터를 보호   내부 보안 : 운영체제/하드웨어 내장, 프로그램의 신뢰성 있는 운영/무결성 보장   사용자 인터페이스 보안 : 인증, 패스워드   암호화            비밀키 = 공통키 = 대칭키 = 관용키 = 단일키 = Private Key System                    암호화 키 = 복호화 키           DES, 평문을 암호화                       공개키 = 비대칭키                    암호화 키(공개) != 복호화 키(보호)           키 분배가 간단, 암호화 과정 복잡, 속도가 느림           RSA, PGP                           Flynn     SISD : 개인 컴퓨터, Pipeline 기법   MISD : 실제 없음   SIMD : 대형 컴퓨터, Array Processor   MIMD : 분산/병렬 컴퓨터            교환형 다중 처리기 : 크로스바 교환 행렬(버스의 수 만큼 메모리 증가)           분산 시스템의 결함     링크 결함, 사이트 결함, 메시지의 분실   분산 처리 시스템의 계층 구조     하드웨어 ⇒ 기억 장치 ⇒ 프로세스 ⇒ 파일 시스템 ⇒ 사용자 응용   UNIX 기본 구성     쉘            명령의 입력을 받아 시스템 기능을 수행하는 명령 해석기       사용자 시스템 간 인터페이스 담당, 여러 가지 내장 명령어 보유       파이프라인 기능, 입출력 방향 지정           UNIX 특징     Pipe : 먼저 입력된 데이터를 먼저 처리하는 선형 구조(FIFO) 형태로 통신 경로 확보   UNIX 파일 시스템     부트 블록   실린더 블록   i-Node 테이블            사용자 ID, 그룹 ID, 보호모드, 블록 주소       처음 생성 시기, 마지막 사용 시기, 최종 수정 시기       파일 링크 수, 파일 속성           파일 테이블 블록   UNIX 주요 명령어     Mount : 파일 시스템에 새로운 파일 시스템을 서브 디렉터리에 연결할 때 사용  ","categories": ["study"],
        "tags": ["(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/operating-system/",
        "teaser": null
      },{
        "title": "[(구)정처기/컴퓨터일반] (4) 소프트웨어 공학 자주 틀리는 내용 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.     소프트웨어 생명주기     나선형 모델            계획 수립(Planning) → 위험 분석(Risk analysis) → 개발(Engineering) → 고객 평가(Customer evaluation)            프로젝트 계획 단계의 특징     정의 단계의 시작 단계   개발 비용을 추정   유지보수 비용은 개발이 모두 끝난 뒤 책정   계획 단계에서 프로젝트 관리자의 임무는 매우 중요   소프트웨어 범위 결정 사항     기능, 성능, 제약 조건, 개발 인원, 일정 계획   위험성을 최소화 목적   소프트웨어 비용 측정 4가지 원칙     소프트웨어 비용 측정을 최대한 지연   분해 기술(단계별, 인월별 분해) 이용   실험적 비용 측정 모델을 이용   자동화 도구 이용   비용 측정 방법론     COCOMO(COnstructive COst MOdel)            Boehm, 상향식, 수학적 산정 기법       변화 모형(Basic, Intermediate, Detailed)       규모 모형(Organic, Semi-detached, Embedded)           Putnam 모형            시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력분포도 곡선       기초로 만든 자동화 도구 SLIM       대형 프로젝트의 노력 분포 산정에 용이           CPM(Critical Path Method)     병행 작업이 가능하도록 계획   비용측정은 하지 않음   이전 작업이 모두 완료되지 않으면 다음 작업으로 진행 불가   정확한 일정 예측은 불가능   위험 관리 절차     위험 식별 : 위험 요소가 될 사항   위험 분석 및 평가 : 위험의 비중과 영향력 파악   위험 관리 계획 : 위험 예방, 대안 준비, 문서화   위험 감시 및 조치 : 위험 관찰, 모니터링   위험표 포함 사항     위험 발생 확률   위험의 내용 및 종류   위험에 따르는 영향력   위험 발생 시간 X   자료 흐름도     프로세스 : 원 / 데이터 흐름 : 화살표 / 데이터 저장 : 실선 2줄 / 입출력 : 사각형   소단위 명세서     설계 단계에서 사용하는 구조적인 언어 사용 가능   서술 문장, 의사결정 나무, 의사 결정표, 표, 그래프 등   소프트웨어 설계 모형     문서량 기준 : 데이터(DD, 메타데이터) ⇒ 구조(구조도) ⇒ 관계 ⇒ 절차(PDL 알고리즘)   노력 기준 : 절차 ⇒ 관계 ⇒ 구조 ⇒ 데이터   HIPO(Hierarchy plus Input Process Output)     하향식 설계 기법, IBM에서 개발한 프로그램을 기능 위주로 문서화   입력/처리/출력 구성, 소규모 프로젝트에 적합   도식 목차(가시적 도표, Visual Table of Contents) : 전체적인 흐름과 구조   총괄 도표(총체적 도표, Overview Diagram) : 입력, 처리, 출력 등의 기능 명확히 표현   상세 도표(세부적 도표, Detail Diagram) : 총괄 도표의 일부 기능을 구체적으로 표현   자료 흐름 설계 과정     정보 흐름의 유형을 설정   흐름의 경계를 표시   자료 흐름도를 프로그램 구조로 사상 ⇒ 변환 사상(Transform Mapping)   제어 계층을 분해시켜서 정의   경험적 방법으로 구체화   결합도(약 → 강)     데이터 결합도(Data Coupling)   구조 결합도(Stamp Coupling) : 두 모듈이 매개 변수로 자료를 전달할 때, 자료 구조 형태   제어 결합도(Control Coupling)   외부 결합도(Extern Coupling)   공통 결합도(Common Coupling) : 두 모듈이 동일한 전역 데이터를 접근   내용 결합도(Content Coupling) : 하나의 모듈이 직접적으로 다른 모듈의 내용 참조   응집도(약 → 강)     우연적 응집도(Coincidental Cohesion)   논리적 응집도(Logical Cohesion)   시기적 응집도(Temporal Cohesion)   절차적 응집도(Procedural Cohesion)   통신적 응집도(Communication Cohesion)   순차적 응집도(Sequential Cohesion)   기능적 응집도(Functional Cohesion)   객체지향 분석 순서     객체 모델링 : 객체의 속성, 연산을 식별   동적 모델링 : 객체 모형들의 행위, 상태, 조건을 파악   기능 모델링 :  입출력 결정 ⇒ 자료 흐름도 ⇒ 기능의 내용 상세 기술 ⇒ 제약사항 결정 / 최소화   객체지향 기술     다형성 : 동일한 메소드를 다양한 방법으로 사용할 수 있는 능력   객체 분석     형식적인 전략으로 기술   모델링 구성 요소인 클래스, 객체, 속성, 연산들을 표현해서 문제를 모형화   E-R 다이어그램 적합, 개념적으로 파악   객체 설계     구체적인 절차, 객체의 속성과 자료 구조를 표현   서브 클래스와 메시지 특성을 세분화하여 세부사항을 정제화   사용자 중심, 대화식 프로그램의 개발에 적합  cf) 객체 구현 : 객체의 정의   객체지향 기법 vs 구조적 프로그래밍 기법     추상적 자료형  vs 절대적 자료형   객체 사용 vs 함수 사용   메시지를 통해 객체 호출 vs 매개 변수를 통해 함수 호출   전역 변수에 영향 없음 vs 전역 변수에 영향 받음   화이트 박스 검사 방법     기초 경로 검사(Basic Path Testing)            가능한 경로를 어느 정도 통과하는지의 적용 범위성 측정       복잡도(Cyclomatic Complexity)       V - E + R = 2 (V : 노드의 수, E : 간선의 수, R : 영역의 수)       화살표로 둘러싸인 면의 수 + 1           블랙 박스 검사 방법     균등 분할(Equivalence Partitioning) : 정상 데이터 / 비정상 데이터   한계값 분석(Boundary Value Analysis) : 범위 한계 위주   원인-결과 그래프(Cause-Effect Graphing) : 임의의 자료 입력 ⇒ 정상 출력 확인   오류 예측(Error Guessing) : 데이터 확인 방법, 위 3가지 이외 오류 검사   비교 검사 : 하나의 프로그램을 여러 컴퓨터에서 테스트   소프트웨어 검사 단계     단위 검사(Class) ⇒ 통합 검사 ⇒ 검증 검사 ⇒ 시스템 검사   cf) 개발 순서 : 시스템 공학 ⇒ 요구 분석 ⇒ 설계 ⇒ 코딩(구현)   통합 검사     하향식(Top Down) 통합 검사 : 가짜 모듈이 필요(Stub), 회귀 검사, 프로그램 전체 실행   상향식(Bottom Up) 통합 검사 : Cluster, Driver, 중요한 모듈 우선 검사 가능   클러스터 결함 ⇒ 드라이버 작성 ⇒ 클러스터 검사 ⇒ 드라이버 제거 후 상위 결합   유지보수 비용 측정     BL방법 : M = P + K * e^(c-d) (M:인원/월, P : 비용, K : 상수, c : 복잡도, d : SW지식)   유지보수 작업의 종류     하자보수(=수리보수, Corrective M) : 잠재적인 오류 수정   기능 개선(=완전보수, Perfective M) : 기능의 수정, 추가, 전반적인 기능 개선 ⇒ 비용 많음   환경 적응(=적응보수, Adaptive M) : 환경 변화에 대응하여   예비 조치(=예방보수, Preventive M) : 미리 예측하여 준비   품질 목표 항목     정확성(Correctness) : 요구사항 충족시키는 정도   신뢰성(Reliability) : 요구된 기능을 오류없이 수행하는 시스템 능력 정도   효율성(Efficiency) : 최소한의 처리 시간과 기억 장소를 소유하여 요구된 기능 수행   유연성(Flexibility) : 새로운 요구사항에 접하여 쉽게 수정될 수 있는 능력   OMA(Object Management Architecture) 레퍼런스 모델     객체 간의 관계를 표현하는 표준 참조 모델   Object Service, Common Facilities, Domain Interface, Application Interface   소프트웨어 재공학(Reengineering)     개조(Restructuring) : SW 기능을 변경하지 않으면서 SW 형태에 맞게 수정   같은 추상적인 수준에서 하나의 표현을 다른 형태로 바꾸는 작업   분석(Analysis) : 기존 SW의 명세서를 확인하여 SW 동작을 이해, 재공학 대상 선정   재개발(Redevelopment) : 기존의 SW 삭제 ⇒ 새롭게 개발   소프트웨어 재사용 단위     명령어, 모듈, 요구분석서, 설계, 코딩 ⇒ 개발 비용은 변하면 안됨  ","categories": ["study"],
        "tags": ["(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/software-engineering/",
        "teaser": null
      },{
        "title": "[(구)정처기/컴퓨터일반] (5) 데이터통신 자주 틀리는 내용 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.     네트워크 서비스     여러 개의 컴퓨터를 연결하여 각각에 연결된 컴퓨터의 하드웨어 자원과 소프트웨어 자원을 공유, 데이터나 파일을 공유   데이터 통신 시스템의 발전     SAGE : 미국의 군사용 방공 시스템, 최초의 데이터 통신 시스템   SABRE : 항공기 좌석 예약 시스템, 상업용   ARPANET : 최초의 유선 패킷 시스템, 인터넷 기술의 모체   ALOHA : 최초의 무선(라디오) 패킷 네트워크 시스템, CSMA, CSMA/CD의 모체   CTSS : 최초의 학내 시스템, 시분할 기술 최초 사용   SNA(System Network Architecture) : 네트워크의 표준화를 제시한 최초의 네트워크 시스템   데이터 통신 시스템     데이터 전송계            단말장치(DTE : Data Terminal Equipment)                    데이터 전송 회선                       신호변환기(DCE) / 통신회선       통신 제어 장치(CCU:Communication Control Unit) : 오류/동기/흐름/응답 제어           데이터 처리계            컴퓨터                    하드웨어 / 소프트웨어                           DTE ⇒ DCE ⇒ 통신망 ⇒ DCE ⇒ DTE ⇒ CCU ⇒ HOST Com   데이터 통신 시스템의 구성 요소     통신 시스템의 3대 구성 요소 : 단말 장치, 통신 제어 장치, 전송 장치   전송 시스템의 3대 구성 요소 : 단말 장치, 통신 제어 장치, 데이터 전송 회선   베어러 속도 = 반송 속도     데이터 신호에 동기 신호와 상태 신호를 합한 속도   디지털 vs 아날로그 신호     디지털 : 많은 대역폭이 필요, 전송 거리가 짧아 증폭기 사용, LSI/VLSI 기술 진보   모뎀의 분류     동기 방식            비동기식 모뎀 방식 : ASK, FSK       동기식 모뎀 방식 : PSK, QAM           FSK(Frequency Shift Keying: 주파수 편이 변조)  Non-coherent 방식 : 다양한 주파수와 진폭, 다양한 모양의 위상, 비동기와 유사   QAM(Quadrature Amplitude Modulation : 진폭 위상 변조, 직교 위상 변조)  Coherent 방식 : 단일 주파수, 같은 모양의 위상, 동기와 유사  2차원 벡터 공간에서 신호를 사용할 수 있음   DSU(Digital Service Unit)     신호 변환 방식            단극 RZ(Return to Zero)       양극 NRZ(Non Return to Zero)                    NRZ-L(Level) : ‘1’ : 양극 / ‘0’ : 음극           NRZ-M(Mark=’1’) : ‘1’ : 비트 간격의 중간에서 천이 / ‘0’ : 천이 없음           NRZ-S(Space=’0’) : ‘1’ : 천이 없음 / ‘0’ : 비트 간격의 중간에서 천이           NRZ-I(Inversion) : ‘0, 1 ⇒ 1’ : Interval 중간에서 변화                       바이폴라(Bipolar)                    AMI(교호 반전 부호), 3원 부호, ISDN 신호 방식, 동기화 어려움           ‘1’ : 양극과 음극 교대로 변환, ‘0’ : Zero                       맨체스터(Manchester)                    하나의 펄스폭을 2개로 나누어 ‘1’, ‘0’을 반대로 구성하여 사용           CSMA/CD LAN에서의 전송부호로 사용, 동기화 가능                           CODEC     양자화 잡음(PCM 극 장치) : 실수형의 표본 값 ⇒  정수 반올림, 이 때 발생하는 오차   부호화 : 인접 부호 간 1비트만 변화하는 그레이코드 주로 사용            원천 부호화: 제한된 대역폭에서 고속 전송                    DM(Delta Modulation), PCM(Pulse Code Modulation) 허프만 코딩, LPC(Linear Predictive Coding), PNM                        채널 부호화 : 에러 검출 및 정정을 위한 비트를 추가하여 전송       파형 부호화 : 디지털 부호를 전송 회선에 적합한 파형으로 변환하는 방식                    PCM, DPCM, ADPCM, DM                            ISI(InterSymbol Interference)  PCM에서 수신된 신호 파형이 일그러져서 각 비트에 할당된 슬롯 타임을 벗어나 인접 슬롯 타임에 영향을 주는 현상, 이러한 현상으로 신호 파형이 중첩되게 된다 중첩되는 모양을 오실로스코프로보면 사람의 눈을 닮아 아이 패턴이라 함   Optimum Sampling Time : 아이 패턴이 열린 최대 높이가 최적의 샘플링   Sensitivity to Timing Error : 아이 패턴의 기울기를 통해 시간 오차에 대한 민감도 평가   Noise Margin : 아이 패턴이 눈을 뜬 상하의 높이 만큼   Maximum Distortion : 아이 패턴의 맨 위와 맨 아래의 파형들의 진동폭은 신호가 샘플링되는 순간 왜곡되는 최대값   비동기식 전송     간헐적, 독립적, 문자 단위 전송   휴지 시간 존재, 저속 전송, 버퍼를 적게 사용   대화용 전송에 적당, ASK/FSK   일반적으로 패리티 비트 추가 전송     동기식 전송       블록 단위 전송, 파일 전송 적합   PSK, QAM   RS-232C     핀4(RTS-송신 요청) : 송신할 데이터가 있음을 DTE에서 DCE로 전달   핀5(CTS-송신 준비 완료) : DCE에서 DTE로 신호 전달, ON/OFF   핀8(DCD-수신선 신호 감지) : DCE가 선로쪽으로부터 감시할 수 있는 크기의 신호를 수신하고 있음을 DTE에게 통보   데이터 전송 프레임     문자 지향 프레임 = BSC 프레임 구조            BASIC, 반이중 방식만 사용       같은 전송 회선만 가능 (종속적)       동기/비동기 전송 방식 사용       SYN(7) / SYN(7) / SOH(7) /Heading / STX(7) / TEXT / ETX(7) / BCC(7)           비트 지향 프레임            동기식 전송       Flag(8) / Address(8bit ~ 8Byte) / Control(8/16) / Info / FCS(16/32) / FLAG(8)       Control                    I Frame : 첫 번째 비트가 0, 순수한 정보, 피기백킹           S Frame : 상위 두 비트 10, 감시, 감독           U Frame : 상위 두 비트 11, 초기 설정 및 링크 확립과 해제                            NRM(표준 응답 모드 : Normal Response Mode, UNC)  반이중 통신, 주 스테이션이 링크 제어               ARM(비동기 응답 모드 : Asynchronous Response Mode, UAC)  전이중 통신, 주 스테이션이 링크 제어               ABM(비동기 균형 모드 : Asynchronous Balance Mode, BAC)               전이중 통신, 주 스테이션과 부 스테이션 구분이 없음               링형, 망형 구조               X.25링크에서 LAPB와 동일               SIM(Set Initial Mode) : 설정 초기화                                                   오류 제어     순방향 오류 수정(FEC : Forward Error Correction) :            해밍코드                    해밍 거리 : 같은 비트 수를 갖는 이진 부호 사이에 대응되는 비트 값이 일치되지 않는 것의 개수                        상승코드           역방향 오류 수정(BEC : Backward Error Correction) : 역 채널 필요 ⇒ 재전송            CRC, 패리티 비트, 블록 합       ARQ                    Stop-And-Wait : BASIC 전송 절차           Go-Back-N :                            오류가 발생한 프레임부터 다시 전송, 중복 전송 문제 발생               HDLC, SDLC                                   Selective-Repeat :                            오류가 발생한 프레임만 재전송, 별도의 버퍼가 필요               HDLC                                   Dynamically                           오류 검출 방식     군 계수 검사 방식   패리티 방식 : 짝수 개의 비트가 오류가 발생할 경우 검출률이 낮아짐            수직 중복 검사(VRC : Vertical Redundancy Check)       세로 중복 검사(LRC : Longitudinal Redundancy Check)       순환 중복 방식(CRC : Cyclic Redundancy Check = 집단, 군집 오류 검출)                    다항식을 계산, 오류를 수정할 수는 없음(재전송 요청)           동기식 전송에 적합                           검사 합(Check Sum)   해밍 코드   상승 코드  여러 개의 비트 오류가 있더라도 한계값/순차적 디코딩을 이용하여 모두 수정   정 마크 방식 : 전송 비트수에 1의 개수와 0의 개수를 고정적으로 정하여 전달            2 out-of 5 : 5개의 비트 전송 ⇒ 1의 비트 2개, 0의 비트 3개           다중화기     주파수 분할 다중화(FDM : Frequency Division Multiplexing)            전송 매체의 유효 대역폭이 클 때 사용       아날로그 신호, 비용 저렴, 기술이 간단       비동기식 전송, 멀티 포인트 방식에 적합       모뎀의 역할을 겸하므로 별도의 모뎀이 필요하지 않음       전송지연 없이 실시간 전송이 가능       보호대역 때문에 대역폭이 낭비       TV, 라디오와 같은 공중파, CATV, ADSL           시간 분할 다중화(TDM : Time Division Multiplexing)            전송 매체의 유효 전송률이 클 때 사용       디지털 신호, 비용/기술 복잡       전송지연 없이 실시간 전송이 가능       별도의 모뎀 필요, 대역폭이 낭비되지 않음       STDM(동기식 시분할 다중화 : Synchronous TDM)       ATDM(비동기식/통계적 시분할 다중화 : Asynchronous TDM)                    흐름 제어, 에러 제어 및 자체 진단 기능 ⇒ 지능 다중화기           헤더 정보를 필요로 하며, STDM에 비해 시간 슬롯 당 정보 전송률 증가                           코드 분할 다중화(CDM : Code Division Multiplexing)            확산 대역 방식, 전송 용량/품질 증가       보안성 보장, 전송지연이 감소, 이동통신에 사용           다중화의 발전 기술     OFDM(Orthogonal Frequency Division Multiplexing : 직교 주파수 분할)            분할된 반송파 사이의 주파수 간격을 최소화하기 위해 직교 다중화           DSSD(Direct Sequence Spread Spectrum)            고정된 하나의 채널을 이용하여 전송하는 방식       디지털 데이터를 넓은 대역으로 분산하여 전송하는 방식           FHSS(Frequency Hopping Spread Spectrum)            23개의 채널을 이용하여 데이터를 전송하는 방식       송수신측에서 주파수의 위치를 변화시키면서 통신하는 방식           블루투스     RF &amp; Baseband - 물리 계층 : 통신 장비   Link Manager - 링크 계층 : 연결 보안 설정   HCI Bottom - 네트워크 계층   HCI Top - 전송 계층 : 통신 기기와 통신 기기 제어기 사이에 연결   L2CAP - 세션 계층 : 통신 기기 프로토콜과 통신 기기 제어기 프로토콜 사이를 중재   RFCOMM - 통신 기기 간의 논리적 접속 제어   Application   집중화기     여러 개의 채널을 몇 개의 소수 회선으로 공유화시키는 장치   구조 복잡, 불규칙 전송에 사용   입출력 각각의 채널 대역폭이 다르다   전용 회선     직통 회선 / 분기 회선 / 직선 분기 회선    교환 회선     회선 교환 방식 : 관리 제어 신호, 주소 제어 신호, 호 정보 제어 신호, 감시 제어 신호            SLIP : 교환기 사이에 클록 주파수의 차이로 데이터의 손실이 발생 (DCS 설치 필)       공간 분할 교환 방식                    단일 / 다단 교환 방식                       시간 분할 교환 방식                    TDM 버스 교환 방식 ⇒ 동기식           시간 슬롯 상호 교환 방식 ⇒ 대부분 사용, 전 2중 동작을 위해 한 쌍의 슬롯           시간 다중화 방식 : TSI 장치 문제점(크기가 커지면 지연이 커짐) 해결                           축적 교환 방식            메시지 교환 방식       패킷 교환 방식                    가상 회선 패킷 교환 방식           데이터 그램 패킷 교환 방식                           교환 기술의 성능 비교 요소     전파 지연 / 전송 시간 / 노드 지연 시간 / 데이터 처리율   경로 선택     비적응적 방법 : 정적, 수동적인 방법            고정 경로 선택(=착국 부호 방식, Fixed Routing)  상대방에 미리 붙여둔 번호를 해석해서 진행 경로 선정       범람 경로 선택(Flooding Routing)           적응적 방법 : 능동적            국부적 경로 선택(Isolated Routing) : 독립적인 판단에 의해 결정       분산 경로 선택(Distribute Routing) : 자신을 중심으로 연결되어 있는 모든 경로 정보 분석       집중 경로 선택(Centralized Routing) : 전체 네트워크 경로 흐름 파악/제어하는 RCC(Routing Control Center)의 정보로 경로를 선택           경로 선택 프로토콜     RIP(Routing Information Protocol) : 평면적인 구조, 인접해있는 게이트웨이 정보 취득   OSPF(Open Shortest Path Fast) : 계층적인 구조, 링크상태 알고리즘 사용   BGP(Border Gateway Protocol) : 두 개 이상의 AS(자율적으로 사용하는 라우터 집합)로 사용되는 프로토콜, 관리자에 의해 독자적인 경로 설정이 필요할 때 사용   IGRP(Internet Gateway Routing Protocol) : BGP를 보완, 중간 규모 네트워크   RTP(Reliable Transport Protocol) : EIGRP(IGRP 개선) 패킷의 송수신을 위해 사용   트래픽 제어     흐름 제어            슬라이딩 윈도(Sliding Window)  송신측에서는 수신측으로부터 전송할 프레임의 개수 미리 지정받음  수신측에서 전송할 프레임의 개수를 다시 지정 시 전송 가능  X.25 패킷 레벨의 프로토콜에서도 사용           혼잡 제어   교착 상태 회피   LAN(Local Area Network)     어떤 종류의 시스템 기기와도 연결이 가능   오류 발생률 낮고 전송 지연을 최소화할 수 있음   공유 매체 사용 ⇒ 경로 선택 없이 매체에 연결된 모든 장치로 데이터 전송 가능   재배치, 확장성 우수   광대역 전송 매체의 사용으로 고속 통신이 가능   DCF(CSMA/CA방식) : IEEE 802.11의 기본적인 매체 접근 방식   ISDN(Integrated Service Digital Network)     하나의 통신망으로 통폐합 ⇒ 확장성, 재배치 우수   모든 통신 선로와 교환기를 디지털화   복수 통신 가능, 중복 투자 회피(경제적)   기존 전화망 ⇒ 디지털 교환기와 연결하여 기본 서비스 제공(2B+D)   규모가 큰 사용자와 기업은 광케이블 설치하여 1차군 서비스(23B/30B+D) 제공   회선 교환 방식, 패킷 교환 방식   64kbps 1회선 교환 서비스가 기본   접속점(기준점, 분계점)            타인의 전산망 기기와 접속되는 경우에 그 설치와 보전에 관한 책임의 한계를 명확하게 구분하기 위한 접속점       U(User) / T(Terminal) / S(System) / R(Rate)           ATM(Asynchronous Transfer Mode : 비동기 전송 방식)     일정한 크기(쉘)로 구분하여 순서대로 전송하는 자료의 전송 방식 ⇒ 송수신 처리 간단   오버헤드가 줄어 고속 전송 가능, 멀티미디어 서비스 적합   비동기식 다중화 방식 사용   양 끝단 간 오류와 흐름을 제어 ⇒ 어떤 종류의 서비스라도 제공 가능   물리 계층 : 셀의 속도 조정, 셀의 경계 식별, 비트 타이밍   ATM 계층 : 일반 흐름 제어, 셀 헤더 생성 및 추출, 셀 교환, 셀 다중화 및 역다중화   ATM 적용 계층(AAL) : 수렴과 셀 분할 조립   상위 계층 : 서비스별 상위 계층 기능   LAN 계층     물리 계층 + 데이터 링크 계층    X.25 계층     물리 계층 + 프레임 계층 + 패킷 계층    TCP/IP(인터네트워킹) 계층     링크 계층 + 인터넷 계층 + 전송 계층 + 응용 계층    PPP(Point to Point Protocol)     전화선과 모뎀을 이용하여 인터넷에 접속하기 위한 프레임 프로토콜   SLIP 개선 ⇒ 에러 검출 기능, 복구 기능 추가, 문자 위주 프레임   IETF 표준 프로토콜, 다중 프로토콜 지원   오류 검출만 제공, 재전송을 통한 오류 복구와 흐름 제어 기능 제공하지 않음   비동기식 링크도 지원해야 하므로 프레임은 반드시 바이트의 정수배   Protocol Field            PAP(Password Authentication Protocol)  초기 접속 시 ID/Password를 미리 입력해 놓으면 자동으로 접속  2-Way 방식       CHAP(Challenge Handshake Authentication Protocol)  매번 접속 시 3단계 핸드쉐이크 인증을 행하는 방법, 안전           IP 계층의 주요 기능     패킷을 절단(단편화), 재조립   비연결성 네트워크 프로토콜   주소 지정, 논리적으로 관리   수명 시간 관리, 오류 제어, 흐름 제어   네트워크 계층 프로토콜     ARP(Address Resolution Protocol)   RARP(Reverse Address Resolution Protocol)   ICMP(Internet Control Message Protocol)   IGMP(Internet Group Management Protocol)   DNS(Domain Name System)   DHCP(Dynamic Host Configuration Protocol)   전송 계층 프로토콜     RTP(Real Time Transport Protocol)            실시간으로 음성이나 동화상을 송수신하기 위한 통신 규약       UDP / 응용프로그램 사이       Version(V)       Padding(P) : 추가적인 데이터들이 포함되어 있는지를 표시       Extension(X) : 고정 헤드와 페이로드 사이에 확장 헤드가 있는지 여부 표시       Marker(M) : 패킷 스트림에서 프레임 간의 경계에 존재하는 특별한 경우       PT(Payload Type) : 데이터가 어떤 형식인지를 결정       Sequence Number       TimeStamp : 첫 번째 바이트의 샘플링 시점           RTCP(RTP Control Protocol)            RTP를 제어하기 위한 프로토콜           국제 표준화 단체의 기술     ISO : HDLC   IETF : PPP   IEEE : LLC   ITU : LAPB, CCITT, PSDN, PSTN, IDSN   서브넷 마스크     네트워크 논리적인 분할, 네트워크 ID와 호스트 ID 구별   네트워크의 부하 감소   A Class : 1 + Network Address(7) / Host Address(24)   B Class : 10 + Network Address(14) / Host Address (16)   C Class : 110 + Network Address(21) / Host Address (8)   D Class : 1110 + Multicast Address   E Class : 1111 + Test Address  ","categories": ["study"],
        "tags": ["(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/data-communication/",
        "teaser": null
      },{
        "title": "[토익/TOEIC] 문법 실전 압축",
        "excerpt":"주어      There is/are/remain/exist 뒤에는 명사 주어   가짜주어 it ⇒ (for+명사) to부정사 / that절   (빈칸) that S + (should)+동사원형            Insist / order / suggest / ask / request / demand            It is (빈칸) that S + (should) 동사원형            Important / vital / imperative / necessary / essential / advised            명령문 ⇒ (Please) + 동사원형으로 시작   보어      주격보어 자리 =&gt; 형용사(상태/설명), 명사(동격)   주격보어를 가지는 동사 : ~가 되다/유지되다/지속되다/감각 동사            Become / come / grow / go / get / turn / stay / remain / seem / prove  감각동사 : feel / taste / smell / look / sound            목적격 보어 Keep / Consider / Find + O + O.C(형용사)     make / leave   Call / consider / elect / make + O + O.C(명사/ 목적어와 동격)   Describe / regard A(O) as B(O.C)   동사   조동사     Cannot help V-ing  = cannot but V·R  = cannot help/choose but V·R  = have no choice but to V·R = ‘~하지 않을 수 없다’   Cannot ~ too = ‘아무리 ~해도 지나치지 않다   Had better + V·R = may as well + V·R = ‘~하는 것이 낫다’   May well + V·R ‘~하는 것도 당연하다’   Might as well A(V·R) as B(V·R) ‘B할 바엔 A하는 것이 낫다’   Be going to V·R / be about to V·R   Be willing to V·R   사역 동사  Have/make + O + O.C ⇒ 동사원형(능동’~하게하다’) / p.p(수동’~되게하다’)  Get + O + O.C ⇒ to부정사(능동) / p.p(수동)  Help + (O) + 동사원형 or To부정사(의미차이 없음)  Let + O + 동사원형 or Be p.p(수동)   자동사 vs 타동사     자동사(Intransitive Verb : vi) =&gt; 목적어 X =&gt; 수동태 X   자동사 : last / expire / function /  proceed / rise / work / fall / exist / participate   혼용(자/타) : decline - vi. 감소하다 / vt. 거절하다   자동사 + 전치사                                                                          Account for       agree (to/with/on)       apologize for       apply (for / to)       benefit from                 belong to       care for       comply with       consent (to/with/on)       contend with                 contribute to       cooperate with       cope with       deal with       depend on                 differ from       engage in       Arrive (at/in)       interfere with       listen to                 look after       look into       look at       look over       look for                 object to       participate in       react to       refer to       rely on                 reply to       respond to       speak to       specialize in       talk (about/to)                 wait for       proceed (with, to)       dispose of       deal with                   타동사(Transitive Verb : vt) =&gt; 명사구(목적어)     Access =&gt; n. 접근(~to), v. 접근하다(타)                                                                          accompany       announce       answer       approach       approve                 attend       await       contract       discuss       email                 emphasize       explain       interview       leave       marry                 mention       oppose       reach       resemble       raise                 organize       establish       conduct       address                   동사는 주어에 수일치     불가산명사 / 고유 명사 ⇒ 단수 취급   one / each / every + 단수명사 ⇒ 단수 취급   each of the / neither of the / the number of / one of the + 복수 명사 + 단수 동사   a couple of / a number of / a variety of + 복수 명사 + 복수 동사   4형식 동사 =&gt; 목적어 2개     offer(*offer to : 제안하다) / award / forward / grant / give / pay / send / refund            ※ 수동태 형식일 때 뒤에 목적어가 남을 수 있음.           3형식 동사 : announce / describe / explain / mention / say / suggest + (to + 명사) + O   4형식 동사 : advise / assure / notify / convince / inform / remind / tell + O + O(that)   5형식 동사, O + O.C(to V)                                                                          allow       permit       ask       require       encourage                 expect       advise       tell       force       order                 want       elect       deem       show                      ※ Ask / expect / want / would like + to V (3형식)   ※ Tell A about B(3형식)   수동태   4형식 동사의 수동태 뒤 ⇒ 목적어 : (S + V + I.O + D.O)  advise / assure / convince / inform / notify / remind / tell ⇒ S + be P.P + that     ※ (Notify / inform / remind) A of B : A에게 B를 알리다   5형식 동사의 수동태 뒤 ⇒ 목적 보어 (S + V + O + O.C)     consider / call / make / leave / keep / find / appoint / name   be encouraged to / be asked to / be expected to / be told to / be required to   Expect + to v (3형식)   사람의 감정 ⇒ 수동태                                                                          Encourage       distract       amaze       depress       excite                 exhaust       tire       please(with)       amuse(at)       satisfy(with)                 interest(in)       fascinate(with)       excite(by)       disappoint(at)       discourage(by)                 depress(by)       frustrate(with)       shock(at)       surprise(at)                   수동태 + 전치사     For            known / renowned / used            With            satisfied / pleased / associated / concerned / equipped / faced / covered            To            dedicated / devoted / committed / exposed / related / assigned            To -V            allowed / permitted / asked / requested / invited / required / advised / prompted / reminded / warned / encouraged / intended / prepared / supposed / scheduled / excited / pleased / entitled / prepared / pleased  be entitled to (V / 명사)            In            interested / engaged / involved / absorbed / included            Etc            based on / divided into            목적어   가목적어는 5형식 구문에서 사용 가능     Make it possible to v   (for + 명사) 의미상 주어 + to v   (to + 명사) + that절   목적어가 있으면 능동태, 없으면 수동태     자동사는 목적어가 없어도 항상 능동태   attend + O : ~에 참석하다 / attend to ~ : ~을 처리하다, 시중들다   시제   과거 시제 ⇒ 과거에 이미 끝난 동작 or 상태     Ago, yesterday, last   Once / recently   과거 완료 시제     By the time + S + 과거시제, S + 과거완료(had p.p)   before/after 접속사 구문에서는 과거시제를 사용하기도 함   현재 시제     반복(usually, always, often, everyday) / 습관적 / 일반적 사실 / 규칙 / 규정 ⇒ 현재 시제   cf) have always p.p : 항상 예전부터 ~ 해왔다   가까운 미래를 대신할 수 있음            come/go/depart/leave/arrive/expire/end/conclude/complete/start/finish            현재 진행     가까운 미래 ⇒ 이미 예정된 일   Now / right now / currently   현재 완료 시제     have p.p ~ before   have + once/recently + p.p   have + p.p + since 과거   for/in/(over the last/past) + 기간, ~ have p.p   in the last/past + 기간(과거 ~ 동안) + have p.p   미래 시제     be to 명사적 용법, 미래 시제(~할 것이다/~할 의무이다 = is due to v)   next / in / shortly / soon / upcoming   미래 완료 시제     will have p.p 과거(시작) ⇒ 현재 ⇒ 미래(완성)   by the time S + V, S + V(미래/미래완료)   준동사(To부정사, 동명사)   To부정사를 목적어로 취하는 동사                                                                          determine       offer       aim       refuse       fail                 promise       hesitate       intend       (dis)agree       try                 want       hope       wish       expect       decide                 choose       plan       prepare       intend       ask                 need                                           To부정사를 목적 보어(5형식 구조)로 취하는 동사     advise / ask / invite / allow / persuade / force / encourage / require / request / expect / enable    To부정사와 함께 쓰이는 명사/형용사     명사 + To v (~ 할)            ability/authority/plan/promise/right/time/authorization/opportunity/permission/way + to do            형용사 + to            be + (able / about / hesitate / likely / ready / willing / liable / eager / difficult / delighted) +to            To부정사는 목적(~하기 위해서)/이유(~하기 때문에)/결과(~해서)를 의미할 수 있다     by ~ing : ~ 함으로써   in order to / so as to / in order that: ~ 하기 위해서   be (happy / glad / pleased) to ⇒ 이유(~하기 때문에)   Only to V : (그러나) 결국 ~하다   동명사   전치사 + 동명사 + 관사 + 명사  전치사 + 동명사/과거분사 + 명사 ⇒ 해석(동명사 : 명사하는 것 / 과거분사 : ~된 명사)   동명사를 목적어로 취하는 동사 - MEGA P(F)AS(C) ID     Suggest / consider / postpone / avoid / recommend / deny / finish / quit / discontinue / give up / keep / enjoy / include / mind    동명사 관용구     have difficulty / trouble / a problem (in) ~ing/with 명사   be busy/used to ~ing(~하는데 익숙하다)   cf) be used to v : ~하기 위해 사용되다   (Cannot help) /keep (on) / feel like / go / on / upon(~하자마자)   upon (전치사) + 명사+목X / 동명사+목O   it is no use v-ing / be capable of v-ing / be worth v-ing / feel like v-ing /   spend (시간/돈) v- ing / prevent A from B v-ing   전치사(To) + 동명사     be (committed / dedicated / devoted / opposed / related / used / accustomed)   object / contribute / look forward / lead   To부정사 또는 동명사를 목적어로 취하는 동사     continue / begin / hate / love / prefer / start (의미에 차이가 없음)   forget / remember / regret + to부정사 : 앞으로~할 / ing : 과거에 이미 ~한   주의) begin + 명사목적어   준동사(분사)   현재분사(~하는/하면서, ~ing) / 과거분사(~되는/되면서, p.p)     when/while/after/before/until/if + ~ing   접속사 + S + V ⇒ 주어 제거, 동사원형 + ~ing(being은 생략) ⇒ 접속사 + ing/p.p   with + 명사 + 분사(현재:~가 ~한 상태로/과거 : ~가 ~된 상태로)   with + 명사 + 형용사(~가 ~한 상태로)   혼동하기 쉬운 표현                  Leading hotel       일류 호텔       Prefered option       선호되는 선택권                 Opening statement       개회사       Proposed change       제안된 변경 사항                 Promising opportunity       유망한 기회       Experienced professional       숙련된 전문가                 Existing manual       기존 설명서       Detailed description       자세한 설명                 Lasting effect       지속적인 영향       Attached file       첨부된 파일                 Improving market       발전하는 시장       Limited budget       제한된 예산                 Missing information       누락된 정보       Damaged appliance       손상된 기기           명사   품사가 혼동되는 단어     visit : v. 방문하다 n. 방문   timely/orderly/friendly ⇒ 형용사   potential/advance   가산 명사 / 불가산 명사     가산 명사 : detail / suggestion / request / profit / increase / bonus / price / discount / rate / fund / refund / reservation / approach / permit / plan / account   불가산 명사 : approval / satisfaction / advice / confirmation / housing / baggage / luggage / information / equipment / construction / furniture / appreciation / participation / access / permission / planning / Merchandise   사람 / 사물 / 추상 명사                  critique       평론       criticism       비평                 critic       비평가       facilitator       조력자                 facilitation       촉진       architect       건축가                 authority       권위자       authorization       권한 부여                 architecture       건축       beneficiary       수혜자                 benefit       이익       coordinator       조정자                 correspondent       통신원       correspondence       연락                 coordination       조정       relative       친척                 relation       관계                           비슷한 의미를 가지는 단어 주의                  utilization       활용       utility       효용                                 process       과정, 절차       processing       가공,처리                                 cover       표지       coverage       범위                                 alternative       대안       alternation       교체       alteration       수정                 indicator       지표       indication       암시                                 initiation       시작,개시       initiative       주도, 계획                                 as one’s own initiative       ~의 주도로                                           복합 명사                  customs office       세관       savings account       저축계좌                 registration process       등록절차       registration fee       등록비                 registration office       등록사무소       safety precautions       안전 예방책                 safety regulations       안전 규정       benefits package       복리후생제도                 awards ceremony       시상식       confirmation number       예약 확인 번호                 manufacturing process       제조 과정       feasibility study       타당성 조사                 earnings growth       수익 성장       office supplies       사무용품                 living expenses       생활비       sales quota       판매 할당량                 reference letter       추천서       travel arrangements       출장 준비                 Performance appraisals/evaluations       업무 수행 평가                                 Customer service representative       고객 서비스 상담원                           대명사   지시대명사     That ⇒ 단수명사, those ⇒ 복수명사   Those (who + be) : ~하는 사람들   부정대명사 / 부정형용사     Other ⇒ 가산 명사 복수/불가산(혼자 쓰일 순 없음), another ⇒ 가산 명사 단수 앞   Another + 시간/거리/무게단위   The others : (대명사) 나머지들   Any other : 가산 명사 단/복수, 불가산   Other + 복수명사 == others   소유대명사     one’s own ⇒ 명사 수식(소유격)   one’s own + 명사 : ~ 자신의 (것) = 명사 of one’s own   on one’s own = by oneself : 스스로   재귀대명사     재귀대명사는 목적어 자리에 올 수 있다 (주어 == 목적어)   재귀대명사 강조 : 주어/목적어 뒤(생략 가능)   재귀대명사 관용어구            For oneself : 혼자힘으로       Of itself / in itself : 본질적으로       Pay for itself : 본전을 찾다       Have + O + to oneself : O를 주어가 차지하다       Help oneself to + 명사 : (음식을)맘껏 먹다/(사물을)맘껏 사용하다           형용사   다른 의미를 가지는 형용사                  Distinguishable       구별할 수 있는       Distinguished       유명한                 Advisable       권할 만한       Advisory       자문의, 경고                 Argumentative       시비를 거는       Arguable       주장할 수 있는                 Comparable       필적할 만한       Comparative       비교의                 Confident       확신하는       Confidential       비밀의, 신임하는                 Dependent       의존적인       Dependable       믿을 수 있는                 Considerate       사려 깊은       Considerable       상당한                 Enviable       부러운       Envious       선망하는                 Favorable       호의적인       Favorite       가장 좋아하는                 Informative       유익한       Informed       정통한, 알고 있는                 Momentous       중대한       Momentary       순간적인                 Reliable       믿을 수 있는       Reliant       의지하는                 Seasonal       계절적인       Seasoned       경험이 많은                 Successful       성공한, 성공의       Successive       연속의                 Understanding       이해심 있는       Understandable       이해할 만한                 Profitable       유리한       Proficient       능숙한                 Respectable       존경할 만한       Respective       각자의                 Careful       세심한, 조심스러운       Caring       보살피는                 Managerial       경영의       Manageable       관리할 수 있는                 Persuasive       설득력있는       Persuaded       확신하고 있는                 Prospective       장래의       Prosperous       번영하는           Be + 형용사     Be about to -v   Be available to -v   Be capable of v -ing   Be eligible for   Be responsible for   Be likely to -v   Be willing to -v   Be skilled in/at   명사의 수에 수량 형용사 일치     (Each / every / one / a single) + 가산 단수 명사 / each of the + 복수 명사(~중에 각각)   [some/most/any/rest/분수 + (of the)]/all (of) the/ + 가산 명사 복수 / 불가산 명사   another/each/few/little/most/many/much/some + (명사)   Other ⇒ 가산 명사 복수 / 불가산   A (wide/large/diverse) variety of = various   (Either/one) of the + 가산 복수 + 단수 동사   (few/most) of the + 명사   A few (조금의), few(거의 없는) ⇒ 가산 복수 명사   A little (조금의), little(거의 없는) ⇒ 불가산명사   Some/Any/Every/No + body/one/thing + 단수 명사   All / most / any / some / half / a lot(lots) / part / the rest / the bulk / percent / 분수  ⇒ of + (단수 명사 + 단수 동사) / (복수 명사 + 복수 동사)   형용사 + that     be aware that / be confident that / be (happy/glad) that / be optimistic that /   be positive that / be (confident/convinced/sure) that / be (afraid/sorry) that   (형용사 / 부사) + 형용사 + 명사     해석으로 접근!   수식받는 품사(형용사/명사)를 확인한다.   부사   동사를 수식하는 부사     Work cooperatively / rise significantly   Almost/nearly + everybody/everything/nobody/nothing/anybody/anything   비슷한 부사 어휘                  High       높게       Highly       대단히                 Even       심지어 ~조차       Evenly       고르게                 Right       바로 (부사)       Largely       주로                 Late       늦게       Lately       최근에                 Most       가장       Mostly       일반적으로, 주로                 Otherwise S + V       그렇지 않다면(접속부사)       Otherwise + V       달리(부사)           숫자를 수식하는 부사     거의/대략 ⇒ nearly/approximately/roughly/about/almost/around   At least/just/more than/only/over/up to   강조 부사     so/very/too/quite + 형용사/부사   *quite + 관사 + 형용사 + 명사   much too(부)/too much(형/부) + 명사/동사 수식   부사 + 동명사(동사의 성질이 있음)     관사X, 형용사X   소유격(~이/가, 의미상주어) + 동명사   동명사 + 목적어   동명사처럼 보이는 명사            clothing/funding/heating/housing/planning/processing/seating/spending/staffing           접속부사     접속 부사 != 접속사   S + V. 접속부사, S + V   S + V + 접속사 + 접속부사, S + V   양보 : however / nevertheless / nonetheless / still   결과 : accordingly / consequently / hence / therefore / thus / as a consequence / finally / as a result   부가 : besides / furthermore / moreover / above all / in addition   추가 설명 : indeed / in fact   대조 : contrarily / in contrast   순서 : then / thereafter   가령 : otherwise   시점/사건 연결 : (in the)meantime, meanwhile   기타 : alternatively / afterward(s) / as usual(=as always) / even so / initially / since then / similarly(=likewise), namely, in comparison   전치사   전치사 + ~ing/명사  전치사 + 명사 + 목적어 X  전치사 + ~ing + 목적어 O   시간과 장소 전치사     In ⇒  [시간] 일정 기간(월/계절/연도)\t[장소] 도시/국가 또는 내부가 강조된 방,   On ⇒ [시간] 요일/날짜\t\t[장소] 거리명(표면 위),   At ⇒  [시간] 구체적인 시간\t\t[장소] 지점/회사/건물(기본위치)   관용어구 : at no charge(무료로) / at the time of(~할 때)   시점/기간 전치사     시점 / 기간 : after   시점 : before / toward / by / from / prior to / since / until(진행/계속)   기간 : during(+숫자X) / for(+숫자) / in / over / throughout / within / The + 날짜   방향/위치 전치사     방향 : Opposite / across from / for + (교통수단 목적지) / toward + (막연한 방향)        Across / through / along / into / out of       위치 : beside / next to / between / among / throughout / above / over / behind / near / around   past : (prep) ~지나서 / (a) 지난   alongside : (prep) ~의 옆쪽에 / (ad) 옆쪽에   ‘~에 관하여’ 전치사     as for/as to/concerning/regarding/on/over   (in/with) + (reference/regard/relation) to   pertaining to/related to/referring to   기타 전치사     제외 : except (for) / without / apart from / aside from   이유 : due to / because of  목적 : for   양보 : despite / in spite of / notwithstanding   부가 : besides / in addition to   By + 명사(~에 의해) / v-ing(~함으로써) / 교통수단 (~를 타고)   following / given / plus / amid                  according to       along with(~와 함께)       as of       owing to                 in accordance with       in the event of       in celebration of       in charge of                 in excess of       in keeping with       in light of       in place of                 in preparation for       in respect of       in terms of       in violation of                 on behalf of       as to       in exchange for       in place of                 in case of       in response to       regardless of       in charge of           동사 + 전치사                  Register for       rely on       count on       congratulate A on B       advertise on                 keep track of       direct A to B       comply with       return A to B       consist of                 transfer A to B       add to                                   형용사 + 전치사                  equivalent to       identical to       consistent with       similar to                         responsible for       comparable to       comparable with       familiar with                         eligible for       dependent on       reliant on       different from                         adjacent to       absent from       capable of       worthy of                      be eligible (for + 명사 / to V)   명사 + 전치사                  a solution to       concern (over/about)       a dispute over       a lack of       access to                 an effect on permission from       an advocate (for/of)       a problem with       a cause for       a reason for                 Respect for       an impact on       an influence on       an increase in       a decrease in           전치사 to / to 부정사     be (dedicated / committed / devoted) to ~ing, contribute to ~ing   leat to / look forward to / be used to / object to / be accustomed to   commitment + to 명사/to 부정사   접속사      접속사 S + V / 전치사 + 명사   전치사 : as to / during / despite / in spite of / because of / at the time of / thanks to / as for   접속사 : although / even though / while / because / at the time / even if / considering(that) / now that / as p.p / yet / for   since ⇒ 전치사:~이래로, 접속사:~때문에/~이래로   Whoever(접속사) == anyone(대명사) who == ‘누구든지’   Whoever : 선행사X, 동사가 바로 나옴   Anyone (who + be-V)   So / for 문장 접두에 사용 불가   상관 접속사(수일치)     both A and B (복수)   neither A nor B   either A or B   B as well as A = not only A but (also) B   to and from / before and after   시간/조건을 나타내는 접속사     접속사 + S + 현재시제, S +  미래시제   after / as soon as / by the time / when / while / if / once / unless / provided(that)   부사절   [시간 / 조건] 부사절 접속사 (미래시제 ⇒ 현재시제)     as : ~할 때, 함에 따라\t\t● as soon as \t\t\t● once   unless \t\t\t● in case(that)\t\t\t● in the event (that)   as long as\t\t\t● providing / provided (that)   only if\t\t\t\t● on condition that   [양보] 부사절 접속사     whereas / while   even if\t/ even though   [이유] 부사절 접속사     as / since\t\t\t● now that\t\t\t● in that   [목적] 부사절 접속사     so that\t\t\t\t● in order that   [결과] 부사절 접속사     so / such ~ that ~   [제외] 부사절 접속사     except that   비교구문   원급비교     동급 : as 형용사/부사 as, as (many/fewer/less + 명사) as   Not as ~ as = not so ~ as   비교급 : er ~ than     ※ than을 사용하지 않는 비교급 :            the same + N + as / (inferior/superior) to       just as(그만큼 ~ 한), Prior to(= before)       the 비교급, the 비교급       would rather ~ than           -er than ever   비교급 강조 부사 : much / even / far / a lot / still / by far   rather + 형용사(꽤) / 동사(차라리) / than(~보다)   비교급 표현                  No later than       늦어도 ~까지       No longer       더 이상 ~ 않다                         No sooner ~ than ~       ~하자마자 ~하다       Other than       ~이외에                         Rather than       ~보다는                                   최상급 : the ~est / the most ~     부사의 최상급은 the를 생략, 소유격으로 대체가능   Of all ~, the most ~   최상급 강조 부사 : much/by far/quite ⇒ 단연코   The 최상급 + possible/ever   최상급 + of~ / in~ / that절   관계사절 == 형용사절   관계사절 ⇒ 형용사 역할(‘~하는’) ⇒ 명사 수식   관계대명사(that / who / which / whose) = 접속사 + 대명사     관계 대명사(주격/목적격) + 불완전한 문장   whose(소유격) + 명사 : ~의   목적격 관계대명사 생략 가능   (주격 관계대명사 + Be동사) 생략 가능   관계대명사(주격) who + (S + V) + V   think/hope/believe/boast/say/feel   전치사 + 관계대명사(목적격) : 숙어 암기!   수량 표현(S) + of + 관계대명사(목적격) + V(수일치 주의!)   all/any/half/most/one/rest/some   ※ some/most/all (of the) 명사 + 동사(명사에 대해 수일치)   복합관계대명사(명사절/부사절 접속사)     Whatever(=anything which(범위X))‘‘무엇이든지’ 접속사로도 사용   whichever(=anything which(범위O))/whoever/whomever   Whatever/whichever ⇒ 복합관계형용사, 명사 수식   관계부사     when/where(=in which/at which/on which)/how/why ⇒ 완전한 절   the way / how 둘 중 선택하여 사용   복합 관계 부사     However(no matter how) + 형/부 + S + V : ‘아무리 ~하더라도’   wherever(no matter where), whenever(no matter when)   명사절   명사절 접속사     선행사 X + That(접속사) + 완전한 절 : ‘~의 것’으로 해석   cf) 관계대명사 that : 선행사 O + that + 불완전한 절   선행사X + What(관계대명사) + 불완전한 절 : ‘~의 것’으로 해석   say/indicate/ + (that)   동격절 ⇒ fact/confirmation/idea/news/opinion that   Whether / if : ‘~인지 아닌지’ + 완전한 문장   Whether S + V = to부정사   같은 의미의 if는 불가능!   If절은 whether절과 달리 동사의 목적어(동사 뒤), 보어로만 사용   의문사 = 의문대명사 + 의문부사   복합의문대명사(~든지)  : whatever / whoever / whichever   의문사 + S + V     주어, 목적어, 보어 자리에 사용 가능   의문대명사(who/whom/whose/what/which) + 불완전한 절   의문형용사(which/what/whose) + 명사   의문부사(when/how/why/where) + 완전한 절   How + 부사 / 형용사(뒤 문장에 Be동사가 있을 때): 얼마나 ~하게   How S + V : 어떻게 ~했는지   How much + S + V : 얼마나 ~ 하는지   의문사 + S + (should)V ⇒ to부정사   기타구문(가정법, 도치)   가정법 시제 일치     If S + 과거 완료 (had p.p), S + would/could/might/should 현재 완료 (have p.p)   If S + 과거 시제, S + would/could/might/should + 동사원형   But for / if it were not for + 명사 : ~가 없었더라면   Should + S + 동사원형 == if가 생략된 가정법 도치 구문   도치구문     부정부사            hardly/seldom/rarely/never/not only/neither/scarcely/barely + V + S  Only + 부사(구/절) + V + S  cf) hardly … when … : ~하자마자 ~했다            So/as(긍정) or neither/nor(부정)(=~도 역시) + do/does/did/be(V) + S   p.p + be-V + S ⇒ 수동태의 도치            attached/included/enclosed            전치사구 + be-V + S   5형식 도치 : O.C + S + V + O (주어 동사 위치 변경 X)            attached/included/enclosed 명령문 ⇒ (Please) V(동사원형) + O.C + O            기타문법     Lead A to V : A가 ~하게 하다   (Leave / drop off) A with B : A에게 B를 맡기다   Keep A updated : A에게 계속 상황을 알리다   Take A to B : A를 B로 데려가다   Enough + 명사 ‘a. 충분한’ / 형용사 + Enough ‘adv. 충분히’   Be used to V : ‘~하기위해 사용되다’ / be used to v-ing : ‘~하는 것에 익숙하다’   Used to V : ‘~하곤 했었다’   Be bound (to V : ‘분명히 ~하다’ / for + 목적지 : ‘~행이다’)   Fill in for : ‘~을 대신하다’   Deserve + ( 명사 : ‘~받을 자격이 있다’ / to V : ‘~할 자격이 있다’)   Be (required / expected) of A   Complain about (명사 : ‘~에 관해 불평하다’ / 명사 + v-ing : ‘명사가 ~하는 것에 불평하다’)   Appear + (형용사 / to V / that S + V) : ‘~인 것 같다’    제가 공부한 내용을 정리한거라 잘못된 부분이 있을 수도 있습니다.  추가로, 개선사항을 답글로 따로 남겨주시면 검토 후 수정하도록 하겠습니다.  스크랩 또는 공유시 가능한 출처표기 및 답글 부탁드리겠습니다~  ","categories": ["study"],
        "tags": ["TOEIC"],
        "url": "https://many258.github.io/study/toeic-grammar/",
        "teaser": null
      },{
        "title": "[(구)정처기/실기] 업무프로세스 키워드 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.           ERP(Enterprise Resource Planning : 전사적 자원 관리)  기업 내의 모든 인적/물적 자원을 효율적으로 관리 경영자원을 하나의 체계로 통합 시스템을 재구축 → 생산성 극대화            BPR(Business Process Reengineering : 업무 재설계)  경영 전반을 분석하여 경영 목표 달성에 가장 적합하도록 재설계            CPM(Corporate Performance Management : 기업 성과 관리)  예측 경영을 통한 최적의 의사 결정을 내릴 수 있게 해주는 시스템            BSC(Balanced Score Card : 균형 성과 평가 제도)  기업의 성과를 종합적으로 평가하는 균형 잡힌 성과측정기록표            WBS(Work Break down Structure : 업무 분업 구조)  성과 목표 완전 달성을 위한 프로그램            MBO(Management By Objectives : 목표 관리)  조직의 상/하위층이 참여하여 효과적으로 조직의 목표를 달성하려는 관리기법            BPM(Business Process Management)  기업 업무 프로세스를 효율적으로 관리하기 위한 솔루션            BPMS(Business Process Management System : 비즈니스 프로세스 관리 시스템)  업무와 인간과 시스템간의 관계를 통합 관리하는 시스템            SEM(Strategic Enterprise Management : 전략적 기업경영)  경영진이 가치 중심 경영을 할 수 있도록 도와주는 통합된 분석용 제품 툴과 프로세스            MIS(Management Information System : 경영정보 시스템)  경영 내외의 관련 정보를 즉각/대량으로 관리할 수 있도록 편성한 인간과 컴퓨터 결합            EA(Enterprise Architecture)  기업 조직의 구조와 운영을 정의하는 종합적인 청사진            EAI(Enterprise Application Integration : 기업 어플리케이션 통합) 기업에서 사용하는 서로 다른 애플리케이션 통합            SIS(Strategic Information System : 전략 정보 시스템)  경쟁 우위를 확보하기 위해 구축 및 이용하는 정시 시스템            DSS(Decision Support System : 의사 결정 지원 시스템)  정형화되지 않은 문제에 관해 의사 결정자가 효과적인 의사 결정을 할 수 있도록 지원            EIS(Executive Information System : 경영진 정보 시스템)  전략 구상을 지원할 목적으로 구축된 경영 정보 시스템            KMS(Knowledge Management System : 지식 관리 시스템)  조직 내의 인적자원들이 축적하고 있는 개별적인 지식을 체계화하여 공유            EDI(Electronic Data Interchange : 전자 문서 교환)  기업 간의 거래 데이터를 교환하기 위한 표준 포맷            CSF(Critical Success Factors : 주요 성공 요소)  핵심 업무를 성공적으로 수행하기 위한 중요한 요인을 찾아내어 경영상 중요한 정보 결정       5 Forces  다섯 가지 힘의 정도에 따라 힘이 강하면 위협, 약하면 기회가 될 수 있음을 의미            잠재적 경쟁자의 위협(진입장벽의 힘)  기존 기업과의 경쟁(산업 내 경쟁강도)  공급자의 교섭력(공급자의 힘)  소비자의 교섭력(구매자의 힘)  대체재의 위협(대체재의 힘)            AS-IS  새로운 프로세스 비전을 설정하기 위해 현재의 업무 프로세스 분석        To-Be  미래에 구현하고자하는 업무 프로세스를 정의            7S  조직 문화에 영향을 주는 조직내부요소 7가지 요인 Strategy / Structure / System / Staff / Style / Skill / Shared Value            SWOT  Strength / Weakness / Opportunity / Threat 경영 전략을 수립하기 위한 분석 도구            TQM(Total Quality Management : 전사적 품질 경영)  기존의 조직문화와 경영관행을 재구축            ITA(Information Technology Architecture)  조직 전체의 정보화 구성 요소들을 통합적으로 분석한 뒤 관계를 구조적으로 정리한 체계            6-Sigma  품질 혁신과 고객 만족을 달성하기 위한 과학적이고 합리적인 문제 해결 방법            SCM(Supply Chain Management : 공급망 관리)  공급 체인을 재공학 및 동시 공학 기법을 활용하여 시간과 비용을 절약하는 관리 기법            CRM(Customer Relation Management : 고객 관계 관리)  고객 중심의 경영 기법            MRP(Material Requirement Program : 자재소요량계획)  부품이 투입될 시점, 투입되는 양을 관리하기 위한 시스템            MOT(Moment of Truth)  결정적인 순간, 일상 생활 공간을 파고드는 마케팅 기법            VOC(Voice Of Customer)  고객의 소리            VBM(Value Based Management : 가치 창조 경영)  모든 의사 결정의 기준을 기업 가치 중심으로 하는 기업 관리 기법            CKO(Chief Knowledge Officer : 지식 총괄 책임자)  지식 활동을 총괄하는 최고 책임자            AIS(Accounting Information System : 회계 정보 시스템)  회계 정보를 회사 전체의 종합 시스템으로 결합/처리            CALS(Commerce At the Light Speed)  제품의 수명 주기를 통합 데이터베이스로 관리 및 지원하는 시스템            SOA(Service-Oriented Architecture : 서비스 지향 아키텍처)  정보 시스템을 공유와 재사용이 가능한 서비스/컴포넌트 중심으로 구축하는 아키텍처            CoP(Communities of Practice : 지식 공동체)  공통의 관심사를 가진 사람들의 비공식/자발적/소규모 연구 모임            EMR(Electronic Medical Record : 전자 의료 기록)  의료 기록 업무를 전산 처리            CBD(Component Based Development : 컴포넌트 기반 개발)  컴포넌트를 조립해서 하나의 새로운 어플리케이션 만드는 소프트웨어 개발 방법론            PDM(Product Data Management : 제품 데이터 관리)  제품 개발의 각 과정의 모든 데이터를 일원적으로 관리            EP(Electronic Payment : 전자 지불)  대금 지불을 전자적인 방법으로 처리            LMS(Learning Management System : 학습 관리 시스템)  학습 활동 지원 시스템            ABC(Activity Based Costing : 활동 기준 원가 계산)  비즈니스를 업무 활동 단위로 세분화하여 경비를 수치화 하는 방법            EIP(Enterprise Information Portal : 기업 정보 포털)  기업의 내부/외부 정보를 통합해 웹 포털 형태로 제공하는 통합 정보 시스템            G2B(Korea ON-line Procurement System : 나라장터)  국가 종합 전자 조달 서비스            ASP(Application Service Provider : 응용 서비스 제공자)  기업이나 개인에게 일정 기간 완성된 소프트웨어/솔루션 임대 제공            TPS(Transaction Processing System : 거래 처리 시스템)  업무 처리 시 발생하는 거래 자료를 전산화            EDMS(Electronic Document Management System :  전자 문서 관리 시스템)  문서 관련 전체 생명주기에 걸쳐 일관성있게 전자적으로 통합 관리하기 위한 시스템            BCP(Business Continuity Planning : 업무 연속성 계획)  재해 백업 시스템 운영 체계            WebSphere  JAVA 기반의 완전한 애플리케이션 서비스 세트를 구비, 기업 전반의 어플 관리/통합 지원       Reengineering  경영과정과 지원시트템을 근본적으로 재설계하는 기법  ","categories": ["study"],
        "tags": ["(구)정보처리기사"],
        "url": "https://many258.github.io/study/business-process/",
        "teaser": null
      },{
        "title": "[(구)정처기/실기] 신기술동향 키워드 정리",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.   통신           NFC(Near Field Communication : 근거리 무선 통신)  고주파를 이용한 근거리 무선 통신 기술, 가까운 거리에서 양방향 통신을 지원하는 RFID            FemtoCell(펨토셀)  10-15을 뜻하는 펨토(Femto) + 이동통신에서 1개 기지국이 담당하는 서비스 구역(Cell)            AP(Access Point : 접근점)  네트워크와 이용자의 접근점 / 유선 랜을 통하여 무선망에 연결하는 기능            USIM(Universal Subscriber Identity Module : 유심)  휴대전화 사용자의 개인 정보를 저장하는 모듈            Anycast(애니캐스트)  IPv6에서 한 송신자와 인근에 있는 일단의 소수 수신자간의 통신을 의미하는 것            IPv6(128)  IPv4의 주소공간을 4배 확장한 128비트 인터넷 주소 체계            Cyber Bullying(사이버 협박)  개인이나 집단이 인터넷에서 상대에게 나타내는 적대 행위            Wibro(Wireless broadband)  휴대 인터넷 단말을 이용하여 언제 어디서나 고속으로 무선 인터넷 접속이 가능한 서비스            WIPI(Wireless Internet Platform for Interoperability)  한국형 무선 인터넷 플랫폼 표준 규격            ZigBee  저속 전송속도를 갖는 홈오토메이션 및 데이터 네트워크를 위한 표준 기술            Alljoyn(올조인)  사물인터넷 중심의 연합단체인 올신 얼라이언스에서 표준화한 오픈 소스 기반 IoT 플랫폼            Phablet(패블릿)  Phone + Tablet. 5인치 이상의 대화면 스마트폰을 지칭하는 용어            PICONET(피코넷)  여러 개의 독립된 통신장치가 블루투스/UWB 기술을 사용하여 통신망을 형성하는 기술            LTE(Long Term Evolution)  패킷 데이터 전송에 기반을 둔 다양한 서비스 지원을 목표로 하는 기술            M2M(Machine to Machine)  무선 통신을 이용한 기계와 기계 사이의 통신            MDM(Mobile Device Management : 이동 장비 관리)  모바일 장비의 소프트웨어/펌웨어를 업데이트하는 솔루션            Mobile Computing(모바일 컴퓨팅)  휴대형 기기로 이동하면서 자유로이 네트워크에 접속하여 업무를 처리하는 환경            Bluetooth(블루투스)  IEEE 802.15.1에서 표준화된 무선 통신 기기 간에 가까운 거리에서 낮은 전력으로 통신            BLE(Bluetooth Low Energy)  블루투스 4.0 스펙이 채택된 이후로 배포되는 저전력 블루투스            IMT-2000(International Mobile Telecommunication - 2000)  미래 공중 육상 이동 통신 시스템(FPLMTS)를 우리나라에서 부르는 이름            IMT-2020  국제전기통신연합(ITU)에서 채택한 5세대 이동통신의 공식 명칭. 5G            VHF(Very High Frequency : 초단파)  IEEE 802.11n 후속으로 진행하고 있는 표준안            Multipath Fading(다중 경로 페이딩)  전파가 2개 이상의 경로를 통하여 수신 측에 도달하는 경우, 강도가 변하는 현상       보안/해킹           APT(Advanced Persistent Threats : 지능형 지속 위협)  특정 기업이나 조직 네트워크에 침투해 정보를 외부로 빼돌리는 형태의 공격들의 총칭            DES(Data Encryption Standard : 데이터 암호화 표준)  비밀 키 방식, 64비트의 키를 사용하여 64비트의 평문을 암호화/복호화            Pharming(파밍)  사용자의 도메인 탈취 및 DNS 이름을 속여 사용자들이 진짜 사이트로 오인하도록 유도            DDoS(Distributed Denial of Service attack : 분산 서비스 거부 공격)  좀비PC 를 이용해 특정 시스템으로 다량의 패킷을 무차별적으로 보내 과다 트래픽 야기            Trust Zone(트러스트 존)  스마트폰의 AP칩에 적용된 보안영역            BOTNET(봇넷)  악의적인 의도로 사용될 수 있는 다수의 PC들이 네트워크로 연결된 형태            Attack Tool Kit(공격용 툴킷)  네트워크에 연결된 컴퓨터를 공격하려고 사용하는 악성 코드 프로그램을 모아 놓은 것            DoS(Denial of Service : 서비스 거부) 정당한 사용자가 적절한 대기시간 내에 사용하는 것을 방해하는 행위            WEP(Wired Equivalent Privacy : 유선급 프라이버시)  무선 랜의 보안 프로토콜            WBAN(Wireless Body Area Network)  웨어러블/ 몸에 심는 형태의 기기를 무선으로 연결하는 개인 영역 네트워킹 기술            Malware(Malicious Software : 악성 소프트웨어)  악의적인 목적을 위해 작성된 실행 가능한 코드. 악성코드라고 함            IAM(Identity and Access Management : 식별/접근 관리)  ID와 패스워드를 종합적으로 관리해주는 역할 기반의 사용자 계정 관리 솔루션            DLP(Data Leakage Prevention : 데이터 유출 방지)  내부자의 고의나 실수로 정보가 밖으로 새어나가는 것을 방지하는 시스템            Ping of Death(죽음의 핑)  인터넷 프로토콜 허용 범위 이상의 큰 패킷을 고의로 전송하여 발생한 서비스 거부 공격            LEA(Lightweight Low-power Encryption Algorithm)  국가보안연구소에서 개발한 블록 암호 기술            Spoofing(스푸핑)  승인 받은 사용자인 것 처럼 접근 통제를 우회            Sniffing(스니핑)  네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형의 하나            Splogger(스플로거)  Spam + Blogger. 다른 사람의 콘텐츠를 무단으로 복사해 자신의 블로그에 개제            Stuxnet(스턱스넷)  시스템을 마비하게 하는 악성 코드. (독일 지멘스사의 원격 감시 제어 시스템에 침입)            SYN Flood(신플러드 공격)  TCP/IP의 취약성을 이용한 서비스 거부 공격 방식 중 하나. 3방향 핸드셰이크 연관            Switch Jamming Attack(스위치 재밍)  위조된 MAC 주소를 지속적으로 네트워크로 보내 스위치 저장 기능을 혼란 야기            Trap Door(트랩도어)  액세스 편의를 위해 시스템 설계자가 고의로 만들어 놓은 시스템의 보안 구멍            Tvshing(티비싱)  TV + fishing. 스마트 TV에 악성 소프트웨어를 설치            QKD(Quantum Key Distribution : 양자 암호키 분배)  양자현상을 이용한 암호용 키 분배를 적용한 기술            WPA(Wi-Fi Protected Access)  Wi-Fi에서 제정한 무선 랜 인증 및 암호화 관련 표준            Zero Day Attack(제로 데이)  보안 취약점이 발견되었을 때 그 문제의 존재 자체가 널리 공표되기도 전에 취약점 약용            Zombie PC  해커의 원격 조정에 의해 공격을 수행하도록 설정된 컴퓨터나 서버            Zapping Effect(재핑 효과)  채널을 전환하다가 중간에 있는 채널의 시청률이 높아지는 현상            Certificate(공인인증서)  전자 서명법에 의한 공인 인증 기관이 발행한 인증서            CA(Certification Authority : 인증 기관)  인증업무를 수행하는 제3자의 신뢰 기관            CRL(Certificate Revocation List : 인증서 폐기 목록)  폐기된 인증서를 이용자들이 확인할 수 있도록 목록을 배포, 공포하기 위한 메커니즘            PKI(Public Key Infrastructure : 공개키 기반 구조)  공개 키 암호 시스템을 안전하게 사용하고 관리하기 위한 정보보호 표준 방식            Authentication(검증)  시스템이 작동 개시 정보를 확인하는 보안 절차            BCP(Basic Call Process :  기본 호 처리)  특정 기본 서비스의 제공을 지원            Key Pair(키 페어)  공개키 암호 알고리즘에 사용되는 개인키와 공개키 쌍을 의미            SAM(Secure Application Module)  스마트 카드 보안 응용 모듈. 카드 판독기 내부에 장착하여 보안 향상       가상현실           Augmented reality(증강 현실)  실제 촬영한 화면에 가상의 정보를 덧붙여 보여주는 기술, 혼합 현실(MR)이라고도 한다            HMD(Head Mounted Display : 두부 장착형 디스플레이)  보안경이나 헬멧형으로 눈 앞에 있는 스크린을 보는 영상 장치            Telepresence(텔레프레즌스)  가상화상회의 시스템       기업/사업           BEMS(Building Energy Management System : 건물 에너지 관리 시스템)  건물에 IT 기술을 활용하여 여러 건축 설비를 관리하는 시스템            ERM(Enterprise Risk Management : 전사적 위험 관리)  경영 위험들을 전사적으로 차원에서 통합 관리하는 위험관리 방식            CC(Common Criteria : 공통 평가 기준)  정보 보호 제품 평가 기준            Devops(디봅스)  Development + Operation. 시스템 개발과 운영을 병행 및 협업            OGSA(Open Grid Service Architecture :  오픈 그리드 서비스 아키텍처)  웹 서비스 표준과 인프라 자원의 공유를 위한 그리드 기술의 결합            RPO(Recovery Point Objective : 목표 복구 시점)  재난 상황으로 IT 시스템 마비 시 백업 수단을 활용하여 복구할 수 있는 기준점            SaaS(Software as a Service : 서비스형 소프트웨어)  소프트웨어의 기능 중 사용자가 필요로 하는 서비스만 이용가능하도록 한 소프트웨어            DRM(Digital Rights Management : 디지털 저작권 관리)  저작권 소유자나 판권 소유자가 이용하는 정보 보호 기술의 일종인 접근 제어 기술            Escrow Service(에스크로 서비스)  전자 상거래 등에서 구매자와 판매자 사이에 중개 서비스 회사가 개입해 대행            Gap Filler(갭 필러)  송신소로부터 발사된 전파를 수신하여 재송신하는 소출력 재송신소            G-PIN(Government-Personal identification Number : 정부 개인 식별 번호)  정부가 추진하고 있는 주민 등록 번호 대체 수단            HSDPA(High Speed Downlink Packet Access : 고속 하향 패킷 접속)  비동기식 3세대 이동 통신의 하향 링크에서 고속 패킷 데이터 서비스를 제공 전송 규격            M-Commerce(모바일 전자상거래)  무선 데이터 장비를 이용하여 정보/서비스/상품 등을 교환            OSMU(One Source Multi Use)  1차 콘텐츠를 시장에 성공시킨 후 투자 및 라이센스를 통해 2, 3차 콘텐츠로 발전            IT Compliance(IT 규제준수)  기업이 따라야 하는 규정과 지침 및 법규를 준수하는 것을 의미            Service Delivery  고객과의 서비스 수준 계약과 이에 따른 서비스 수준 모니터링을 정의            SLA(Service Level Agreement : 서비스 수준 협약)  서비스 사업자와 사용자가 제공될 정보 서비스 및 연관된 조건들에 대한 협약서            SOA(Service-Oriented Architecture : 서비스 지향 아키텍처)  정보 시스템을 공유와 재사용이 가능한 컴포넌트 중심으로 구축하는 정보 기술 아키텍처       빅데이터           Big Data(빅 데이터)  막대한 양의 정형/비정형 데이터 집합            HADOOP(High-Availability Distributed Object-Oriented Platform : 하둡)  오픈 소스 기반 분산 컴퓨팅 플랫폼            CEP(Complex Event Processing : 복잡 이벤트 처리)  실시간으로 발생하는 많은 사건 중 의미가 있는 것만 추출            SEO(Search engine optimization : 검색엔진 최적화)  글을 효과적으로 싣고 널리 알릴 수 있도록 웹 페이지를 구성해서 상위에 오르는 작업            Metadata  일련의 데이터를 정의하고 설명해주는 데이터       미래기술           Smart grid(스마트 그리드)  정보 기술을 전력에 접목에 접목해 효율성을 제고한 시스템. 에너지 사용 효율 증대            Cloud Computing(클라우드 컴퓨팅)  가상화된 정보 기술 자원을 서비스로 제공하는 컴퓨팅            Crowd Sourcing(크라우드 소싱)  기업 활동의 전 과정에 소비자/대중이 참여할 수 있도록 일부를 개방            Digital Archiving(디지털 아카이빙)  디지털 정보 자원을 장기적으로 보존하기 위한 작업            Digital Forensics(디지털 포렌식)  디지털 정보를 수집하고 범죄의 증거를 확보하는 기술            Stereoscope(스테레오스코프)  다른 각도에 촬영한 사진들을 동시에 보여줌으로써 물체를 입체적으로 만드는 기술            Thin Client(신 클라이언트)  소유 총비용의 삭감을 목표로 하는 클라이언트 하드웨어의 구상을 의미            Biometrics(생체인식)  자동화된 장치로 사람의 신체/행동 특징을 추출하고 분석하여 개인의 신원을 확인            ETL(Extract Transform and Load : 추출/변환/올려놓기)  시스템에서 시스템으로 데이터를 이동시키는 기능의 3가지 형태            Giga Fi(기가 파이)  60GHz 대역을 이용해 데이터를 기가급으로 전송할 수 있는 기술            GT(Green Technology : 녹색 기술)  에너지와 자원을 절약하고 효율적으로 사용하여 오염 물질의 배출을 최소화            SED(Surface-conduction Electron-emitter Display : 표면전도 전자방출 디스플레이)  화소 하나 하나가 CRT의 전자총에 해당하는 나노 수준의 미세 구조            Semantic Web  이해하기 쉬운 의미를 가진 차세대 지능형 웹            Relational Technology  상호관계를 이해하는 관계성을 기반으로 하는 새로운 패러다임            T-Ray  테라헤르츠대의 전파를 이용하여 물질 내부의 모습을 보여주는 기술       프로그램 언어           XML(Extensible Markup Language : 확장성 생성 언어)  하이퍼텍스트 생성 언어(HTML) 기능을 확장한 목적            AJAX(Asynchronous Javascript And Xml)  전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법            JAX(Java API for Xml)  확장성 생성 언어 데이터 처리를 위한 자바 응용 프로그램 인터페이스            RSS(Really Simple Syndication : 초간편 배급)  업데이트된 정보를 쉽게 사용자들에게 제공. XML을 기초로 만들어진 데이터 형식            DOM(Document Object Model : 문서 객체 모델)  웹 브라우저를 통한 XML 문서의 상호 연동을 위한 객체 기반의 문서 모델       하드웨어           Flash Memory (플래시 기억 장치)  전원이 제거되어도 정보를 그대로 유지하는 비휘발성 기억 장치            Memristor(멤리스터)  메모리 + 레지스터. 기존의 상태를 모두 기억하는 소자            MEMS(Micro Electro Mechanical Systems)  마이크로시스템, 마이크로머신.       네트워크           ICN(Information Centric Networking : 정보 중심 네트워킹)  통신을 기반으로 한 패러다임을 정보 중심으로 재편성하려는 네트워킹            ICMP(Internet Control Message Protocol : 인터넷 제어 메시지 프로토콜)  IP와 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로의 변경등을 위한 무연결 전송            SAN(Storage Area Network)  서버 옆에 있는 고속 네트워크. 서버 간에 정보 교환 가능하게 구현            SCO(Synchronous Connection Oriented link : 동기식 접속 지향 링크)  지정된 대역폭 통신을 위한 전용 회선의 동기식 접속 방법            SDN(Software Define Network : 소프트웨어 정의망)  네트워크를 컴퓨터처럼 모델링하여 네트워킹 가상화            Tajo  아파치, 하둡 기반의 분산 데이터 웨어하우스 프로젝트            TEIN(Trans Eurasia Information Network : 트랜스 유라시아 네트워크)  아시아와 유럽을 연결하는 초고속 정보 통신망            Typo-squatting(타이포스쿼팅)  실수를 이용하기 위해 유사한 유명 도메인을 미리 등록            USN(Ubiquitous Sensor Network)  각종 센서에서 감지한 정보를 무선으로 수집할 수 있도록 구성한 네트워크            Trackback(트랙백)  다른 사람의 포스트를 자신의 블로그에 가져와서 다른 사람의 댓글이 보이도록 핑 보냄            Unicast(유니캐스트)  메시지의 수신 주소를 1개만 지정하는 1:1 통신 형태            CTTH(Coax To The Home)  기존 케이블 방송망으로 초고속/대용량 서비스를 제공하는 새로운 전송 방식            NAS(Network-Attached Storage)  네트워크에 연결된 파일 수준의 데이터 저장 서버            Network Neutrality(망 중립성)  모든 네트워크 사업자는 모든 콘텐츠를 동등하게 취급하고 차별하지 않는다는 원칙            OFDM(Orthogonal Frequency Division Multiplexing : 직교 주파수 분할 다중)  디지털 변조 방식            WCDMA(Wideband Code Division Multiple Access : 광대역 부호 분할 다중 접속)  ITU가 표준화를 추진하고 있는 IMT-2000을 위해 CDMA을 광대역하는 기술            Web 2.0  다양한 신규 서비스를 만들 수 있는 플랫폼으로서의 웹 환경            Quickdom(퀵돔)  짧은 형태의 도메인            SON(Self Organizing Network)  자가진단네트워크. 인공지능 기술을 통신장비에 접목한 기술            STTD(Space Time Transmit Diversity : 시공간 송신 다이버시티)  광대역 부호 분할 다중 접속 시스템에 적용하는 송신 다이버시티 방식            UPNP(Universal Plug and Play : 범용 플러그 앤 플레이)  주변 기기를 가정의 네트워크에 접속해 공유할 수 있도록 하는 기술       멀티미디어 서비스           DAISY(Digital Accessible Information System : 데이지)  시각 장애인이나 독서 장애인을 위한 국제 디지털 문서 포맷            VoIP(Voice Over Internet Protocol : 인터넷 텔레포니)  음성서비스를 IP기술을 사용하여 제공            Groupware(그룹웨어)  여러 사람이 함께 사용할 수 있는 소프트웨어, 집단의 생산성을 향상시키기 위해 사용            BYOD(Bring Your Own Device)  개인 소유 단말기를 업무에 사용하는 환경            IMS(IP Multimedia Subsystem)  넷 프로토콜(IP)를 기반으로 멀티미디어 서비스를 제공하는 규격            T-DMB(Terrestrial Digital Multimedia Broadcasting : 지상파 DMB)  지상파 디지털 멀티미디어 방송 표준. 약 1.5MHz의 대역폭을 갖는 초단파(VHF) 대역            S-DMB(Satellite Digital Multimedia Broadcasting : 위성 DMB)  위성을 방송 매체로 사용            RVC(Reconfigurable Video Coding : 재설정 비디오 코딩) 다중 비디오 부호화 표준. 하나의 디지털 미디어 기기에서 다양한 콘텐츠를 재생            i-PIN(internet Personal Identification Number : 인터넷 개인 식별 번호)  사이버 신원 확인 번호            VOD(Video On Demand : 주문형 비디오)  가입자가 원하는 시간에  프로그램을 즉시 선택해 시청할 수 있는 양방향 영상서비스            Cresumer  크리에이티브 + 컨슈머. 소비를 통해 욕구 충족을 넘어 개성을 표현하는 소비자            CCL(Creative Commons License : 저작물 이용 약관)  자유 이용을 허락하는 내용의 라이선스            FDR(Flight Data Recorder : 비행 기록 장치)  비행할 때 있었던 주요 사항을 자동으로 기록하는 장치            LBSNS(Location Based Social Network Service : 위치 기반 소셜 네트워크 서비스)  위치 기반 서비스(LBS) + 소셜 네트워크 서비스(SNS).            ACN(Automatic Crash Notification : 자동차량충돌알림)  차량충돌에 관계된 정보를 가공하여 제공하는 무선통신매체를 이용한 자동 시스템            QoS(Quality of Service : 서비스 품질)  통신 서비스에서 사용자가 이용하게 될 서비스의 품질 척도            Miracast(미라캐스트)  휴대 기기로부터 대형 TV스크린에 정보를 전송하는 Wi-Fi 기반의 표준            Multicast(멀티캐스트)  인터넷에 접속되어 있는 일부 사용자 내에서 한 사람이 몇 사람에게 정보를 송신            N-Screen(N 스크린)  N개의 이종 단말기에서 동일한 콘텐츠를 자유롭게 이용할 수 있는 서비스            Widget(위젯)  운영체제 위에 화면을 표시하는 작은 그래픽 사용자 인터페이스 도구            Active X  윈도우 사용자들이 인터넷을 편리하고 쉽게 이용하도록 마이크로소프트 사에서 개발            Alt-Text(Alternate Text)  시각 장애인이 웹 사이트에 게시된 이미지를 이해할 수 있도록 설명해주는 글            AMR(Automatic Meter Reading : 원격 검침)  고객을 방문하지 않고 원격에서 단말기를 이용해 검침 데이터를 읽을 수 있는 시스템            CODEC(Coder/Decoder)  큰 파일/프로그램이 차지하고 있는 저장 공간을 줄여주는 알고리즘            ITS(Intelligent Transport System :  지능형 교통 시스템)  종합 교통 정보의 수집/가공/전파 시스템            IT389(8대 정보통신/방송 서비스)  미래의 정보기술 시장을 선도하기 위하여 정보통신부가 수립한 IT 성장 전략 방향            JPEG(Joint Photographic Experts Group)  칼라 정지영상의 저장 및 전송을 위한 효율적인 압축 표준            MMS(Multimedia Messaging System : 멀티미디어 메시징 시스템)  다양한 형식의 데이터를 주고받을 수 있는 메시징 시스템            PostNet(Postal Numeric Encoding Technique)  IT기반 우편 물류 통합 정보 시스템. 우편물에 RFID칩 부착            QMail  유닉스 운영체제의 인터넷 메시지 전송 에이전트(MTA)            QoE(Quality of Experience : 체감 품질)  이용자가 각자의 기대치에 근거하여 주관적으로 인지하는 서비스의 총체적인 허용도            Digilog(디지로그)  디지털 기술과 아날로그적 정서가 결합된 제품/서비스            LBS(Location Based Service : 위치 기반 서비스)  위치 정보를 기반으로 여러가지 애플리케이션을 제공하는 서비스 지칭            Kill Switch  원격 제어를 통해 사용을 제한하는 소프트웨어 기술            OLAP(Online Analytical Processing)  이용자가 직접 데이터베이스 검색/분석하여 문제점이나 해결책을 찾는 분석형 앱 개념            Telematics  자동차 안의 단말기를 통해서 운전자에게 다양한 종류의 정보 서비스를 제공하는 기술            U-Health  정보통신기술을 의료서비스에 접목. 언제 어디서나 건강 관리를 받을 수 있는 서비스            VMC(Vehicle Multihop Communication : 차량 멀티홉 통신)  자동차에 정보 기술을 접목해 차량 충돌을 예방하는 기술       MPEG(Moving Picture Experts Group : 엠펙)  디지털 컬러 동화상 및 오디오 신호의 국제 표준화 작업을 추진하는 조직   MPEG-1  디지털 저장 매체용 컬러 동화상 및 오디오의 압축/부호화 방식의 국제 표준        MPEG-2  TV 방송, 통신, 오디오/비디오 기기 등 광범위한 적용 분야를 대상으로한 국제 표준       OCAP(OpenCable Application Platform)  대화형 TV 서비스나 응용 프로그램을 설계할 수 있는 미들웨어 소프트웨어 계층   사회           DAI(Digital Access Index : 디지털 접근 지수)  정보통신기술(ICT)의 접근성과 서비스 이용에 관한 전 세계적 비교 지수            Bio Informatics(BIT : 바이오 정보학)  생물학 데이터를 IT 기술로 분석하는 학문            Infolust  정보(Information) + 열망(lust). 정보를 열광적으로 모으고 퍼뜨리는 사람들            Digital Prosumer(디지털 프로슈머)  정보와 자료를 얻는 소비자이면서 의견을 적극 개진해 생산에도 영향을 미치는 사람            Patent Troll(특허 괴물)  로열티 수입만으로 이익을 창출하는 특허 관리 전문 기업            Hacktivism(핵티비즘)  해커 + 행동주의. 자신들의 정치적 목적을 달성하기 위해 해킹하는 일체의 활동이나 주의            Media Bigbang(미디어 빅뱅)  새로운 미디어가 등장하여 기존의 미디어 질서가 해체되는 현상            Meformer(미포머)  나(me) + 정보 제공자(informer). 나를 알리는 데에만 열중하는 사람            NRI(Network Readiness Index : 네트워크 준비 지수)  경제 발전과 국가 경쟁력에 미치는 영향력을 평가한 종합 지수            Pro-teur(Professional amateur : 프로튜어)  전문가 같은 아마추어. 일반 네티즌이 정보의 수요자가 아닌 공급 주체            Social Engineering(사회 공학)  인간 상호 작용의 신뢰로 사람들을 속여 보안 절차를 통과하는 비기술적 침입 수단            Smart Divide(스마트 정보격차)  스마트 미디어를 활용하는 사람과 그렇지 못한 사람들의 정보 격차            Space Club(스페이스 클럽)  인공위성을 자국에서 우주로 발사한 나라를 통틀어 일컫는 말            Subscription Commerce(정기 구독 상거래)  구독료를 지불하면 해당업체가 상품을 선택해 배달            W3C(WWW Consortium)  WWW 브라우저/서버 기술의 표준화를 추진하는 단체            Webaholism(웨바홀리즘)  Web + Alcoholism. 일상 생활에 지장을 느낄 정도로 지나치게 인터넷에 몰두            Wikipedia(위키페디아)  누구나 자유롭게 작성할 수 있고 함께 만들어 가는 웹을 기반한 백과사전            Wikinomics(위키노믹스)  대중들의 지성과 지혜를 바탕으로 한 협업이 중심적 역할을 하는 새로운 경제 패러다임            Bio Information Technology(BIT : 생명 정보 기술)  생물학과 IT가 융합된 기술            Digerati(디저라티)  Digital + Literati. 디지털 분야의 지식이 많은 사람을 지칭            Cyber Stalking(사이버 스토킹)  정보 통신망을 이용해 악의적인 의도로 지속적으로 공포감/불안감 등을 유발 야기 행위            Collective Intelligence(집단 지성)  다수의 개체가 서로 협력/경쟁하여 얻게 되는 지적 능력의 결과로 얻어진 집단적 능력            Digital Native(디지털 원주민)  디지털 기술을 어려서부터 사용하면서 성장한 세대            Vandalism  다수가 참여할 수 있도록 공개된 문서의 내용을 훼손            Ubiquitous(유비쿼터스)  시간과 공간에 구애받지 않고 언제나 네트워크에 접속할 수 있는 통신 환경            UCC(User Created Content : 사용자 제작 콘텐츠)  일반 사용자들이 직접 만들어 유통되는 콘텐츠            Killer APP(Killer Application)  오랜 시간 시장을 지배하던 경쟁자를 압도한 소프트웨어            Long tail  역 파레토 법칙. 80% 소외 받던 책들의 매출 합계 &gt; 20% 베스트셀러 매출 합계            ONE Seg(원 세그)  일본의 디지털 휴대 이동 방송 서비스 명칭            CLMS(Copyright License Management System : 저작권 라이선스 통합 관리 시스템)  디지털 저작물에 대한 체계적인 관리를 위해 추진하고 있는 시스템            Taxonomy  전통적인 분류학 기반의 분류체계      ","categories": ["study"],
        "tags": ["(구)정보처리기사"],
        "url": "https://many258.github.io/study/technology-trend/",
        "teaser": null
      },{
        "title": "[Jekyll X BLOG] 나만의 블로그 설정 준비하기(feat. Jekyll)",
        "excerpt":"목차     Jekyll로 블로그 설정 준비하기   (2) 원하는 Jekyll 테마 찾아보기   (3) Markdown 기본 문법   (4) Git을 이용해서 실제 배포해보기   (5) 내 블로그 검색되게 해주세요(Google-Search/Naver-Advisor)   개요  나만의 블로그를 제작하는 방법은 여러가지가 있습니다.  예를 들자면, 네이버 블로그나 티스토리가 있죠  하지만 뭔가 심심한 느낌이 있고 내가 스스로 이것저것 만들고 바꿔보고 싶다면   개발자가 아니더라도 따라하면 쉽게 가능하니 이제 시작하는 문서를 참고부탁드립니다.  예로부터 시작이 반이라고 했고 초기 설정만 제대로 한다면 솔직히 반 이상을 한거나 다름이 없다고 생각합니다.   본 블로그는 Windows 환경에서 제작되었습니다.   환경 설정하기   Ruby?     Jekyll은 Ruby로 만들어졌기에 기본적으로 설치를 하셔야 사용이 가능합니다    프로그램 언어 중 하나이자 스크립트 언어의 일종, Python과는 라이벌 관계. 초보자들이 다루기 쉬운 언어라고 합니다. 응용해서 Ruby on rails라는 웹 프레임워크를 사용할 수 있지만  단순히 Jekyll을 사용할 것이므로 간단히 설치해주고 넘어갈게요   참고로 Ruby 언어가 매력적으로 느껴지신다면,  코드카데미 강좌[영문]  초보자를 위한 레일스 가이드북  해당 사이트에서 더 깊은 공부를 하실 수 있습니다.   루비 공식 홈페이지에서 다운로드페이지로 넘어갑니다      원하는 버전에 유의하시어 각자 환경에 맞는 인스톨러를 설치합니다.  처음 설치하시는 분들은 추천버전(Devkit 포함) 다운받는 것을 권장합니다.            MYS32 development toolchain : 루비로 개발 시 필요하므로 체크하고 넘어갑니다      설치가 완료되면 CMD창이 나오는데 여기서 필요하에 (저의 경우) 1, 2, 3 순서대로 완료하시고   끝으로 CMD창을 열어     ruby -v   을 입력하시면      다음과 같이 버전 정보가 나오면 성공!   Gem     젬은 루비 프로젝트에 포함시킬 수 있는 코드입니다. 기능들을 패키지화해서 다른 사람들이나 프로젝트에 공유할 수 있게 해줍니다.    간단하게 필요한 기능이 있을 때, 이 때 Gem을 통해 루비 어플리케이션이나 라이브러리를 설치 및 패키징 관리하는 역할을 합니다.   gem install '패키지명' (설치)   gem update '패키지명' (갱신)   gem uninstall '패키지명' (삭제)     Bundler?      Bundler 는 Gemfile 에 있는 젬들을 설치합니다.    앞서 Gem들을 하나하나 설치하기 힘드므로 이를 한번에 묶음으로 처리해주기 위해 Bundler라는 프로그램을 사용합니다.   먼저 Bundler를 설치하기 위해서   gem install bundler  Gem의 사용방식과 유사합니다.   bundle install bundle update  GemFile?   Gemfile 은 사이트에 필요한 젬들의 목록입니다. 단순한 Jekyll 사이트를 예로 들면 이렇게 생겼습니다:   source \"https://rubygems.org\"  gem \"jekyll\"  group :jekyll_plugins do   gem \"jekyll-feed\"   gem \"jekyll-seo-tag\" end  이 문서에 필요프로그램을 작성하면 위 bundler가 한꺼번에 처리해주는 역할을 합니다.   일단 이 문서에서는 GemFile을 사용하지 않고 단순하게 Jekyll을 통해 로컬 서버에 적용하는 예제를 다루겠습니다.   Jekyll?     Jekyll 은 정적 사이트 생성기입니다.  당신이 즐겨 사용하는 마크업 언어로 작성된 텍스트를 Jekyll 에 넘겨주면 레이아웃을 사용해 정적 웹사이트를 생성합니다.  사이트 URL 의 형식이나 어떤 데이터를 사이트에 표시할 것인지 등, 여러 동작을 조정할 수 있습니다.    Jekyll 은 평범한 루비 젬이며, 거의 모든 시스템에 설치할 수 있습니다.   Jekyll을 설치하기 위해서 위와 같은 코드로  gem을 설치하고   gem install jekyll     하지만 설치도중 다음과 같은 에러가 발생했습니다.    추가로 Gem을 업데이트 시켜줍니다.  (저는 이전 버전을 쓰기때문에 발생하지 않았을까 생각이 드네요)   gem update --system     로컬서버에 적용하기  새 jekyll 사이트를 생성   jekyll new blog        생성된 디렉토리로 이동 후   새 파일을 생성해 index.html이라 저장합니다.  &lt;!doctype html&gt; &lt;html&gt;   &lt;head&gt;     &lt;meta charset=\"utf-8\"&gt;     &lt;title&gt;NEW BLOG&lt;/title&gt;   &lt;/head&gt;   &lt;body&gt;     &lt;h1&gt;Hello! World!&lt;/h1&gt;   &lt;/body&gt; &lt;/html&gt;   다시 Cmd로 돌아와서   cd blog   사이트를 빌드하고 로컬 서버에 적용  bundle exec jekyll serve     http://localhost:4000 접속 확인      위와 같은 화면이 표시된다면 성공! 로컬 서버를 종료시 Ctrl + C를 입력해주세요.   다음 시간엔 Jekyll에서 사용할 수 있는 테마와 구조에 대해 알아보도록 하겠습니다.   참고사이트  http://jekyllrb-ko.github.io/docs/installation/   수정이 필요하거나, 개선사항이 있을시 답글을 남겨주시면 빠른 시일안에 해당 항목을 수정하겠습니다.  ","categories": ["blog"],
        "tags": ["Jekyll"],
        "url": "https://many258.github.io/blog/start-wtih-jekyll/",
        "teaser": null
      },{
        "title": "[Jekyll X BLOG] 원하는 Jekyll 테마 찾아보기  ",
        "excerpt":"목차     Jekyll로 블로그 설정 준비하기   원하는 Jekyll 테마 찾아보기   (3) Markdown 기본 문법   (4) Git을 이용해서 실제 배포해보기   (5) 내 블로그 검색되게 해주세요(Google-Search/Naver-Advisor)   개요   저번 문서에서는 기본적으로 환경을 어떻게 설정하는가 기본 작업을 살펴보았습니다  하지만, 빈 화면에 덩그러니 Hello World만 있으니 뭔가 휑하게 느껴집니다.  세련되고 멋지게 해보고 싶은데 방법이 없을까…?  생각을 해보셨다면 이 문서를 천천히 읽어주시길 바라겠습니다.   사실 이번에 할 일은  위대한 선조님들이 이 고민을 할 우리들을 위해 틀을 이미 만들어 놓았기 때문에 이번에 해야할 일은 많지 않습니다.   그럼 시작해도록 하겠습니다.   테마 선택하기   다음 웹사이트에서 원하는 테마를 미리 데모로 실행해보고 다운받을 수 있습니다.   지킬 테마 홈페이지      여기서 각자 선호하는 테마를 선택하여 블로그에 적용시킬 수 있습니다.  저의 경우는 minimal-mistakes 라는 보통 많이 사용하는 테마를 사용하였습니다.   1. GitHub 계정이 있다면?      해당 홈페이지에서 Fork를 해서 내려받고  리포지토리의 이름을 username.github.io 변경하거나   2. GitHub 계정이 없다면?   minimal-mistakes 홈페이지에 접속하여 압축파일을 설치할 수 있습니다.    또는    차후 배포할 때 계정이 필요하니 지금 이순간에 회원가입을 하시길 권유드립니다.      그럼 이 블로그에 현재 적용된 테마에 대해 조금 더 면밀히 알아보도록 하겠습니다.   디렉토리 기본 설정하기   현재 버전에서 최초 파일 구조는 다음과 같습니다.      .editorconfig .gitattributes .github /docs /test CHANGELOG.md README.md screenshot-layouts.png screenshot.png  여기서 위 파일은 불필요한 파일이기에 삭제를 진행합니다.   이어서 _posts, _draft(선택) 폴더가 없다면 새로 추가해줍니다.   디렉터리 구조   이제 하나씩 구성요소를 분석해보겠습니다.   _data     사이트에 사용할 데이터를 적절한 포맷으로 정리하여 보관하는 디렉토리.  Jekyll 엔진은 이 디렉토리에 있는 (확장자와 포맷이 .yml 또는 .yaml, .json, .csv, .tsv 인) 모든 데이터 파일을 자동으로 읽어들여 site.data 로 사용할 수 있도록 만든다.  만약 이 디렉토리에 members.yml 라는 파일이 있다면, site.data.members 라고 입력하여 그 컨텐츠를 사용할 수 있다.    문장이 어려울 수 있으나, 단순히 말하자면 데이터 파일들이 모여있는 폴더라는 의미입니다. 여기서 데이터 파일은 테마를 커스텀하기 위해 사용됩니다.   예제: 구성원 목록 이 링크에서 예제를 확인할 수 있습니다   이 테마에서는 기본적으로 다음과 같은 데이터파일 2개가 존재합니다              navigation.yml  상단에 표시되는 메뉴들,  메뉴클릭시 지정된 URL페이지로 이동하여 문서를 보여줍니다            ui-text.yml  일종의 언어팩. 기본은 영어로 되어있으나 config 설정을 통해 한국어로 변경할 수 있으며, 해당 옵션을 다른 글로 변경하여 내 설정에 맞게 블로그에 반영할 수 있습니다       _includes     재사용하기 위한 파일을 담는 디렉토리로서, 필요에 따라 포스트나 레이아웃에 쉽게 삽입할 수 있다.  {% include file.ext %} 와 같이 Liquid 태그를 사용하면 _includes/file.ext 파일에 담긴 코드가 삽입된다.       재사용이 가능한 자잘자잘한 구성 요소들. 이 구성요소들로 커다란 틀(레이아웃)을 꾸미거나 기능을 추가할 때 이용합니다.      Analytics-provides  어떤 애널리틱스를 사용하는지에 따라 설정이 가능하며 config.yml analytics 부분에 정보를 입력해주면 됩니다               comments-providers  내 글에 댓글기능을 삽입할 수 있는데 여러 플랫폼이 있어 사용자가 원하는 플랫폼을 선택하여 추가할 수 있게끔 해준다(필자는 disqus로 설정!)            footer/head  각 폴더 내 커스텀 html 파일에서 사용자 취향에 맞게 설정할 수 있다            search  검색 엔진을 어떤 것으로 설정할 지 선택할 수 있는 폴더  comment-provider, analytics-provides와 마찬가지로 config.yml파일에서 해당 항목을 설정하여 적용시킬 수 잇다              Feature_row  여러 이미지를 한 줄로 나타낼 때 사용합니다.  갤러리와 유사하나 사진마다 제목과 부가설명이 있다는 차이점을 가지고 있습니다       feature_row:   - image_path: /assets/images/unsplash-gallery-image-1-th.jpg     alt: \"placeholder image 1\"     title: \"Placeholder 1\"     excerpt: \"This is some sample content that goes here with **Markdown** formatting.\"   - image_path: /assets/images/unsplash-gallery-image-2-th.jpg     alt: \"placeholder image 2\"     title: \"Placeholder 2\"     excerpt: \"This is some sample content that goes here with **Markdown** formatting.\"     url: \"#test-link\"     btn_label: \"Read More\"     btn_class: \"btn--inverse\"   - image_path: /assets/images/unsplash-gallery-image-3-th.jpg     title: \"Placeholder 3\"     excerpt: \"This is some sample content that goes here with **Markdown** formatting.\"   {% include feature_row %}      Figure  캡션을 가진 하나의 이미지를 생성할 때 사용한다   {% include figure image_path=\"/assets/images/unsplash-image-10.jpg\" alt=\"this is a placeholder image\" caption=\"This is a figure caption.\" %}      Gallery  캡션을 가질 수 있는 2개 이상의 이미지를 생성할 때 사용하며 갤러리를 배치하려면 추가적으로 yaml 파일 생성이 필요하다   gallery:   - url: /assets/images/unsplash-gallery-image-1.jpg     image_path: /assets/images/unsplash-gallery-image-1-th.jpg     alt: \"placeholder image 1\"     title: \"Image 1 title caption\"   - url: /assets/images/unsplash-gallery-image-2.jpg     image_path: /assets/images/unsplash-gallery-image-2-th.jpg     alt: \"placeholder image 2\"     title: \"Image 2 title caption\"   - url: /assets/images/unsplash-gallery-image-3.jpg     image_path: /assets/images/unsplash-gallery-image-3-th.jpg     alt: \"placeholder image 3\"     title: \"Image 3 title caption\"   {% include gallery caption=\"This is a sample gallery with **Markdown support**.\" %}      Video  유튜브, 비메오, 구글드라이브 영상을 내용 안에 담을 수 있습니다.  특정시점으로 부터 영상 재생도 가능한데  ex) https://www.youtube.com/watch?v=[id] 1:50초부터 영상을 시작하고 싶다면 ?start=110 를 추가하면 된다.   # 유튜브 {% include video id=\"id\" start=110 provider=\"youtube\" %}  # 비메오 {% include video id=\"id\" provider=\"vimeo\" %}  # 구글드라이브 예) https://drive.google.com/file/d/[id]/preview {% include video id=\"id\" provider=\"google-drive\" %}      TOC(Table of contents)  글 옆에 보이는 목차를 나타내주는 역할을 합니다. Toc : true를 통해 표시할 수 있습니다 다음과 같은 선택으로 커스터마이징이 가능합니다            Toc_label : TOC의 이름       Toc_icon : TOC 아이콘       Toc_sticky : TOC Liquid 문법으로 다음과 같이도 사용가능합니다.           {% include toc %}           nav-list  메뉴 상단 리스트  _data/navigation.yml에서 설정할 수 있으며 children : 태그를 통해 하위 메뉴를 생성하는 것도 가능하다            analytics  _config.yml에서 작성한 애널리틱스를 바탕으로 analytics-provides와 이어주는 역할을 한다            archieve-single  포스트 페이지들 링크를 모아둔 아카이브 페이지에서 각 포스트 링크가 어떻게 보여질지에 대한 문서            author-profile / author-profile-custom-links  _config.yml 사이트 저자에 대한 설명을 나타낼 때 사용하는 문서            breadcrumbs  페이지의 상대경로를 계층식 구조로 표시하는 역할을 해주는 문서  config.yml에서 설정이 가능하며 기본값으로 false이다       # breadcrumbs            : false # true, false (default)          browser-upgrade  IE9 브라우저로 접속할 경우 업그레이드를 요청한다            category-list / tag-list  각 카테고리/태그와 관련된 리스트를 만드는 문서  이 글의 하단에서 카테고리는 Blog, 태그 Jekyll을 확인할 수 있다            comment / comments  댓글에 관련된 정보를 다루는 문서            document-collection  collection은 아카이브페이지와 유사하지만, 태그/카테고리 별로 자동으로 분류되는 아카이브페이지와는 달리  서로 관련성이 있는 포스트를 사용자 정의로 그룹화한 페이지를 말한다            footer / head  페이지 하단/상단의 내용을 가지고 있는 문서            masthead  홈페이지 전체의 구조 중 네비게이션과 검색부분이 있는 상단 바로 아래 지평선            page_date / page_hero / page_hero_video / page_meta  페이지의 상단의 역할을 맡고있다  날짜, 상단의 이미지 또는 비디오, 상단의 보이는 ~분 소요시간을 나타낸다            page__taxonomy  페이지의 태그와 카테고리를 나타내는 역할을 한다            paginator / post_pagination  페이지 하단에 보면 이전글, 다음글에 관련된 문서            posts-category / posts-tag  각 카테고리, 태그를 모아놓은 아카이브 페이지            scripts  JavaScript, 검색 엔진, 댓글 플랫폼 관련 등 소스를 불러오는 곳            seo  검색 엔진 최적화(Search Engine Optimization : 내 웹사이트를 구글이나 네이버와 같은 검색엔진의 검색결과 상단에 노출시킬 수 있도록 최적화하는 방법)를 다루는 문서            sidebar  이 홈페이지 왼쪽 부분에 표시되는 사이드바 관련 문서            skip-links  홈페이지 내 간단하게 구현된 바로가기(숏컷)에 대한 문서            social-share  소셜서비스와 연관된 문서, 트위터/페이스북/링크드인 하이퍼링크로 구성되어 있다            toc  TOC의 기능을 모아놓은 문서       _layouts     포스트를 포장할 때 사용하는 템플릿이다.  각 포스트 별로 레이아웃을 선택하는 기준은 머리말이며, {{ content }}와 같이 Liquid 태그를 사용하면 페이지에 컨텐츠가 주입된다.    문서를 포스팅할 때 가장 큰 틀이며 기본적으로 default를 사용합니다.  만약 매 문서마다 같은 양식을 사용하고 싶다면 이 부분에서 수정하므로서 가능해집니다. 파일 내 코드를 살펴보면 {{ content }} 이 부분에 작성한 글의 내용이 삽입이 되는 구조입니다.   예시로 나만의 블로그 설정 준비하기문서는 single이라는 레이아웃으로 설정하였습니다.   --- layout: single title: \"[Jekyll X BLOG] 나만의 블로그 설정 준비하기(feat. Jekyll)\" categories:   - blog tags:   - Jekyll sidebar:   nav: \"docs\" ... ---   _posts     한마디로 말하면, 당신의 컨텐츠다.  중요한 것은 파일들의 명명규칙인데, 반드시 이 형식을 따라야 한다: YEAR-MONTH-DAY-title.MARKUP.  고유주소는 포스트 별로 각각 정의할 수 있지만, 날짜와 마크업 언어 종류는 오로지 파일명에 의해 결정된다.    실질적으로 우리가 앞으로 작성할 글(포스팅한 문서)들이 모여있는 폴더입니다.   _sass     이것은 당신의 main.scss 에 임포트할 수 있는 Sass 조각들로서,  하나의 스타일시트 파일 main.css 로 가공되어 당신의 사이트에서 사용하는 스타일들을 정의한다.  Jekyll 은 Sass 를 기본적으로 지원하고 루비 젬을 통해 CoffeeScript 와 연동할 수 있습니다. 사용 방법은, 일단 적절한 확장자 (.sass 나 .scss, .coffee 중 하나) 로 파일을 생성하고 파일의 시작부분에 3 개의 대시문자 두 줄을 입력해야 합니다(YAML 헤더)    혹시나  css에 대해 들어본 적 있으신가요?  덕분에 이쁘고 스타일리쉬하게 웹페이지를 만들 수 있었지만, 점점 늘어날수록 코드가 복잡해진다는 단점을 가지고 있었습니다.   이 단점을 보완하기 위해 탄생한 아이가 Sass입니다.  sass는 css 전처리(Preprocessor)이며 Css가 동작하기 전에 작동하는 방식으로 기존 css의 확장의 개념이다라고 생각하시면 편할 것 같습니다.  scss 파일을 모아놓은 폴더 위 설명과 같이 모든 scss 파일이 뭉쳐 main.css로 가공됩니다.   _site     Jekyll 이 변환 작업을 마친 뒤 생성된 사이트가 저장되는 (디폴트) 경로이다.  대부분의 경우, 이 경로를 .gitignore 에 추가하는 것은 괜찮은 생각이다.    Jekyll로 사이트를 빌드하면 해당 최종 결과물이 디렉토리에 생성됩니다. 차후 이 폴더에 있는 내용들로 배포를 할 예정입니다.   Assets  main.scss, images(없으면 새 폴더 추가해줍니다.) , javascript로 구성된 폴더 특히, 사진이나 이미지들은 images에서 주로 관리하게됩니다.   _config.yml 설정하기  이번 문서에서 가장 중요한 작업입니다  기존값 또는 기본값을 자신의 설정대로 변경하는 작업을 주로 다루겠습니다.   기본 사이트 설정   locale                   : \"ko\" # 한국어로 설정 title                    : \"\" # 사이트 제목 name                     : \"\" # 이름 description              : \"\" # 사이트 설명 url                      : \"\" # \"https://[github ID].github.io\" 결과적으로 github 리포지토리의 이름과 동일해야합니다.   사용하는 답글 플랫폼이 있다면 해당 플랫폼 설정   comments:   provider               : # false (default), \"disqus\", \"discourse\", \"facebook\", \"staticman\", \"staticman_v2\", \"utterances\", \"custom\"   disqus:     shortname            : # https://help.disqus.com/customer/portal/articles/466208-what-s-a-shortname-   discourse:     server               : # https://meta.discourse.org/t/embedding-discourse-comments-via-javascript/31963 , e.g.: meta.discourse.org   facebook:     # https://developers.facebook.com/docs/plugins/comments     appid                :     num_posts            : # 5 (default)     colorscheme          : # \"light\" (default), \"dark\"   utterances:     theme                : # \"github-light\" (default), \"github-dark\"     issue_term           : # \"pathname\" (default)   staticman:     branch               : # \"master\"     endpoint             : # \"https://{your Staticman v3 API}/v3/entry/github/\"   사이트 저자 관련 정보   author:   name             : \"\"    avatar           : # 보여질 이미지 경로 ex) \"/assets/images/bio-photo.jpg\"    bio              : \"\" # 부가 텍스트   location         : \"\" # 주소   email            :   links:     - label: \"Email\"       icon: \"fas fa-fw fa-envelope-square\"   블로그 하단에 표시할 사이트 저자 정보   footer:   links:     - label: \"Twitter\"       icon: \"fab fa-fw fa-twitter-square\"       # url:     - label: \"Facebook\"       icon: \"fab fa-fw fa-facebook-square\"       # url:     - label: \"GitHub\"       icon: \"fab fa-fw fa-github\"       # url:     - label: \"GitLab\"       icon: \"fab fa-fw fa-gitlab\"       # url:     - label: \"Bitbucket\"       icon: \"fab fa-fw fa-bitbucket\"       # url:     - label: \"Instagram\"       icon: \"fab fa-fw fa-instagram\"       # url:   가장 기초적인 설정은 위 내용만 수정해도 충분할 것이라 생각됩니다.   최종테스트  이전 문서에서 사용했던 것처럼 사이트를 빌드하고 로컬 서버에 적용해 접속하였을 때 정상적으로 블로그가 나타난다면 성공!   마무리  초라했던 블로그가 이제 제법 세련되어졌습니다.   이제 본격적으로 글을 작성해볼텐데 주로 Markdown(.md)을 사용합니다.   다음엔 이 마크다운 문법에 대해서 알아보도록 하겠습니다.   이상입니다. 고생많으셨습니다.   감사합니다 :)   참고사이트  https://ansohxxn.github.io/blog/jekyll-directory-structure/   수정이 필요하거나, 개선사항이 있을시 답글을 남겨주시면 빠른 시일안에 해당 항목을 수정하겠습니다.  ","categories": ["blog"],
        "tags": ["Jekyll"],
        "url": "https://many258.github.io/blog/jekyll-themes/",
        "teaser": null
      },{
        "title": "[NETFLIX] (내가 만든) 호러 X 스릴러를 위한 설연휴 넷플릭스 추천 가이드라인",
        "excerpt":"Intro  2020년 추석에 이어 이번 2021년 설에도 코로나의 영향이 고스란히 이어지고 있습니다.   이에 대해 정부에서는 간곡하게 설연휴 이동을 자제하도록 요구하고 있는데요.     가급적 모두 이 운동에 동참할 필요성이 있다고 생각합니다.   특히나 이번에 넷플릭스에서 설연휴 정주행 가이드라는 컨텐츠로 많은 영화/드라마를 추천하고 있는데요.   하지만, 호러스릴러 매니아에게는 안타깝지만 따로 카테고리를 만들어놓지 않았습니다..    그래서 나름대로 호러/스릴러 영화 10개를 추려내 보았습니다.        이 추천하는 영화들은 지극히 주관적인 평가이므로 만약 인상 깊게 감상한 영화가 있으시다면 답글로 부탁드리겠습니다 :)   ※ 이 글은 2021년 2월 10일자에 작성되었음을 알려드립니다!   10. 캐빈 인 더 우즈(The Cabin in the Woods)         감독 : 드류 고다드   개봉일 : 2012.06.28   넷플릭스 재개봉 : 2020.06.17   상영시간 : 95분 (X1.25 : 약 76분, X1.5 : 약 64분)   관람등급 : 18세이용가      기분전환을 위해 인적이 드문 숲으로 여행을 떠난 다섯 명의 친구들.  설레는 마음도 잠시, 곧 지옥의 시스템이 가동된다.          규칙을 어기는 순간 찾아오는 자비 없는 처벌, 단 한 명도 빠져나갈 수 없다.  게임이 끝날 때 까지.    주관적인 평가  스토리 : 3.8 / 5.0  잔인함 : 4.0 / 5.0  공포성 : 3.7 / 5.0   한마디:  저는 이 영화를 넷플릭스가 아닌 영화관에서 관람했었습니다.  처음엔 단순한 클리셰 느낌의 영화인 줄 알았으나, 중간쯤돼서 점점 장르가 변하는 것에 대해 굉장히 신선한 느낌을 받았습니다.   게다가 기존에 공포영화를 즐기셨던 분들은 짐작할 만한 많은 패러디 요소가 있으니 하나씩 찾아보는 재미도 느끼실 수 있으실 겁니다. 근데, 엔딩이 아쉬운 게 약간의 흠    9. 맨 인 더 다크(Don’t Breathe)         감독 : 페데 알바레스   개봉일 : 2016.10.05   넷플릭스 재개봉 : 2020.08.04   상영시간 : 88분 (X1.25 : 약 71분, X1.5 : 약 60분)   관람등급 : 18세이용가      10대 빈집털이범 록키, 알렉스, 머니는 밑바닥 삶을 청산하기 위해 눈 먼 노인을 겨냥한 마지막 한 탕을 준비한다.  노인이 잠 든 사이 거액의 현금을 쟁취하려던 순간 마침내 그가 깨어나게 되고, 이들의 치밀한 계획은 아무것도 보이지 않는 암전 속에서 모두 역전되기 시작하는데…    주관적인 평가  스토리: 4.0 / 5.0  잔인함: 2.8 / 5.0  공포성: 4.1 / 5.0   한마디:  팝콘을 사들고 들어갔는데 영화 컨셉 상 먹을 수가 없더라구요. 일하시는 분에게 죄송하지만 바닥에 거의 흩뿌리고 돌아왔습니다.   꼭 조용한 환경에서 시청부탁드리겠습니다. 분위기 장난이 아닌 영화 중 하나    8. 더 보이(The boy, 2016)         감독 : 윌리엄 브렌트 벨   개봉일 : 2016.06.01   넷플릭스 재개봉 : 2020.03.19   상영시간 : 97분 (X1.25 : 약 78분, X1.5 : 약 65분)   관람등급 : 15세이용가      그레타(로렌 코핸)는 어두운 과거에서 벗어나 새 출발을 하기 위해 외딴 마을의 대저택에 유모로 들어간다.       그러나 노부부가 아들 브람스라며 소개한 건 소년 인형.          장난이라는 의심과 달리 부부는 너무나 진지한 태도로 인형을 대하고, 심지어 10가지 규칙을 꼭 지켜야 한다고 당부한 후 여행을 떠난다.  대저택에 인형 브람스와 단둘이 남게 된 그레타는 자꾸만 일어나는 기이한 사건들을 겪으며 점점 인형이 살아있다고 믿게 되는데…    주관적인 평가  스토리: 3.5 / 5.0  잔인함: 2.5 / 5.0  공포성: 3.9 / 5.0   한마디:  인형이 스토리의 주가 되는 애나벨과 먼 친척뻘입니다.  컨져링이 한 때 뜨면서 같은 유니버스인 애나벨도 영향을 받아 높게 평가됐는데, 이 영화는 이 때문인지 주목을 많이 못받았던 것 같습니다. 반전도 나름 신선했기에 전 개인적으로 애나벨보다 이 영화를 추천드립니다.    7. 라이트 아웃(Light out)         감독 : 다비드 F. 산드베리   개봉일 : 2016.08.24   넷플릭스 재개봉 : 2020.06.10   상영시간: 81분 (X1.25 : 약 65분, X1.5 : 약 55분)   관람등급 : 15세이용가      불이 꺼지면 나타나는 누군가를 목격한 남매 레베카와 마틴.       알고보니 어둠 속 그 여자는 빛이 닿으면 피부가 타들어가는 기이한 병을 앓고 있던 엄마의 어릴적 친구 ‘다이애나’였고, 현재도 엄마 곁에서 함께 살고 있다는 걸 알게 되는데…    주관적인 평가  스토리: 3.0 / 5.0  잔인함: 2.0 / 5.0  공포성: 3.4 / 5.0   한마디:  짧은 독립영화가 유명해지자 만들어진 극장 영화.  저예산 영화임에도 불구하고 보이지 않는 공포요소를 잘 이용했습니다. 이 영화가 끝나면 그 날은 불을 끄고 자기 싫어질 거에요.    6. 유전(Hereditary)         감독 : 아리 애스터   개봉일 : 2018.06.07   넷플릭스 재개봉 : 2020.04.22   상영시간: 127분 (X1.25 : 약 106분, X1.5 : 약 85분)   관람등급 : 15세이용가      ‘애니’는 일주일 전 돌아가신 엄마의 유령이 집에 나타나는 것을 느낀다.  애니가 엄마와 닮았다며 접근한 수상한 이웃 ‘조안’을 통해 엄마의 비밀을 발견하고, 자신이 엄마와 똑같은 일을 저질렀음을 알게 된다.       그리고 마침내 애니의 엄마로부터 시작돼 아들 ‘피터’와 딸 ’찰리’에게까지 이어진 저주의 실체가 정체를 드러내는데…    주관적인 평가  스토리: 3.4 / 5.0  잔인함: 3.1 / 5.0  공포성: 3.6 / 5.0   한마디:  공포영화치고는 상영시간이 긴 만큼 점프스퀘어보다는 심리적으로 불안감과 불쾌함을 조성하여 천천히 관객을 몰입하게하며 옥죄어 옵니다. “뚂”    5. 블레어위치(Blair Witch, 2016)         감독 : 다니엘 미릭   개봉일 : 2016.11.23   넷플릭스 재개봉 :   상영시간: 89분 (X1.25 : 약 66분, X1.5 : 약 55분)   관람등급 : 15세이용가      1994년, 200년 동안 내려온 블레어 위치의 전설을 찾아 3명의 영화과 학생들이 버키츠빌 숲에 들어간 후 실종된다. 그리고 1년 후 그들이 찍은 필름이 발견된다. 1999년 오랜 법정 싸움 끝에 필름은 유가족에게 돌아가고 영화화가 결정된다. 영화는 전세계를 충격에 빠트린다.       그리고… 2016년       유가족 중 헤더의 동생은 SNS에 올려진 1999년의 영상 속에서 누나가 생존해 있을지 모른다는 단서를 발견한다. 그는 팀을 꾸려 버키츠빌로 떠나는데…    주관적인 평가  스토리: 3.4 / 5.0  잔인함: 3.1 / 5.0  공포성: 3.6 / 5.0   한마디:  셰이키캠, 핸드헬드 촬영기법으로 제작되었기에 멀미가 심하신 분들께는 추천드리지 않습니다.   이 영화를 즐기셨다면 전작인 블레어윗치(1999)도 같이 관람하시길 추천드립니다. 제 기준으로는 원작이 좀 더 스릴있었습니다.      4. 알포인트(R-POINT)         감독 : 공수창   개봉일 : 2004.08.20   넷플릭스 재개봉 : 2020.12.01   상영시간 : 105분 (X1.25 : 약 84분, X1.5 : 약 70분)   관람등급 : 15세이용가      1972년, 베트남 전쟁의 막바지.  200명의 부대원 중, 혼자 살아 남은 혼바우 전투의 생존자 최태인 중위(감우성)는 악몽에 시달리며 괴로워한다. 그러나 그의 본대 복귀 요청은 철회되고, CID 부대장은 그에게 비밀 수색 명령을 내린다.       1월 30일 밤 10시.  이날도 사단본부 통신부대의 무전기엔 “당나귀 삼공…”을 외치는 비명이 들어오고 있다. 6개월전 작전 지역명 ‘로미오 포인트’에서 사망한 것으로 추정되는 18명의 수색대원들로부터 구조요청이 오고 있었던 것. 그 흔적 없는 병사들의 생사를 확인할 수 있는 증거물을 확보하는 것이 이번 작전의 목표다.       3일 후.  좌표 63도 32분, 53도 27분 _ 로미오 포인트 입구. 어둠이 밀려오는 밀림으로 들어가는 9명의 병사들 뒤로 나뭇잎에 가려졌던 낡은 비문이 드러난다.          不歸! 손에 피 묻힌 자, 돌아갈 수 없다!!  7일간의 작전, 첫 야영지엔 10명!! 의 병사가 보이고…. 그러나 이제 하루가 시작되고 있을 뿐이다.    주관적인 평가  스토리: 4.2 / 5.0  잔인함: 2.7 / 5.0  공포성: 3.8 / 5.0   한마디:  군대를 다녀오기 전/후 관람하였는데, 다녀오고 난 후 보는게 더욱 무서웠습니다.  보통 한국 공포영화는 인정하지 않지만 이건 수작 중 하나라고 생각합니다. “하늘소…”    3. 부산행(Train To Busan)         감독 : 연상호   개봉일 : 2016.07.20   넷플릭스 재개봉 : 2020.07.01   상영시간 : 120분(X1.25 : 약 96분, X1.5 : 약 80분)   관람등급 : 15세이용가      정체불명의 바이러스가 전국으로 확산되고 대한민국 긴급재난경보령이 선포된 가운데, 열차에 몸을 실은 사람들은 단 하나의 안전한 도시 부산까지 살아가기 위한 치열한 사투를 벌이게 된다.       서울에서 부산까지의 거리 442KM  지키고 싶은, 지켜야만 하는 사람들의 극한의 사투!    주관적인 평가  스토리: 3.1 / 5.0  잔인함: 4.3 / 5.0  공포성: 3.7 / 5.0   한마디:  우리나라도 이제 좀비물 잘 만들 수 있다는 것을 보여준 작품.  한정된 공간이지만 계속 나아가야하는 긴박함을 잘 풀어낸 영화라 생각힙니다. 하지만, 한국 특유의 신파극만 좀 빼줬으면 좋겠네요.    2. 오큘러스(Oculus)         감독 : 마이크 플래너건   개봉일 : 2014.05.29   넷플릭스 재개봉 :   상영시간 : 105분(X1.25 : 약 85분, X1.5 : 약 70분)   관람등급 : 15세이용가      어린 시절, 충격적인 사고로 부모님을 잃은 남매. 이 일로 동생이 소년원에 수감된다.       그로부터 10년 후,  동생이 출감하기를 기다린 누나는 어린 시절의 일이 부모님들이 새 집에 이사오면서 들여놓았던 거울의 짓이라 믿고 조사에 들어간다.  그 거울의 역대 주인들을 추적한 결과, 모두 비참한 죽음을 맞이했다는 사실을 알게 되고 그들이 모두 거울의 조종을 받은 희생자들이란 가설을 세우게 되는데…    주관적인 평가  스토리: 4.3 / 5.0  잔인함: 2.3 / 5.0  공포성: 3.8 / 5.0   한마디 :  현재와 과거가 교차되며 뭐가 진짜고 뭐가 환상인지 계속 생각들게 하는 영화.  기존 귀신/악마로부터 도망다니는 일반적인 클리셰와 달리 맞서싸우고 극복하려는 모습에서 미스터리 장르에 조금 가깝다고 할 수 있겠습니다.    1. 향수 - 어느 살인자의 이야기(Perfume: The Story of a Murderer)         감독 : 톰 튀크베어   개봉일 : 2007.03.22   넷플릭스 재개봉 :   상영시간 : 146분(X1.25 : 약 117분, X1.5 : 약 98분)   관람등급 : 15세이용가      18세기 프랑스 생선시장에서 태어나자마자 사생아로 버려진 ‘장바티스트 그르누이’.       불행한 삶 속에서 그의 유일한 즐거움은 천재적인 후각으로 세상을 바라보는 것. 그러던 어느 날 그는 파리에서 운명적인 ‘여인’의 매혹적인 향기에 끌리게 된다. 그 향기를 소유하고 싶은 욕망에 사로잡힌 그는 향수제조사 ‘주세페 발디니’의 후계자로 들어간다.       뛰어난 후각으로 파리를 열광시킬 최고의 향수를 탄생시키지만, ‘여인’의 매혹적인 향기를 온전히 소유할 수 없었던 그는 해결책을 찾아 ‘향수의 낙원, 그라스’로 향하게 된다. 마침내 그곳에서 그는 그토록 원했던 자신만의 향수를 만드는 방법을 알아낸다. 한편 ‘그라스’에서는 아름다운 여인들이 나체의 시신으로 발견되는 의문의 사건이 계속되는데…    주관적인 평가  스토리: 4.5 / 5.0  잔인함: 2.9 / 5.0  공포성: 2.9 / 5.0   한마디 :  ‘사람의 욕망은 어디까지인가?’에 대해 물음을 던지는 영화. 공포스릴러장르에 속하지만 철학적인 냄새가 많이 나는 영화입니다.   광기 어린 잔혹한 사이코패스에 불과하지만 진정한 사랑의 의미를 몰랐기에 사랑을 줄 수도 받을 수조차도 없었던 비운의 소년 영화    마치며..  그 밖에도, 인시디어스(Insidious) 영화를 추천해 드리고 싶지만 1~4편 중 현재 2, 3편만 넷플릭스에 등록이 되어있기에 스포일러를 먼저 접하실 수도 있을 거 같다는 생각에 제외했습니다.      혹시 다 보셨던 건가요? 다가오는 3월에도 재밌는 영화가 많습니다.   추후 가능하다면 다음엔 영화가 아닌 드라마로 글을 작성해보려 합니다.   모두 건강하고 안전한 설 연휴 보내시길 바랍니다.     ","categories": ["hobby"],
        "tags": ["Netflix"],
        "url": "https://many258.github.io/hobby/netflix-holiday-guide/",
        "teaser": "https://many258.github.io/assets/images/netflix/teaser_netflix.png"
      },{
        "title": "[BoardGame] 디스워오브마인(This War of Mine : TWoM) 보드게임 룰",
        "excerpt":"Intro      스토리기반 전쟁생존 보드게임          게임인원 : 1인 ~ 6인 (1-2인 추천)   게임시간 : 45 ~ 120분   게임연령 : 18세이용가   난이도 : 2.33 / 5.0   핵전쟁이 일어난 후 민간인의 입장이 되어 최후의 순간까지 생존을 목표로 시나리오가 이어지는 보드게임입니다.  스토리가 전반전으로 탄탄하나 전쟁 컨셉 상 비참하고 무거운 느낌이 강할 수 있으며 플레이어의 윤리과 생존의 갈등을 테스트하고 크게 하루(아침-낮-해질녘-저녘-밤(수집/야간습격)-새벽)를 서사적으로 나누어서 진행하게 됩니다.   주로 ‘무엇을 얻는가’가 아닌 ‘무엇을 잃어야 하는가’에 대해 많은 고민을 하게 만드는 게임입니다.  난이도는 PC게임 원작보다 높은 편이라고 하며 계속해서 확장판을 제작중에 있어서 기대가 많은 게임이기도 합니다.   게임준비      리더 정하기  무작위로 플레이어 중 리더를 고른다.   캐릭터 카드 선택하기  캐릭터 카드들을 섞은 다음 뽑기 :     맨 처음 나온 빨간 테두리의 카드 1장(다음에 빨간 테두리의 카드가 나오다면 무시하고 캐릭터카드를 다시 뽑는다.)   맨 처음 나온 검은 테두리의 카드 2장   이 3장의 카드를 보드 근처에 앞면으로 놓는다.  이번 게임의 시작 캐릭터들이다.  세이브 시트에 이들의 이름을 적는다.  각 캐릭터의 옆에 배고픔 토큰(2 레벨)을 놓는다.  이들 캐릭터를 나타내는 피규어를 찾아 보드의 경계 칸에 놓는다.  남겨진 캐릭터 카드들은 사용되지 않은 캐릭터 칸에 놓는다.   카드 준비하기  모든 카드 더미들을 카드 뒷면과 보드의 일러스트가 일치하는 자기 칸 위에 놓는다.  초록 모서리의 설비 카드들은 설비 칸에 놓는다.  지속되는 설비 카드들은 알맞은 칸에 놓는다.   상단 우측 빨강 모서리의 한 밤의 습격 더미와 거주자 더미를 찾아 옆에 놓는다(나중에 필요하다).        지역 더미에서 3장의 카드를 뽑아 3 개의 지역 칸에 놓는다.   모든 주거지 카드 배치하기  모든 카드들을 앞면으로 놓아 확인한다(파랑 모서리가 없는지).     누구도 뒷면을 훔쳐보지 않는다.    각 주거지 카드는 반드시 카드에 있는 것과 같은 이름의 칸에 놓는다.  (예를 들어 고물 더미 카드는 고물 더미 칸에, 잠겨진 문 카드는 잠겨진 문 칸에).   이벤트 더미 준비하기  이벤트 카드들은 뒷면으로 이벤트 칸에 놓고(앞면을 보지 않고), 다음 순서대로 한다.   1) 3장의 엔딩 이벤트 카드를 섞는다. – 더미의 맨 아래에 놓일 것이다.  2) 챕터 3 카드를 더미의 맨 위에 놓는다.  3) 4장의 이벤트 카드를 무작위로 뽑아 더미의 위에 쌓는다.  4) 챕터 2 카드를 더미 위에 놓는다.  5) 3장의 이벤트 카드를 무작위로 뽑아 더미의 위에 쌓는다.  6) 챕터 1 카드를 더미의 위에 놓는다.   남은 이벤트 카드들은 이번 게임에서는 필요하지 않다   토큰과 자원 배치하기  토큰들과 자원들을 일러스트에 맞게 박스의 적절한 칸에 배치한다.   상태 토큰  게임 동안, 캐릭터들은 다치고, 굶주리고 피로하게 되는 등의 경험을 한다.  “증가/감소” 로 설명되는 피로/상처/비참함/배고픔/질병 효과들이 나올 때마다 토큰을 새로 놓거나 양면 토큰의 경우 뒤집어서 1씩 상태 토큰들의 레벨을 조정한다.  레벨 4 토큰은 당신에게 무슨 일이 일어날 지 알려줄 것이다.   전투 주사위  회색주사위는 비무장상태  노란주사위는 근접무기 무장상태  적색주사위는 화기 무장상태   상황에 맞는 주사위로 굴린다.  검정 주사위 (이하 D10)  소음 마커  일지  디스워오브마인 지원툴 또는 보드게임 내 스크립트 북을 참조한다. 게임 내에서 “~번을 확인하라” 내용이 있을 시 사용한다.   게임을 시작하기 전  최대 플레이 가능한 캐릭터는 4명  5번 째 캐릭터는 그룹에 추가될 수 없다.   컬러 베이스 디스크  캐릭터 피규어들을 쉽게 구분하기 위하여, 각 피규어를 한 색깔의 디스크에 끼운다. 그러면 캐릭터 카드에 토큰을 놓을 때 그 캐릭터의 색깔로 된 토큰을 놓으면 된다.          버리기/제거하기  박스 안에 있는 특정 자원이나 토큰이 바닥날 때마다, 그 아이템은 이제부터는 사용할 수 없다.  (찾거나, 사거나 등을 할 수 없음).   “토큰/자원 버리기”는 박스로 돌려 놓으라는 뜻이다.  “토큰/자원/카드 제거하기”는 이번 게임에서 사용할 수 없다.(Discard의 개념)   공유된 경험  캐릭터들은 개별 플레이어들에게 배당되지 않는다.  플레이어들은 그룹의 모든 캐릭터들과 상호작용한다.  현재 일지를 들고 있는 플레이어를 “리더” 라고 부른다.  플레이어가 ‘다음 플레이어-&gt;’라는 상징을 일지에서 볼 때 마다 :  일지를 자신의 왼쪽에 있는 플레이어에게 건네주고 건네받은 플레이어가 리더가 되며 권한도 위임받는다.  게임에서 당신에게 어떤 종류의 결정을 하라고 말할 때마다(캐릭터, 토큰, 액션 등을 고른다 던지),  플레이어들은 토론하거나, 제안하거나, 다툴 수도 있지만 반드시 최종 결정은 언제나 리더가 한다.     오직 리더만 게임 구성물을 만질 수 있습니다.(피규어, 카드, 토큰을 움직이기 등)    거주지에서의 이동  경계 칸에서 시작하는 캐릭터를 거주지의 어떤 칸이나 설비, 거주지 카드들에 놓을 수 있다.  캐릭터들은 수평으로는 자유롭게 움직인다. 층과 층 사이의 사다리들을 이용하여 수직으로도 움직일 수 있다.  하지만 창살이 있는 창문, 잠긴 문, 돌무더기, 구멍들과 같은 장애물들은 지나갈 수 없고, 그 너머에 있는 카드나 칸은 사용할 수 없다.   게임시작  아침(■□□□□□□)     새로운 날이 시작된다.    이벤트  이벤트 카드 더미의 맨 위 카드를 뽑고 해결한다. 추위 토큰(상단 왼쪽에 표시)을 보드의 추위 공간에 더하는 것을 잊지 않도록 합니다.   챕터 목표   챕터 목표의 경우 목표 상태 토큰을 이용하여 현재 진행도를 나타낼 수 있으며 나중에 챕터가 종료되었을 때 목표 달성 여부에 따라 보상 및 불이익을 적용한다.   다음 플레이어에게 순서를 넘긴다.   낮(■■□□□□□)     새로운 날이 시작된다.     밖은 남은 세력들의 충돌과 우리에게 총을 겨누고 있는 스나이퍼가 있다.  우리는 거주지의 떠날 수 없지만 이곳을 개선할 수 있다.     우리는 침대와 스토브, 심지어 라디오도 사용하여 이 곳을 좀 더 집 같은 느낌이 들게 만들 수 있다.  하지만 먼저, 우리는 여기저기를 치워야 할 것이다.     다행스럽게도 우리는 이 무더기들에 유용한 무언가를 찾을 수 있었다.    행동  각 캐릭터는 3개까지의 행동을 할 수 있다.  행동의 수는 그 캐릭터가 가지고 있는 상태 토큰에 있는 검정색 마커에 따라 적어질 수 있다.  상태 토큰이 보여주는 대로, 검정 마커는 3번의 행동 중 얼마나 사용이 불가한지를 나타낸다.   검은색 마커가 하나씩 칠해질 때마다 행동 횟수가 하나씩 줄어든다.  최종적으로, 캐릭터가 가진 상태 토큰 중 가장 많은 검은색 마커가 칠해진 토큰이 기준이 되어 행동 횟수를 판별한다.                예시로, 한 캐릭터가 위와 같은 상태를 가질 때,  검은 마커가 가장 많은 피로감(fatigue)를 기준으로 1번의 행동이 가능하다.   오직 한 캐릭터만을 각각의 설비/거주지 카드나 거주지 행동 칸에 놓을 수 있다. (돌무더기 뒤지기행동은 이 규칙의 적용을 받지 않는다)   개별 행동(첫 행동, 둘째 행동, 셋째 행동)을 시작할 때, 모든 사용가능한 캐릭터들의 행동을 선택한 다음 동시에 그들의 효과를 해결한다.   개별 행동 후에 다음 플레이어에게 순서를 넘긴다.   할 수 있는 행동들     거주지 칸/설비 카드에서의 행동  선택한 칸/카드에 캐릭터 놓고 요구되는(요구되는 것들이 있는 경우) 자원이나 토큰 저장고로부터 꺼내어 버린다.  만약 행동의 결과로 토큰이 만들어진다면 저장고에 더한다.              거주지 카드에서의 행동(카드 내 상단 빨간 손을 확인!)  선택한 거주지 카드에 캐릭터를 놓는다. 거주지 카드 행동의 결과로 카드의 뒷면을 해결한다.  어떤 거주지 카드(돌무더기, 창살 혹은 잠긴 문)는 캐릭터외에도 저장고로부터 특정 토큰(삽, 줄톱, 자물쇠 핀) 놓기를 요구한다.  행동을 해결한 후 토큰은 저장고로 돌려놓는다.  돌무더기, 돌무더기 잔해 카드의 경우, 삽 대신 추가 캐릭터를 놓을 수도 있다.                       잠긴 문 카드의 행동은 아래에 설명된 주사위 굴림을 요구한다.                      자물쇠 열기 - 자물쇠 핀 필요, D10[^blackDice]  결과 = 1~3 - 효과 없음  결과 = 4-10 - 자물쇠 핀 카드를 버리고 이 카드의 뒷면을 해결한다.                        새로운 설비 카드를 배치하기  설비 칸의 카드 더미에서 어떤 카드도 고를 수 있다.  거주지의 빈 칸(층 옵션의 수면, 경계 칸이나 다른 카드나 행동이 없는 칸)에 설비 카드를 놓으면,  거기에 어느 캐릭터든 놓고 요구하는 자원/토큰을 저장고로부터 버린다. 그 후 설비 카드를 앞면으로 뒤집는다.  정확한 설명과 요구사항은 각 설비카드의 뒷면에 써있다.            야외행동  D10을 굴림하고, 만약 1이 나온다면 저격수로부터 총을 맞고 상처 2를 증가시킵니다.  그런 다음에 방문자들 카드를 한 장을 뽑아 해결합니다.       해질녘(■■■□□□□)     태양은 지평선 너머로 사라졌다.  그림자들과 어둠이 도시를 지배한다.  지금이 밖으로 나가기에 조금은 더 안전하다.  하지만 먼저 우리의 체력부터 회복해야 한다.    각 캐릭터에게 물과 음식을 배급한다.   물 배급  물을 마시지 못한 캐릭터마다, D101을 굴린다 :                  D10       결과                 1 ~ 5       배고픔 1증가                 6 ~ 10       비참함 1증가           사용된 물은 버린다.   음식 배급                          결과                 배급안함       배고픔 1 증가                 야채       배고픔 현상태 유지                 날음식       배고픔 1 감소                 통조림       배고픔 2 감소           마찬가지로 사용된 음식은 버린다.   다음 플레이어에게 순서를 넘긴다.   저녁(■■■■□□□)     어두워지기 전에 우리는 거주지에 머물며 체력을 회복하거나 문을 지키는 사람과 폐허가 된 도시로 모험을 떠날 사람을 결정해야 한다.     우리의 유일한 희망은 약간의 음식와 약품들과 다른 필요한 것들을 찾아내는 것이다.    각 캐릭터를 4 가지의 가능한 과제들 중 하나에 분배한다.   침대에서 자기 :  1 개의 침대 카드에 최대 1 명의 캐릭터를 놓는다. 해당 캐릭터의 피로도가 0이 된다.   바닥에서 자기 :  바닥에서 자기 칸에 캐릭터를 얼마든지 놓는다. 해당 캐릭터들의 피로도가 2 감소한다.   경계 서기 :  야간습격↓단계 동안의 공격들로 부터 거주지를 지키기 위해 경계 칸에 캐릭터를 얼마든지 놓는다.  경계 실력이 높을 수록 좋다.  경계 칸에 최소 1명의 캐릭터를 놓지 않았다면, 스크립트 북의 333을 참조한다.  해당 캐릭터들의 피로도가 1 증가한다.   수집 :  3명의 캐릭터까지 수집 칸에 놓으면 수집 단계 동안 그들을 폐허가 된 도시로 보낸다. 캐릭터의 인벤토리와 실력이 좋을 수록 수집 단계 동안의 수행이 더 좋다.  캐릭터의 피로도가 1 증가한다.   다음 플레이어에게 순서를 넘긴다.   수집(■■■■■□□)     밤이 도시를 돌아다니기에 조금 더 안전하다.  여전히 산발적으로 총성이 들린다.  당신은 배낭을 조여 메고 거주지를 떠난다.  당신은 신중하게 포탄이 떨어진 거리를 따라 폐허가 된 가게와 집들로 발걸음을 옮긴다…    지역 선택하기     3개의 가능한 지역 카드 중 1개를 선택하기(근거리/중거리/원거리) 수집 칸에 놓은 모든 캐릭터를 지역 카드 위로 이동시킨다.  만약 추가 규칙이 있다면 지역 카드의 빨간 칸에 쓰여 있을 것이다.   장비 선택하기  저장고에 무기(손도끼, 칼, 총 등)나  장비(자물쇠핀, 줄톱, 삽 같은)가 있다면,  수집하러 가는 그룹에 이 토큰들을 분배한다(찾은 것들 칸에 놓는다).  또한 만약의 사태를 대비해 거래를 위한 토큰들도 가져갈 수 있다.   소음 마커 셋팅하기  소음 마커를 소음 트랙의 1 칸에 놓는다.  게임에서 소음의 증가나 감소를 이야기할 때마다 소음 마커를 트랙의 위나 아래로 움직인다.  ‘소음 굴림’이라고 쓰여져있으면, D10을 굴린다.   그 결과가 현재의 소음 보다 같거나 낮으면 원하지 않는 만남이 즉시 일어난다 :     소음 마커를 1 칸으로 셋팅한다.   거주자 카드 더미의 맨 위 카드를 뽑고 해결한다.   거주자 카드를 해결한 후, 수집을 재개한다(또 다른 누군가를 여전히 만날 수 있다!)  전투진행시↓   미확인 더미와 탐색 준비하기  당신이 탐색하기로 선택한 지역의 칸에 보이는 만큼의 탐색 카드를 뽑는다.  (근거리 = 10 / 중거리 = 12 / 원거리 = 14)  앞면을 보지 않고 그 카드들을 엎은 채로 미확인 더미에 놓는다.  이제 이 카드들을 하나씩 해결한다.  해결된 카드는 보드 위의 버린 카드 칸에 앞면으로 버린다.   각 카드를 해결한 후 다음 플레이어에게 순서를 넘긴다.   게임이 탐색 카드를 되돌려 놓으라고 하면 앞면을 보지 않고 미확인 더미에서 탐색 카드 더미로 확인하지 않은채로 되돌려 놓는다.  미확인 더미가 다 떨어지면, 탐색이 자동적으로 끝난다.   수집 중에 획득한 모든 아이템은 저장고가 아닌 찾은 것들 칸에 놓아야 한다.  수집 단계가 끝나면 당신은 어떤 것을 두고 가고 어떤 것을 거주지로 가져 갈 건지 결정해야 한다.   찾은 것들 선택하기  탐색이 끝나면, 모든 탐색 카드, 거주자 카드들을 섞어 그들이 있던 카드 더미에 넣는다.      수집을 나선 모든 캐릭터의 전체 보관함(카드 하단 오른쪽 수치)와 동일한 무게2만큼의 토큰/자원(당신이 가져간 장비와 무기를 포함한)을 가지고 돌아올 수 있다.  가지거나 운반할 수 없는 모든 것들을 버려두고 떠나야 한다.  캐릭터들과 그들이 찾은 것들은 새벽↓ 단계에 돌아온다.  그 전에 한 밤의 습격이 일어난다…   다음 플레이어에게 순서를 넘긴다.   야간습격(■■■■■■□)     그동안 거주지에서는…        우리가 가진 것들을 빼앗기 위하여 밤 중에 누군가가 왔다.    경계 서는 자를 위한 무기 선택하기  저장고에 무기 토큰을 가지고 있다면, 그것들을 경계 서는 자에게 줄 수 있다(무기 토큰을 경계 칸에 놓는다).  각 캐릭터는 오직 하나의 무기만 들 수 있다.   한 밤의 습격  야간습격 카드 더미의 맨 위 카드를 뽑고 해결한다.   손실 - 빼앗긴 토큰과 자원들은 반드시 저장고에서 버려져야 한다.  (경계 서는 사람이 들고 있는 무기들은 안전하게 남는다)   상처 - 상처들은 반드시 경계 칸의 캐릭터들에게 나누어 입혀야 한다.  손실과 상처를 최소화 할 수 있는 방법은 아래와 같다.   경계자와 무기  경계 칸의 각 캐릭터를 위해 전투 주사위(사용하고 있는 무기에 맞는)를 굴린다.   하얀 전투 주사위 - 비무장 노란 전투 주사위 - 근거리 무기(손도끼, 칼) 빨간 전투 주사위 - 화기(권총, 자동 소총, 샷건)   굴려진 주사위의 아이콘 수는 손실(토큰, 자원)이나 상처의 고통을 피할 수 있는 양을 나타낸다.   야습 동안 무기 사용하기  권총 - 탄약 토큰을 반드시 버린다.  자동 소총 - 탄약 토큰을 반드시 버린다.   → 만약 2 개의 탄약 토큰을 버린다면 2개의 샷으로 인정된다.  샷 건 - 탄약 토큰을 반드시 버린다.   샷 건을 사용하는 동안 샷-건 아이콘이 나오면, 진행 중인 야습 카드를 즉시 무시한다.  손도끼 – 손도끼를 사용하는 동안 손도끼 아이콘이 나오면, 진행 중인 야습 카드를 즉시 무시한다.   샷 건 아이콘과 손도끼 아이콘은 다른 무기를 사용하는 동안은 빗맞음으로 간주한다.   야습 동안의 실력  실력은 캐릭터가 야습 중에 더 낳은 결과를 내기 위해 주사위를 다시 굴릴 수 있는 횟수를 결정한다.  캐릭터는 모든 재굴림 기회를 사용하지 않아도 되지만 마지막으로 굴린 주사위가 최종 결과가 된다.   보드 개선 (나무가림막) :  모든 설치된 보드 개선 토큰은 [상처 1] 또는 [손실 1]을 피하게 해준다.         지나가는 밤마다 상황은 더욱 냉혹 해지고있다.    범죄 발생  셋팅 동안, 빨강 모서리의 야습 카드와 거주자 카드는 옆에 셋팅한다.  만약 이 카드들이 남아 있다면 :  2 장의 카드를 임의로 조합하여(야습/거주자) 해당 더미에 섞는다.   다음 플레이어에게 순서를 넘긴다.   새벽(■■■■■■■)     생존을 위한 또 다른 날. 우리는 포기할 수 없다…    수집조의 복귀  모든 수집에 나섰던 캐릭터들을 거주지로 이동시키고, 그들이 가져온 토큰/자원들을 저장고에 놓는다.   약과 붕대 분배하기  약/약초/붕대가 저장고에 있다면, 그것들을 질병/상처가 있는 캐릭터 카드를 선택하여 놓을 수 있다.  다음에 이어질 운명의 내용에 따라 아이템을 사용하거나 버린다.   운명 카드 뽑기  운명 카드 1 장을 뽑고 해결한다(아랫 부분에 있는 죽음 마크는 무시한다). 운명 카드가 지역 카드 교체를 말한다면, 그 카드를 게임에서 제거하고 남아 있는 지역 카드들을 아래로 내린다. 그러면 제일 윗 칸이 비게 된다.   다음 플레이어에게 순서를 넘긴다.   이야기 행동 카드(네러티브 행동)  2장의 이야기 행동 카드를 뽑아 1장을 선택한 후, 나머지 1장은 더미로 돌려 놓은 뒤 섞는다.   다음 플레이어에게 순서를 넘긴다.   술  운명 카드를 해결하기 전이나 후에 사용할 수 있다(저장고에서 버리며) :  밀주 - 선택한 캐릭터의 피로를 2 를 올리고, 비참함을 1 내린다.  100% 알콜 - 선택한 캐릭터 피로를 1 올리고, 비참함을 1 내린다.   우리 안에 있는 죽음  새벽 단계가 끝나면 오늘 하루동안 캐릭터들이 죽었는지, 버려졌는지 체크한다.  만약 그렇다면 검은 주사위를 굴려 각 캐릭터의 감정이입 결과와 비교한다.  결과가 그들의 감정이입 보다 같거나 낮으면 - 그들의 비참함 2 증가한다.   저장  지금 당신은 현재 게임의 상태를 저장하고 박스에 넣을 수 있다.  언제든 당신이 돌아와 게임을 시작하려 할 때, 당신이 떠났던 시점부터 시작할 수 있다.  스크립트 책의 10 을 보라.      지난 날을 돌아보자.  우리는 어떻게 해왔나?  다음으로 우리에게 필요한 것은 무엇일까?  우리가 반드시 수집하거나 교환해야 하는 것은 무엇일까?  우리가 반드시 만들어야 하는 건 무엇일까?     … 자, 이제 내일이 우리에게 가져올 것을 보자.    새로운 날이 시작된다(아침 단계↑로 되돌아간다)…   전투  거주자 카드를 해결하는 동안 뽑게 된 A, B, C 토큰들은 당신의 적들을 나타낸다.  이 토큰들은 그들의 무기(거주자 카드에 설명되어 있는)와 실력(숫자)를 결정한다.  전투 차트의 첫째 칸에 적 토큰들을 놓는다.  건강함 -&gt; 상처 1 -&gt; 상처 2 -&gt; 상처 3 = 죽음(적 토큰을 버린다)      각 캐릭터는 찾은 더미에 있는 무기 하나를 분배 받을 수 있다.  (거주지에서 싸움이 일어났다면 저장고에 있는 무기를 가지고온다)   전투는 라운드 단위로 진행한다.  각 라운드마다 당신은 각 캐릭터와 적의 전투 주사위(사용하고 있는 무기에 맞는)를 굴린다.   굴려진 주사위의 아이콘의 수는 입힌 상처의 양을 뜻한다.  적들에 의해 나온 상처의 양은 캐릭터들에게 분배해야 한다.  캐릭터들에 의해 나온 상처의 양은 적들 중에서 선택하여 분배한다.  각 라운드 마다 전투에 임하는 사람들은 동시에 싸우고 상처를 준다.     적의 상처는 전투 차트 위의 적 토큰을 오른쪽으로 이동하는 것으로 표시한다.   캐릭터의 상처는 상처 상태 토큰으로 표시한다.   전투 시나리오  전투 주사위(당신이나 적의) 굴림에서 § 아이콘이 나오면, 당신은 빗맞음/운명을 선택해야 한다.  운명을 선택한다면, 운명 카드를 뽑고 전투 주사위의 아이콘 색이 그 카드에 있는지 체크한다.  만약 굴려진 전투 주사위와 일치하면, 전투 주사위 아이콘 아래의 문장을 읽고 따른다.  일치하지 않는다면 빗맞음으로 간주한다.      전투에서의 실력(재굴림)  실력은 캐릭터가 전투 중에 더 낳은 결과를 내기위해 주사위를 다시 굴릴 수 있는 횟수를 결정한다.  캐릭터는 모든 재굴림 기회를 사용하지 않아도 되지만, 마지막으로 굴린 주사위가 최종 결과가 된다.  적들은 자동적으로 그들의 실력을 사용한다 - 결과가 상처 0일 때만 재굴림 한다.   도망가기  전투의 각 라운드를 시작하기 전에 당신은 싸움을 계속하는 대신 도망가기를 선택할 수 있다.  이 행동을 한다면, 적은 등치기 행동을 한다. 해결한 후에 캐릭터들은 지역을 떠난다.  찾은 것들 중에 선택하기 단계를 해결한다.  (수집 - 찾은 것들 선택하기 단계를 참조한다)   등치기(배후공격)  보통 전투와는 다르게 등치기 할 때는 한 쪽 편만 공격하고(오직 캐릭터들이나 오직 적들), 상대 측은 보복할 수 없다.  보통 전투처럼 공격 주사위를 굴리고 해결한다.  은신한 상태에서 등치기를 하는 경우에는(탐색 카드 더미의 은신처 카드를 참고한다), 등치기를 해결한 후 정식 전투가 시작된다.   전투 시 무기 사용하기  화기(권총, 자동 소총, 샷 건) – 총을 가진 사람이 항상 먼저 굴린다.  만약 총을 가지지 않은 적이 죽었다면, 공격할 기회를 얻지 못한다.   캐릭터가 한 발 쏠 때마다 무조건 탄약 토큰을 1 개 버린다.  만약 캐릭터에게 탄약이 없다면,     반드시 다른 무기를 사용하거나   (다른 무기를 사용할 수 없다면) 비무장으로 싸워야 한다.   적들은 탄약 토큰을 사용하지 않는다.  그 대신 전투 주사위를 굴려 탄약 없음 아이콘이 나오면 해당 적을 전투 차트의 다른 줄로 옮긴다.  (다른 무기가 있거나 무기 없이 싸워야 될 수 있다)   자동 소총 - 만약 2 개의 탄약 토큰을 버린다면 2개의 샷으로 인정된다. 적들은 항상 2 개씩 쏜다.    샷 건 - 샷 건을 사용할 때 샷건 아이콘이 나오면, 목표는 즉시 죽는다.   손도끼 – 손도끼를 사용할 때 손도끼 아이콘이 나오면, 목표는 즉시 죽는다.   샷 건 아이콘과 손도끼 아이콘은 다른 무기를 사용하는 동안은 빗맞음으로 취급한다.   적의 죽음 – 당신이 누군가를 죽인다면(침입자를 제외하고),  검정 주사위를 굴리고 각 캐릭터의 현재 감정이입 상태와 비교한다.  그 결과 그들의 감정이입 보다 같거나 낮다면, 그들의 비참함은 1 증가한다.   캐릭터의 죽음  스크립트 북(266) 참조   거래  거래는 어떤 지역/방문자/거주자 카드와 스크립트들에서 가능한 행동이다.  토큰(수집 동안은 찾은 것들, 거주지로 방문자가 올 때는 저장고에 있는 것들)을 주어진 스크립트나 카드의 범위 안에서 다른 토큰들과 교환할 수 있다.  거래를 시작하기 전에, 당신은 반드시 거래 수수료를 먼저 지불해야 한다.  주어진 카드/스크립트의 거래에 대한 설명에 묘사된 만큼의 전체 가치3의 토큰들을 버려야 함을 뜻한다.  (이것은 당신과 물물교환을 하는 거래자의 이익을 나타낸다)   이제 당신이 사고자 하는 토큰들의 가치와 같거나 더 높은 가치의 토큰들을 버리며 교환할 수 있다.  물, 나무, 부품들은 거래하면서 결코 사거나 팔 수 없다.    각주  1: 검은 주사위 ↩  2: 토큰 내 검은 아이콘에 있는 수치를 나타내며, 없을 시 0으로 책정한다. ↩  3: 각 토큰들은 노랑 아이콘으로 가치를 보여준다. ↩     참고사이트  http://boardlife.co.kr/bbs_detail.php?bbs_num=3571&amp;id=&amp;tb=info_files&amp;game_category=  ","categories": ["hobby"],
        "tags": ["BoardGame","This War of Mine"],
        "url": "https://many258.github.io/hobby/this-war-of-mine/",
        "teaser": null
      },{
        "title": "[정보처리기사/컴퓨터일반] 컴퓨터의 역사",
        "excerpt":"주의) 해당 내용은 (구)정보처리기사, 컴퓨터일반 내용을 기반으로 문서화하였습니다. 수정이 필요하거나, 부족한 내용이 있을시 답글을 남겨주시면 해당 항목을 수정하겠습니다.   세대별 분류     1세대 컴퓨터(1951-1958)            주로 통계 및 미사일 탄도 등 과학 계산에 사용       진공관과 자기드럼(주기억장치 용도)을 사용       부피와 전력 소모는 크지만 계산 능력 및 신뢰도는 떨어졌으나, 계산성능 및 필요성으로 개발은 활발히 진행됨과 함께 상용화가 시작되었다.       기계어, 어셈블리어       대표기종 :  ENIAC, EDVAC, UNIVAC I, 80, 90과 IBM 650과 700계열, Burroughs 220           2세대 컴퓨터(1958-1963)            기억장치를 이루는 회로소자가 트랜지스터(크기 및 발열이 개선)와 다이오드 등 반도체 소자로 제작       IBM 기업이 주도하였으며, 고수준 프로그래밍 언어가 개발되기 시작한 시기       FORTRAN, COBOL, ALGOL 등의 프로그램 언어가 등장과 언어번역 프로그램인 컴파일러가 개발되었음       대표기종 : IBM 1401, 7070, UNIVAC Ⅲ, 1107, USSC 80, CDC 3000계열           3세대 컴퓨터(1964-1970)            집적회로(IC: Integrated Circuit)가 등장해 중앙처리장치가 작아지고 기억용량이 거대해짐       운영체제(operating system: OS), 다중프로그램, 실시간 처리시스템, 시분할시스템 등이 실현       경영 정보 시스템(MIS)이 도입       BASIC, PASCAL, LISP, PL/1 등       대표기종 : IBM 360계열, UNIVAC 1108, CDC 6000계열, Burroughs 5500, Honeywell 200계열, NCR Centry, G.E. 400, 600           4세대 컴퓨터(LSI)(1971-1983)            대규모집적회로(Large Scale Integration: LSI)를 소자로 사용한 컴퓨터       최초의 개인용 컴퓨터(마이크로프로세서(Micro Processor)의 출현으로 컴퓨터의 소형화)와 슈퍼 컴퓨터가 등장       네트워크의 발전과 가상 기억 장치 기법(Virtual Memory)이 도입       개인용 컴퓨터가 개발되기 시작과 사용이 전반적으로 확대       C,ADA 사용       공장자동화(FA), 사무자동화(OA), 가정자동화(HA) 등 각종 분야에 컴퓨터를 이용한 자동화       대표기종 : IBM PC, VAX 780, APPLE 2           5세대 컴퓨터(VLSI)(1984∼ )            초고밀도 집적회로 사용(VLSI)       Visual C, Visual Basic, Java, Delphi 등의 언어 사용       복잡한 계산을 수행하고 고도의 시스템 분야에 활용하고 있다.           기계식 컴퓨터     파스칼의 치차식 계산기   라이프니츠의 가감승제 계산기   배비지의 차분-해석 기관   홀러리스의 천공카드 (PCS)   ABC(Atanasoff Berry Computer : ABC)            진공관으로 이루어진 특수 목적용 컴퓨터           마크원 : 최초의 전기 기계식 자동계산기   에니악(ENIAC：Electronic Numerical Integrater And Computer)     전쟁을 위해 고안된 진공관을 사용한 컴퓨터   최초의 디지털 컴퓨터                                         ENIAC      (출처 : 위키피디아)           에드삭(EDSAC : Electronic Delay Storage Automatic Calculator)     최초의 프로그램 내장 컴퓨터는 아니었으나, 세계 최초의 실용적 프로그램 내장 전자식 컴퓨터   에드박(EDVAC;Electronic Discrete Variable Automatic Computer)     기존의 10진수 계산을 2진수 계산으로 처리   폰 노이만의 전자식 프로그램 내장방식을 사용                                         EDVAC      (출처 : 위키피디아)           유니박 I(UNIVAC－I)     최초의 상업용 컴퓨터   자기테이프를 보조기억장치로 도입                                         UNIVAC      (출처 : 위키피디아)           집적회로의 발전     무어의 법칙(Moore’s Law) :  집적회로의 트랜지스터 개수는 2년마다 2배로 증가한다.   폴락의 법칙(Pollack’s Law) :  성능은 면적(트랜지스터 수) 증가량의 제곱근과 비례   황의 법칙 (Hwang’s Law):  무어의 법칙과 달리 메모리반도체의 집적도가 1년에 두 배씩 늘어난다는 이론  ","categories": ["study"],
        "tags": ["(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/computer-history/",
        "teaser": null
      },{
        "title": "[NCS/경제상식] 국제수지와 환율",
        "excerpt":"국제수지  경상수지     경제적으로 항상 있는 일로 발생한 수지타산의 준말    국가가 재화와 서비스를 외국과 거래한 결과로 나타나는 수입과 지출의 차액  상품수지  일반적인 상품의 수출입  서비스수지  운송/여행/금융/보험/지적재산 사용료 등 서비스의 거래  본원소득수지  국내외 노동자의 임금 소득과 투자 소득  이전소득수지  개인 송금, 기부, 원조 등 무상으로 주고받는 거래에서 발생한 수지   경상수지와 경제     흑자 : 외국에서 구매한 물건 &lt; 외국에 판매한 물건            수출 증가 ⏩ 국내총생산의 증대 ⏩ 고용 및 소득의 증대 ⏩ 소비 증가 ⏩ 경제 호황       외화자산의 증대(통화량 증가) ⏩ 외채 감소, 외국에서 생산되는 원자재의 공급이 수월, 해외 직접투자의 증대 ⏩ 환율 하락           적자 : 외국에서 구매한 물건 &gt; 외국에 판매한 물건            수출 감소 ⏩ 국내총생산의 감소 ⏩ 고용 및 소득의 감소 ⏩ 소비 감소 ⏩ 경제 악화           자본·금융 계정(자본수지)  제품이나 서비스 거래가 아닌  국내 기업,  금융 기관과 외국의 기업,  금융기관이 서로 돈을 꾸거나 빌려주는 거래를 통해 생기는 수입과 지출의 차액   외국인 투자, 해외투자, 차관 등이 포함   환율     국가 간 통화의 교환 비율    환율의 증감     환율 인상 ⏩ 원화 가치 하락(원 약세/절하) ⏩ 국내 물가 상승, 수입품의 가격경쟁력 하락  수출 증가, 수입 감소, 자국민 해외여행 감소, 외국인 국내여행 증가   환율 인하 ⏩ 원화 가치 증가(원 강세/절상) ⏩ 수출품의 가격경쟁력 감소  수출 감소, 수입 증가 ⏩ 경상수지의 적자 가능성 증가  ","categories": ["study"],
        "tags": ["NCS"],
        "url": "https://many258.github.io/study/current-account-balance/",
        "teaser": null
      },{
        "title": "[웹 프로그래밍] HTML5",
        "excerpt":"HTML5     HTML(Hyper Text Markup Language)의 완전한 5번째 버전  WWW(World Wide Web)의 핵심 표준 마크업 언어       ? 마크업 언어  문서 안의 정보를 구조화시키는 언어   탄생배경  기존의 HTML은 HTML4.0 이후에도 W3C에 의해서 HTL 4.01, XHTML 1.0, 1.1, 2.0 등으로 발전해왔지만,  그 동안의 HTML에서의 한계를 극복하기 위해 탄생   특징  기존 HTML과의 호환성 유지, 간단한 업데이트   어도비 플래시나 실버라이트 등의 플러그인을 기반으로 하는 응용프로그램에 대한 필요성을 줄이는 것에 초점   비디오, 오디오 등 다양한 부가기능과 최신 멀티미디어 콘텐츠를 액티브 X 없이 브라우저에서 쉽게   웹 표준, 웹 접근성 한층 증대   JAVA Script 사용하지 않고도 문법이 간결하고 명확하게 변화 ⏩ 문서의 크기 감소 ⏩ 생산성 향상   HTML5 기반 암호화 표준화 진행     모질라 한국 커뮤니티는 웹 표준 기반 HTML5 암호화 및 대한민국의 공인인증서등에 사용가능한  W3C 웹 크립토그래피 API를 제안    주요기능     Device Access  카메라, 동작센서 등의 H/W 기능을 웹에서 직접적으로 제어   Connectivity  웹(클라이언트)에서 서버 측과 직접적인 양방향 통신 가능   3D Graphics &amp; Effects  다양한 2/3차원 그래픽 기능을 지원   Styling Effects(CSS3)  글씨체, 색상, 배경 등 다양한 스타일 및 이펙트 기능 제공   Multimedia  비디오 및 오디오 기능을 자체적으로 지원   Offline &amp; Storage  네트워크 미지원 환경에서도 웹 이용을 가능하게 함   Geo-Location  GPS없이도 단말기의 지리적인 위치 정보를 제공   Semantics  웹 자료에 의미를 부여하여 사용자 의도에 맞는 맞춤형 검색 제공   기타기능     캔버스 : 2차원 그래픽(애니메이션, 게임)을 그리기 위한 캔버스 API 제공   오프라인 웹 : 인터넷 연결이 되지 않은 상태에서도 정상적인 기능을 지원하는 애플리케이션 캐시 API 제공   웹 데이터베이스 : 표준SQL을 사용할 수 있는 데이터베이스 API 제공   로컬 저장소 : 클라이언트에 데이터를 저장하기 위한 API 제공  (웹 브라우저가 실행되는 컴퓨터에 데이터를 저장하는 API, 쿠키와 유사한 역할을 가지나 더 큰 용량으로 저장공간을 이용할 수 있다.)   웹 워커 : 웹 응용을 스레드 기능에 대한 API 제공  (시간이 많이 소요되는 작업들을 백그라운드로 개발해 웹 브라우저의 UI가 느려지지 않도록 하는 기능)   드래그앱드롭 : 모든 요소를 드래그 앤 드랍으로 이동할 수 있음   SSE(Server-Send Events) : 웹페이지가 자동으로 서버에서 업데이트 정보를 가져오는 기능(페이스북, 트위터…)   다양한 Element, Attribute의 변화        시멘틱 태그 추가  웹 리소스와 정보를 모두 컴퓨터가 처리할 수 있도록 구조화시킨 기술                   태그       설명                 Header       문서의 Header를 나타낼 때                 Footer       문서의 Footer를 나타낼 때                 Nav       문서 내 네비게이션(Navigation) 요소가 있을 때                 Section       문서의 영역을 구성, 문서 구조를 구성하는 H1~H6와 함께 사용                 Article       뉴스기사나 블로그 Article과 같은 독립된 Contents를 표시할 때 사용                 Aside       주요 컨텐츠 이외의 참고가 될 수 있는 컨텐츠를 구성할 때 사용                 Figure       그림, 비디오와 같은 포함된 컨텐츠의 Caption 을 표시할 때 사용                 Figcaption       캡션에 사용                 Details       사용자가 필요에 따라 보거나 숨길 수 있는 세부정보를 지정                 Summary       details 요소 안에 보이는 머리글을 정의.   summary를 클릭하여 세부정보를 보거나 숨길 수 있음                 Main       문서의 중요내용을 지정. 고유한 내용. 둘 이상의 main 태그가 존재할 수 없음                 Mark       텍스트 부분을 강조                 Meter       알려진 범위 또는 또는 분수값내에서 스칼라 측정을 정의                 Progress       진행바를 표시                 Time       일자/시간을 정의하는 태그                 Wbr       텍스트에서 줄 바꿈을 추가할 수 있는 위치 지정   (같은 기능의 br 와 달리 공간이 충분할 경우에는 줄바꿈을 수행하지 않음)          ","categories": ["study"],
        "tags": ["HTML5"],
        "url": "https://many258.github.io/study/html5/",
        "teaser": "https://many258.github.io/assets/images/html5/html5.jpg"
      },{
        "title": "[면접/Interview] 면접 시 준비항목 및 키포인트",
        "excerpt":"자주 나오는 질문들  자신을 소개하십시오  ❓ 질문의도  일반적으로 서류상의 내용들을 간략하게 듣기 위한 경우이며, 면접대상자의 언어구사력, 표현력 등을 판단.   🔑 올바른 답변  자기 소개는 자신의 PR입니다. 업무와 연결되는 장점, 성취업적을 부각시켜야 합니다.  2~3분 정도가 가장 적당하며, 회사가 왜 자신을 고용해야 하는지 자신의 주장이나 생각을 숫자, 금액 등을 이용해서 말합니다.   이 때 자신감이 가장 중요한 요소로 여겨집니다.   💯 답변 예시     신입사원의 경우, 학력 및 현재상황을 중심으로 답변   경력사원의 경우, 경력위주(성취업적, 수행업무, 특기사항 등) 중심으로 답변   우리 회사에 지원하게 된 계기는 무엇입니까? (= 지원동기)  ❓ 질문의도  회사의 기여도 및 개인의 목표의식을 알아보려는 질문.  또한 회사에 공헌할 의지가 있는지 아니면 회사가 제공하는 안정, 혜택에만 관심이 있는지를 파악하려는 질문입니다.   🔑 올바른 답변  이 질문에 대한 답변은 자신의 장점을 최대한 부각시켜야 합니다.  업무와 연결하여 자신이 회사를 위해 무엇을 할 것이며, 무엇을 해결할 수 있는지를 구체적으로 말합니다.   이 질문의 답변을 위해 회사의 대한 정보나 자료 수집이 중요합니다.  (회사연혁, 사훈, 경영이념, 가치관, 회사의 대표사업모델, 회사의 자제적 능력개발에 대한 제안, 상품, 기업문화 등)   회사업무 및 당면문제 등을 해결하는데 적절한 능력과 경력을 갖추고 있음을 언급하는 것 또한 좋은 인상을 받을 수 있습니다.  특정분야에 경험, 경력, 자격이 없다면 이 일에 대한 열정을 강조하여 어필합니다.   💯 답변 예시     저는 ~에서 모집하는 분야에 있어 ~한 업무 경력과 업무수행, 업적등으로 인해 누구보다도 업무를 잘 진행할 수 있다고 확신합니다.   저는 모집분야에 있어 최고의 전문가가 되겠다는 강한 목표가 있습니다.   귀사는 매우 빠른 성장을 보이는 회사입니다. 현재의 규모는 작지만 앞으로의 성장 가능성을 믿고 같이 일하고 싶습니다.   전 직장에서 경력은 무엇입니까? ( = 경력사항)  ❓ 질문의도  회사에서 모집하는 업무에 적합한 사람인지 파악하려는 질문   🔑 올바른 답변  체계적이고 실질적인 답변이 중요  실제 사례를 들어 문제상황, 해결 과정 등을 가급적 금액, 숫자, %와 같이 구체적으로 답변  지원회사에서 필요한 자질과 능력에 초점   💯 답변 예시     공정관리를 보다 효율적으로 수행하여 생산성을 00% 높였습니다.   사무실내 관련서류를 전산화하여 업무를 효육성 있게 만들고 회사 경비를 00% 줄였습니다.   품질관리 부분에서 불량률을 00% 정도 줄였습니다.   회사를 왜 퇴직하였는지? 이직하는 이유는 무엇입니까?  ❓ 질문의도  전 직장에서 왜 퇴사하는지? 또 다시 퇴사를 반복할 것인지? 처음 회사에 입사했을 경우 얼마나 일할 사람인지 도는 퇴사이유가 합리적인 부분인지,  구직자의 성향이 어떠한 사람인지 등 대부분 기업이 불안정하기 때문에 이 불안감을 해소하고자 계속해서 확인 차 면접자에게 물어보는 질문   🔑 올바른 답변  전 직장에 대한 어떠한 부정적인 답변을 하지 않습니다.  단어조차도 긍정적인 답변으로 예로서 ‘희망퇴직’, ‘업무가 없어짐’, ‘라인드롭’과 같은 표현을 사용해야 합니다.   기타 ‘도전과 배움에 대한 열망’, ‘새로운 분야로의 접근’, ‘자신의 능력을 향상시켜 보여줄 수 있는 직업선택’ 등이 있습니다.   회사나 상사와의 좋지 않은 감정에 대한 언급은 절대 없어야 합니다.  퇴직을 자청한 이유는 본인에게 더 큰 만족을 줄 수 있는 좋은 직종에서 일을 하고 싶어한다는 부분이 강조되어야 합니다.   💯 답변 예시     중소업체에서 다양한 분야의 일을 하고 싶습니다. 현재 직장은 일은 좋지만 역할이 너무 제한되어 있습니다.   비중 있는 역할을 위해 더 성장 가능성이 있는 귀사에 지원하였습니다.   이전 직장보다 좀 더 제 능력을 인정 받는 곳에서 일을 하고 싶습니다.   원하는 급여는 어느정도 입니까?  ❓ 질문의도  일과 급여는 매우 밀접한 상관관계가 있습니다.  급여에 따라 회사에서의 의욕과 열의, 근무 여부, 재직 후 이직여부 등 여러가지 복합적인 부분을 알아보려는 질문.   🔑 올바른 답변  지원자는 면접 전에 회사의 급여에 대한 정보를 확보하는 것이 현명합니다.  면접 초기 단계는 고용에 대해 회사에서도 확신이 없는 단계이며, 정확한 급여가 정해지지 않을 수 있습니다.  급여는 일을 선택하는데 고려할 것 중의 한가지에 불과하며 그보다는 일 자체에 대해 자세하게 알고 싶다고 말하는 것이 현명합니다.  특히 경력자들은 급여부분에 있어 너무 많은 것을 요구하면 탈락하는 경우가 있습니다.  지원자가 원하는 액수를 말한다면 지원자가 돈에 연연하는 인상을 줄 수 있습니다.  회사가 생각하는 액수보다 높을 경우 지원자를 채용하지 않을 수 있습니다.   💯 답변 예시     제 자신의 경력으로는 어느 정도의 급여가 가능합니까?   정말 중요한 것은 적당한 업무를 찾는 것이며 저의 경력과 자질을 고려할 때, ~ 이상이 되리라 생각합니다.   급여도 중요하지만 매일 제가 맡아야 되는 업무 내용이 더 중요합니다. (회사의 급여 정보를 확보했을 시)   지금까지 취업을 왜 못하셨나요?  ❓ 질문의도  한 직장에 오래 근무할 수 있는지 파악하려는 질문.  오랜 기간동안 취업을 못해 심리적으로 위축된 구직자를 기업에서는 부정적으로 보는 경향이 있습니다.  또한 일할 의욕과 의지를 가지고 있는 사람인지도 평가할 것입니다.   시간상 공백기간은 면접관으로부터 그 동안의 생활, 인생의 목표, 비전의 확립 등에 대한 집요한 질문의 표적이 됩니다.   🔑 올바른 답변  지원자가 지원하고자 하는 분야에 좀 더 능력과 특기를 살리기 위해서 그리고 궁극적으로 회사에 이바지할 수 있는 적합한 직종을 찾는 기간이라는 점이 부각되어야 합니다.  지원자의 목적이 무조건 취업이 아니고 지원자 자신의 적성과 자질을 살려 회사에 기여할 수 있는 직종을 찾아다닌다는 것이 부각되어야 합니다.   또한 구직기간 동안 자신의 능력 및 경력을 향상(학업, 학원수강 등)시켰다는 점이 나타나는지를 평가합니다.   💯 답변 예시     제가 지닌 경력과 능력을 바탕으로 기여할 수 있는 일을 찾고 있습니다.   일을 찾는 것은 어렵지 않지만 정말 제가 원하는 일을 찾는 것은 쉽지 않았습니다. 지금은 귀사를 위해 큰 기여를 할 준비가 되었습니다.   장점이 무엇입니까?  ❓ 질문의도  당신의 장점이 회사에서 필요한 사람인지를 파악하려는 질문.   🔑 올바른 답변  업무를 수행하는데 회사가 중요하게 생각하는 것과 지원자의 답변이 어떠한 연관관계가 있는지를 파악합니다.   지원자의 장점을 통해 수행한 부분이 무엇인지를 판단합니다.  업무와 관련된 신임, 열의, 책임감 등의 실례를 유도하여 판단합니다.   💯 답변 예시     저는 두 가지 장점이 있는데 하나는 분석능력이고 다른 하나는 문제해결능력입니다. 이러한 두 가지 능력으로 문제를 해결하는데 뛰어납니다.   저는 추진력이 강합니다. 일을 완수할 때까지 적극적으로 움직입니다.   저의 장점은 진지하고 성실한 것입니다. 전직장의 상관도 저의 성실성과 진지함을 인정하셨습니다.   저는 목표가 뚜렷하고 그 목표를 위해 계속 노력한다는 것이 장점입니다.   단점은 무엇입니까?  ❓ 질문의도  업무수행에 있어 문제가 될 수 있는지를 파악하려는 질문.   🔑 올바른 답변  업무를 수행하는데 문제가 될 만한 단점은 언급하지 않습니다.  약점으로 여겨질 수 있는 지원자의 단점을 최대한 장점화 시켰는지를 봅니다.   지원자가 업무를 수행하는데 어떤 작은 단점이라도 극복할 자신이 있음을 판단합니다.   💯 답변 예시     나이가 많다는 부분이 단점이지만 저의 전문분야에 대한 더 많은 지식과 훈련 습득을 볼 때, 업무에 안정되고 책임감이 있다고 할 수 있습니다.   결정에 있어 너무 신중해 느릭 결정을 내리곤 합니다. 올바른 결정이 빠른 결정보다 중요하다 생각합니다.   일에 집중하면 동료에게 매우 냉정합니다. 그 외 업무수행에 문제될 큰 단점은 없습니다.   5년(10년) 후의 당신의 비전은 무엇입니까? ( = 미래계획)  ❓ 질문의도  목표를 이루기 위해 지원자의 노력과 진지함을 묻는 질문.  확고한 장/단기 목표와 그 목표를 이루기 위해 구체적인 행동의식을 파악합니다.   🔑 올바른 답변  이력이나 면접에서의 목표를 위해 과거에 무엇을 했고 앞으로는 무엇을 할 것인자를 구체적으로 체계적으로 답변합니다.   💯 답변 예시     컴퓨터 능력을 겸비한 예산전문 회계사가 되고 싶습니다.   모든 직원에게 신뢰를 받고 존경받는 관리자가 되고 싶습니다.   5년 내 저희 동료들도 믿고 따를 수 있는 능력을 겸비한 관리자가 되고 싶습니다.   더 질문이 있습니까?  ❓ 질문의도  회사는 회사에 대해 특별한 관심과 열의가 있는지 파악할 수 있는 질문.   아무 질문이 없으면 해당분야에 정보 및 경험이 없다고 이해할 수 있습니다.   🔑 올바른 답변  지원자가 회사에 대해 미래지향적인 생각을 갖고 있음을 파악합니다.  질문을 통해 지원자의 특징을 부각할 수 있습니다.   지원자의 희망업무나 회사에 대한 파악은 회사에 대한 특별한 관심을 보여줄 수 있습니다.  그러나, 급여/혜택/근무시간/휴가에 대한 질문은 최종 결정이 될때까지 삼가야 할 질문 중에 하나입니다.   💯 답변 예시     지금의 직책은 어떤 사업부문에 속합니까?   해당 업무에서 수행해야 할 목표는 무엇입니까?   업무를 수행하기 위해 추가적인 교육은 어떤 것이 있습니까?   본인이 해결해야 하는 문제와 업무는 어떤 것이 있습니까?   제가 갖추어야 하는 가장 중요한 요소들은 무엇이 있습니까?   일반적인 질문들  당신의 성격은 어떻습니까?  면접대상자가 서부사료에 적합한지의 여부를 판단하기 위한 질문.  회사의 분위기와 문화에 맞는지를 판단.   성격은 반드시 지원자가 지원하는 직종에 적합하도록 성격 특성도 준비되어 있는지를 판단합니다.   당신의 취미는 무엇입니까?  지원자가 균형잡인 생활을 하고 있는지를 판단하는 질문.  취미생활을 위한 적당한 시간할애는 하고 있는지, 취미를 위해 너무 많은 시간을 보내고 있는지를 판단.  중요한 점은, 지원자의 취미생활 및 여가활동이 지원자의 성격과 가치관을 반영한다는 점을 염두해두어야 합니다.   어떤 종류의 책을 읽으십니까?  지원자가 지원하는 직업과 관련한 전문서적에 관해 언급하는 지를 보고 판단.  만약, 취미로 읽는 책에 관해서도 언급한다면 독서 생활을 균형있게 한다는 것을 보여주는 것으로 판단할 수도 있습니다.   팀 별로 일하는 부분에 문제가 없는지?  대답은 지원자가 지원한 분야가 독자적인 업무인지 아니면 팀 별로 일하는 부분인지를 사전에 파악했는지 여부를 판단.  때때로 혼자 일하는 것이 시간이 절약되는 경우가 있지만 서로의 생각을 공유함으로 더 나은 결과를 얻을 수 있다는 점이 강조되어야 합니다.  체계적인 조직의 통제력을 받을 때 독창적이고 혁신적인 성과를 거두는 경우가 많습니다.   우리 회사에 대해 알고있는 점은?  지원자가 지원하는 회사에 대해 나름대로 관심을 가져왔다는 점을 판단.  회사의 전망, 시장상황, 기술 여건 등에 대한 지원자의 생각을 유도하는 것이 중요합니다.   어려운 업무상황에 처했을 경우 어떻게 문제해결을 했는지?  힘든 상황을 극복하거나 개선하기 위해 지원자가 어떤 기술을 사용했는가의 관점에서 판단.  조직문화에 따라 회사의 마찰, 팀 관리, 직원관리 등에 역점을 둘 수 있습니다.  만일 지원자가 지원하는 회사에서도 동일한 문제가 존재한다면 이에 대해 긍정적으로 대처할 것인지 부정적으로 대처할 것인지를 봅니다.  지원자가 그러한 문제를 극복하고 개선시킬 수 있는 것이라면 그러한 지원자의 능력이 무엇인지를 판단합니다.   이전직장에서 보람됐던 일은?  전 직장에서 업무를 수행하면서 팀 별로 업무를 완수한 일, 계획수립 후 업무완수, 과도한 업무 끝에 성공한 일들이 무엇인지를 봅니다.   이전 상사에 대해 어떻게 생각하십니까?  지원자가 이전 직장 상사와 갈등의 관계에 있었는지를 판단.  만약 이전 상사에 대해 좋은 감정을 가지고 있다면 그 이유가 무엇인지에 대한 질문을 유도합니다.   우리 회사에서 뚜렷한 성과를 이룰때까지 어느정도 기간이 소요되리라 생각합니까?  가능한 한 현실적인 답변을 하는 지원자가 좋은 평가를 받으며 보통 6개월에서 1년 정도의 구체적 기간을 언급하는 것이 효과적입니다.  수긍이 가는 대답을 할 수 있을 정도로 직책에 대한 정보를 가지고 있는 것이 중요합니다.   당신의 관리 스타일은?  회사는 관리자의 스타일로서 높은 참여 의식을 선호하는지 아니면 권위주의 선호하는지에 대해 알려고 합니다.   상황 예시 후 어떻게 문제를 해결할 것인지 말씀해보십시오.  상황과 관련하여 지원자의 성과나 업적을 보여줍니다.  조직의 문화나 필요에 따라 경영상에 있어서 마찰, 팀 관리, 부하 직원 관리 등에 대해서 역점을 둘 수도 있습니다.   관리자로서 직원을 고용할 때는 어떤점을 중요시하십니까?  직원의 능력, 솔선함, 적응능력, 성향이 조직에 적합한가 여부를 판단합니다.   업무적인 측면에서 힘들었던 상황은?  이러한 힘든 상황을 극복하거나 개선하기 위해 지원자가 어떤 기술을 사용했는가의 관점에서 봅니다.  문제를 극복하고 개선시킬 수 있는 것이라면 그러한 지원자의 능력이 강조되었는지를 평가합니다.   이전 직장에서 성취하지 못했던 목표와 그 이유는?  지원자가 계획된 모든 목표를 달성했다면 그 사실을 그대로 답변합니다.   정당한 이유로 해낼 수 없었다면 통제할 수 없었던 부분에 대한 설명을 유도합니다.  통제할 수 없었던 장애물로 인하여 당신이 재조정해야 했던 목표에 대해 어떻게 대처했는지는 보는 것이 중요합니다.   리더로서의 경험을 사례를 들어 말씀해주십시오.  지원자의 리더십 기술을 증명하는 성과 등을 예로 들어 답변합니다.   지원자의 전 상사는 당신의 장점의 단점은 무엇이라고 생각하십니까?  전 직장 상사가 이에 대해 어떻게 대답할 것인지 일관성있게 답변하는지를 평가합니다.  어떤 단점이라도 긍정적으로 얘기하고 있는지를 봅니다.  대부분 이전 직장의 상사는 지원자에게 좋은 신용보증을 해주려 할 것입니다.  그러니 되도록 지원자는 상사를 위해 했던 좋은 일들을 많이 열거하도록 합니다.   단답형 질문  지망 동기에 관한 질문     다른 회사에 지망한 적이 있습니까?   우리회사를 들어오기 전에 본인이 특별히 노력한 것이 있습니까?   우리회사의 제품을 보신적이 있습니까? 어떻게 생각하는지?   회사를 선택할 시 중요시하는 것은 무엇입니까?   추천인과는 어떤 관계입니까?   우리회사에 채용이 안되면 어떻게 하실 예정입니까?   우리회사와 다른 회사가 동시에 합격되었을 경우 어떻게 하실겁니까?   지망회사를 결정하기 위해 누구와 상담하셨습니까?   우리회사와 같이 중소기업을 선택한 이유는 무엇입니까?   우리회사의 장점과 단점은?   집에서 회사까지 시간이 얼마나 소요됩니까?   업무에 대한 질문     당신이 희망하는 직종은?   상사와 의견이 다를 경우에 어떻게 하겠습니까?   입사 후 자신이 싫어하는 업무를 맡았을 때 어떻게 하겠습니까?   지방근무를 할 수 있습니까?   이 회사에 입사한다면 어떤 업무를 맡고 싶습니까?   당신에게 직업은 무엇입니까?   입사하면 어떤 일을 하고 싶습니까?   희망부서에 배치되지 않을 경우에 어떻게 하겠습니까?   희망하는 근무지   일과 개인 생활 중 어느 쪽을 선호하십니까?   어떤 일이 적성에 맞는다고 생각합니까?   당신의 특성을 일에서 어떻게 살릴 생각입니까?   입사 후 다른사람에게 절대로 지지 않을 만한 것은?   회사에 대해 묻고 싶은 것은?   비즈니스 사회에서 가장 중요한 것은?   우리회사에서 언제까지 근무할 생각입니까?   어디까지 승진할 예정이십니까?   어떤 사람을 상사로 모시고 싶습니까?   첫 월급을 받으면 어디에 사용할 것입니까?   상사와 의견이 다를 경우에 어떻게 할것입니까?   자기 주장과 협조정신은 무엇입니까?   당신의 포부는 무엇입니까?   자신에 대한 질문     당신의 개성은 무엇입니까?   리더십이 있습니까?   협조정신이 있습니까?   친구가 많습니까?   사람과 이야기하는 것을 좋아합니까?   사람과 함께 있는 것을 좋아합니까?   어떤 성향의 사람을 좋아합니까?   지금까지 좌절감을 느껴본 적이 있습니까?   대인관계를 잘 유지할 자신이 있습니까?   당신은 주위로부터 의논을 받는 편입니까?   일을 시작하면 끝까지 합니까?   살면서 가장 기뻤던 경우와 슬펐던 경우에 대해 말씀해 주십시오.   자신에게 있어 가장 소중한 것은 무엇입니까?   타인의 입을 통한 본인의 평가는 무엇입니까?   생활신조는 무엇입니까?   학창시절에 대한 질문     출신학교 및 본인의 전공은 무엇이며 전공을 선택한 이유는?   학창시절 서클활동과 내용에 대해서 간단히 말씀부탁드립니다.   아르바이트를 해본 경험이 있습니까?   어떤 면을 보고 친구를 사귑니까?   대학생활에서 얻은 것이 있다면 무엇입니까?   제일 좋아하는 과목은 무엇입니까?   친하게 지내는 친구는?   친구는 당신에게 어떤 존재입니까?   친구들은 당신을 어떻게 본다고 생각하십니까?   개인의 인생관     인생의 좌우명이 있다면 무엇입니까?   자신의 인생지표가 되는 사람이 있다면 누구입니까? 그 이유는 무엇입니까?   10년 뒤 당신의 모습은?   휴일에 시간을 어떻게 보냅니까?   기상시간과 취침시간은 언제입니까?   최근에 읽은 책의 내용과 느낀점을 말씀해 주십시오.   신문을 자주 봅니까? 어느 분야를 우선적으로 봅니까?   최근에 흥미있게 본 뉴스에 대해 말씀해 주십시오.   존경하는 사람은 누구입니까?   건강관리를 위해 어떤 것들을 하실겁니까?   지금 가장 원하는 것은 무엇입니까?   기타 질문     앞으로의 포부를 말씀해 주십시오.   자신이 본 책/영화 중 가장 감명 깊게 본 책/영화는 무엇입니까?   현재 가장 하고 싶은 일은 무엇입니까?   어려운 일이 생기면 주로 누구와 상의합니까?   입사하게 되면 회사에 바라는 것은 무엇입니까?   스트레스가 누적되면 어떻게 해결하려고 합니까?   앞으로의 계획은 무엇입니까?   ","categories": ["study"],
        "tags": ["Interview"],
        "url": "https://many258.github.io/study/interview-keypoint/",
        "teaser": null
      },{
        "title": "[알고리즘] 정렬 알고리즘(Sorting Algorithm)",
        "excerpt":"정렬 알고리즘     원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘    내부정렬(Internal Sort)     입력의 크기가 주기억 장치의 공간보다 크지 않은 경우    외부정렬(External Sort)     입력의 크기가 주기억 장치 공간보다 큰 경우, 보조 기억 장치에 있는 입력을 여러 번에 나누어 사용    계산 복잡도 이론(Computational Complexity Theory)  복잡도의 기준은 알고리즘이 소모하는 소요 시간과 메모리 사용량 등의 자원이다.  전자를 시간 복잡도, 후자를 공간 복잡도라 한다.   알고리즘의 시간복잡도는  어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 수론과 해석학의 방법인 점근 표기법 중 빅오 표기법을 사용한다.   빅 오 표기법(Big-O)     수리과학의 여러 분야에서 함수의 증감 추세를 비교하는 표기법이다    알고리즘에서 시간의 복잡도를 표시하기 위하여 대문자 오(O)를 사용하여 나타내는 표기.  입력된 데이터의 크기를 n이라 가정할 때, O(n), O(2) 등으로 표기한다.      O(1)  상수시간 입력값이 아무리 커도 실행 시간이 일정한 경우 최고의 알고리즘이지만 상수값이 매우 크다면 의미가 없다. 해시 테이블의 조회 및 삽입   O(log n)  로그시간 매우 큰 입력값에도 크게는 영향을 받지 않는 경우 입력값에 영향을 받기 시작하지만 크기가 어느만큼 커져도 견고한 편이다 이진 검색   O(n)  선형시간 입력값만큼 실행 시간에 영향을 받는 경우 원하는 값을 찾기 위해 적어도 모든 입력을 살피게 되는 경우 정렬되지 않은 리스트에서 값 탐색   O(n log n)  선형-로그시간 대부분의 효율 좋은 정렬 알고리즘 병합 정렬   O(n2)  2차시간 입력값의 제곱만큼의 시간이 소요되는 경우 버블 정렬 등 비효율적인 정렬 알고리즘   O(2n)  지수시간 재귀로 계산되는 경우   O(n!)  팩토리얼시간 가장 짧은 경로를 찾는 문제 등에 브루트 포스로 풀이 무차별로 대입하는 경우로 제일 느린 알고리즘.      버블 정렬(Bubble Sort)     이웃하는 숫자를 비교하여 작은 수를 앞쪽으로 이동시키는 과정을 반복하여 정렬하는 알고리즘  오름차순으로 정렬할 때, 작은 수는 배열의 앞부분으로 이동하는데, 배열을 좌우가 아니라 상하로 그려보면 정렬하는 과정에서 작은 수가 마치 거품 처럼 위로 올라는 것에서 영감    거의 모든 상황에서 최악의 성능, 효율성이 낮다   의사코드   크기가 n인 배열A  for pass = 1 ~ n-1   for i = 1 ~ n-pass     if (A[i-1] &gt; A[i])       swap A[i-1], A[i]  return A            복잡도                                            최선 시간복잡도       O(ｎ)                 평균 시간복잡도       O(n2)                 최악 시간복잡도       O(n2)                 공간복잡도       O(ｎ)           선택정렬(Selection Sort)  입력 배열 전체에서 최솟값을 선택하여 배열의 0번 원소와 자리를 교환하고,  다음에는 0번 원소를 제외한 나머지 원소에서 최솟값을 선택하여 배열의 1번 원소와 자리를 바꾸는 과정이 정렬이 완료될 때까지 반복한다.   의사코드  크기가 n인 배열A  for i = 0 ~ n-2   min = i   for j = i+1 ~ n-1     if(A[j] &lt; A[min])       min = j   swap A[i], A[min] return A            복잡도                                            최선 시간복잡도       O(n2)                 평균 시간복잡도       O(n2)                 최악 시간복잡도       O(n2)                 공간복잡도       O(ｎ)           삽입정렬(Insertion Sort)  배열이 정렬된 부분과 정렬이 안 된 부분으로 나누고,  정렬이 안 된 부분의 가장 왼쪽 원소를 정렬된 부분의 적절한 위치에 삽입하고 그 뒤의 원소를 한 칸씩 뒤로 밀어내는 방식   의사코드  크기가 n인 배열A  for i=1 ~ n-1   currentElement = A[i] # 정렬이 안 된 부분의 가장 왼쪽 요소   j = i-1   while(j &gt;= 0) &amp;&amp; (A[j] &gt; CurrentElement)     A[j+1] = A[j]     j = j-1   A[j+1] = CurrentElement return A              복잡도                                            최선 시간복잡도       O(ｎ)                 평균 시간복잡도       O(n2)                 최악 시간복잡도       O(n2)                 공간복잡도       O(ｎ)           병합정렬(Merge Sort)  입력이 2개의 부분문제로 분할되고, 부분문제의 크기가 1/2로 감소하는 분할 정복 알고리즘 즉, N개의 숫자들을 N/2개씩 2개의 부분문제로 분할하고,  각각의 부분문제를 재귀적으로 합병 정렬한 후,  2개의 정렬된 부분을 합병하여 정렬한다.   데이터 크기만한 메모리가 더 필요하지만 최대의 장점은 데이터의 상태에 별 영향을 받지 않는다는 점이다.   의사코드   MergeSort(A, p, q) # 입력 A[p]~A[q]  if(p &lt; q&gt;)   k = |(p+q)/2|   MergeSort(A, p, k)   MergeSort(A, k+1, q)   A[p]~A[k] / A[k+1]~A[q] 합병            복잡도                                            최선 시간복잡도       O(ｎlogｎ)                 평균 시간복잡도       O(ｎlogｎ)                 최악 시간복잡도       O(ｎlogｎ)                 공간복잡도       O(ｎ)           힙정렬(Heap Sort)  힙(Heap)     힙은 힙 조건을 만족하는 완전 이진트리이다.  힙 조건이란, 각 노드의 값이 자식 노드의 값보다 커야하는 것을 의미.  노드의 값은 우선순위라고 일컫는데 따라서 힙의 루트에는 가장 높은 우선순위(가장 큰 값)가 저장되어 있다.    힙 정렬은 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법이다.   힙의 루트에는 가장 큰 수가 저장되므로, 루트의 숫자를 힙의 가장 마지막 노드에 있는 숫자와 교환한다.  (즉, 가장 큰 수를 배열의 가장 끝으로 이동시킨 것)  루트에 새로 저장된 숫자로 인해 위배된 힙 조건을 해결하여 조건을 만족시킨다.  힙 크기를 1 줄인다. (루트를 출력하고 힙에서 제거)  이러한 과정을 반복하여 나머지 원소를 정렬한다.   추가적인 메모리를 전혀 필요로 하지 않는다는 점과, 최악의 경우 O(n2)의 성능을 내는 퀵정렬과 달리 항상 O(ｎlogｎ) 정렬의 성능을 발휘하는 장점이 있다.   의사코드   heapify(i) # 위배된 힙 조건을 만족시키기 위한 함수   l = 왼쪽노드   r = 오른쪽노드   if(l &lt;= Heapsize &amp;&amp; A[l]&gt;A[i])     big = l   else     big = i   if(r &lt;= Heapsize &amp;&amp; A[r]&gt;A[big])     big = r   if big != i     swap A[i], A[big]     heapify(i)  build_max_heap()   HeapSize = Length   for i = Length/2 ~ 1 (--)     heapify(i)  build_max_heap(A) for i = length ~ 2   swap A[1], A[i]   HeapSize = HeapSize-1   heapify(A, i)             복잡도                                            최선 시간복잡도       O(ｎlogｎ) 모든 키가 구별되는 경우                 평균 시간복잡도       O(ｎlogｎ)                 최악 시간복잡도       O(ｎlogｎ)                 공간복잡도       O(ｎ)           셀정렬(Shell’s Sort)     삽입 정렬이 거의 정렬된 배열에서 최적의 성능을 내는 것에서 착안한 정렬 방법  버블 정렬, 삽입 정렬에서 이웃하는 원소의 숫자들끼리의 비교를 통해서 느리게 이동하는 단점을 보완    삽입 정렬을 이용하여 배열 뒷부분의 작은 숫자를 앞부분으로 빠르게 이동시키고,  동시에 앞부분의 큰 숫자는 뒷부분으로 이동시키며, 가장 마지막에는 전체에 대해 삽입 정렬을 수행한다.   의사코드   for each gap h 큰 간격 부터 차례로   for i = h ~ n-1     CurrentElement = A[i]     j = i     while(j &gt;= h) &amp;&amp; (A[j-h] &gt; CurrentElement)       A[j] = A[j-h]       j = j-h     A[j] = CurrentElement return A            복잡도                                            최선 시간복잡도       O(ｎlogｎ)                 평균 시간복잡도       O(ｎlogｎ)                 최악 시간복잡도       O(n4/3)                 공간복잡도       O(ｎ)           퀵정렬(Quick Sort)  원소 하나를 기준(피벗)으로 삼아 그보자 작은 것은 앞으로 빼내고 그 뒤에 피벗을 옮겨 피벗보다 작은 것, 큰 것으로 나눈 뒤 나누어진 각각에서 다시 피벗을 잡고 정렬해서 각각의 크기가 0이나 1이 될 때까지 정렬.   의사코드  QuickSort(A, l, r) # 배열A, 왼쪽, 오른쪽 if(l &lt; r)   피봇(p)을 A[l]~A[r] 중 적절한 알고리즘으로 인하여 선택   피봇을 A[l]과 교환한 후   피봇과 배열의 각 원소를 비교하여 피봇보다    작은 숫자들은 A[l] ~ A[p-1]로 옮기고   큰 숫자들은 A[p+1] ~ A[r]로 옭기고 피봇은 A[p]에 놓는다.   QuickSort(A, l, p-1)   QuickSort(A, p+1, r)            복잡도                                            최선 시간복잡도       O(ｎlogｎ)                 평균 시간복잡도       O(ｎlogｎ)                 최악 시간복잡도       O(n2), 피벗을 최대값/최소값으로 설정할 경우                 공간복잡도       O(n)           기수정렬(Radix Sort)     비교정렬이 아닌, 숫자를 부분적으로 비교하는 정렬 방법 제한적인 범위 내에 있는 숫자에 대해서 각 자릿수별로 정렬하는 알고리즘.    어느 비교정렬 알고리즘보다 빠르다는 장점을 가지고 있다.   의사코드   n개의 r진수 for i = 1 ~ K(K자리 숫자)   각 숫자의 i자리 숫자에 대해 안정한 정렬을 수행 return A  복잡도                                            최선 시간복잡도       O(ｎ)                 평균 시간복잡도       O(dn) d는 데이터의 자릿수                 최악 시간복잡도       O(dn)           정렬 알고리즘의 속도 비교    ","categories": ["study"],
        "tags": ["Algorithm"],
        "url": "https://many258.github.io/study/sorting-algorithm/",
        "teaser": null
      },{
        "title": "[리눅스] 기본 디렉토리 구조",
        "excerpt":"주요 디렉토리  리눅스의 디렉토리 혹은 파일 시스템 구조는 윈도우와는 조금 다른 구조를 가지고 있습니다.  기본적으로 디렉토리를 구분하는 ‘/’(슬래시)는 리눅스에서 사용하고 윈도우는 반대인 ‘'(역슬래시)를 사용합니다.  디렉토리 또한 그 명칭을 리눅스에서는 디렉토리(directory), 윈도우에서는 폴더(folder)라고 지칭합니다.   리눅스 시스템의 디렉토리 구조는 전체적으로 역 트리(tree) 구조를 하고 있습니다.  그리고 명령어의 종류와 성격, 사용권한등에 따라 각각의 디렉토리들로 구분됩니다.  리눅스 배포판들은 ‘리눅스 파일시스템 표준’ 인 FSSTND(LINUX FILE System Standard) 라는 표준을 준수하므로 대부분의 리눅스 배포판들은 그 기본 골격이 같습니다.      /(루트)  최상의 디렉토리인 루트 디렉토리를 의미하며, 리눅스의 모든 디렉토리들의 시작점이다. 모든 디렉토리들을 절대경로로 표기할 때에 이 디렉토리로부터 시작해야 한다.   /bin  Binary의 약자로 기본적인 명령어가 저장된 디렉토리.  리눅스 시스템사용에 있어 가장 기본적이라고 할 수 있는 mv, cp, rm… 등과 같은 명령어들이 이 디렉토리에 존재하며  root 사용자와 일반사용자가 함께 사용할 수 있는 명령어 디렉토리이다.   /sbin  bin과 유사하나 ifconfig, e2fsck, ethtool, halt 등과 같이 주로 시스템 관리자 또는 루트 유저들이 사용하는 시스템관리자용 명령어(시스템 점검, 복구, 초기, 종료 명령 등)를 저장하고 있는 디렉토리.   /boot  리눅스 부트로더(Boot Loader)가 존재하는 디렉토리. GRUB 과 같은 부트로더에 관한 파일들(grub.conf 등)이 이 디렉토리에 존재한다.   /dev  시스템 디바이스(Device)파일을 저장하고 있는 디렉토리. 하드디스크 장치파일 /dev/sda, CD-ROM 장치파일 /dev/cdrom 등과 같은 장치파일들이 존재하는 디렉토리이다.   /etc  대부분의 환경설정 파일이 존재하는 디렉토리.  네트워크 관련 설정 파일, 사용자 정보 및 암호정보, 파일 시스템 정보, 보안파일, 시스템 초기화 파일 등 중요 설정 파일들이 위치.  /etc/sysconfig(시스템 제어판용 설정파일),  /etc/passwd(사용자관리 설정파일),  /etc/named.conf(DNS 설정파일) 등과 같은 파일들이 존재한다.   /etc/mai/  sendmail.cf 나 access 파일등의 sendmail 의 설정파일들이 존재하는 디렉토리.   /etc/ssh/  SSH 서비스, 즉 sshd 데몬에서 사용하는 각종 설정파일들이 존재하는 디렉토리.   /etc/squid/  squid 프록시서버의 설정파일들이 저장된 디렉토리.   /etc/samba/  삼바관련 설정파일들이 저장된 디렉토리   /etc/gnome/  GTK+ 정의파일들이 있음   /etc/skel/  계정사용자 생성시의 초기화파일들이 저장된 디렉토리(useradd 에서 사용함)   /etc/rc.d/  부팅레벨별 부팅스크립트파일들이 존재하는 디렉토리.   /etc/rc.d/init.d/  시스템 초기화 파일들의 실제파일들이 존재함.   /etc/pam.d/  PAM 설정 정보파일들이 저장된 디렉토리.   /etc/security  터미널 보안에 관련된 설정이 있음   /etc/httpd/  RPM 으로 설치된 아파치 설정파일(httpd.conf 등)들이 저장된 디렉토리.   /etc/cron.d/, /etc/cron.daily/, /etc/cron.hourly/, /etc/cron.monthly/, /etc/cron.weekly/  모두 크론설정파일이 존재하는 디렉토리임.   /etc/xinetd.d/  xinetd 수퍼데몬에 의해 서비스되는 서비스설정파일이 존재함.   /home  사용자의 홈디렉토리, useradd 명령어로 새로운 사용자를 생성하면 대부분 사용자의 ID와 동일한 이름의 디렉토리가 자동으로 생성됨.   /lib  커널모듈파일과 라이브러리파일.  커널이 필요로하는 커널모듈파일들과 프로그램(C, C++ 등)에 필요한 각종 라이브러리 파일들이 존재하는 디렉토리.   /media  DVD, CD-ROM, USB 등과 같은 탈부착이 가능한 장치들의 마운트포인트로 사용되는 디렉토리.   /mnt  /media 디렉토리와 비슷한 용도로 사용되나, 다른점은 사용자가 직접 마운트를 경로로 사용   /srv  서버를 위한 폴더. FTP/SFTP/RSync와 같은 프로토콜을 이용하여 외부 사용자와의 공유를 위해 사용   /sys  실제 디스크의 물리적 영역이 아닌 RAM을 기반으로 한 파일시스템.  커널 데이터에 대한 구조 속성 등 시스템 전반에 대한 내용을 제공   /proc  일명 가상파일시스템 이라고 하는 곳으로 현재 메모리에 존재하는 모든 작업들이 파일형태로 존재하는 곳이다.  디스크상에 실제 존재하는 것이 아니라 메모리상에 존재하기 때문에 가상파일시스템이라고 부른다.   현재 시스템 정보을 제공하며 존재하는 파일들 가운데 실행중인 커널(kernel)의 옵션 값을 즉시 변경할 수 있는 파라미터파일들이 있기 때문에 시스템 운용에 있어 매우 중요한 의미를 가진다.   /root  시스템 최고관리자인 root 사용자의 개인 홈 디렉토리.   /tmp  공용디렉토리. 시스템을 사용하는 모든 사용자들이 공동으로 사용하는 디렉토리.   /opt  응용프로그램 패키지 설치 장소. 패키지 매니저가 자체적으로 설치 및 삭제를 수행   /usr  User System Resource의 약자로 일반사용자들이 주로 사용하는 디렉토리. 각 유저 이름에 맞는 폴더이름이 생성되어 있으며 각 폴더마다 bin/sbin/shared/lib와 같이 각 유저들이 사용할 수 있는 폴더들이 위치   /usr/bin/  일반 사용자들이 사용가능한 명령어 파일들이 존재하는 디렉토리.   /usr/sbin/  /bin 에 제외된 명령어와 네트워크관련 명령어가 들어있는 디렉토리.   /usr/X11R6/  X 윈도우 시스템의 루트 디렉토리.   /usr/include/  C 프로그램에 필요한 헤드파일(*.h) 디렉토리.   /usr/lib/  /usr/bin과 /usr/sbin에 있는 실행 바이너리를 실행하기 위한 라이브러리 디렉토리   /usr/src/  프로그램 소스 및 주로 커널 소스가 저장되는 디렉토리.   /usr/local/  새로운 프로그램들이 설치되는 곳 (windows의 Program Files 와 유사)   /usr/share/man/  명령어들의 도움말을 주는 메뉴얼(manual)페이지 디렉토리.  이 디렉토리에는 시스템에서 사용하는 모든 맨페이지파일(man page)이 존재함.   /var  시스템 운용중에 생성되었다가 삭제되는 동적인 데이터를 일시적으로 저장하기 위한 디렉토리.  거의 모든 시스템 로그파일은 /var/log 에 저장되고,  DNS 의 zone 설정파일은 /var/named 에 저장되고,  메일파일은 /var/spool/mail 에 저장되며,  크론설정파일은 /var/spool/cron 디렉토리에 각각 저장됨.   /var/tmp/  /tmp 디렉토리와 같은 공용디렉토리.  /tmp 디렉토리와 /var/tmp 디렉토리의 퍼미션은 1777 로서 sticky bit 가 설정되어 있는 공용디렉토리이다.  리눅스 시스템에서 공용디렉토리는 /tmp 와 /var/tmp 둘뿐이다.   /var/log/  시스템로그파일(messages, secure, xferlog 파일등)이 저장되는 디렉토리.   /var/ftp/  vsftp 등과 같은 FTP 서비스를 위한 다운로드될 파일들   /var/named/  BIND 즉, DNS 에서 사용하는 zone 파일들이 저장되는 디렉토리.   /var/spool/mail/  각 계정사용자들의 메일파일이 저장되는 디렉토리.   /var/spool/lpd/  프린트를 하기 위한 임시 디렉토리(스풀링 디렉토리).   /var/spool/mqueue/  발송을 위한 메일 일시저장 디렉토리.   /var/spool/cron/  각 사용자들의 cron 설정파일들이 저장된 디렉토리.   /var/spool/at/  예약작업에 관한 파일들이 저장되는 디렉토리.   /lost+found  부팅시 파일시스템 손상이 되었을 때 사용되는 디렉토리.  평소에는 파일에 이상이 없으면 비어있음  ","categories": ["study"],
        "tags": ["Linux"],
        "url": "https://many258.github.io/study/linux-file-structure/",
        "teaser": null
      },{
        "title": "[리눅스] 계정 패스워드와 관련된 파일 (/etc/passwd, /etc/shadow)",
        "excerpt":"리눅스의 계정 관리 파일  리눅스에서는 파일로 사용자 계정을 관리합니다.  계정을 생성할 경우 다음과 같은 파일에 내용이 추가됩니다.   /etc/passwd : 계정을 관리하는 파일  /etc/shadow : 패스워드를 관리하는 파일   /etc/passwd 파일 구조   root : x : 0 : 0 : root : /root : /bin/bash                                                                                          root       x       0       0       root       /root       /bin/bash                 1       2       3       4       5       6       7           한 줄의 각 항목은 콜론 문자(:)에 의하여 분리되어 있으며 총 7개의 필드로 구성되어 있다.     사용자 명(ID)   사용자 패스워드. x로 되어있는 것은 /etc/shadow 파일에 암호화되어 저장되어 있다는 의미.   사용자 ID 를 의미하며 root 경우 0  adduser 스크립트에 의하여 부여됨.   사용자가 속한 그룹 ID 를 의미하며 root 경우 0   사용자 계정 이름 (정보)   사용자의 홈 디렉토리   사용자가 기본으로 사용하는 쉘 종류 지정   /etc/shadow 파일 구조   root : &amp;6$zF24Dfs5&amp;...(생략) : 15426 : 0 : 99999 : 7 :   :   :                                                                                                                           root       &amp;6$zF24Dfs5&amp;…       15426       0       99999       7                                                         1       2       3       4       5       6       7       8       9                           한 줄의 각 항목은 콜론 문자(:)에 의해 분리되어 있으며 총 9개의 필드로 구성되어 있다.     사용자 명(ID)   패스워드를 암호화시킨 값. 앞에 !가 있으면 잠긴 상태   (::) : 패스워드가 필요없다는 것을 나타낸다.   (:*:) : 계정을 막아두었다는 것을 나타낸다.   1970-01-01 날짜부터 패스워드가 수정된 날짜의 일수를 계산한 값   패스워드 최소 유지기간   0 이면 언제든지 바꿀 수 있다는 의미.   패스워드 최대 유지기간   99999 는 오랫동안 패스워드를 바꾸지 않았다는 것을 의미.   패스워드 만료 경고기간   패스워드 만료 전 경고 메세지가 나오는 일수    ex) 만료일이 90일이고, 만료 경고기간이 7일이면 83일부터 90일까지 7일동안 경고메지니가 나오다 91째 만료된다.   계정 잠김으로부터 남은 일수(패스워드 만료 후 계정이 잠기는 일수)   계정 만료 일자(비어있으면 만료 없음)   예약 필드(사용되지 않음).   /etc/shadow 내 2번째 필드      [$Hashid $Salt $Hash vlaue]    Hashid  적용된 단방향 해시 알고리즘을 나타냅니다.  사용되는 Scheme은 1.MD5 2. BlowFish 5. SHA-256 6. SHA512  주로 $1, $5, $6 이 많이 사용되는 HashID입니다.   Salt  해시는 기본적으로 단방향 함수이므로 이미 수행된 결과값을 이전값으로 복호화가 불가합니다.   공격을 시도하는 해커들은 레인보우테이블을 구비하는데, 여기서 레인보우테이블은 모든 해시의 쌍들을 미리 구해둔 데이터로 이를 이용하여 빠르게 대입해 패스워드를 크랙할 수 있습니다.   그래서, 이 공격을 힘들게 하기 위해 중간에 OS 내에서 생성하는 임의의 값인 Salt를 추가합니다.  마치 음식 간을 맞추기위해 소금을 첨가하는 것과 마찬가지로 Salt를 추가해서 암호화 강도를 높이는 역할을 합니다.   실제로 passwd 명령로 똑같은 암호로 변경한 후 shadow 파일을 확인해보면 값이 달라져있는 것을 확인할 수 있습니다.  이는 패스워드를 변경할 때마다 Salt 값이 변하기 때문입니다.   즉, 패스워크 크랙하기 위해서는 Salt 값을 알아야 하며 해당 Salt 값을 모르면 레이보우 테이블을 가지고 있어도 의미가 없게 됩니다.   Hash Value  HashID 에 따른 해시 방법과 Salt 값을 가지고 해쉬 함수를 수행한 결과.   관련된 리눅스 명령어           passwd [계정]  계정 비밀번호 설정                                  옵션           설명                             -s           사용자의 패스워드에 대한 정보 표시                             -d           계정 비밀번호를 삭제                             -l           계정 비밀번호 잠금 (로그인 잠금)                             -u           계정 비밀번호 잠금 해제                             -n           사용자가 암호를 바꾸지 못하는 Min day 설정                             -x           사용자 암호 변경없이 사용 가능한 Max day 설정                             -i           사용자 패스워드가 만료된 후 실제로 로그인이 불가능해질 때까지의 기간 설정                             -e           다음 로그인 시 무조건 패스워드를 변경하도록 하는 옵션                             -w           패스워드 만료 전 경고 날짜를 지정                                chage  사용자 패스워드를 관리하는데 사용. /etc/shadow의 날짜와 관련된 필드의 설정을 모두 변경할 수 있는 명령어                                  옵션           설명                             -l(대문자 : L)           사용자 패스워드에 대한 정보 표시                             -d           최근 패스워드를 변경한 날을 수정 (/etc/shadow 3번째 필드)                             -m           패스워드 변경 후 최소로 사용하는 날 지정                             -M           설정한 패스워드의 만기일을 지정                             -I (소문자 : i)           패스워드 만기일 이후 실제 패스워드가 사용 불가능해질 때까지의 기간                             -W           패스워드 만기 전 변경을 요구하는 경고 날짜 지정                             -E           계정이 만기되는 날을 지정                                pwconv  일반 패스워드에서 shadow 패스워드로 변경하는 명령어. 수행되고 나면 /etc/passwd 의 내용 중 두 번째 필드에 있는 암호화된 패스워드 부분만이 /etc/shadow 파일에 따로 저장.            pwunconv  shadow 패스워드에서 일반 패스워드로 되돌리는 명령어. /etc/shadow 파일에 보관되었던 패스워드를 다시 /etc/passwd 파일에 저장.      ","categories": ["study"],
        "tags": ["Linux"],
        "url": "https://many258.github.io/study/linux-security-structure/",
        "teaser": null
      },{
        "title": "[정보보안기사/정보보안일반] 보안 기술 요소",
        "excerpt":"정보보호     정보의 수집/가공/저장/검색/송신/수신 중에 정보를 훼손/변조/유출 등을 방지하기 위한 관리적/기술적 수단    정보보호 목표          기밀성(Confidentiality)  허가되지 않은 사용자가 기업 혹은 개인의 중요자료에 접근하거나 또는 중요자료가 유출되었을 때 그 내용을 알 수 없도록 암호화하는 것을 의미  접근 통제 측면에서 중요자료에 대해서 보안등급을 부여해 접근 및 열람이 가능한 주체를 정의하여 통제            무결성(Integrity)  중요자료에 대해서 임의적으로 변경하지 못하도록 하는 것을 의미. 대표적인 방법은 해시함수이며 종류로는 MD2, MD4, MD5, SHA가 존재.            가용성(Availability)  정당한 사용자가 서비스를 요청할 때 서비스를 제공할 수 있는 특성을 의미.  가용성을 확보하기 위해 주로 디스크, 네트워크, 서버를 이중화하며 RAID, DRS의 방법을 사용.  RAID : 디스크를 이중적으로 구성하여 하나의 디스크에 장애가 발생할 경우 백업된 디스크를 사용해서 중단 없이 시스템을 이용.  DRS : 재해복구시스템으로 서버를 2대의 Active로 구성하여 한 대의 서버에 장애가 발생해도 2번째 서버를 이용하여 서비스 중단 상황을 방지.       정보보호 공격유형          변조(Modification)  원래의 데이터를 조작하는 행위.  소스 프로그램을 변경하여 악성코드를 실행하거나 특정 URL로 접속하게 유도  ex) Redirection            가로채기(Interception)  네트워크상에서 전송되는 데이터에 대하여 복사, 열람 등을 하는 공격유형  가로채기는 정보를 열람하는 것이고 이러한 공격을 수동적 공격(Passive Attack)이라고 지칭.  ex) 스니핑(Sniffing)            차단(Interruption)  정상적인 서비스를 방해하는 행위.  ex) DoS 및 프로세스 고갈 공격            위조(Fabrication)  송신되는 메시지를 변조하여 상대방을 속이는 행위.       정보보호 대책          일반 통제  소프트웨어 생명주기에 대한 통제  모든 애플리케이션에 공통으로 적용하는 IT조직, 직무분리, 시스템 개발, 논리적 및 물리적 보안, 하드웨어 통제, 백업 및 복구, 비상계획 등을 수립하는 통제            응용 통제  정보시스템에서 발생시키는 트랜잭션과 데이터 무결성을 확보하기 위한 통제       시점별 분류          예방 통제(Preventive)  능동적인 통제로, 발생가능한 문제점을 사전에 식별하여 통제를 수행하는 것.  물리적 접근 통제 : 승인되지 않은 사람이 주요 정보시스템에 출입 방지. ex) 경비원  논리적 접근 통제 : 인증받지 못한 사람이 주요 정보시스템에 접근 방지. ex) 방화벽            탐지 통제(Detective)  예방 통제를 우회하여 발생되는 문제점을 식별. ex) CCTV, 경보            교정 통제(Corrective)  탐지된 위협과 취약점에 대응하는 것. ex) 백신 S/W            복구 통제(Recovery)  자원과 능력을 복구.  ex) 백업 및 복구       사용자 인증 방식 및 원리  지식기반 인증     사용자의 기억으로만 인증하는 방식. ex) 패스워드, PIN       패스워드 공격기법  무차별 공격(Brute Force Attack)  사전 공격(Dictionary Attack)  트로이목마 프로그램  사회 공학적 공격 : 예로 콜 센터 등에 전화하여 패스워드를 알아내는 심리적 공격 방법  전자적 모니터링 : 패스워드 입력/전송 시 스니핑   소유기반 인증     대표적인 예로는 열쇠가 있으며 복제와 분실의 위험이 존재.       스마트 카드 :  메모리 토큰과 달리 프로세스 능력 보유  통일성 결여(표준의 미흡)  주파수를 복제의 위험성이 존재   존재(생체)기반 인증     불변의 특성을 지닌 생체적, 행동적 특징을 자동회된 수단으로 등록    생체인증 분류     존재 특징 : 생체 특성, 지문, 장문, 얼굴, 손 모양, 홍채   행동 특징 : 서명, 음성, 키보드 입력   생체인증 특징          보편성(University)            유일성(Uniqueness)            지속성(Permanence)            성능(Performance) 개인 확인 및 인식의 우수성, 시스템 성능            수용성(Acceptance) 거부감이 없어야 함.            저항성(Resistance) 위조가능성이 없어야 함.       생체인증 평가항목     FRR(False Reject Rate)  잘못된 거부율, 편의성 관점, 정상적인 사람을 거부함   FAR(False Acceptance Rate)  잘못된 승인율, 보안 관점, 비인가자를 정상인 사람으로 받아들임   CER(Crossover Error Rate), ERR(Equal Error Rate)  FRR과 FAR가 교차되는 지점. 효율성 및 생체인증의 척도      행동기반 인증     개인의 고유한 행동적 특성을 사용하여 인증하는 기술    서명, 키스트로크, 마우스 움직임, 걸음걸이, 모바일 단말기 사용패턴 등을 분석하여 인증   커버로스(Kerberos) 인증  중앙 집중형 사용자 인증 프로토콜 = RFC1510  대칭키 암호화 기법에 바탕을 둔 티켓기반 인증 프로토콜  3A 지원(AAA서버). Authentication(인증), Authorization(인가), Accounting(과금)   커버로스 구성요소          KDC(Key Distribution Center)  키 분배센터. TGS + AS로 구성  사용자와 서비스 암호화 키를 유지하고 인증 서비스를 제공하며 세션 키를 만들고 분배            TGS(Ticket Granting Service)  티켓 부여 서비스. 티켓(인증 토큰)을 만들고 세션 키를 포함한 Principals에 티켓을 분배하는 KDC의 한 부분            AS(Authentication Service)  인증 서비스. 실질적 인증 수행            Principals  인증을 위하여 커버로스 프로토콜을 사용하는 모든 실제를 이르는 말            TimeStamp  시간 제한을 설정하여 다른 사람이 티켓을 복사하여 나중에 그 사용자인 것처럼 위장하여 티켓을 사용하는 것(Replay Attack)을 방지         ","categories": ["study"],
        "tags": ["정보보안기사"],
        "url": "https://many258.github.io/study/security-access-control/",
        "teaser": null
      },{
        "title": "[엑셀/Excel] 자주 출제 및 사용하는 함수",
        "excerpt":"수학 관련 함수  통계          SUM(숫자1, [숫자2], [숫자3],…)  지정된 셀 범위의 합계를 구하는 함수            SUMIF(조건범위, 조건, [찾을범위])  조건을 만족하는 데이터의 합계            SUMIFS(합을 구할 범위, 참조할 범위1, 조건1, [참조할 범위2], [조건2], …)  범위 안 여러개의 조건을 만족하는 값의 합계            DSUM(전체범위, 찾을 열 필드, 조건범위)  조건을 만족하는 값의 합계를 출력            AVERAGE(숫자1, 숫자2, 숫자3,…)  지정된 셀 범위의 평균을 구하는 함수            DAVERAGE(전체 범위, 찾을 열번호, 기준)  전체 데이터베이스 내에서 기준에 맞는 자료의 평균            MAX(숫자1, 숫자2, 숫자3,…)  지정된 셀 범위 내 최대값 출력            MIN(숫자1, 숫자2, 숫자3,…)  지정된 셀 범위 내 최솟값 출력            LARGE(인수 또는 셀범위, 숫자인수)  범위 내 [지정한 숫자인수 값] 번째로 큰 수 출력            SMALL(인수 또는 셀범위, 숫자인수)  범위 내 [지정한 숫자인수 값] 번째로 작은 수 출력            MODE(범위1, [범위2],…)  인수들 중 가장 많이 발생한 값인 최빈값 출력            RANK(값, 범위, [논리값])  범위 내에서 지정한 수의 순위를 구한다.  논리값이 0이거나 생략되면 내림차순으로, 0이외의 값은 오름차순으로 표시            COUNT(숫자1, 숫자2, 숫자3,…)  인수로 입력된 숫자의 개수 출력            COUNTA(범위1, 범위2,…)  셀 범위 중 비어있지 않은 셀의 개수 출력            COUNTBLANK(범위)  비어있는 셀의 개수 출력            COUNTIF(범위, 조건)  범위 내 조건을 만족하는 셀의 개수 출력            COUNTIFS(범위1, 조건1, 범위2, 조건2, …)  범위 내 여러 조건을 만족하는 셀의 개수 출력            DCOUNT(전체 범위, 찾을 열번호, 기준)  전체 데이터베이스 내에서 기준에 맞는 숫자 포함 셀들의 개수            DCOUNTA(전체 범위, 찾을 열번호, 기준)  전체 데이터베이스 내에서 비어있는 셀은 무시하고 기준에 맞는 셀들의 개수       어림값          EVEN(숫자)  가까운 짝수값으로 올림            ODD(숫자)  가까운 홀수값으로 올림            ROUND(인수, 소수점 이하 자릿수)  표시된 소수점 이하 자릿수에서 반올림            ROUNDDOWN(인수, 내림할 자릿수)  지정된 자릿수 아래의 수를 내림            ROUNDUP(인수, 올림할 자릿수)  지정된 자릿수 아래의 수를 올림            TRUNC(버림할 인수, 자릿수)  지정된 자릿수에서 버림하여 출력       표시 형식          INT(실수)  실수에서 소수점 이하 절삭 후 정수로 내림            ABS(숫자)  숫자의 절대값을 변환            SQRT(양수)  양수의 제곱근을 구함            CEILING(숫자, 기준배수)  특정 배수를 기준으로 올림된 수를 반환            FLOOR(숫자, 기준배수)  숫자의 배수 중 기준이 되는 배수와 가장 가까운 내림된 값을 반환            MROUND(숫자, 기준배수)  특정값에 가장 가까운 배수를 계산            EXP(숫자)  인수를 자연로그의 밑 e의 지수로 올린다            FACT(숫자)  인수의 팩토리얼을 표시            PI()  원주율 값            MOD(나누어질 인수, 나눌 인수)  나머지 출력            PRODUCT(인수 또는 셀 범위)  모든 셀을 곱한 값 출력            SUMPRODUCT(배열1, 배열2,…)  배열을 n차원 벡터로 취급하고 내적            POWER(인수, 승수)  인수의 지정한 승수만큼의 값 출력  예를 들어 = POWER(2, 3)면, 23  ** 1번 인수가 음수라면, 2번 인수가 정수가 아닐 경우 계산 불가            SUBTOTAL(함수, 참조1, [참조2], …)  필터링으로 가려진 데이터들을 제외하고 계산 작업을 할 수 있게 돕는 함수       날짜/시간 관련 함수          DATE(년, 월, 일)  특정 날짜 출력            TODAY()  현재 컴퓨터 시스템의 날짜 표시            NOW()  현재 컴퓨터의 날짜와 시간을 표시            YEAR(날짜) / MONTH(날짜) / DAY(날짜)  연도/월/일 값 출력            WEEKDAY(날짜, 유형)  해당하는 요일 번호 표시            TIME(시, 분, 초)  특정 시간 출력            HOUR(시간) / MINUTE(시간) / SECOND(시간)  시/분/초 값 출력       논리 관련 함수          IF(조건, 참값, 거짓값)  조건을 만족 시 참값, 불만족 시 거짓값으로 출력            IFERROR(검사수식, 반환값)  수식에서 오류가 발생할 경우 사용자가 지정한 값을 반환            AND(조건1, 조건2,…)  모든 논리가 전부 참일 경우 TRUE 를 출력하고, 하나라도 거짓이 있을 경우 FALSE 를 출력            OR(조건1, 조건2,…)  하나라도 참이 있을 경우 TRUE 를 출력하고, 전부 거짓일 경우 FALSE 를 출력            NOT(조건)  논리식의 결과 값을 반대로 출력       문자열 관련 함수          LEFT(문자열, 정수)  주어진 문자열 중 왼쪽으로부터 정수번째 있는 값 출력            RIGHT(문자열, 정수)  주어진 문자열 중 마지막부터 정수번째 있는 값 출력            MID(문자열 또는 문자열 참조 셀, n번째 글자, x개까지)  문자열의 가운데 부분을 추출해 표시한다. n번째 글자부터 x개만큼을 추출            LOWER(문자열)  입력된 문자열을 모두 소문자로 표시            UPPER(문자열)  입력된 문자열을 모두 대문자로 표시            PROPER(문자열)  문자열에서 첫단어만 대문자로 표시            TRIM(셀 또는 문자열)  해당 셀/문자열의 텍스트 양 끝에 있는 공백을 제외한 텍스트를 추출            LEN(문자열)  문자열의 길이 출력            FIND(찾으려는 문자, 문자열, 시작위치)  특정문자가 시작하는 위치를 숫자로 반환            SEARCH(찾을 문자, 검색할 문자열, [시작지점])  문자열에서 특정 문자의 시작위치 검색            REPLACE(문자열, 시작위치, 문자열 수, 대체할 문자열)  문자열의 시작위치에서부터 지정하는 수 만큼 문자열을 다른 문자열로 대체            SUBSTITUTE(문자열, 찾을문자, 새로운문자, [바꿀지점])  문자열에서 특정 문자를 찾아 다른 문자로 대체 한 셀 내에 대상 텍스트가 여러 개가 있는 상황에서는 바꿀지점을 활용할 수 있는데,       모두 바꾸려면 생략하고, 숫자를 입력하면 그만큼 왼쪽에서부터 대상 텍스트를 세어서 선택적으로 적용            CONCATENATE(문자열1, 문자열2, …)  여러 문자열을 하나로 조인            REPT(문자열, 반복 횟수)  문자열을 지정한 횟수만큼 반복            VALUE(문자열)  문자열을 숫자로 변환       검색 기능 함수          COLUMN(셀)  해당 셀의 가로열의 번호를 표시            ROW(셀)  해당 셀의 세로행의 번호를 표시하는 함수            CHOOSE(색인번호(1 이상 254이하의 정수형), 값1, [값2], …)  순번으로 구성된 색인을 참조하여 목록에서 해당 순번의 값을 반환            INDEX(배열, 행위치, 열위치)  배열 내의 몇 행 몇 열에 해당하는 대상을 찾아서 출력            OFFSET(시작지점, 행이동, 열이동, [높이], [넓이])  시작지점으로부터 지정한만큼 이동한 곳의 셀 참조 또는 값을 반환       VLOOKUP(찾을 값, 참조범위, 열번호, [옵션])  가로(수직)로 된 범위에서 값을 참조하여 다른 항목의 값을 반환            옵션  1 : 유사값이나 생략  0 : 정확한 값           HLOOKUP(찾을 값, 참조범위, 행번호, [옵션])  가로(수평)로 된 범위에서 값을 참조하여 다른 항목의 값을 반환            옵션  1 : 유사값이나 생략  0 : 정확한 값           XLOOKUP(찾을 값, 참조 범위, 출력 범위, [옵션], [검색옵션])  범위에서 일치하는 항목을 찾아 반환            옵션  0 : 정확히 일치하는 값만 반환하며 일치하는 값이 없을 경우 #N/A 반환  -1 : 일치하는 값이 없을 때 그보다 적으면서 가장 가까운 값 반환  1 : 일치하는 값이 없을 때 그보다 많으면서 가장 가까운 값 반환  2 : 와일드카드 옵션       검색옵션  1 : 오름차순  -1 : 내림차순  2 : 데이터가 정렬되었다고 가정한 오름차순  -2 : 데이터가 정렬되었다고 가정한 내림차순           MATCH(찾을값, 범위, [옵션])  배열 내에서 찾고자 하는 값이 몇 번째에 위치하는지 찾아서 숫자로 출력            옵션  0 : 정렬되지 않은 배열에서 정확히 일치하는 값을 검색. 여러 개가 검색되었을 경우 첫째 것을 출력  1 : 오름차순으로 정렬된 배열에서 작거나 같은 값 중 가장 큰 값  -1 : 내림차순으로 정렬된 배열에서 크거나 같은 값 중 가장 작은 값           XMATCH(찾을 값, 찾을 범위, [옵션], [검색옵션])  배열 또는 범위에서 특정 값의 상대 위치(순번)을 반환            옵션  0 : 정확히 일치하는 값만 반환하며 일치하는 값이 없을 경우 #N/A 반환  -1 : 일치하는 값이 없을 때 그보다 적으면서 가장 가까운 값 반환  1 : 일치하는 값이 없을 때 그보다 많으면서 가장 가까운 값 반환  2 : 와일드카드 옵션       검색옵션  1 : 오름차순  -1 : 내림차순  2 : 데이터가 정렬되었다고 가정한 오름차순  -2 : 데이터가 정렬되었다고 가정한 내림차순          ","categories": ["study"],
        "tags": ["Excel"],
        "url": "https://many258.github.io/study/excel-function/",
        "teaser": null
      },{
        "title": "[정보보안기사/정보보안일반] 접근 통제 기술",
        "excerpt":"접근통제  접근의 개요          주체  자원의 접근을 요구하는 활동 개체. (사람, 프로그램…)            객체  자원을 가진 수동적인 개체(DB, 컴퓨터, 파일…)            접근  주체와 객체의 정보 흐름       정보 접근의 단계          식별(Identification)  사용자 ID를 확인하는 과정            인증(Authentication)  패스워드가 정확한지 판별            인가(Authorization)  인증된 사용자에게 파일을 Read/Write/Execute 권한을 부여       접근 통제의 정의  주체의 대한 객체의 접근을 통제.  사용자가 파일인 객체에 대해 읽기/쓰기/실행의 권한이 있는지 확인하고 권한이 있으면 권한을 부여하고 권한이 없으면 접근을 차단하는 것이다.   접근 통제 원칙          최소 권한의 원칙  최소한의 권한만을 허용하여 권한의 남용을 방지            직무분리  업무의 발생/승인/변경/확인/배포 등이 한 사람에 의해 처리되지 않도록 직무를 분리       참조 모니터  주체의 객체에 대한 접근 통제를 결정을 중재하는 OS의 보안 커널로서, 일련의 SW   주체가 객체를 참조할 때 직접참조를 수행하지 않고 보안 커널을 통해서 참조.     보안 커널    주체에 대해서 정당한 권한을 확인하고 접근한 객체에 대한 정보를 모두 로그에 기록  결함으로 발생할 수 있는 취약점 차단   참조 모니터의 3가지 요소          완전성(Completeness)  우회가 가능하지 않아야 함.            격리(Isolation)  부정 조작이 불가능해야 함. (Tamper Proof)            검증성(Verifiability)  분석하고 테스트할 정도로 충분히 작아야 함       접근 통제 기술  MAC(Mandatory Access Control)  강제적 접근 통제  주체의 객체에 대한 접근이 주체의 비밀 취급 인가 레이블(Clearance Label) 및 객체의 민감도 레이블(Sensitivity Lable)에 따라 지정되는 방식   MAC 특징  데이터에 대한 접근을 시스템이 결정(정해진 룰에 의해)한다.  데이터 소유자가 아닌 오직 관리자만이 자원의 카테고리를 변경 가능  비밀성을 포함하고 있는 개체에 대해 주체가 가지고 있는 권한에 근거하여 객체의 접근을 제한하는 정책   구현/운영의 어려움. 높은 비용   MAC 종류     Rule-Based MAC  주체와 객체의 특성에 관계된 특정 규칙에 따른 접근 통제 방화벽   Administratively-directed MAC  객체에 접근할 수 있는 시스템 관리자에 의한 통제   CBP(Compartment-Based-Policy)  일련의 객체 집합을 다른 객체들과 분리.  동일 수준의 접근허가를 갖는 부서라도 다른 보안등급을 가질 수 있다.   MLP(Multi-Level Policy)  각 객체별로 지정된 허용 등급을 할당하여 운영(Top Secret, Secret, Confidentiality…)  미국 국방성 컴퓨터 보안 평가지표에 사용. BLP 수학적 모델로 표현 가능  *BLP : 높은 등급의 사용자는 낮은 등급의 정보에 접근이 불가능   DAC(Discretionary Access Control)  자율적 접근 통제  객체의 소유자가 권한 부여   DAC 특징  사용자의 신분에 따라 임의로 접근을 제어하는 방식(User-Based, Identity)  융통성이 좋아 UNIX, DBMS 등 상용 OS에서 구현 가능  접근 통제 목록(ACL : Access Control List) 사용    – 특정 객체에 접근할 수 있는 사용자 목록과 접근 권한을 명시 (객체 관점)   트로이목마 공격에 취약, ID 도용 문제   DAC 종류     Identity-Based DAC  주체와 객체의 ID에 따른 접근 통제. 주로 UNIX에서 사용   User-Based DAC  객체 소유자가 접근 권한을 설정 및 변경할 수 있는 방식   Non-DAC(Non-Discretionary Access Control)  비임의적 접근 통제  주체의 직무와 역할에 따라 접근할 수 있는 객체를 지정하는 방식   Non-DAC 특징  MAC과 DAC의 단점을 보완하기 위한 대안  기업 내 개인의 작은 이동 및 조직 특성에 밀접하게 적용하기 위한 통제 방식  Role-Based, Task-Based 이라고도 함.  Central Authority(중앙 인증) : 중앙 관리자에 의해 접근 규칙을 지정한다.  사용자별 접근 통제 규칙을 설정할 필요가 없다.   Non-DAC 종류     Role-Based Accesss Control(RBAC)  사용자가 적절한 역할에 할당되고 역할에 적합한 권한이 할당된 경우만 사용자가 특정한 모드로 정보에 대한 접근을 통제할 수 있는 방법   Latice-Based Non-DAC  역할에 할당된 민감도 레벨에 의해 결정. 관련된 정보로만 접근 가능  주체와 객체의 관계에 의거하여 접근을 통제할 수 있는 Upper Bound와 Lower Bound를 설정하여 제어.   Task-Based Non-DAC  조직 내 개인의 임무에 의한 접근 통제   RBAC(Role Base Access Control)  권한들의 묶음으로 Role을 만들어서 사용자에게 Role 단위로 권한을 할당하고 관리   RBAC의 특징  관리 수월 - 관리자에게 편리한 관리 능력을 제공, 비용 감소  보안관리 단순화 - 권한 지정을 논리적/독립적으로 할당하거나 회수 가능  최소 권한 - 최소한의 권한만을 허용하여 권한의 남용을 방지  직무분리 - 시스템상에서 오용을 일으킬 정도의 충분한 특권이 사용된 사용자 방지  데이터 추상화 - 역할에 대한 계층을 두어 상속 가능   접근 통제 방법  Capability List  주체별로 객체를 링크드리스트로 연결하고 권한을 할당한 구조   주체별로 모든 파일리스트가 존재하므로 권한을 알기 위한 탐색시간이 오래 걸리는 단점 존재.   Access Control List  주체와 객체간의 접근 권한을 테이블로 구성한 것  행에는 주체, 열에는 객체를 두고 행과 열의 교차점에는 주체가 객체에 대한 접근 권한(W/R/D/E)을 기술하여 이름 기반으로 제어하는 방식   접근 통제 매트릭스 종류          객체 기반 접근 제어(ACL:Access Control List)  객체 관점에서 접근 권한을 테이블 형태로 기술하여 접근 제어  구분될 필요가 있는 사용자가 비교적 소수와 분포도가 안정적일 때 적합  지속적 변경 환경에서는 부적합            내용 의존 접근 통제(Content Dependent Acceess Control)  데이터베이스에서 가장 많이 사용.  접근 제어가 내용에 의해 이루어지는 접근 통제  (데이터베이스에 사용자 정보를 등록하고 입력된 정보와 비교하여 접근 통제를 수행)            제한적 인터페이스(Restricted Interfaces)  특정 기능이나 자원에 대한 접근 권한이 없을 경우 아예 접근을 요청하지 못하도록 하는 방식       접근 통제 모델  Bell-Lapadula  기밀성 모델로서 높은 등급의 정보가 낮은 레벨로 유출되는 것을 통제하는 모델    정보 구분 : Top Secret / Secret / Unclassified    최초의 수학적 모델. 보안 등급과 범주를 이용한 강제적 정책에 의한 접근 통제 모델    미 국방성(DOD)의 지원을 받아 설계된 모델로서 오렌지북인 TCSEC의 근간이 됨.    시스템의 비밀성을 보호하기 위한 보안 정책           No-Read-Up(NRU or ss-Property) : 단순 보안 규칙  주체는 자신보다 높은 등급의 객체를 읽을 수 없다.  주체의 취급인가가 객체의 비밀 등급보다 같거나 높아야 그 객체를 읽기 가능            No-Write-Down(NWD or *-Property) : 스타-보안 규칙  주체는 자신보다 낮은 등급의 객체에 정보를 쓸 수 없다.  주체의 취급인가가 객체의 비밀 등급보다 같거나 낮을 때 그 객체를 주체가 기록 가능            Strong *-Property  더욱 강화된 모델. 주체는 자신과 등급이 다른 객체에 대해 읽기나 쓰기 불가       Biba 모델  Bell-Lapadula 모델의 단점인 무결성을 보장할 수 있는 모델  주체의 의한 객체 접근의 항목으로 무결성을 다룬다.     No Read-Down(NRD or Simple Intergrity Axiom)   No Write-Up(NWU or *Intergrity Axiom)   클락 윌슨 모델 (Clark and Wilson)  무결성 중심의 상업용으로 설계. App의 보안 요구사항을 다룬다.  정보의 특성에 따라 비밀 노출 방지보다 자료의 변조 방지가 더 중요한 경우가 있음을 기초로 한다.  주체와 객체 사이에 프로그램이 존재, 객체는 항상 프로그램을 통해서만 접근이 가능  2가지 무결성을 정의 : 내부 일관성(시스템 이용), 외부 일관성(감사에 활용)   만리장성 모델(Chinese Wall = Brewer-Nash)  서로 상충 관계에 있는 객체 간의 정보 접근을 통제하는 모델(이익 상충 금지)  상업적으로 기밀성 정책에 따른다.   보안 운영체제  보안 취약성으로부터 시스템 자체를 보호하기 위해 기존 운영체제의 커널 등급에 추가적인 보안 기능을 강화시킨 OS   Secure DBMS 구조          신뢰 필터 구조  신뢰할 수 없는 전위 사용자 인터페이스와 후위 DB 사이에 신뢰 필터를 사용하여 데이터에 대한 접근 통제 및 보안 서비스 제공  신뢰 필터는 하부의 보안 운영체제가 제공하는 보안 서비스 및 메커니즘에 의존       장점 : 다른 구조에 비해 간단. 크기가 작음 ==&gt; 보안 기능의 검증 및 평가가 용이  단점 : 데이터의 보안을 침해하는 일부의 위협에 대해서는 취약성을 가짐            커널 구조  TCB 분할 개념에 의해서 구현. 따라서 DB시스템은 보안 커널 외부에 존재하면서 임의적 보안만을 관리  DB 객체에 대한 임의적 접근 통제 - DBMS에 의해 수행  DB 파일에 대한 임의적 접근 통제 및 모든 강제적 접근 통제 - 하부의 보안 운영체제에 의하여 제공            이중 커널 구조  강제적 보안 기능을 갖는 DB 시스템을 구현하고,  이를 보안 운영체제와 함께 시스템의 TCB(Trust Computing Base)로 간주하여 보안시스템을 평가            중복 구조  낮은 보호 수준의 데이터를 DB에 중복하여 저장하는 방식.            *은닉 채널(Convert Channel)  기본 통신채널에 기생하는 통신채널로서, 스테가노그래피로 숨겨진 메시지를 송신자와 수신자만 확인 가능.  보안 메커니즘에 의해 통제되지 않는 정보 흐름으로 시스템의 보안 정책을 위반하는 행위  은닉 채널의 위험은 대역폭에 따라 변경되기 때문에 한 번에 전달되는 정보량을 줄이기 위해 대역폭 제한 필요       키 분배 프로토콜  대칭키 암호화(Symmetric Key)  Session Key, Shared Key, Secret Key, Conventional Key(관용키)라고도 한다.  암호화할 때 사용하는 암호화 키와 복호화할 때 사용하는 복호화 키가 동일한 암호화 기법(양방향 암호화 기법)  작은 비트의 암호호 키를 사용하여 빠르게 암호화/복호화가 가능하다. (대용량 Data 암호화에 적합)  기밀성을 제공하나 무결성, 인증, 부인방지는 보장할 수 없다  같은 키를 사용하므로 안전한 키 전달 및 공유 방법이 필요   대칭키 암호화의 종류          스트림 암호(Stream Cipher)  하나의 비트/바이트 단위로 암호화  평문을 XOR로 1Bit 단위로 암호화  실시간 암호/복호화, 블록 암호화보다 빠르다.  종류 : RC4, SEAL, OTP            블록 암호(Block Cipher)  여러 개의 Bit를 묶어 블록 단위로 치환/대칭을 반복하여 암호화  대용량의 평문 암호화  종류 : DES, 3DES, AES, IDEA, Blowfish, SEED       공개키 암호화(Public Key)  공개키와 개인키라는 두개의 암호화 키를 사용하여 암호화/복호화  클라이언트 - 공개키를 수신 받은 후 공개키로 암호화하여 메시지 전송  수신자 - 개인키로 복호화   대칭키 암호화 기법의 키 공유 문제를 해결한 방법이나, 암호화 키의 길이가 길어 암호화/복호화 성능 비효율  공개키/개인키를 사용하여 인증, 서명, 암호화를 수행   공개키 암호화 방식          암호모드  소량의 메시지 암호화 목적, 주로 키교환의 용도로 사용            인증모드  메시지를 인증(부인방지)하는 것이 목적          공개키 암호화 종류          Diffie Hellman - 이산대수  최초의 공개키, 키 분배 전용 알고리즘  필요 시에만 생성(저장 불필요)  암호 모드로 사용 불가, 위조에 취약            RSA - 소인수분해  대표적 공개키 알고리즘  컴퓨터 속도의 발전으로 키 길이 증가            DSA - 이산대수  간단한 구조를 가진 전자서명 전용 알고리즘 표준  암호화, 키 교환 불가            ECC - 타원곡선  짧은 키로 높은 암호 강도. 160키 = RSA1024  오버헤드가 적으며 키 테이블(20KB) 필요  PDA, 스마트폰       ","categories": ["study"],
        "tags": ["정보보안기사"],
        "url": "https://many258.github.io/study/access-control/",
        "teaser": null
      },{
        "title": "[데이터베이스/DB] 트랜잭션(Transaction)과 병행제어 및 회복",
        "excerpt":"트랜잭션  데이터베이스의 상태를 하나의 상태에서 또 다른 일관된 상태로 변화시켜주는 일련의 논리적인 연산 집합  한번에 모두 소행되어야하는 연산들의 집합, 하나의 작업을 처리하기위한 작업 단위  하나의 트랜잭션은 완료(Commit)되거나 복귀(Rollback)되어야 한다   트랜잭션의 성질          Atomicity(원자성)  트랜잭션이라는 것은 연산의 집단을 의미하지만, 논리적으로는 하나의 의미 연산들은 모두 수행되거나 모두 수행되지 않아야한다(= 일부의 완료는 존재하지 않는다)            Consistency(일관성)  고정 요소는 트랜잭션 실행 전과 후가 같아야 한다는 성질 트랜잭션이 실행되고 나서도 데이터베이스의 상태는 무결성이 유지되고 모순되지 말아야 된다는 성질            Isolation(독립성,격리성)  트랜잭션이 실행되는 중간에는 다른 트랜잭션 연산이 침범하지 못하는 성질 같은 자원에 대해 여러 개의 트랜잭션이 동시에 사용할 수 없다는 성질            Durability(영속성,지속성)  트랜잭션에 의해서 변화된 상태는 계속해서 유지될 수 있어야 한다는 성질       트랜잭션의 상태          활동(Active)  트랜잭션이 실행 중인 상태            부분 완료(Partially Committed)  트랜잭션이 마지막 연산을 끝내고 데이터베이스에 실행 결과를 적용하기 직전의 상태            완료(Committed)  트랜잭션이 연산을 완료하고 연산의 결과를 데이터베이스에 적용한 상태            실패(Failed)  트랜잭션이 실행 중 어떤 오류에 의해서 더 이상 진행될 수 없는 상태            철회(Aborted)  트랜잭션 실행이 실패하여 복귀된 상태       병행제어  다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행수행할 때,  동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것을 의미.   목적     데이터베이스의 공유를 최대화   시스템의 활용도 최대화   데이터베이스의 일관성 유지   사용자에 대한 응답시간 최소화   제약없는 병행 처리(Concurrency Processing) 시 문제점  병행제어 기법에 의한 제어 없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용할 경우 다음과 같은 문제점이 발생           분실된 갱신(Lost Update)  두 개의 트랜잭션이 같은 데이터에 대해서 동시에 갱신 작업을 하면 하나의 갱신 작업이 분실되는 경우            모순성(Inconsistency, 불일치)  한 개의 트랜잭션 작업이 갱신 작업을 하고 있는 상태에서 또 하나의 트랜잭션이 같은 작업 구역에 침범하여 작업하게 되면, 트랜잭션이 모두 끝나게 되더라도 그 데이터에 대한 결과는 사용자가 원하는 결과와 일치하지 않는 상태가 되어 데이터베이스의 일관성을 해치는 경우            연쇄 복귀(CasCading Rollback)  다른 트랜잭션이 처리하는 과정에서 실패하게 되면 두 개의 트랜잭션 모두 복귀되는 현상            비완료 의존성(Uncommitted Dependency)  한 개의 트랜잭션이 수행과정에서 실패하였을 때, 이 트랜잭션이 회복되기 전에 다른 트랜잭션이 이 트랜잭션의 수행 결과를 참조하는 현상       병행제어 기법의 종류  로킹  자원 이용에 대하여 상호배제 기능을 이용하는 기법   직렬성을 보장하기 위해 하나의 트랜잭션이 어떤 데이터에 대해서 액세스하는 동안 또 다른 트랜잭션이 이 데이터에 대해 액세스하기 위해서는 로크를 소유하고 있어야만 가능하도록 하는 방법.  언제 로크를 소유하고 해제하는가 하는 로킹 규칙을 정해놓고 해결.      로킹 기법                     공유 잠금(Shared Lock)  잠금 걸린 데이터에 대해 읽기 가능, 쓰기 불가능                        베타 잠금(Exclusive Lock)  잠금 걸린 데이터에 대해 읽기, 쓰기 불가능                   로킹단위(Locking Granularity)  병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기  주요 단위로는 DB, DBSPACE, 테이블, 페이지 등                     로킹 단위가 작다  데이터의 공유도와 병행성이 증가하나 로크의 수가 많아 병행 제어 기법이 복잡하고 관리가 어렵다.                        로킹 단위가 크다  데이터의 공유도와 병행성 이 감소하고 로크의 수가 적어 병행 제어 기법이 간단하고 관리가 쉽다.                   2단계 로킹 규약(Two-Phase Locking Protocol)  트랜잭션 스케쥴의 직렬성을 보장하는 대표적인 기법            요청단계(Growing Phase) = 확장 단계  로크를 얻는 과정에서는 어떠한 로크도 반납될 수 없다는 것을 나타내는 단계(잠금만 수행)       반납단계(Shrinking Phase) = 축소 단계  트랜잭션이 완료되는 시점에서 데이터에 대한 로크를 반납하는 과정에서는 어떠한 로크도 획득할 수 없는 단계(해제만 수행)           타임스탬프  시스템에 진입하는 트랜잭션 순서대로 타임스탬프를 지정하여 동시성을 제어하는 기법   검증 기법  = 최적 병행수행, 확인 기법, 낙관적 기법   읽기 단계, 검증 단계, 기록 단계를 이용하여 직렬성을 보장하는 기법   다중버전 기법  = 다중 버전 타임 스탬프 기법   갱신 연산 때마다 새로운 버전을 만들어 병렬수행을 제어하는 기법   회복(Recovery)  어떤 외부적인 장애 요인이나 내부적인 장애 요인에 의해서 데이터베이스의 상태가 일관성 유지에 제약이 걸렸을 때, 장애 이전의 일관된 상태가 되도록 복원하는 일   장애(Failure)의 유형     실행 장애   트랜잭션 장애   시스템 장애  H/W 시스템 자체에서 발생할 수 잇는 장애   미디어 장애  디스크 자체의 손상으로 발생할 수 있는 장애   UNDO  변경된 데이터를 취소하여 원래의 내용으로 복원시키는 연산   주로 트랜잭션이 실행 중인 상태에서 실행이 실패하였을 경우 원래의 내용으로 복원하는 경우에 사용   REDO  이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 것을 의미   주로 데이터베이스의 내용이 손상되었을 때, Backup 본으로 회복한 다음 Backup 본에 있는 데이터 이후는 로그에 갱신되어 있는 데이터를 데이터베이스에 적용하는데 사용   회복 기법     로그 기반 회복 기법                     즉시 갱신  트랜잭션이 수행중인 상태에서도 그 결과를 즉시 데이터베이스에 반영  커밋 발생 이전의 갱신은 원자성이 보장되지 않는 미완료 갱신이므로 장애 발생 시 UNDO 연산 필요                        지연 회복 기법  트랜잭션의 갱신 결과를 로그에 기록하여 두었다가 트랜잭션의 연산이 완료되면 한번에 데이터베이스에 반영 처리 도중 장애가 생기더라도 데이터베이스에 반영되지 않았으므로 UNDO 연산이 불필요 (REDO 연산 수행)                        검사점(CheckPoint) 회복 기법  장애 발생 시 검사점 이전에 처리된 트랜잭션은 회복에서 제외하고 검사점 이후에 처리된 트랜잭션은 회복작업을 수행  장애 발생 시점 이전에 Commit이 완료된 경우 - UNDO 수행  장애 발생 시점 이전에 Commit을 못한 경우 - REDO 수행            그림자페이징 기법  로그를 이용하지 않으며 트랜잭션이 실행되는 메모리상의 현 페이지 테이블(Current Page Table)과 하드디스크의 그림자페이지 테이블(Shadow Page Table) 사용       트랜잭션 시작지점에서 현 페이지 테이블과 동일한 그림자페이지 테이블 사용  트랜잭션이 성공으로 완료될 경우, 그림자페이지 테이블 삭제  트랜잭션이 실패할 경우, 그림자페이지 테이블을 현 페이지 테이블로 교체            미디어 회복 기법  디스크와 같은 비휘발성 저장 장치가 손상되는 장애 발생을 대비한 회복 기법       데이터베이스의 내용을 백업/미러링/RAID 등을 통해 별도의 물리적 저장장치에 덤프  미디어 장애 시 가장 최근 덤프로 복구하고 로그 파일을 참조해 덤프 이후의 작업을 REDO 수행 (UNDO는 수행하지 않음)       ARIES 회복 기법            REDO 중 역사 반복(Repeating history)  붕괴가 발생했을 때의 데이터베이스 상태를 복구하기 위하여 붕괴 발생 이전에 수행했던 모든 연산을 다시 한번 수행.  붕괴가 발생했을 때 완료되지 않은 상태였던 (진행 트랜잭션)은 UNDO 된다.                UNDO 중 로깅(Logging)  UNDO를 할 때에도 로깅을 함으로써 회복을 수행하는 도중에 실패하여 회복을 다시 시작할 때에 이미 완료된 UNDO 연산은 반복하지 않는다.               주요 3단계                    분석(Analysis)단계: 붕괴가 발생한 시점에 버퍼에 있는 수정된 페이지와 진행 트랜잭션을 파악, REDO가 시작되어야 하는 로그의 위치를 결정           REDO 단계: 분석 단계에서 결정한 REDO 시작 위치의 로그로부터 로그가 끝날 때 까지 REDO를 수행, REDO 된 로그 레코드의 리스트를 관리하여 불필요한 REDO 연산이 수행되지 않도록 한다.           UNDO 단계: 로그를 역순으로 읽으면서 미완료된 트랜잭션의 연산을 UNDO 한다.                       구성 요소                    WAL(Write Ahead Logging)  DB 변경 사항에 대한 전체 로깅           LSN(Log Sequence Number)  모든 로그에 대한 고유 순서 번호           Repeating History  장애 시 이전의 데이터베이스 수행 기록을 모두 추적하여 REDO           Logging Changes  UNDO 완료된 트랙잭션을 기록하여 UNDO 반복 수행 회피                          ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-transaction/",
        "teaser": null
      },{
        "title": "[운영체제/OS] RAID",
        "excerpt":"RAID  Redundant Array of Independent/Inexpensive Disks : 복수 배열 독립 디스크  여러 대의 물리적 디스크를 하나의 논리적 디스크로 인식시키는 기술  여러 개의 하드 디스크에 일부 중복된 데이터를 나눠서 저장하는 기술 = 디스크 어레이   데이터를 나누는 다양한 방법이 존재하며, 이 방법들을 레벨이라 하는데, 레벨에 따라 저장장치의 신뢰성을 높이거나 전체적인 성능을 향상시키는 등의 다양한 목적을 만족시킬 수 있다.   RAID의 사용 목적     무정지 구현(가용성)   성능 향상   주의) 데이터의 무결성, 안전, 백업에 대한 목적은 아니다.   RAID 0  스트라이핑 Striping   일련의 데이터를 하나의 논리적 디스크 배열에 일정한 크기로 나누어서 분산 저장하는 기법  사용자와 시스템 데이터는 하나의 논리 디스크상에 저장되어 있는 것으로 인식하며 디스크는 스트립(Strip)이라는 일정한 크기의 섹터 또는 물리적 블록 단위로 나누어 연속적인 배열 구성요소와 대응되도록 순환할당된다.  이와 같이 하나의 스트립들과 각 배열의 구성요소가 대응하는 논리적으로 연속적인 스트립의 집합을 스트라이프라고 한다.   RAID 0 방식은 데이터를 입출력할 때, RAID 컨트롤러에서 여러 개의 하드 디스크로 나눠서 쓰고 읽어 들이므로 중요하지 않은 데이터에 대한 빠른 데이터 입출력 성능이 요구되는 동영상 편집 등에 적합   데이터를 중복해서 기록하지 않으므로 장애발생에 대비한 여분의 저장 공간을 가지고 있지 않다. 즉, 어느 한 드라이브에서 장애가 발생하면 데이터는 손실      RAID 1  미러링 Mirroring + 스트라이핑 Striping   RAID 0 과 같이 데이터 스트라이핑을 사용하면서 배열 내의 모든 디스크가 동일한 데이터를 가지는 미러 디스크를 가진다. 각 논리적 스트립은 두 개의 별도 디스크에 대응되므로 미러링이라고도 하는데, 중복 저장된 데이터를 가진 적어도 두 개의 드라이브로 구성   멤버 디스크 중 하나만 살아남으면 데이터는 보존되며 복원도 1:1복사로 매우 간단하기 때문에 서버에서 끊김없이 지속적으로 서비스를 제공하기 위해 사용   읽기 요구는 요구 데이터를 가지고 있는 두 개의 디스크 중 어떤 디스크에서도 서비스를 받을 수 있기 때문에 성능이 향상될 수 있으나, 데이터를 분할 저장하지 않기 때문에 두 스트립이 모두 갱신되어야 하며 쓰기 요구는 단일 디스크 드라이브의 경우와 같다.      RAID 2  스트라이핑 + 허밍 코드 Hamming Code   디스크들 간에 데이터 스트라이핑을 사용하며 오류 검출 능력이 없는 드라이브를 위해 허밍 코드 기법을 사용한다.(안전성 확보)  몇몇 디스크들은 오류를 감지하고 수정하는 데 사용되는 오류정정코드(ECC, Error Correcting Code)정보를 저장   허밍 오류정정코드는 패리티 비트를 사용해 디스크로부터 전송된 데이터에 오류가 있는지 검사 및 정정   실시간 오류수정이 가능하다는 장점이 있지만, 현재의 SCSI 드라이브들이 자체 오류 검출 능력을 갖고 있기 때문에 실제 잘 쓰이지 않음.      RAID 3  RAID 0과 같이 스트라이브를 사용하며, 오류 검출과 수정을 위해 별도의 드라이브 한 개를 패리티 드라이브로 사용  각각의 데이터 디스크에 데이터를 비트 단위로 스트라이핑하여 기록   대형 레코드가 많이 사용되는 단일 사용자 시스템과 다량의 데이터 전송이 요구되는 작업에 적합      RAID 4  데이터 분산 저장을 위해 스트라이핑과 패리티 드라이브를 사용한다는 점에서 RAID 3과 유사하지만, 각 드라이브에 데이터를 블록 단위로 분산 저장한다는 점에서 다름   쓰기 요청이 있을 때마다 사용자 데이터와 함께 패리티 정보를 갱신해야 하기 때문에 추가시간이 소요되므로 크기가 작은 입출력이 요청될 때 쓰기 성능 저하(입출력의 병목현상 유발)  데이터 읽기 요청은 RAID 0과 비슷한 성능을 가짐   여러 드라이브 중에서 한 대의 드라이브만이 여분의 패리티 정보를 기록하는데 사용되기 때문에 용량당 비용은 높지않아 저렴한 가격으로 장애 복구 능력이 요구되거나 빠른 판독속도가 필요한 경우에 사용      RAID 5  RAID 4 구성과 유사하며 별도의 패리티 드라이브 대신 모든 드라이브에 패리티 정보를 나누어 저장. (디스크 병목현상 해결)   다중 프로세스 시스템에서와 같이 작고 잦은 데이터 기록이 있을 경우 더 빠르지만, 읽기 요청의 경우 각 드라이브에서 패리티 정보를 건너뛰어야 하기 때문에 RAID 4보다 속도가 느리다.   최소한 3대, 일반적으로 5대 이상의 드라이브가 필요. N개의 디스크를 사용하면 (N-1)배의 저장 공간을 사용 가능하다.   데이터는 각 데이터 영역에 블록 단위로 스트라이핑하여 저장된다.  병렬 입출력이 가능하기 때문에 기록과 읽기가 동시에 가능하며 데이터 입출력 선능이 아주 빠르면서도 안전성 또한 높은 편으로 파일 서버 등의 입출력이 빈번한 업무에 적합하다.      RAID 6  RAID 5와 원리는 같으며, 서로 다른 방식의 패리티 2개를 동시에 사용한다.  성능과 용량을 희생해서 가용성을 높인 셈.   N개의 디스크를 사용하면 (N-2)배의 저장 공간을 사용할 수 있다.      Nested RAID  레이드 볼륨의 멤버로 다른 레이드 볼륨을 사용하는 형태.  멤버 디스크를 묶는 배열을 하위 배열, 하위 배열을 묶는 배열을 상위 배열이라고 한다. 표기 방법은 m(하위 배열)n(상위 배열)이며 m=0이면 뒤에 +를 붙인다.   RAID 0+1  RAID 0으로 스트라이핑 된 볼륨을 RAID 1로 미러링. (적어도 4개의 디스크 필요)  ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-raid/",
        "teaser": null
      },{
        "title": "[네트워크] 네트워크 개요 및 일반",
        "excerpt":"네트워크  송신자의 메시지를 수신자에게 전달하는 과정으로 한 지점에서 원하는 다른 지점까지 의미 있는 정보를 보다 정확하고 빠르게 상대방이 이해할 수 있도록 전송하는 것을 의미   프로토콜  송신자와 수신자가 통신이라는 것을 하려면 서로 메시지의 포맷, 언제 데이터를 보낼 것인지, 한 번 전송하고 한 번 응답받는 형태로 할 것인지에 관한 것을 서로 약속해야 한다. 이 때, 이러한 약속이 프로토콜을 의미한다.   네트워크의 분류  거리에 따른 네트워크 유형          PAN(Personal Area Network)  3M 이내의 인접 지역 간의 통신 방법  짧은 거리로 인하여 유선보다는 무선의 WPAN이 많이 활용            LAN(Local Area Network)  근거리 영역의 네트워크로 동일한 지역 내 고속의 전용 회선으로 연결하여 구성하는 통신망  Client/Server와 peer-to-peer 모델            WAN(Wide Area Network)  광대역 네트워크망으로 서로 관련이 있는 LAN 간의 상호 연결망  LAN에 비해 선로 에러율이 높고, 전송 지연이 크다  두 목적지 사이를 최단경로로 연결시켜 주는 라우팅 알고리즘 필요            MAN(Metropolitan Area Network)  LAN과 WAN의 중간 형태의 네트워크로 데이터, 음성, 영상 등을 지원하기 위해 개발  DQDB(Distributed Queue Dual Bus)       데이터 전송 방식     단방향(Simplex)   반이중(Half Duplex)   전이중(Full Duplex)   회선교환(Circuit Switching)  교환기를 통해 통신 회선을 설정하여 직접 데이터를 교환하는 방식     특징            전송 전에 회선이 전용선으로 설정 : 동일한 경로(독점)       데이터 전송이 없더라도 회선 해제 요청이 없으면 계속 접속 유지       전송 시작 후 오버헤드가 없음       Point-to-Point 전송 구조       전송된 데이터의 에러 제어나 흐름 제어는 사용자에 의해 수행되어야 한다           장점            대용량의 데이터를 고속으로 전송할 때 좋으며, 고정적인 대역폭 사용       접속에는 긴 시간이 소요되나 그 후 접속이 항상 유지되어 전송 지연이 없고, 데이터 전송률이 일정       아날로그나 디지털 데이터로 직접 전달       연속적인 전송에 적합(실시간)           단점            회선 이용률 면에서 비효율적       연결된 두 장치는 반드시 같은 전송률과 같은 기종 사이에서만 송수신이 가능       속도나 코드의 변환이 불가능 : 교환망 내에서의 에러 제어 기능이 어려움       실시간 전송보다 에러없는 데이터 전송이 요구되는 구조에서는 부적합       통신 비용 고가           패킷교환(Packet Switching)  송신측에서 메시지를 일정한 크기의 패킷으로 분해/전송, 수신측에서 원래의 데이터로 조립     특징            패킷 다중화, 논리 채널, 경로 선택 제어, 순서 제어, 트래픽 제어, 오류 제어       수신된 패킷의 저장기능(대기 큐)       순서 제어 기능 : 목적지에서 수신된 패킷의 순서를 재정렬       트래픽 제어 : 흐름 제어, 혼잡 제어, 교착상태       경로 배정 요소 : 성능 기준, 결정 시간, 결정 장소, 네트워크 정보           장점            회선 이용률이 높고, 속도 변환, 프로토콜 변환 가능, 음성 통화       고신뢰성 : 상황에 따라 교환기 및 회선 등의 장애가 발생하더라도 패킷의 우회전송이 가능하므로 전송의 신뢰성 보장       고품질 : 디지털 전송이므로, 인접 간에 또는 단말기와 교환기 간에 전송, 오류 검사를 실시하여 오류 발생 시 재전송 가능       고효율 : 다중화를 사용하므로 전송로 사용 및 효율이 좋다       이 기종 단말장치 간 통신 : 전송 속도, 전송 제어 절차가 다르더라도 교환망이 변환 처리를 제공하므로 통신 가능           단점            각 교환기의 경로에서 다소 지연이 발생       이러한 지연은 가변적임. 전송량이 증가함에 따라 지연이 더욱 심할 수 있음       패킷별 헤더 추가로 인한 오버헤드 발생 가능성           패킷교환 방식의 종류     가상회선(Virtual Circuit)            패킷을 전송하기 전에 논리적인 연결을 먼저 수행 : 연결형 서비스       호출 요구를 하고 호출 수신 패킷을 주고받아서 연결하는 방식(X.21)       회선교환처럼 사용하지만 교환기에 패킷이 일시적으로 저장되며 일정한 전송률 보장 불가       비교적 긴 메시지의 전송 시 더 효과적           데이터그램(Datagram)            각 전송 패킷을 미리 정해진 경로 없이 독립적으로 처리하여 교환하는 방식       같은 목적지의 패킷도 같은 경로를 거치지 않고 서로 다른 경로를 통해서 목적지에 도달       망의 한 부분이 혼잡할 때 패킷에 다른 경로를 지정하여 배정 가능, 융통성 있는 경로를 설정       특정 교환기의 고장 시 모든 패킷을 잃어버리는 가상회선 방식과는 달리, 그 경로를 피해서 전송할 수 있음 : 신뢰성 보장       짧은 메시지의 패킷들을 전송할 때 효과적, 재정렬 기능 필요           네트워크 토폴로지(Network Topology)  컴퓨터 네트워크의 요소들(링크, 노드)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식         계층형(트리형)            Tree 구조, 최상위에 있는 노드가 네트워크 제어       통제 및 유지 보수 용이       단말기의 추가나 제거 및 에러 발생 시 발견이 쉬움       병목 현상 발생 가능, 중앙 노드 장애 발생 시 전체 통신망 마비           수평형(버스형)            중앙 통신 회선 하나에 여러 대의 노드를 연결하는 방식       근거리 통신망에서 볼 수 있는 일반적인 형태       하나의 컴퓨터가 다운되어도 나머지 컴퓨터에는 지장이 없음       DTE 추가 삭제가 용이       우선순위 제어가 어려움       통신 회선의 길이에 제한, 충돌이 자주 발생           성형(스타형)            중앙에 있는 컴퓨터를 중심으로 터미널이 연결된 중앙 집중식 형태       유지보수 및 관리가 용이, 단말기 고장 시 발견이 용이       중앙 컴퓨터 고장 시 전체 네트워크 마비       통신망 제어가 복잡           원형(링형)            인접해 있는 노드들을 연결하는 단방향 전송 형태       매채 엑세스 방식       토큰 링 이용, 동축/광섬유 케이블 이용       전송 매체와 DTE 고장 시 발견이 용이       단말기 추가 및 삭제가 어려움       전송 지연 발생 시 DTE 간의 순차적 전송때문에 중계기 기능이 필요           망형(메쉬형)            모든 노드들이 상호 연결       통신 회선 장애 시 다른 경로로 데이터 전송이 가능       DTE 고장과 병목 현상에 대해 면역성이 있음       가장 많은 통신 선로가 필요           OSI 7계층  Open System Interconnection 7-layer  개방형 시스템 네트워크의 효율적인 이용을 위하여 모든 데이터 통신 기준으로 계층을 분할하고, 각 계층 간의 필요한 프로토콜을 규정한다.   정보가 전달되는 Framework를 제공하며, 네트워크 형태에 차이가 발생해도 데이터 통신을 지원   OSI 7계층 구조                  OSI 7계층       주요 내용       주요 프로토콜(매체)                 7. Application       사용자 소프트웨어를 네트워크에 접근 가능하도록 함. 사용자에게 최종 서비스를 제공       FTP, SNMP, HTTP, Mail, Telnet 등                 6. Presentation       포맷 기능, 압축, 암호화 텍스트 및 그래픽 정보를 컴퓨터가 이해할 수 있는 16진수 데이터로 변환       압축, 암호, 코드 변환  GIF, ASCII, EBCDIC                 5. Session       세션 연결 및 동기화 수행, 통신 방식 결정 가상 연결을 제공하여 Login/Logout 수행       반이중, 전이중, 완전이중 결정                 4. Transport       가상연결, 에러 제어, 데이터 흐름 제어, Segment 단위 두 개의 종단 간 End-To-End 데이터 흐름이 가능하도록 논리적 주소 연결 신뢰도, 품질보증, 오류탐지 및 교정 기능 제공  다중화(Multiplexing) 발생       TCP, UDP                 3. Network       경로선택, 라우팅 수행, 논리적 주소 연결(IP) 데이터 흐름 조절, 주소 지정 메커니즘 구현  네트워크에서 노드에 전송되는 패킷 흐름을 통제하고, 상태메시지가 네트워크상에서 어떻게 노드로 전송되는 가를 정의, Datagram(Packet) 단위                         2. Data Link       물리주소 결정, 에러 제어, 흐름 제어, 데이터 전송 Frame 단위, 전송 오류를 처리하는 최초의 계층       흐름제어, 오류제어(ARQ)  브리지, PPTP, L2TP, HDLC  Frame Relay                 1. Physical       전기적, 기계적 연결 정의, 실제 Data Bit 전송 Bit 단위, 전기적 신호, 전압구성, 케이블, 인터페이스 등을 구성 Data Rates, Line noise Control, 동기화 기능 수행       매체: 동축케이블, 광섬유, Twisted Pair Cable              End-to-End : 7 ~ 4계층, 송수신자 간의 에러 제어   Point-to-Point : 4 ~ 1계층, 각 구간에 대해 에러 제어   OSI 계층별 하드웨어 장비     Physical                     Cable  Twisted Pair Cable, Coaxial, Fiber-Optic Cable                        Repeater  네트워크 구간 케이블의 전기적 신호를 재생하고 증폭하는 장치 디지털 신호를 제공, 아날로그 신호 증폭 시 잡음과 왜곡까지 증폭                   Data Link                     Bridge  서로 다른 LAN Segment를 연결, 관리자에게 MAC 주소 기반 필터링 제공하여 더 나은 대역폭 사용과 트래픽을 통제 리피터와 같이 데이터 신호를 증폭하지만 MAC 기반에서 동작                        Switch  목적지의 MAC 주소를 알고 있는 지정된 포트로 데이터를 전송 Repeater와 Bridge의 기능을 결합 네트워크의 속도 및 효율적 운영, Data Link 계층에서도 작동                   Network            Router  패킷을 받아 경로를 설정하고 패킷을 전달 Bridge는 MAC 주소를 참조하지만, Router는 네트워크 주소를 참조하여 경로를 설정 패킷 헤더 정보에서 IP 주소를 확인하여 목적지 네트워크로만 전달하며 Broadcasting을 차단           Application            Gateway  서로 다른 네트워크망과의 연결(PSTN, Internet, Wireless Network 등) 패킷 헤더의 주소 및 포트 외 거의 모든 정보를 참조           데이터 전송 방식  직렬 전송(Serial Transmission)  한 문자의 각 비트 열을 하나의 전송 선로를 통해 순차적으로 전송하는 방식(모뎀)      시프트 레지스터를 이용하여 병렬을 직렬화한 후 송신   동기 전송 방식의 요구   전송 에러가 적고, 장거리에 적합   통신 회선 설치 비용이 저렴   전송 속도가 느림   병렬 전송(Parallel Transmission)  한 문자를 이루는 각 비트가 각각의 전송로를 통해 한꺼번에 전송되는 방식(프린터) 블록 버퍼를 이용      송수신 문자 간격을 식별하는 스트로브 신호와 BUSY 신호로 다음 문자의 송신 시기 결정   단위 시간에 다량의 데이터를 빠른 속도로 전송   전송 길이가 길어지면 에러 발생 가능성 농후   통신 회선 설치 비용이 커짐   동기 방식(Synchronous Method)  전송할 데이터를 여러 블록으로 나누어 블록 단위로 전송하는 방식 제어 정보를 데이터의 앞뒤에 붙여 프레임을 구성      전송 단위 : 프레임, 문자 중심 / 비트 중심   에러 검출 : CRC   오버헤드 : 프레임당 고정된 크기   전송 속도 : 고속   전송 효율 : 높다(휴지 간격 없음, 채널 할당 시간 공백 없음)   장점            원거리 전송에 이용           단점            에러 발생 확률이 높다       고가(별도의 하드웨어 장치가 필요)           비동기 방식(Asynchronous Method)  한 번에 한 문자씩 전송하는 방식(한 문자 전송 시마다 동기화하는 방식)  start-stop 비트를 사용, 패리티 비트, 정지 비트 ‘1’ 시작비트 ‘0’      전송 단위 : 문자 단위의 비트 블록   에러 검출 : 패리티 비트   오버헤드 : 문자당 고정된 크기   전송 속도 : 저속   전송 효율 : 낮음   장점            동기화가 단순하며 저렴           단점            문자당 2~3비트의 오버헤드가 발생       프레임 에러가 발생할 가능성이 있음          ","categories": ["study"],
        "tags": ["데이터통신","네트워크"],
        "url": "https://many258.github.io/study/network-base/",
        "teaser": null
      },{
        "title": "[웹프로그래밍] Ajax",
        "excerpt":"   보통 우리가 생각하는 웹프로그래밍은 클릭과 같은 이벤트를 통해 웹 서버에 요청하고 요청에 대한 응답을 클라이언트에게 보내주어 갱신되는 것이 일반적이다.     하지만, 구글 지도와 같은 몇 웹페이지에서는 신기하게도 전체 페이지를 다시 새로고침하지 않고도 지도 정보만 갱신되는 것을 볼 수 있다.    Ajax  (Asynchronous JavaScript and XML, 에이잭스)  비동기적인 웹 애플리케이션의 제작을 위해 아래와 같은 조합을 이용하는 웹 개발 기법     표현 정보를 위한 HTML (또는 XHTML) 과 CSS   동적인 화면 출력 및 표시 정보와의 상호작용을 위한 DOM, 자바스크립트   웹 서버와 비동기적으로 데이터를 교환하고 조작하기 위한 XML, XSLT, XMLHttpRequest   JavaScript의 라이브러리 중 하나이며, JavaScript를 사용한 비동기 통신, 클라이언트와 서버 간에 XML 데이터를 주고받는 기술이다.   즉, 자바스크립트를 통해 다양한 형태의 데이터(JSON, XML, CSV)를 서버와 주고받을 수 있다.   비동기 방식  웹페이지를 새로고침하지 않고 데이터를 불러오는 방식.   보통 자주가는 카페를 예로 들어보자면,  동기 방식의 경우는 손님이 들어올 때마다 주문을 받고 손님은 커피를 받기 전까지 카운터에서 기다리는 상황이고  비동기 방식은 진동벨을 구비해서 손님의 주문을 받음과 동시에 진동벨을 배분하고 일을 하다가 중간에 다른 손님이 오더라도 주문을 받을 수 있는 상황과 유사하다고 할 수 있다.   위 예시에서 손님이 갑자기 몰려온다고 생각해보자.  동기 방식에서는 손님이 주문하고 커피를 준비하고 넘겨주어야 다음 손님을 맞을 수 있으므로 시간 낭비가 심하다.  하지만, 비동기 방식에서는 손님을 기다리게 하고 다른 업무를 할 수 있으니 시간적으로 효율이 좋다.   즉, 비동기 방식의 장점은  기존의 변경할 필요가 없는 이미지, 스크립트 등은 남겨두고 필요한 부분만 갱신해 사용할 수 있다는 점이다.      데이터 전송 방식     GET  지정한 URL의 데이터를 열람하기 위한 메소드  사용이 간편하고 전송량이 적으나 사용자정보를 URL에 노출함으로 보안상 취약할 수 있음   POST  지정한 URL에 데이터를 생성하기 위한 메소드(수정 및 삭제 작업도 수행 가능)   PUT  지정한 URL의 데이터를 갱신하기 위한 메소드   DELETE  지정한 URL의 데이터를 삭제하기 위한 메소드   HEAD  지정한 URL의 헤더 정보를 요청하는 메소드   AJAX의 장점     웹페이지 속도 향상   서버 처리를 기다리지 않고, 비동기 요청 가능   수신하는 데이터의 양을 줄일 수 있고, 클라이언트에게 처리를 위임할 수도 있다.   플러그인 없이도 인터렉티브한 웹페이지 구현이 가능   AJAX의 단점     Ajax를 쓸 수 없는 브라우저에 대한 문제가 있음   HTTP 클라이언트 기능이 한정되어 있음   페이지 이동없는 통신으로 인한 보안상의 문제 발생 가능성   히스토리 관리가 되지 않음   지원하는 Charset이 한정   스크립트로 작성되므로 디버깅이 용이하지 않음   요청을 남발하면 역으로 서버 부하가 늘 수 있음   동일-출처 정책으로 인하여 다른 도메인과는 통신이 불가능(Cross-Domain문제)   AJAX 프레임워크  Ajax를 이용하여 개발을 손쉽게 할 수 있도록 미리 여러 가지 기능을 포함해 놓은 개발 환경      JQuery   Prototype   script.acul.us   dojo   Google Web Toolkit   ASP.NET AJAX   YUI   AJAX 예제  JavaScript에서 Ajax   var xmlhttp; if (window.XMLHttpRequest) {     xmlhttp = new XMLHttpRequest(); }  else {     xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\"); }   xmlhttp.onreadystatechange = function() {     if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) {          //통신 성공시 구현부분           //readState : Ajax 통신의 진행중인 상태 표시          // 0 : 초기화되지 않은 상태(open 메소드가 호출되지 않은 상태)          // 1 : open 메소드가 호출된 상태(send메소드는 호출되지 않은 상태)          // 2 : 송신완료, 요청을 시작한 상태(요청은 하지 않았지만 데이터가 아직 오지 않은 상태)          // 3 : 수신 중인 상태(데이터를 받고 있는 상태)          // 4 : 수신 완료(데이터를 모두 받은 상태)           //status : 데이터 수신의 성공 여부를 판단해주는 속성값          // 0 : 로컬로 접근 성공을 의미          // 200 : 해당 URL로 접근 성공한 상태          // 403 : 접근이 거부됨.          // 404 : 해당 URL이 없음          // 500 : 서버오류      } } xmlhttp.open(\"GET\", \"exam.xml\", true); xmlhttp.send()   JavaScript에서 Ajax는 텍스트/XML 타입으로만 데이터를 가져올 수 있기 때문에 JSON/CSV 형식으로 데이터를 받기 위해서는 따로 파싱(Parsing)하는 코드 작업이 필요.   JQuery에서 Ajax   &lt;script  src=\"http://code.jquery.com/jquery-latest.min.js\"&gt;&lt;/script&gt;  $.ajax({     url:'', //request 보낼 서버의 경로     type:'post', // 메소드(get, post, put 등)     data:{ name: 'yoo'}, //보낼 데이터     datatype: \"json\"     success: function(data) {         //서버로부터 정상적으로 응답이 왔을 때 실행     },     error: function(err) {         //서버로부터 응답이 정상적으로 처리되지 못햇을 때 실행     } });  또는  $.ajax({     url:'', //request 보낼 서버의 경로     type:'post', // 메소드(get, post, put 등)     data:{ name: 'yoo'}, //보낼 데이터     datatype: \"json\"})     .done(function(json){       // HTTP 요청이 성공하면 요청한 데이터가 done 메소드로 전달     })     .fail(function(xhr, status, errorThrown){       // HTTP 요청이 실패하면 오류와 상태에 대한 정보가 fail 메소드로 전달     })     .always(function(xhr, status){       // HTTP 요청이 성공, 실패에 상관없이 언제나 alway 메서드 실행     }); });  ","categories": ["study"],
        "tags": ["AJAX"],
        "url": "https://many258.github.io/study/web-ajax/",
        "teaser": null
      },{
        "title": "[네트워크] TCP/IP 4계층 및 응용계층",
        "excerpt":"TCP/IP  Transmission Control Protocol/Internet Protocol   DoD(미국방성)모델이라고 하며 OSI 7계층과 흡사하나 OSI보다 먼저 만들어지고 가장 많이 사용중이다.   TCP/IP 구조          Application(Application/Presentation/Session)  네트워크를 실제로 사용하는 응용프로그램으로 구성  FTP, TELNET, SMTP 등등            Transport(Transport)  도착하고자 하는 시스템까지 데이터를 전송  Port를 가지고 있으며, 프로세스를 연결 또는 비연결해서 통신함  TCP, UDP            Internet(Network)  Datagram을 정의하고 routing하는 일을 담당  IP, ARP, RARP, ICMP, IGMP            Network Access(Data Link/Physical)  케이블, 송수신기, 링크 프로토콜, LAN 접속과 같은 물리적 연결 구성을 정의       Application Layer  일반 사용자들이 사용하는 프로그램이 있는 계층. 사용자는 프로그램을 사용하여 통신.           FTP(File Transfer Protocol)  사용자 파일의 업로드 혹은 다운로드를 수행하는 프로그램 파일 전송을 위한 인터넷 표준으로 제어 접속과 데이터 접속을 위한 분리된 포트를 사용            DNS(Domain Name Service)  DNS 쿼리를 사용해서 DNS서버에 URL을 전송하고 해당 URL에 매핑되는 IP주소를 제공하는 서비스       HTTP(Hyper Text Transfer Protocol) WWW(World Wide Web)로 시작되는 인터넷에서 웹브라우저와 웹 서버 사이에 웹 페이지의 Request 및 Response를 수행하는 W3C 표준 개방형 프로토콜  TCP 기반 프로토콜의 80번 포트를 사용, State-less로 프로토콜을 구성                     HTTP v1.0  연결을 수행할 때 마다 3-Way Handshaking 기법 사용  HTML 페이지를 수신 받고 완전히 종료  필요 시 재연결하고 페이지를 수신받음                        HTTP v1.1  어느 정도 대기한 후에 연결을 종료(Keep Alive Connection)                        HTTP v2.0  멀티플랙싱(Multiplexing) : 순차적 연결이 아니라 동시 다발적인 양방향 통신 지원  헤더압축(Header Compression) : 헤더 정보를 1/3 수준으로 압축. 속도 향상  서버푸시(Server Push) : 웹 서버가 웹 브라우저에게 필요한 데이터를 알아서 미리 전송할 수 있는 기술                        Telnet  특정 지역의 사용자가 지역적으로 다른 곳에 위치한 컴퓨터를 온라인으로 연결하여 사용하는 서비스            SMTP(Simple Mail Transfer Protocol)  TCP 25 Port. RFC821에 명시된 인터넷 전자우편(MIME 데이터 형식)을 위한 프로토콜로 메시지 전달을 위해 Store and Forward 방식을 사용  암호화 및 인증 기능 없이 사용자의 e-mail을 전송하는 프로토콜       SNMP(Simple Network Management Protocol)  네트워크에 대한 트래픽, 세션 등의 네트워크 상태를 모니터링하고 정보를 전달할 때 사용되는 프로토콜   3-Way Handshaking  1) 웹브라우저(클라이언트)가 웹 서버에 SYN 메시지를 전송  2) 웹 서버는 웹브라우저에게 SYN, ACK로 응답  3) 웹브라우저는 웹 서버에 최종 연결확립 메시지인 ACK를 전송해 웹 서버와 연결 확립(ESTABLISHED 상태)      HTTP  Header : Request 시 전달해야 하는 웹브라우저 정보, 요청방식, 파라미터  Body : Request 할 때는 사용하지 않고 POST 방식의 Request 시 Body에 파라미터 정보를 넣고 전송     HTTP Request 시 Header 구조                     Request Method  호출되는 메소드. GET/POST/OPTIONS/PUT/DELETE/TRACE/CONNECT                        Accept  웹 브라우저에서 사용 가능한 미디어 타입. text/html..등                        Accept-Language  웹 브라우저가 인식할 수 있는 언어를 의미                        User-Agent  웹 브라우저 정보 의미                        Accept-Encoding  웹 브라우저에서 제공되는 인코딩 방식                        Host  웹 서버의 기본 URL                        Connection  연결 지속(Keep Alive) 및 연결 끊기(Close) 상태 표시                   HTTP Response 시 Header 구조                     Status Code  HTTP 응답코드. 200 : 성공적으로 처리                        Server  서버 프로그램 이름과 버전 전송                        Expires  자원의 만기일자                        Cache Control  캐시 사용 여부. HTTP/1.1                        Pragma  캐시 사용 여부. HTTP/1.0                        Content-Encoding  응답되는 메시지의 인코딩 방식                        Content-Length  바이트 단위로 응답되는 리소스의 크기                        Keep-Alive  연결 유지 시간을 의미                        Connection  Keep-Alive 사용 여부                        Content-Type  응답되는 미디어 타입                   HTTP 요청 방식                     GET 방식  서버에 전달할 때 데이터를 URL에 포함시켜서 요청  전송할 수 있는 데이터 양이 제한(2Kbyte or 4Kbyte)                        POST 방식  서버에 전달할 때 데이터를 Request Body에 포함시킴  데이터 전송량의 제한이 없음                        쿠키(Cookie)  웹브라우저에서 저장할 수 있는 작은 공간으로 개발자가 프로그램에 필요한 정보를 임시적으로 저장 가능  쿠키 값은 변조가 가능하기에 보안 상 주의를 요함       세션(Session)  클라이언트와 웹 서버 사이의 네트워크 연결이 지속적으로 유지되는 상태   SMTP     구성요소                     MTA(Mail Transfer Agent)  메일을 전송하는 서버                        MDA(Mail Delivery Agent)  MTA에게 받은 메일을 사용자에게 전달(수신측에 고용된 우체부)                        MUA(Mail User Agent)  사용자들이 사용하는 클라이언트 어플리케이션                        기본 동작 방식  1) 송신자가 보낸 전자우편은 전자우편을 관리하는 메일 서버에 전달  2) 메일 서버는 수신자의 전자우편 주소를 분석하고 최단 경로를 찾아 근접한 메일 서버에게 편지를 전달  3) 최종 수신자 측 메일 서버에 도착하기까지 연속적으로 전달하는 중계 작업을 수행            POP3  TCP 110 Port. 메일서버에 접속하여 저장된 메일을 내려 받는 MDA 프로그램  메시지를 읽은 후 메일 서버에서 해당 메일을 삭제       IMAP &amp; IMAP3  TCP 143 Port. 위 POP과 역할은 유사하나 메일을 내려받아도 메일 서버에 원본을 계속 저장한다는 차이점이 있음   FTP  해당 컴퓨터에 등록된 사용자만 파일전송이 가능하며, 그 외에는 익명으로 사용  ftpuser에 등록된 사용자는 FTP 접근 불가  제어 접속과 데이터 접속 포트 분리           Active Mode  1) 클라이언트에서 서버 TCP 21번 포트로 접속 시도  2) 서버는 TCP 20번 포트로 데이터를 송수신            Passive Mode  1) 클라이언트는 서버의 TCP/21번 포트로 접속 후 두 번째 포트를 질의  2) 서버는 클라이언트에게 데이터 연결을 위한 두 번째 포트(TCP 1024 ~ 65535)을 알림  3) 클라이언트는 서버가 알려 준 두 번째 포트로 접속       SNMP  운영되는 네트워크의 안정성, 효율성을 높이기 위해 구성/장애/통계/상태 정볼르 실시간으로 수집 및 분석하는 네트워크 관리 시스템   NMS(Network Management System)는 SNMP 프로토콜을 사용해서 네트워크 정보 수집  MIB(Management Information Base)는 SNMP에서 모니터링해야 하는 객체 정보를 소유      SNMP 명령                     GET  장비의 상태 및 기동시간 등의 관리 정보 읽기                        GET-NEXT  정보가 계층적 구조를 가지므로 관리자가 장비 조회를 해서 해당 트리보다 하위층 정보를 읽기                        SET  장비 MIB를 조작하여 장비 제어/관리자는 요청을 보내 초기화 혹은 장비 재구성                        TRAP  일반적으로 SNMP는 Polling 방식으로 주기적으로 정보 요청과 요청에 대한 정보 응답 방식으로 동작되는데,  이 때 만약 연결구간이 혼잡하게 될 경우 중요한 관리 정보가 손실되어 그 정보를 인지 못할 수도 있다는 문제점을 보완하기 위해 TRAP 기술 도입           Manager가 요청 않더라도 Agent에 의해 자의적으로 경고, 고장통지 등 미리 설정된 유형의 보고서를 생성/송신                  ","categories": ["study"],
        "tags": ["네트워크","데이터통신"],
        "url": "https://many258.github.io/study/tcp-ip-application/",
        "teaser": null
      },{
        "title": "[네트워크] TCP/IP 인터넷, 네트워크 접근 계층",
        "excerpt":"인터넷 계층(Internet Layer)  송신자의 IP주소와 수신자의 IP주소를 읽어서 경로를 결정하거나 전송하는 역할을 수행  다중 네트워크 링크를 통해 패킷의 발신지-대-목적지 전달에 대한 책임을 가진다.(데이터 링크 층은 노드간 전달 책임, Point-to-Point)   IP, ICMP의 TCP/IP 프로토콜 군이 존재하고 멀티캐스팅을 위한 IGMP, 라우팅을 위한 BGP, OSPF, RIP 존재      경로설정(Routing)  수신자의 IP주소를 읽어서 어떻게 목적기까지 가는 것이 최적의 경로인지를 판단하는 것. 라우터(Router)의 역할   Point-To-Point 패킷 전달   논리 주소 지정 : IP주소로 변환하여 사용   주소 변환   데이터그램 : 기존 패킷에 IP Header를 붙이는 것을 의미   라우팅  목적지 IP주소를 읽어서 경로를 결정하는 작업.      정적 경로 방법(Static Routing)  특정 목적지 네트워크로 가는 경로를 관리자가 직접 라우팅 테이블의 경로를 설정하는 방법  실시간으로 이루어지지 않기에 초기에 관리자가 다양한 라우팅 정보를 분석하여 최적의 경로 설정이 가능  라우터의 직접적인 처리 부하를 감소시킬 수 있어서 비교적 환경변화가 적은 형태의 네트워크에 적합            Floating static routing           동적 경로 방법(Dynamic Routing)  네트워크 상태를 파악해서 최적의 경로를 결정하는 방법  실시간으로 이루어지므로 네트워크 환경변화에 능동적인 대처가 가능  라우팅 알고리즘을 통해 자동으로 경로 설정이 이루어지며,  수시로 환경이 변화되는 형태의 네트워크에 적합            Distance Vector routing       Linked state routing           라우팅 프로토콜  인터네트워크를 통해서 데이터를 근원지에서 목적지로 전달하는 기능 수행  경로 결정에서 최단경로 선정 및 전송 수행, 목적지에 대한 경로 정보를 인접한 라우터들과 교환하기 위한 규약           IGP(Internal Gateway Routing Protocol)  동일 그룹(기업 또는 ISP) 내에서 라우팅 정보를 교환            EGP(Exterior Gateway Routing Protocol)  다른 그룹과의 라우팅 정보를 교환       Distance Vector routing  최단 경로를 구하는 벨만 포드 알고리즘 기반  통과해야 하는 라우터의 수가 적은 쪽으로 경로를 결정. 일명 Hop Count 또는 TTL(Time to Live)  네트워크 변화 발생 시 해당 정보를 인접한 라우터에 정기적으로 전달하고,  인접 라우터에서는 라우팅 테이블 정보 갱신            라우팅 정보 : 모든 라우터까지의 거리 정보 보관       정보 전송 시점 : 일정주기(30초, 이웃 라우터와 공유)       대표 프로토콜 : RIP, IGRP, EIGRP(내부 라우팅), BGP       단점  변화되는 라우팅 정보를 모든 라우터에 주기적으로 갱신(브로드캐스팅)하므로 망 자체 트래픽 유발  라우팅 정보를 변경하는 문제 발생 시 Routing Loop가 발생할 가능성 존재           Linked state routing  최소 신상 트리를 구하는 다익스트라 알고리즘 기반  네트워크 대역폭, 지연정보 등을 종합적으로 고려해 Cost를 산정하고 해당 Link의 Cost에 따라 경로를 결정하는 방법  네트워크 변화 감지 시 링크 상태 변경 정보를 인접한 라우터에게 즉각 전달하고 이를 저장            라우팅 정보 : 인정 라우터까지의 Link Cost 계산       정보 전송 시점 : 변화 발생 시에만       대표 프로토콜 : OSPF, IS-IS(소규모 네트워크)       단점  네트워크 전체 정보 유지를 위한 많은 메모리 소요  라우터의 CPU 사용량이 많아짐  라우터간 회선의 대역차이로 동기화 실패할 가능성 존재                RIP(Routing Information Protocol)  RFC 1058. 대표적인 거리 벡터 라우팅 프로토콜       라우터 간 거리 계산을 위한 척도로 홉수(Hop Count) 사용  16Hop 이상이면 패킷을 폐기  180초 이내에 새로운 라우팅 정보가 수신되지 않으면 해당 경로를 이상 상태로 간주  수신된 목적지의 거리 값과 현재 거리 값을 비교하여 작은 것을 기준으로 라우팅 테이블을 변경       라우팅 정보 변경 시 모든 망에 적용하므로 큰 규모의 망에는 부적합            OSPF(Open Shortest Path First)  RFC 1247. IP 라우팅 프로토콜       링크에서의 전송 시간을 링크 비용으로 사용하여 각 목적지별 최단 경로를 계산  네트워크에 변화가 발생했을 때 상대적으로 짧고 간단한 링크 상태 정보 교환       Link의 delay, throughput, reliability를 이용하여 기본적인 throughput만 이용하고, Hop수에 대한 제약이 없음  네트워크를 Area로 구분하여 많은 라우팅 정보의 교환으로 인한 라우터의 성능저하를 예방(대역폭을 절약)  Link 변화 감지 시 해당 Link에 대한 정보만을 즉시 모든 라우터에 전달하며 Convergence가 매우 빠름  Supernetting된 형태로 Routing Information을 전달할 수 있어 라우터 메모리 절약, 성능 향상 및 대역폭 절약              ABR(Area Border Router)  Area에 백본망을 연결해주는 라우터       ASBR(Autonomous System Boundary Router)  다른 AS(Autonomous System)에 속한 라우터와 경로 정보를 교환       IR(Internal Router)  Area에 접속한 라우터       BR(Backbone Router)  백본망에 접속한 모든 라우터                BGP(Border Gateway Protocol)  AS 상호 간의 routing에 적용되는 라우팅 프로토콜.  ISP(Internet Service Provider) 사업자들 상호 간에 주로 사용       EGP라고 하는 Inter-Domain routing Protocol  인터넷을 AS 상호 간 연결 Path로 이루어진 방향성 그래프의 집단으로 인식  경로 벡터 라우팅 방법(path vector routing)을 적용하며 경로 벡터 라우팅 테이블을 유지             Looping Free Routing       TCP 기반 라우팅  BGP 라우팅 정보는 라우터 간에 179번 포트를 통하여 TCP에 의해 신뢰성 있게 전달       라우팅 정보의 점진적 갱신  BGP는 주기적으로 라우팅 정보를 갱신하지 않고, 변화가 있을 때 이웃 라우터에게 갱신 정보를 전달       다양한 라우팅 metric 사용  최상위 경로 선택을 위해 우선순위가 있는 각 metric을 참조       Class 없는 주소체계 지원  CIDR(Classless Inter-Domain Routing) 지원       IBGP(Internal BGP) : 동일한 AS에 속한 BGP 라우터 간의 동작       EBGP(External BGP) : 서로 다른 AS에서 동작하는 BGP 프로토콜           IP(Internet Protocol)  IP 주소 형태로 송신자와 수신자의 IP를 가지고 있고 IP주소를 읽어서 최적의 경로를 결정할 수 있게 함      주소화, 데이터그램 포맷, 패킷 핸들링 등을 정의해놓은 인터넷 규약   IPv4 : 32bit 주소체계를 사용. (네트워크 ID + 호스트 ID)   IPv6 : IP주소의 부족 문제를 해결하기 위해 주소 비트수를 128bit로 확장.   IP Header 구조     Version : IPv4 버전   Header Length : Header의 전체 길이   Type of Service : 서비스 유형   Total Length : IP Datagram의 byte 수   Identification : Host에서 보낸 DataGram 식별        Flags &amp; Offset  IP Datagram 단편화 정보  네트워크에는 MTU(Maximum Transmission Unit)라는 것이 존재하는데, 한 번에 통과할 수 있는 패킷의 최대 크기를 의미한다.       즉, MTU 값보다 크면 패킷은 분할(단편화 : Fragmentation)되고 그 정보를 Flags &amp; Offset이 가지고 있게 된다.       Time to Live  Datagram이 통과할 수 있는 라우터 수(Linux 기본 = 64, Window 기본 = 128)  IP 패킷이 통과할 수 있는 라우터의 수를 의미. 라우터를 하나 통과 시 1씩 감소하며 0이 될 경우 자동 폐기   Protocol : IP헤더 위의 상위 프로토콜 종류. ICMP, TCP, UDP   Header Checksum : IP Header 무결성 검사   IP 주소의 구조  클래스로 분류되며 클래스는 IP 주소를 분류하는 기준으로 사용.                  Class       Content                 Class A       첫 바이트 7bit가 네트워크 식별자 한 네트워크에 가장 많은 호스트 수용 가능                 Class B       14bit의 네트워크 식별자 한 네트워크에 약 216대의 호스트 수용                 Class C       세 번째 바이트까지 네트워크 식별자 한 네트워크에 254대까지 수용                 Class D       멀티캐스트 주소로 사용              서브넷팅(Subnetting)  주어진 네트워크 주소를 작게 나누어 여러 개의 서브넷으로 구성  네트워크 식별자 부분을 구분하기 위한 Mask를 서브넷 마스크라고 함   수퍼넷팅(Supernetting)  ISP(Internet Service Provider) 사업자가 많은 네트워크 망을 효율적을 관리하기 위해서 네트워크를 묶어 관리하는 방법   CIDR(Classless Inter-Domain Routing)  RFC 4632. IPv4의 IP 주소 고갈 및 라우팅 테이블 대형화에 대한 해소책  기존의 클래스 A, B, C 네트워크 주소의 개념을 무시하고 IP주소와 서브넷 마스크를 이진 표기법으로 표현하여 기존의 고정크기 네트워크를 다양하고 세부적으로 분할한 것   VLSM(Variable Length Subnet Mask : 가변길이 서브넷 마스크)  서브넷팅을 실시한 이후에도 IP 주소가 낭비되는 것을 방지하기 위해서 서브넷 마스크의 길이를 더 확장하여 늘리는 기능   ICMP(Internet Control Message Protocol)  TCP/IP 오류 제어 프로토콜  호스트 및 라우터는 다른 호스트나 라우터가 현재 도달 가능한지의 여부를 결정  라우터는 특정 목적지 네트워크로 후속 IP 데이터그램을 보냈는데, 사용할 수 있는 최적의 경로가 있을 때 근원지 호스트에게 통지  호스트나 라우터는 그들이 처리하기에 너무 빠른 IP 데이터그램이 도착하면 다른 시스템에게 통보      오류 보고 메시지 : IP 패킷 처리 도중 발견된 문제를 보고   질의 메시지 : 다른 호스트로부터 특정 정보를 획득하기 위해 사용   ICMP 메시지 구조     Type : ICMP 메시지 유형 표시   Code : Type과 같이 사용되며 세부적인 유형을 표현   Checksum : IP Datagram Checksum   ICMP 메시지                  Type       Message       Content                 3       Destination Unreachable       라우터가 목적지를 찾지 못할 경우 보내는 메시지                 4       Source Quench       패킷을 너무 빨리 보내 네트워크에 무리를 주는 호스트를 제지할 때 사용                 5       Redirection       패킷 라우팅 경로를 수정, SMURF 공격에서 사용                 8 or 0       Echo Request or Reply       Host의 존재를 확인                 11       Time Exceeded       패킷을 보냈으나 시간이 경과하여 패킷이 삭제되었을 때 보내는 메시지                 12       Parameter Problem       IP 헤더 필드에 잘못된 정보가 있다는 것을 알림                 13 or 14       Timestamp Request and Reply       Echo와 비슷하나 시간에 대한 정보 추가           데이터 전송 방식          Unicast  1:1 전송 방식.            Broadcast  1:N 전송 방식. 동일한 서브넷 상의 모든 수신자에게 전송       Multicast  M:N 전송 방식. 하나 이상의 송신자들이 특정 그룹의 수신자에게 전송  IGMP : 그룹에 등록된 사용자를 관리하는 프로토콜            IGMP 메시지 구조 (8byte)                    Version : IGMP 프로토콜의 버전           Type : 메시지 유형. (1 = 보고, 2 = 질의메시지)           Group ID  보고 메시지의 경우 호스트에서 신규 가입하고자 하는 멀티캐스트 서비스의 group id,  계속 받아보기를 원하는 멀티캐스트 서비스의 group id 질의 메시지인 경우는 ‘0’                           Anycast  그룹에 등록된 노드 중에서 최단경로 노드 한 개에만 전송.  IPv6에서 사용 (Broadcast 대신)   ARP(Address Resolution Protocol)  IP주소를 물리적 하드웨어 주소인 MAC 주소로 변경하는 프로토콜  IP 주소와 이에 해당하는 물리적 네트워크 주소 정보는 각 IP 호스트의 ARP 캐시라 불리는 메모리에 테이블 형태로 저장된 후 다음 패킷 전송 시에 다시 사용  ARP Cache Table : MAC 주소와 IP 주소를 보유하고 있는 매핑 테이블   RARP(Reverse Address Resolution Protocol)  물리적인 주소 MAC을 기반으로 논리적인 주소 IP를 알아오는 프로토콜  운영체제도 없는 일종의 더미 터미널 Diskless Host에서 사용하는 것으로 자신의 물리적 주소인 MAC주소를 서버에 전송하고 IP주소를 수신 받아서 기동   네트워크 접근 계층  논리적 주소인 IP 주소를 물리적 MAC 주소로 변환  Physical Layer가 이해할 수 있는 헤더를 붙여주는 Layer, Frame 단위, MAC Address를 사용하는 계층   Point-to-Point 간 신뢰성 있는 전송으로 흐름 제어 기능을 담당  에러 제어 : Error Detection, Error Correction  MAC(Media Access Control) : LAN 카드의 물리적 주소   CSMA/CD  Carrier Sense Multiple Access/Collision Detection  유선 LAN에서 메시지를 송수신하기 위한 접근 방법. IEEE 802.3   1) 각 호스트들이 전송매체에 경쟁적으로 데이터를 전송  2) 프레임을 전송하면서 충돌여부를 검사  3) 전송 중 충돌이 감지되면 패킷의 전송을 즉시 중단  4) 충돌이 발생한 사실을 모든 스텐이션들이 알 수 있도록 간단한 통보신호 송신  5) 통보신호에 따라 전송을 조절   Collision이 일어난 경우 Back off 알고리즘을 이용하여 재전송  리피터와 허브를 이용하면 Collision이 발생하나 Switch는 Collision을 막을 수 있다  Switch는 브로드캐스트를 막을 수 없고 Router가 브로드캐스트를 막을 수 있다.      Non-Persistent  매채가 사용 중이 아니면 즉시 전송  매체가 사용 중이면, 확률분포에서 구한 재전송 지연시간만큼 대기            임의 지연 사용은 충돌 확률을 감소       매체가 비었을 때 임의 지연 때문에 데이터 전송이 없는 채널 휴지 발생           1-Persistent  매체가 사용 중이 아니면 즉시 전송  매체가 사용 중이면 대기 후 채널이 비는 순간 즉시 전송            채널 휴지 시간을 제거하기 위해 사용       임의 지연이 없게 하여 채널 휴지는 거의 없지만 충돌 확률이 높음           p-Persistent  매체가 사용 중이 아니라면, 확률 p로 전송하고 (1-p)의 확률료 하나의 시간단위를 지연  매체가 사용 중이면 기다렸다가 채널이 비는 순간 확률 p로 전송하고 확률 (1-p)로 대기            위 장단점을 상호보완하기 위해 사용           CSMA/CA  Carrier Sense Multiple Access/Collision Avoidance  무선 LAN에서 메시지의 송수신하기 위한 접근 방법   프레임 전송 이전에 제어 메시지를 이용하여 수신자로부터 간단한 전송 유발  제어 신호에 대한 응답이 도착하면 프레임 전송  ","categories": ["study"],
        "tags": ["네트워크","데이터통신"],
        "url": "https://many258.github.io/study/tcp-ip-internet-network-access/",
        "teaser": null
      },{
        "title": "[네트워크] TCP/IP 전송 계층",
        "excerpt":"Transport Layer  수신측에 전달되는 데이터에 오류가 없고 데이터의 순서가 그대로 보존되도록 보장하는 연결 지향 서비스의 역할을 하는 종단 간 서비스(End-to-End) 계층   신뢰성 있는 전송을 하는 TCP와 비신뢰성 전송을 하는 UDP가 존재      Segment  애플리케이션 계층의 메시지에 TCP 혹은 UDP의 헤더를 붙인 것을 의미.   TCP(Transmission Control Protocol)  클라이언트와 서버 간의 연결 지향, 신뢰성 있는 데이터 전송, 에러 제어, 흐름 제어, 완전이중 방식  신뢰성있는 데이터 전송을 위해 가상 연결 수행  송신자가 메시지를 전송하면 수신자는 ACK를 되돌려서 수신 여부를 확인     혼잡 제어(Congestion Control)  수신자 동일한 ACK 번호를 반복적으로 전송 =&gt; 데이터를 받지 못함 ==&gt; GO-BACK-N 방법으로 재전송   흐름 제어(Flow Control)  수신자가 메시지를 제대로 받지 못하면 송신자는 전송 속도를 늦추어 네트워크 효율성 제어   순서 제어 : Sequence 번호를 가지고 메시지의 순서 파악   Checksum : TCP, UDP 모두 존재. 송신 중 메시지의 변조 파악하기 위해 에러 체크   Receive Windows  수신자의 윈도우 크기이자 메모리 버퍼.  수신자의 버퍼가 비어 있으면 송신자는 해당 버퍼의 크기만큼 데이터를 한꺼번에 전송   TCP의 상태 전이  netstat 명령어로 확인 가능   1) 클라이언트는 서버에 연결요청 메시지인 SYN 신호를 보내고 SYN_SEND 상태 전환  2) 서버는 기동되면 클라이언트의 연결을 받기 위해 LISTEN 상태로 클라이언트의 연결 대기  3) 서버는 클라이언트로부터 SYN 메시지가 수신되면 서버는 클라이언트에게 SYN, ACK를 전송하고 SYN_RECEIVED 상태 전환  4) 클라이언트는 ACK를 서버에 전송하고 클라이언트와 서버는 ESTABLISHED(연결 확립) 상태      TCP 프로토콜의 Header 구조          근원지 포트(Source Port)  가상 선로의 송신측 포트(End point of Sender)            목적지 포트(Destination Port)  가상 선로의 수신측 포트(End point of receiver)            일련번호(Sequence Number)  송신자가 전송하는 데이터의 일련번호            전송확인(Piggyback Acknowledgement)  수신자와 응답하는 받은 데이터의 수            TCP 헤더 길이(Header Length)  TCP 헤더에 몇 개의 32Bit 워드가 포함되어 있는가를 나타내는 필드  옵션 필드가 가변 길이를 갖기 때문에 필요, 이 값을 이용하여 실제 데이터의 시작점을 계산            URG(Urgent)  긴급 지점이 사용될 때 1로 설정            ACK(Acknowledgement)  전송 확인을 필요로 할 때 설정            EOM(End of Message)  마지막 메시지임을 가리킴            재설정(RST)  연결의 재설정. 비정상적인 종료            동기화(SYN, Synchronization)  연결 설정 요구            FIN(Finish)  연결 해제에 사용되며, 송신측에서 더 이상 전송할 데이터가 없음을 의미            윈도우 크기(Window size)  수신측에서 수신할 수 있는 최대 Byte 수            체크썸(Checksum)  전송 데이터에 대한 완벽한 신뢰성을 위한 것으로, 모든 데이터의 합에 대한 ‘1’의 보수로 계산 무결성을 확인하기 위해 CRC(Cyclic Redundancy Check)코드 사용 CRC : 데이터 통신에서 전송 중에 전송 오류가 발생하였는지 확인하기 위해 덧붙인 코드            급송 지점(Urgent point)  다음에 이어지는 데이터가 급송되어야 함을 의미. 인터럽트 메시지 대신 사용            옵션  전송 셋업 과정의 버퍼 크기에 대한 통신 등 기타 목적에 활용       에러 제어          FEC(Forward Error Correction)  송신측이 특정한 정보 비트를 함께 전송하여 수신측에서 이 정보 비트로 에러 발생 시 수정하는 방식(수신측이 에러 처리)       데이터 전송과정에서 발생한 오류를 검출하여 오류를 재전송 요구 없이 수정  재전송 요구가 없어 역 채널이 필요 없고, 연속적인 데이터 전송 가능  오류 검출 및 수정을 위한 잉여비트들이 추가 전송되므로 전송 효율 감소             해밍 코드       상승 코드                BEC(Backward Error Correction)  수신측이 에러 검출 후 송신측에게 에러가 발생한 데이터 블록을 재전송 요청(송신측이 에러 처리, ARQ:Auto Repeat reQuest)       패리티 검사, CRC 등 CheckSum을 이용하여 오류 검출 후, 오류 제어는 ARQ가 처리                      Stop-And-Wait  하나의 데이터를 송신하고 수신 확인 신호를 받을 때까지 기다린 다음 전송                        Go-Back-N  수신자가 데이터를 수신 받지 못할 경우 마지막으로 수신 받은 데이터 이후의 모든 데이터 재전송 TCP에서 사용하는 방식                        Selective Repeat ARQ  수신받은 데이터 중에서 중간에 빠져있는 것만 재전송                        Adaptive ARQ                   흐름 제어  송수신측 사이의 전송 패킷의 양, 속도를 조절하여 네트워크를 효율적으로 사용      슬라이딩 윈도우(Sliding Window)  호스트 간에 송수신 혹은 수신할 수 있는 Size 정보를 제공  Stop-And-Wait의 단점을 보완한 방식으로 수신측의 확인 신호를 받지 않더라도 미리 정해진 프레임의 수만큼 연속적으로 전송  수신자의 버퍼 크기를 확인함으로서 최대한 전송 효율 극대화   혼잡 제어  라우터가 패킷을 처리할 수 있는 속도보다 많은 패킷을 수신하는 경우 라우터는 패킷을 손실하게 된다. 송신측에서는 패킷을 재전송하게 되는데, 이러한 과정의 연속으로 데이터의 손실이나 지연이 발생 혼잡 제어는 송신 단말의 전송률을 직접 제어하여 혼잡으로 인해 손실된 데이터를 재전송하기 위함           TCP Slow Start  TCP가 시작될 때 전송속도를 초기값부터 지속적으로 올리는 방법       송신측에서 패킷을 전송하는 비율과 수신측에서 수신된 ACK를 통해 Congestion Window(cwnd)를 지수의 크기로 증가.  cwnd는 계속적으로 증가하다가 임계값에 이르게 되면 Congestion Avoidance로 동작            Congestion Avoidance  Duplication ACK 값이 오거나 일정 시간 동안 ACK가 수신되지 않으면 전송속도를 낮춤  매번 ACK가 수신될 때마다 cwnd를 1/cwnd만큼 증가(선형적인 증가)            Fast Retransmit  Retransmit Threshold 이상 연속된 Duplicate ACK를 수신하는 경우 TCP는 해당 Segment를 재전송            Fast Recovery  Fast Retransmit한 이후 새로 Slow Start를 통해서 설정된 연결의 안전상태에 도달할 필요없이 Congestion Avoidance 상태에서 전송할 수 있도록 하는 것       UDP(User Datagram Protocol)  비연결성, 비신뢰성(블록 재전송 및 흐름 제어 등이 없음)을 특성으로 패킷을 고속 전달할 수 있는 프로토콜  비접속형 : 전달되는 패킷에 대한 상태 정보를 유지하지 않음  간단한 헤더구조(8Byte), 블록 단위로 데이터 전송   UDP 프로토콜의 Header 구조          근원지 포트(Source Port)            목적지 포트(Destination Port)            수신자의 포트번호 길이(Length)            체크썸(Checksum)       VoIP(Voice Over IP)  UDP 프로토콜은 빠르게 데이터를 전송해야 하는 서비스에서 사용하는데 대표적인 활용이 VoIP      RTP(Real Time Protocol) : 음성 전송   RTCP(Real Time Control Protocol) : 에러 처리  ","categories": ["study"],
        "tags": ["네트워크","데이터통신"],
        "url": "https://many258.github.io/study/tcp-ip-transmission/",
        "teaser": null
      },{
        "title": "[데이터베이스] 데이터베이스 설계",
        "excerpt":"데이터베이스 설계  데이터베이스 설계 시 유의사항  저장된 데이터가 연산 수행 후에도 무결성이 유지될 수 있도록 설계  시스템 장애 시 복구될 수 있도록 회복과 예비 절차를 염두에 두고 설계  외부로부터 불법적인 접근을 방지할 수 있는 보안 절차를 유의하여 설계  데이터 관리에 대한 효율성과 일관성이 유지되도록 설계  데이터베이스의 확장과 축소에 대비한 신축성을 고려하여 설계   데이터베이스의 생명주기     요구 조건 분석 : 범위 설정을 위한 사용자와 그 응용을 식별하는 단계   설계 : 개념적 설계, 논리적 설계, 물리적 설계까지의 단계   구현 : 스키마 정의, 빈 데이터베이스 파일 생성, 응용 소프트웨어 구현 단계   운영 : 실제로 운영하여 사용자에게 서비스를 제공하는 단계   감시 및 개선 : 응용 과정에서 새로운 요구조건에 대처하고 성능을 개선하는 단계   데이터베이스 설계 순서  요구 조건 분석 단계  사용자 식별 및 범위 설정   요구되는 개체와 속성, 관계성, 제약조건, 트랜잭션의 유형, 실행 횟수 등을 파악    사용기관의 사용 목적과 내규, 법적인 규정, 데이터베이스의 사용자 식별, 사용 범위 결정 등 분석   개념적 설계 단계          개념 스키마 모델링  요구 분석 단계에서 나온 결과를 E-R 다이엉그램과 같은 DBMS에 독립적이고 고차원적인 표현 기법으로 기술하는 과정을 의미            트랜잭션 모델링  요구 조건 분석 결과로 식별된 응용을 검토해서 이들을 구현할 수 있는 트랜잭션을 고차원 명세로 기술하는 과정       논리적 설계 단계  DBMS에 따라 논리적 모델로 변환, 트랜잭션의 인터페이스 설계, 스키마 평가 및 정제   물리적 설계 단계  물리적 구조 설계, 트랜잭션의 세부 사항 설계     물리적 설계 사항                     저장될 레코드의 양식 설계  데이터 타입, 접근 횟수, 데이터 값의 분포 등을 고려                        저장될 레코드들의 분포 및 집중에 관한 설계  레코드의 저장 방식과 물리적 블록의 크기 고려                        접근 경로의 설계  데이터를 물리적 저장 장치에 어떻게 저장시킬 것이며, 그 저장된 데이터를 어떤 방법으로 가져다 쓸 것인지에 대한 접근 방법을 설계하는 것으로 인덱스 등을 설계                   물리적 설계 옵션 선택 시 고려 사항            응답시간       저장 공간의 효율화       트랜잭션 처리도           물리적 데이터베이스 설계 시 결정 사항            어떤 인덱스를 만들 것인지 고려       성능 향상을 위한 개념 스키마의 변경 여부 검토       빈번한 질의와 트랜잭션들의 수행 속도를 높이기 위한 사항을 고려       파일에 대한 트랜잭션의 갱신과 참조 성향 검토           구현 단계  DDL로 스키마 작성, 트랜잭션 프로그래밍(응용프로그램 작성)   ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-design/",
        "teaser": null
      },{
        "title": "[데이터베이스] 데이터 모델링",
        "excerpt":"데이터 모델  현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위해 사용되는 도구      개념적 데이터 모델(High-Level, Conceptual Data Model)  속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실 세계를 표현하는 방법            종류                    E-R 모델(Entity-Relationship Model)           이진 모델(Binary Model)           의미적 데이터 모델(Semantic Data Model)           정보 논리 모델(Information Logical Model)           함수적 데이터 모델(Functional Data Model)                           논리적 데이터 모델(Logical Data Model)  필드로 기술된 데이터 타입들 간의 관계를 이용하여 현실 세계를 표현하는 방법            종류                    관계형 데이터 모델           계층형 데이터 모델           네트워크형 데이터 모델           객체지향형 데이터 모델                           데이터 모델 구성요소          Structure  데이터의 논리적 구조  데이터 모델을 기술할 때는 데이터 사이의 관계성을 파악하여 그 논리적 구성 형태를 기술해 주어야 한다.            Operation  개체 인스턴스를 처리하는 연산  실제 데이터를 어떤 방법으로 삽입, 선정, 변경, 삭제할 것인가 하는 사항을 기술해야 한다.            Constraint  개체 인스턴스에 대한 논리적 제약 사항  실제 데이터의 특징과 특성을 파악하여 어떤 데이터만을 받아들이며 어떤 관계만을 허용할 것인가를 기술해야 한다.       개념적 데이터 모델  개체 관계 모델(Entity-Relationship Model)  개념적 단계에서 개체 내의 관계, 개체와 개체 사이의 사상 관계를 표현하는 데 쓰이며 사용자의 관점에서 가장 좋은 도구로 많이 사용되는 모델   특징  1976년 Peter Chen에 의해 제안된 이래 개념적 설계에 가장 많이 사용되는 모델  개체 타입과 관계 타입을 이용해서 현실 세계를 개념적으로 표현한 모델  개체라는 것은 현실 세계에 존재하는 객체들을 의미  관계라는 것은 개체들 사이의 관계를 표현하는 것  E-R 다이어그램은 그래프 형태로 표시  최초에는 Entity, Relationship, Attribute와 같은 개념들로 구성되었으나 나중에는 확장된 모델로 발전   기호      사상 원소수(Mapping cardinality)     1:1   1:N   N:1   N:M   논리적 데이터 모델  논리적 단계에서 쓰이는 도구로서 개념적 단계에서 만들어진 개념적 구조를 컴퓨터에 저장시킬 수 있는 논리적 구조로 변환하고자 쓰이는 데이터 모델   데이터베이스의 전체적인 논리적 구조를 설명할 때 사용되는 데이터 모델 관계 표현 : 관계 데이터 모델 - 테이블 구조, 계층 데이터 모델 - 트리 구조, 네트워크 데이터 모델 - 그래프 구조   관계형 데이터 모델(Relational Data Model)  통일적이고 단순한 데이터 구조로 되어 있다  사용자에게 가장 뛰어난 논리적 구조를 지원  릴레이션 구조로 운영되는 데이터베이스  개체나 관계 모두가 릴레이션 형태  기본키와 이를 참조하는 외래키로 데이터 간의 관계를 표현   계층형 데이터 모델(Hierarchical Data Model)  데이터 간의 관계를 순서 트리 형태로 표현  속성 간의 관계를 레코드, 레코드 간의 관계를 링크로 표현  계층 정의 트리 형태로 나타낼 때 노드는 레코드 타입이 되며 가지는 두 레코드 타입 사이의 링크가 된다  모든 링크의 관계는 1:N 관계  두 레코드 타입 간의 관계는 하나의 링크 관계만 있을 수 있으므로 별도의 이름을 부여하지 않음  레코드 타입 간에는 상하 계층이 존재, 사이클이 허용되지 않음  대표적인 DBMS = IMS   네트워크 데이터 모델(Network Data Model)  데이터 간의 관계는 그래프 구조 형태  1에 해당하는 레코드 타입을 오너 레코드 타입, N에 해당하는 레코드 타입을 멤버 레코드 타입, 이들의 관계를 오너-멤버(Owner-Member)관계라 한다.  레코드 타입 간의 관계는 1:1, 1:N, N:1, N:M이 될 수 있다 다 대 다의 관계가 있기 때문에 데이터 간의 연계성이 매우 뛰어난 모델이나 복잡하고 구축 비용이 크다 노드는 레코드 타입이 되고 링크는 개체 집합 간의 관계성을 표현 링크는 어느 한쪽으로 반드시 함수적 관계로 해서 화살표로 표현 링크 위에는 두 레코드 타입 간의 관계를 레이블로 표시 CDASYL(Conference On Data System Languages), DBTG(Data Base Task Group) 보고서에서 DBTG 모델이라는 것을 정의하여 네트워크 데이터 모델에 대한 이론적 개념을 정립   ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-modeling/",
        "teaser": null
      },{
        "title": "[데이터베이스] 데이터베이스 정규화",
        "excerpt":"관계 스키마 설계  데이터베이스 설계에서 중요한 사항 중 하나가 현실 세계를 가장 정확하게 표현하기 위한 데이터의 논리적 구조를 결정하는 것   설계 원칙  필요한 속성, 개체, 관계성을 식별하여 릴레이션을 구성  불필요한 데이터의 중복이 발생하지 않도록 설계  속성 사이의 관계성과 데이터의 종속성을 고려하여 설계  효율적 데이터 처리와 일관성 유지 방법 등을 고려하여 설계   스키마 변환(Schema Transformation)  관련된 어트리뷰트를 수집하고 이들 간에 존재하는 종속성을 파악하여 어트리뷰트의 집합인 릴레이션으로 만든 다음 보다 바람직한 형태의 릴레이션으로 다시 변환하는 과정      스키마 변환 원칙  공해의 원칙  정보 무손실 원칙  데이터 중복 감소의 원칙   이상(Anomaly) 현상  관계 스킴이 잘못되면 불필요한 데이터 중복을 초래하게 된다. 이러한 데이터 중복은 릴레이션을 조작할 때 곤란한 현상을 발생시키는 현상을 의미           삭제 이상(Delete Anomaly)  임의의 튜플을 삭제했을 때 그것과 관계를 형성하고 있는 관계성까지 모두 삭제되는 현상            삽입 이상(Insert Anomaly)  임의의 튜플을 삽입했을 때 삽입 의도가 없는 관계까지도 삽입되는 현상            갱신 이상(Update Anomaly)  임의의 데이터를 갱신했을 때 그것과 관계를 맺고 있는 데이터에 대해 일관성을 유지할 수 없는 현상       정규화 과정  하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해 나가는 과정           목적 구성되는 릴레이션이 중복되지 않게 효과적으로 데이터베이스 내에 표현이 가능하도록 한다 보다 간단한 연산자에 의해 효과적인 연산이 가능하도록 한다 릴레이션에 삽입 이상, 삭제 이상, 갱신 이상의 목제가 발생하지 않도록 한다 새로운 형태의 데이터가 삽입될 때 릴레이션을 재구성할 필요성을 감소시키도록 한다            필요성 자료의 저장 공간을 최소화 자료의 불일치를 최소화 자료 구조 안정화 자료의 삽입, 삭제, 갱신 시 이상 현상을 방지       함수 종속     어떤 릴레이션 R에서 A, B가 릴레이션 R의 부분 속성이라고 할 때,     임의 시점에서 A의 어떤 값도 반드시 B의 하나의 값에 대응되지만, B의 하나의 값이 A의 복수의 값에 대응되는 경우 B는 A의 함수 종속이라 하고, A → B로 표기한다. 여기서 A는 결정자, B는 종속자라 한다.    기본 정규형  제1정규형  어떤 릴레이션 R에 속한 모든 도메인이 원자값(분해될 수 없는 값)으로만으로 되어 있다면 제1정규형에 속한다.   제2정규형  어떤 릴레이션 R이 제1정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 완전 함수적 종속(부분 함수 종속 제거)이면 제 2정규형에 속한다.  기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미.      완전 함수 종속성  A, B가 각각 관계 R의 속성이고 B가 A에 함수 종속(A→B)인 경우, A의 임의의 부분 집합에 대하여 B의 어떤 값도 A의 부분 집합의 값에 대응하지 않으면 B는 A에 완전함수(적) 종속   제3정규형  어떤 릴레이션 R이 제2정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 이행적 함수 종속이 아니면 제3정규형에 속한다      이행 함수 종속성  A, B, C가 각각 관계 R에 상호 중복되지 않는 속성(다만, A는 1차 키 이외의 속성)인 경우에, A가 B에 함수 종속적이 아니면 이때 C는 A에 이행함수 종속이라고 한다. A-&gt;B 이고 B-&gt;C 일 경우에만 A-&gt;C 이면 이행함수(적) 종속이라고 한다.   보이스 코드 정규형(Boyce-Codd Normal Form : BCBF)  릴레이션 R의 모든 결정자가 후보키이면 릴레이션 R은 BC(Boyce-Codd)정규형에 속한다.           슈퍼키  레코드를 유일하게 식별해낼 수 있는 속성들의 집합이다. 한 개의 테이블은 여러 개의 슈퍼키를 가질 수 있다.            후보키  슈퍼 키에서 레코드를 유일하게 식별하는데 있어서 필요없는 속성을 제거한 슈퍼 키의 부분집합       제4정규형  릴레이션 R에 비당연 MVD A-»B가 존재할 때 R의 모든 속성도 A에 함수 종속이면 릴레이션 R은 제4정규형에 속한다      다치 종속성(MVD)  어떤 레코드의 존재가 다른 레코드의 존재로 이어짐을 의미한다. 다치종속성은-»으로 표시하는데, R｛A,B,C｝일 때 (A,C)-»｛B｝≡(A) -&gt;｛B｝ 성립한다. , A-»B이면 A-»C도 성립하고 A-»B│C이다.   제5정규형  릴레이션 R에 존재하는 모든 조인 종속(JD)이 릴레이션 R의 후보키를 통해서만 성립된다면 릴레이션 R은 제5정규형 또는 PJ/NF(Projection-Join Normal Form)에 속한다      조인 종속  릴레이션 R이 그의 프로젝션 A,B,…..,Z의 조인과 동일하면 R은 JD*(A,B,….,Z )를 만족한다. 이때 A,B,….,Z는 R의 애트리뷰트에 대한 부분집합이다.  다시말해서, 테이블 R이 R의 속성의 부분집합을 가지는 여러 개의 테이블들을 조인하여 만들어질 수 있을 때, R은 조인 종속성을 가진다고 한다.  ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-normalization/",
        "teaser": null
      },{
        "title": "[데이터베이스] 관계 데이터베이스",
        "excerpt":"관계 데이터베이스  데이터 간의 관계를 테이블 구조로 나타내는 데이터베이스   이 데이터베이스는 개체를 표현하는 데 있어 속성과 속성 간의 연관 관계를 파악하여 테이블의 형태로 표현하며, 개체와 개체 사이의 연관 관계도 테이블 형태로 표현한다.      관계 데이터베이스 용어  속성(Attribute)  어떤 개체의 정보의 특성이나 특징에 대한 이름을 의미. 파일 시스템의 레코드 필드와 유사   속성이란 용어는 우리가 프로그래밍하게 되면 어떤 값을 넣을 변수를 선언하게 되는데 이 변수의 개념에 해당   도메인(Domain)  한 속성의 의미로 들어오는 실제 값(원자값)들의 집합   변수를 선언하게 되면 그 선언 타입에 해당하는 개념   튜플(Tuple)  릴레이션 스킴에 따라 각 속성으로 실제 값이 입력됐을 때 하나의 행 값에 해당하는 개념  파일시스템의 레코드 개념과 유사   릴레이션(Relation)  데이터 간의 관계를 나타내는 표 자체   한 개 이상 속성들의 집합으로 표현 릴레이션의 일반적 의미는 테이블과는 학술적으로 다르게 사용되어 진다 릴레이션이라는 것은 릴레이션 스킴과 릴레이션 어커런스를 합쳐 지칭하는 용어   릴레이션 스킴(Relation Scheme)  릴레이션 스키마(Schema), 릴레이션 타입(Type) 또는 릴레이션 내포(Intention)라고도 불리며  릴레이션의 논리적 구조를 정의하는 것으로 릴레이션 이름과 해당 릴레이션을 형성하는 하나 이상의 속성을 합쳐 정의하는 개념   릴레이션 어커런스(Relation Occurrence)  릴레이션 인스턴스(Instance) 또는 릴레이션 외연(Extension)이라고도 하며  어느 한 시점(시간에 가변적인 특성)에서 릴레이션 스킴에 따라 실제 데이터로 입력된 튜플들의 집합을 의미하는 개념   릴레이션의 특성          튜플의 유일성  모든 튜플은 다르다는 것으로, 하나의 릴레이션으로 입력되는 튜플은 중복된 튜플이 존재하지 않는다는 개념            튜플간의 무순서  릴레이션으로 입력되는 모든 튜플은 순서가 정해져 입력되는 것이 아니라 상황에 따라 순서 없이 입력된다는 개념            속성값은 원자값  릴레이션에서 하나의 속성으로 입력되는 도메인 값은 하나의 튜플에서 분해 될 수 없는 형태로 입력되어야 한다는 개념            속성 간의 무순서  하나의 릴레이션에서 속성 간의 논리적인 순서는 관계가 없다는 개념            속성 이름의 유일성  하나의 릴레이션에서 속성 이름은 유일해야 한다       차수(Degree)  하나의 릴레이션에서 정의된 속성의 개수, 즉 필드의 개수를 표현  설계의 변경이 이루어지지 않는 한 항상 정적인 상태를 유지   카디널리티(Cardinality)  기수라고도 하며, 하나의 릴레이션에 형성된 튜플의 개수, 즉 레코드의 수를 의미  데이터 조작 연산에 의해 항상 변화하므로 동적인 상태   NULL 값  Empty, 모르는 값, 정의되어 있지 않은 값을 의미. 0과 공백의 의미와 다르다는 것을 유의   관계 데이터베이스 키 제약사항  키(Key)는 각각의 튜플을 유일하게 구분할 수 있는 개념이며 유일한 식별성과 최소성을 가지고 있어야 하며, 하나의 릴레이션에는 최소한 하나의 키가 있어야 한다.      최소성  가장 적은 개수의 어트리뷰트로 구성될 수 있는 성질   유일성  릴레이션으로 입력되는 모든 튜플을 유일하게 구별할 수 있는 성질   슈퍼키(Super Key)  최소성 없이 단지 튜플을 식별하기 위해 두 개 이상의 속성 집합으로 이루어진 키를 의미   후보키(Candidate Key)  하나의 릴레이션에서 유일성과 최소성을 가지고 있는 모든 속성 또는 속성의 집합   기본키(Primary Key)  후보키들 중 데이터베이스의 설계자에 의해 선택된 한 개의 키를 의미   기본키로 선택된 속성은 중복되지 않으며 정의되지 않는(NULL) 값을 가질 수 없다   대체키(Alternate Key)  후보키 중 기본키를 제외한 모든 키는 대체키의 역할을 한다.   외래키(Foreign Key)  테이블의 필드(attribute) 중 다른 테이블의 행(row)을 식별할 수 있는 키를 의미   두 테이블을 연결하는 연결다리 역할을 하며, 참조하는 테이블에 무결성을 높여주는 역할을 수행   무결성(Integrity) 제약사항  데이터베이스에 저장되는 데이터에 대한 정확성을 부여할 목적으로 제약사항을 설정하는 것을 의미   도메인 무결성(Domain Integrity)  기본적인 무결성 규정으로 데이터베이스 릴레이션에서 주어진 속성으로 입력되는 모든 값은 그 속성으로 정의되거나 제약된 도메인 영역에 있어야 한다는 규정을 의미   개체 무결성(Entity Integrity)  하나의 개체 릴레이션에서 기본키를 구성하는 속성은 널(NULL)값이나 중복된 튜플이 존재해서는 안된다는 규정을 의미   참조 무결성(Referential Integrity)  외래키 값은 NULL 값이거나 참조 릴레이션의 기본키와 동일해야 한다. 즉, 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 의미   릴레이션에 있는 튜플 정보가 다른 릴레이션에 있는 튜플 정보와 비교하여 관계성이 있으며, 관계되는 정보의 정확성을 유지하는 가를 규정하는 것   고유 무결성  특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성값은 모두 달라야 하는 제약조건   NULL 무결성  특정 속성값에 NULL값을 가질 수 없다는 조건이 주어진 경우, 그 속성값은 NULL값이 올 수 없다는 제약조건   키 무결성  한 릴레이션에는 최소한 하나의 키가 존재해야 한다는 제약 조건  ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-relationship/",
        "teaser": null
      },{
        "title": "[데이터베이스] 관계 데이터 연산",
        "excerpt":"관계 대수(Relational Algebra)  릴레이션으로부터 필요한 릴레이션을 만들어내는 연산자의 집합  주어진 릴레이션 조작을 위한 연산의 집합  원하는 정보와 그 정보를 어떻게 유도하는가(How)를 기술하는 절차적인 방법  관계 해석과 관계 대수는 표현 방법만 다를 뿐이지 표현 능력의 차이는 없다   집합연산자(Set Operations)          합집합(Union : ∪)  이항 연산으로 관계성이 있는 두 개의 릴레이션에 속하는 튜플의 집합을 구하여 하나의 릴레이션으로 만들어 내는 연산            교집합(Intersection : ∩)  이항 연산으로 관계성이 있는 두 개의 릴레이션에서 중복된 튜플을 선택하여 새로운 릴레이션을 만들어 내는 연산            차집합(Difference : -)  이항 연산으로 관계성이 있는 두 개의 릴레이션이 있을 때 그 중 하나의 릴레이션에서 또 다른 릴레이션의 튜플과 겹치는 튜플을 제거하여 새로운 릴레이션을 생성하는 연산            곱집합(Cartesian Product : ×)  이항 연산으로 두 개의 릴레이션이 있을 때 두 릴레이션의 튜플들을 접속하여 순서쌍의 집합을 만들어 새로운 릴레이션을 만들어 내는 연산       결과 릴레이션의 차수는 연산 대상 릴레이션 차수를 더해서 나오고 카디널리티는 곱해서 나온다       관계연산자(Relational Operations)          설렉션(Selection : σ(sigma))  단항 연산으로 릴레이션에서 조건에 맞는 레코드(튜플)을 분리해 내는 연산       하나의 릴레이션에서 수평적 부분집합을 취하는 연산       A와 B를 릴레이션 R의 애트리뷰트,  θ는 비교 연산자(=,≠, &lt;, ≤, &gt;, ≥),  v는 상수라고 할 때                                               σAθB(R) = {r             t∈R ∧ r.Aθv}                                   σAθB(R) = {r             t∈R ∧ r.Aθr.B}                                      위와 같이 설렉션 연산을 표현한다       설렉션에 표현된 식 r.Aθv나 r.Aθr.B을 비교식/조건식/프레디킷(Predicate)이라 하는데 셀렉션은 바로 이 프레디킷을 참으로 만드는 튜플을 선택            프로젝션(Projection : ∏(pi))  단항 연산으로 릴레이션에서 구하고자 하는 속성을 선택하여 분리해 내는 연산       하나의 릴레이션에서 수직적 부분집합을 취하는 연산       릴레이션 R이 있고, R에 속한 튜플을 t, A, B가 R 릴레이션의 속성이라 할때 프로젝션 여산의 수학적 표현은 다음과 같다                                               ∏A, B(R) = {t.A, t.B             t∈R}                                           조인(Join : ⋈)  두 개 이상의 릴레이션에서 조건에 맞는 속성이 들어 있는 튜플을 접속하여 새로운 릴레이션을 생성하는 연산       두 릴레이션 R과 K가 있다고 가정할 때  R에 속한 튜플을 r, K에 속한 튜플을 k,  R에 속한 속성을 A, K에 속한 속성을 B,  θ는 관계 연산자(=,≠, &lt;, ≤, &gt;, ≥)라 할 때 수학적 표현은 다음과 같다.                                               R⋈AθBK = { r · k             r∈R ∨ k∈K ∧ (r.Aθk.B) }                                                      세타 조인(Theta Join)  조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플을 반환                        동등 조인(Equi Join)  세타조인에서 = 연산자를 사용한 조인을 의미                      R⋈R.C=K.EK                                 자연 조인(Natural Join)  동등 조인에서 중복된 속성을 제거한 결과를 반환                      R⋈NK                                 세미 조인(Semi Join)  자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환           닫힌 쪽의 릴레이션 튜플만 반환                                   외부 조인(Outer Join)  자연 조인 시 조인에 실패한 튜플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환           종류 : 왼쪽 외부조인, 오른쪽 외부조인, 완전 외부조인                                              디비전(Division : ÷)  두 개의 릴레이션 R과 K가 있을 때 K 릴레이션의 모든 조건을 만족하는 경우의 튜플들을 릴레이션 R에서 분리해 내어 프로젝션하는 연산       관계 해석  수학의 프레디킷 해석(Predicate Calculus)에 기반  질의하는 형식으로 원하는 형태의 릴레이션을 정의하는 연산  구하고자 하는 정보가 무엇(What)이라는 것만 명시하는 비절차적 형태의 연산   관계 해석 기호     ∀ : 모든 것에 대하여(for all)   ∃ : 존재한다(There exist)   ∈ : t가 r에 속함( t ∈ r )   θ : 비교 또는 관계 연산자(=,≠, &lt;, ≤, &gt;, ≥)   ∨ : OR 연산자   ∧ : AND 연산자   ㄱ : NOT 연산자   튜플 관계 해석(Tuple Relational Calculus)  원하는 릴레이션을 튜플 해석식으로 정의하는 표기법      정의            {t[A], t[B] | F(t)}  F(t) : 정형식  / t : 튜플변수  / t[A] : 한정 속성            도메인 관계 해석(Domain Relational Calculus)  원하는 릴레이션을 도메인 해석식으로 정의하는 표기법      정의            { &lt;x1,x2,…,xn&gt;｜F(x1,…, xn, xn+1,…, xn+m)}   &lt;x1,x2,…,xn&gt;: 구해야 할 도메인 변수  F(x1,…, xn,…) : 정형식의 구성 원칙에 따라 구성된 식           ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-relational-operation/",
        "teaser": null
      },{
        "title": "[데이터베이스] SQL",
        "excerpt":"SQL(Structured Query Language)  ANSI, ISO에서 선정한 관계 데이터베이스 표준 언어  관계 대수와 관계 해석을 기초로 한 혼합 언어  데이터 정의, 조작, 제어 기능을 모두 갖추고 있다.  비절차식 언어이며 대화식 질의어로 사용 가능  다른 프로그램 언어(COBOL, PL/1, C, Pascal)에 삽입된 형태로 사용 가능   SQL에서 사용하는 테이블     기본 테이블  DDL에 의해 만들어지는 테이블로 독립적으로 존재하며 테이블명을 기록하게 되어 있다   뷰 테이블  역시 DDL에 의해 만들어지며 기본 테이블에서 유도되어 만들어지는 가상 테이블   임시 테이블  질의 처리과정에서 DML에 의해 만들어지는 테이블로 임시적으로 만들어지는 테이블   SQL에서 사용하는 자료형의 종류                  타입명       구분       설명                       BIT(N)       비트열       고정길이로 Bit단위로 할당                 VARBIT(N)       비트열       가변길이로 Bit단위로 할당                 CHAR(N)       문자열       고정 길이로 N개 할당                 VARCHAR(N)       문자열       가변 길이로 N개 할당                 SMALLINT       정수형       2바이트 고정 소수점 형식                 INT or INTEGER       정수형       4바이트 고정 소수점 형식                 FLOAT       실수형       4바이트 부동 소수점 형식                 DOUBLE       실수형       8바이트 부동 소수점 형식                 DECIMAL(i,j)       10진형       i는 10진수의 개수, j는 소수점 이하 자리수                 GRAPHIC(N)       그래픽형       그림 형태의 내용을 기억시킬 기억 장소 할당                 LOGICAL       논리형       TRUE, FALSE를 기억시킬 기억 장소                 DATE       날짜형       YY-MM-DD 형식                 TIME       시간형       HH:MM:SS 형식           SQL 명령어의 분류     데이터 정의어(DDL : Data Definition Language)            CREATE : 테이블/인덱스/뷰의 생성       ALTER : 테이블의 변경       DROP : 테이블/인덱스/뷰의 제거       TRUNCATE : 테이블 초기화           데이터 조작어(DML : Data Manipulation Language)            SELECT : 데이터 검색       UPDATE : 데이터 갱신       INSERT : 데이터 삽입       DELETE : 데이터 삭제           데이터 제어어(DCL : Data Control Language)            GRANT : 사용자에게 권한 부여       REVOKE : 사용자의 권한 해제           트랜잭션 제어어(TCL : Transaction Control Language)            COMMIT : 데이터를 데이터베이스에 저장하고 트랜잭션을 성공적으로 종료       ROLLBACK : 데이터의 변경사항을 취소하고 원상태로 복귀한 후 트랜잭션 종료           데이터 정의어  CREATE  테이블, 뷰, 인덱스 등을 생성할 때 사용   테이블 생성 구문  CREATE TABLE 테이블 명 ({속성의 멤버 정의...}) {[PRIMARY KEY 속성]} {[UNIQUE 속성]} {   [FOREIGN KEY 속성 REFERENCES 기본테이블] 속성   [ON DELETE {RESTRICT/CASCADE/SET NULL/SET DEFAULT}]   [ON UPDATE {RESTRICT/CASCADE/SET NULL/SET DEFAULT}]   [] } {[CHECK 조건식]}     NOT NULL : 널 값을 허용하지 않을 때 지정   PRIMARY KEY : 기본키를 구성하는 속성을 지정   FOREIGN KEY : 외래키로 어떤 릴레이션의 기본키를 참조하는지를 지정   RESTRICT : 동작이 취소(제한)됨   CASCADE : 연속으로 같은 동작을 수행   SET NULL : 모두 NULL로 바꿔주는 동작 수행   SET DEFAULT : 주어진 초기 값으로 설정   CHECK : 속성의 제약조건 지정   뷰 생성 구문  CREATE VIEW 뷰이름(속성)   AS SELECT (속성)     FROM 테이블명     [WHERE 조건식]   인덱스 생성 구문  CREATE [UNIQUE] INDEX 색인명   ON 테이블명 (속성 [ASC/DESC])   [CLUSTER]     UNIQUE : 색인화되어야 할 하나의 필드나 필드 조합이 중복되어서 같은 값이 나타나지 않게 하고자 사용   ASC/DESC : 명시하지 않으면 오름차순(ASC)으로 자동설정   CLUSTER : 색인 값과 물리적인 실제 데이터를 일치시킬 때 사용하는 옵션으로 하나의 테이블에서 한번빡에 생성할 수 없음   ALTER  생성된 기본 테이블이나 도메인의 정의를 변경하고자 할 때 사용하는 명령어   기본 구문  ALTER TABLE 테이블명   [ADD/ALTER/DROP/MODIFY] 변경하고자 하는 속성     ADD : 테이블에 속성 추가   ALTER : 도메인 정의 변경   DROP : 테이블에서 속성이나 제약조건 삭제   MODIFY : 속성의 데이터 유형, 제약조건에 대한 변경                     MODIFY COLUMN 시 고려사항           해당 컬럼의 크기를 늘릴 수는 있지만 줄이지는 못한다. 이는 기존의 데이터가 훼손될 수 있기 때문이다.           해당 컬럼이 NULL 값만 가지고 있거나 테이블에 아무 행도 없으면 컬럼의 폭을 줄일 수 있다.           해당 컬럼이 NULL 값만을 가지고 있으면 데이터 유형을 변경할 수 있다.           해당 컬럼의 DEFAULT 값을 바꾸면 변경 작업 이후 발생하는 행 삽입에만 영향을 미치게 된다.           해당 컬럼에 NULL 값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있다.                   DROP  테이블, 뷰, 인덱스의 정의를 제거   기본 구문  DROP TABLE 테이블 이름 [CASCADE | RESTRICT] DROP VIEW 뷰 이름 [CASCADE | RESTRICT] DROP INDEX 인덱스 이름   데이터 조작어  SELECT  테이블이나 뷰에 접근해서 원하는 튜플이나 속성을 검색하는 명령어   기본 구문  SELECT [COUNT/SUM/AVG/MAX/MIN](속성)    FROM 테이블명  SELECT [ALL(*)/DISTINCT] 속성 리스트   FROM 테이블명   [WHERE 조건식]   {     속성 BETWEEN 값1 AND 값2     속성 IS (NOT) NULL     속성 IN (도메인값:집합형태)     속성 LIKE '문자'   }   [GROUP BY 속성][HAVING 조건식]   [ORDER BY 속성[ASC/DESC]]     ALL(*) : 하나의 테이블에 있는 모든 속성 출력   DISTINCT : 중복을 제거하는 옵션   집계함수            COUNT : 해당 열이 있는 총 튜플의 개수       SUM : 해당 열에 있는 데이터의 합       AVG : 해당 열에 있는 데이터들의 평균       MAX : 해당 열에 있는 데이터 중 최대값       MIN : 해당 열에 있는 데이터 중 최소값           BETWEEN : 값1과 값2 사이에 해당하는 조건   IS (NOT) NULL : 값이 NULL일 경우(아닐 경우) 조건   IN : 연산자는 조건의 범위를 지정하는 데 사용된다. 값은 콤마( , )로 구분하여 괄호 내에 묶으며, 이 값 중에서 하나 이상과 일치하면 조건에 맞는 것으로 평가   LIKE : 문자열 연산으로 사용되며 부분적으로 일치하는 값을 검색(숫자로 되어있는 필드는 사용 불가)            ‘_‘(하이픈) : 한 문자의 대표 문자       ’%’(퍼센트) : 모든 문자의 대표 문자       예시)  ‘유__’ : 문자 ‘유’로 시작하는 3글자 검색  ‘유%’ : 문자 ‘유’로 시작되는 모든 문자열 검색           GROUP BY : 그룹 지정, 조건식으로 HAVING 문법 사용   ORDER BY : 정렬 검색, [ASC: 오름차순 / DESC : 내림차순]   INSERT  원하는 테이블에 원하는 튜플을 삽입시키는 연산   기본 구문  INSERT INTO 테이블명(삽입시킬 속성들)   VALUES(삽입시킬 속성에 삽입될 실제 값들)   UPDATE  테이블에서 원하는 속성값을 변경시키는 연산   기본 구문  UPDATE 테이블명 SET 속성=값 [WHERE 조건식]   DELETE  원하는 테이블에서 원하는 레코드를 삭제시키는 연산   기본 구문  DELETE FROM 테이블 [WHERE 조건식]   데이터 제어어  GRANT  사용자에 따라서 접근할 수 있는 DB데이터와 사용할 수 있는 기능을 제한   기본 구문  GRANT 권한(ALL PRIVILEGES/SELECT/UPDATE/INSERT ...) ON 데이터베이스.테이블  TO '아이디'@'호스트' IDENTIFIED BY '비밀번호' WITH GRANT OPTION  FLUSH PRIVILEGES;     WITH GRANT OPTION : 권한을 할당받은 유저가 GRANT 명령어도 사용할 수 있는 권한을 가지게 된다. 권한의 해제는 REVOKE GRANT OPTION 명령어를 사용한다.   REVOKE  REVOKE 권한 ON 데이터베이스.테이블 FROM 사용자  ","categories": ["study"],
        "tags": ["DB","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/database-sql/",
        "teaser": null
      },{
        "title": "[자료구조] 자료구조 기본",
        "excerpt":"자료구조(Data Structure)     문제 해결에 있어 가장 효율적으로 자료를 조직하고 구조화하며, 자료를 표현하고 연산하는 일련의 활동을 의미한다.    자료구조의 분류     선형구조(Linear)            스택(Stack)       큐(Queue)       데크(Deque)       배열(Array)       연결리스트(Linked list)           비선형구조(Non-Linear)            트리(Tree)       그래프(Graph)           자료의 표현     외부 표현            BCD 코드 : 6비트, 64가지 표현, 소문자는 표현 불가       ASCII 코드 : 7비트, PC와 데이터 통신에서 주로 사용       EBCDIC 코드 : 8비트, 대형 컴퓨터에서 주로 사용           내부 표현            수치 표현 : 컴퓨터 내부에 크기를 표현하기 위한 방법       포인터 표현 : 컴퓨터 내부에서 주소를 표현하기 위한 방법       논리 표현 : 긍정과 부정의 개념을 컴퓨터 내부에 표현하기 위한 방법           예외 표현 : 10진수 표현, 에러 검출, 데이터 송수신 등 용도로 사용            그레이 코드       3초과 코드       패리티 코드       해밍 코드           음수 표현 방식 컴퓨터 내의 연산 시 감산기(뺄셈)을 따로 만들지 않고 가산기(덧셈)만을 이용하여 덧셈과 뺄셈을 수행하기 위해 숫자자료는 보수 표현을 사용한다            부호화 절대치 : 첫 번째 비트가 0이면 양수이고 1이면 음수를 사용하는 방식                    수의 표현 범위 : -(2n-1-1) ~ 2n-1-1                       부호화된 1의 보수 : 양수의 1의 보수값을 음수로 사용                    수의 표현 범위 : -(2n-1-1) ~ 2n-1-1                       부호화된 2의 보수 : 양수의 2의 보수값을 음수로 사용                    수의 표현 범위 : -(2n-1) ~ 2n-1-1                           선형 구조     데이터를 저장시키는데 있어 데이터와 데이터를 1:1 대응 구조로 관계 맺어 저장시키는 형태의 구조를 의미    스택(Stack)  처음 입력시킨 자료는 맨 마지막에 출력되고 맨 마지막에 입력시킨 자료는 맨 처음에 출력되는 LIFO(Last in First Out)구조   한쪽에서만 입출력하는 구조      스택의 응용 분야            함수 호출이나 서브 프로그램 호출 시 복귀를 지정할 때       인터럽트 분기 시 복귀 주소를 저장할 때       되부름 시 복귀 주소를 저장할 때       수식을 연산할 때       수식의 후위 표기법 변환       0주소 명령어 형식의 자료 저장소           삽입 알고리즘 (PUSH)  IF TOP &gt;= M Overflow TOP ← TOP + 1 STACK(TOP) ← X   TOP 포인터가 전체 크기 M보다 크거나 같으면 오버플로가 발생하고 그렇지 않으면 TOP 포인터 값을 하나 증가시켜 원하는 자료 X를 스택의 TOP포인터 위치에 삽입   삭제 알고리즘 (POP)  IF TOP = 0 Underflow X ← STACK(TOP) TOP ← Top - 1  TOP 포인터가 0과 같으면 스택에 데이터가 없는 것이므로 언더플로가 발생하고 그렇지 않으면 스택에서 TOP 포인터 위치와 값을 X에 넣어 삭제시켜주고 TOP 포인터 값을 하나 감소시킨다.   큐(QUEUE)  먼저 입력된 자료가 먼저 출력되는 FIFO(First In First Out) 구조 또는 FCFS(First Come First Serve) 구조라 불린다.   한쪽 방향에서는 입력만 하고, 다른 한쪽 방향에서는 출력만 이루어진다.   삽입(Rear or Tail)과 삭제(Front or Head) 포인터 두 개를 두고 운용한다.  삽입 시 Rear 값을 증가 시키고 삭제 시 Front를 감소시킨다.      큐의 응용 분야            스풀 운용 처리에 사용       운영체제의 스케줄링 작업에 사용           삽입 알고리즘(Enqueue)   IF rear &gt;= M overflow QUEUE(rear) ← X rear ← rear + 1  Rear 포인터가 큐의 전체 크기 M보다 크거나 같으면 오버플로가 발생하고 그렇지 않으면 큐에서 Rear 포인터가 가리키는 위치에 X라는 자료를 삽입하고 삽입 포인터 Rear를 하나 증가시킨다.   삭제 알고리즘(Dequeue)  IF front = rear underflow X ← QUEUE(front) front ← front + 1  삭제 표인터 Front와 삽입 포인터 Rear가 같으면 데이터가 없는 언더플로가 발생하고 그렇지 않으면 큐에서 Front 포인터가 가리키는 위치의 값을 X에 치환하고 삭제 포인터 Front를 하나 증가시킨다.   데크(Deque)  포인터를 두 개 두고 운영(Left, Right)  양쪽끝에서 입출력이 일어나는 구조   입력 제한 데크는 스크롤(Scroll), 출력 제한 데크는 셀프(Shelf)   환형 큐(Circular Queue)  선형 큐는 front가 증가하여 Size 에 도달했을때 다시 빈 공간을 활용할 수 없다는 단점이 있는데,  이 점을 보완하여, 원형 큐를 사용하면 원형으로 배열 요소를 접근하게 하여 빈 공간에 다시 재할당이 가능해진다   큐가 가득 찬 경우와 큐가 비어있는 경우를 구분이 불가능한 단점  =&gt; 배열을 가득 채우지 않고 배열의 길이 N일 경우 N-1개 채워졌을 때 이것을 가득 찬 것으로 가정하여 해결   환형 큐의 상태 알고리즘  // Empty IF QUEUE → Rear == QUEUE → Front   EMPTY  // Full IF (QUEUE → Rear + 1) % QUEUE_SIZE == QUEUE → Front   FULL  // EnQueue IF FULL(QUEUE) Overflow QUEUE → Rear = (QUEUE → Rear + 1) % QUEUE_SIZE QUEUE → Data[QUEUE → Rear] = X  // DeQueue   IF EMPTY(QUEUE) Underflow QUEUE → Front = (QUEUE → Front + 1) % QUEUE_SIZE X = QUEUE → Data[QUEUE → Front]   배열(Array)  같은 크기의 기억 장소를 연속된 공간에 모아 놓고 원하는 데이터를 기록하거나 액세스하는 것을 의미      특징  엑세스 속도가 빠르다  삽입, 삭제가 어렵고 메모리에 종속적이다   연결리스트(Linked List)  자료를 구성할 때 포인터 자료를 포함해서 하나의 자료를 구성하는 형태로, 이 포인터를 이용해 현 자료와 관계있는 자료를 연결하는 형식으로 구성하여 저장      특징  액세스 속도가 느리다  중간에 단절되면 다음 노드를 찾기 어렵다  메모리에 대해 독립적이며 삽입, 삭제가 간편하다  메모리 단편화를 방지하여 기억 장소를 절약할 수 있다  포인터를 위한 추가 공간이 별도로 필요   비선형 구조  자료가 있을 때, 이 자료와 관계를 맺고 있는 다른 자료가 여러 개 존재하는 경우 이러한 관계성(1:N, N:M)을 표현하기 위한 구조   트리(Tree)  노드와 선분으로 되어 있고 정점 사이에 사이클이 형성되지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 구조   여기서는 트리의 용어와 종류만 간단하게 언급하고 다음 장에서 부가 설명을 할 계획      용어            근노드(Root Node) : 트리의 뿌리가 되는 노드       단노드(Terminal Node, Leaf) : 노드의 차수가 0인 노드 또는 자식이 없는 노드를 의미       간노드(Nonterminal Node) : 노드의 차수가 0이 아닌 노드 또는 자식을 가지고 있는 노드를 의미       차수(Degree) : 각 노드의 가지 수, 또는 각 노드가 가지고 있는 자식 노드의 수를 의미       트리의 차수(Tree Degree) : 트리 전체에서 노드의 차수가 가장 큰 것을 의미       레벨(Level) : 근 노드를 1레벨로 하여 차례로 2, 3 레벨로 증가하여 표시       깊이(Depth) : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수       높이(Height) : 트리의 총 레벨을 의미       자노드(Child Node) : 각 노드에 연결되어 있는 다음 레벨의 노드를 의미       부노드(Parent Node) : 각 노드의 바로 상위 레벨에 있는 노드를 의미       제노드(Sibling Node) : 같은 부노드에 연결되어 있는 노드를 의미       숲(Forest) : 트리가 모여서 이루어진 집합       서브 트리(Sub Tree) : 임의의 노드를 제거했을 때 생길 수 있는 트리의 집합을 의미           트리의 운행(Tree Traversal)            중위 운행(Inorder Traversal) : &lt;좌, 근, 우&gt; 순서로 운행       전위 운행(Preorder Traversal) : &lt;근, 좌, 우&gt; 순서로 운행       후위 운행(Postorder Traversal) : &lt;좌, 우, 근&gt; 순서로 운행       레벨 순서 순회(Level-order Traversal) = 너비 우선 순회(Breadth-First Traversal) : 노드를 레벨 순서로 방문하는 순회 방법       위 3가지는 스택을 활용하여 구현이 가능하며, 레벨 순서 순회는 큐를 활용하여 구현이 가능하다           종류            이진 트리       이진 탐색 트리(AVL)       레드 블랙 트리       스레드 이진 트리       B-트리, B+트리       이집 힙           그래프(Graph)  트리보다 더 일반적인 자료 구조이며, 그래프는 트리를 포함한다. 일반적으로 정점과 선분으로 되어있으면서 사이클이 형성되는 경우를 트리와 구별하여 그래프라 지칭      용어            그래프의 표시 : G = (V, E) {V: 정점들의 집합, E: 간선의 집합}       정점(Vertex) : 표현하고자 하는 대상 자료의 집합       간선(Edge) : 정점 사이에 관계       경로(Path) : 임의의 정점과 정점을 연결하는 경로       사이클(Cycle) : 경로의 길이가 2이상인 경로에서 종착점과 시작점이 같은 경로       차수(Degree) : 임의의 정점에 연결되어 있는 가지 수, 간선의 수                    진입 차수(In-Degree) : 정점으로 들어오는 간선의 수           진출 차수(Out-Degree) : 정점에서 나가는 간선의 수                       임의의 두 노드가 하나의 간선으로 연결돼 있을 경우, 이 노드들은 서로 인접(Adjacent)해 있으며, 간선은 두 노드에 부속(Incident)           그래프의 종류          비방향성 그래프(Undirected Graph)  간선 사이에 방향이 표시되지 않은 그래프. G(A, B)로 표현            방향성 그래프(Directed Graph)  간선 사이에 방향이 표시되어 있는 그래프. G&lt;A, B&gt;로 표현            완전 그래프(Complete Graph)  그래프를 구성한 모든 정점에서 자기 자신을 제외한 모든 정점에 대하여 간선이 있는 경우를 의미            레이블 그래프(Labeled Graph)  그래프에서 간선에 실수 레이블을 붙여 표시하는 그래프       그래프의 표현     인접 행렬   인접 리스트      ","categories": ["study"],
        "tags": ["자료구조","(구)정보처리기사","컴퓨터일반"],
        "url": "https://many258.github.io/study/datastructure/",
        "teaser": null
      },{
        "title": "[알고리즘] 최소신장트리(MST)와 그래프의 순회(Graph Traversal)",
        "excerpt":"신장 트리(Spanning Tree)  그래프 내의 모든 정점을 포함하는 트리  최소 연결 부분 그래프.   N개의 정점을 가지는 그래프의 최소 간선의 수는 N-1개이며, N-1개의 간선으로 연결되어 있으면 필연적으로 트리 형태가 이루어지고 이것이 바로 Spanning Tree라 할 수 있다.   하나의 그래프에는 많은 신장 트리가 존재할 수 있으며, 트리의 특수한 형태이므로 모든 정점들이 연결되어 있어야 하고 사이클을 포함해서는 안된다.   최소 신장트리(MST : Minimum Spanning Tree)  가능한 신장트리에서 간선의 가중치 합이 최소인 신장트리를 의미   최소 비용 신장 트리를 구하는 방법들은 모두 탐욕 알고리즘(Greedy Algorithm)으로 구현   ** 탐욕 알고리즘 : 각 단계에서 최선의 선택이 최종 단계에서도 최선의 결과를 나타낼 것이라고 생각하는 알고리즘   크루스칼 알고리즘(Kruskal’s Algorithm)  간선 위주의 알고리즘.      모든 간선들의 가중치를 오름차순으로 정렬   가중치가 최소인 간선을 선택   위에서 선택한 간선이 연결하려는 2개의 노드가 서로 연결되지 않은 상태라면, 2개의 노드를 서로 연결(이 때, 사이클이 발생하지 않도록 주의)   최소신장트리가 만들어지기 전까지 2~3 과정 반복 수행   그래프 내 간선의 개수가 적은 희소 그래프의 경우 크루스칼 알고리즘에 적합하다      프림 알고리즘(Prim’s Algorithm)  정점 위주의 알고리즘      임의의 정점을 선택   정점에 인접한 간선 중 가중치가 최소인 간선으로 연결된 정점을 선택   위 정점에서 다시 최소 간선으로 연결된 정점을 선택   최소신장트리가 만들어지기 전까지 2-3 과정 반복 수행   그래프 내 간선의 개수가 많은 밀집 그래프의 경우 프림 알고리즘이 적합하다      그래프의 순회(Graph Traversal)  하나의 정점에서 시작하여 그래프에 있는 모든 정점을 한번씩 방문하는 것을 그래프 순회 또는 탐색이라 한다   DFS(깊이 우선 탐색 : Depth-First Search)  아직 방문하지 않은 자식 노드를 우선적으로 탐색      정점 i를 방문한다.   정점 i에 인접한 정점 중에서 아직 방문하지 않은 정점이 있으면 이 정점을 모두 STACK에 저장한다   스택에서 정점을 삭제하여 새로운 i를 설정하고 다시 1단계부터 수행   스택이 공백이 되면 연산을 종료         특징                     현 경로상의 노드만을 기억하면 되므로 저장 공간의 수요가 비교적 적지만, 한 경로가 무한히 깊을 경우 오버플로우가 발생할 수 있다.  이를 방지하기 위해, 깊이에 제한을 두고 구현이 필요하다                        목표에 도달하지 못할 가능성이 존재하며, 도달할지라도 해당 경로가 최단 경로라고 보장할 수 없다.                   BFS(너비 우선 탐색 : Breadth-First Search)  형제 노드를 우선적으로 탐색하는 기법      임의의 시작 노드를 정해 QUEUE에 넣는다   Dequeue연산을 통해 큐에서 노드를 가져와 현재 노드로 정한다   현재 노드의 인접 노드 목록을 순회하면서 방문하지 않은 노드가 있는지 확인한다   방문하지 않은 노드가 있다면 그 노드를 큐에 넣고 방문한다.   큐가 공백이 될 때까지 2~4과정을 반복 수행         특징            큐에 다음에 탐색할 정점들을 저장해야 하므로 저장공간이 많이 필요       단순 검색속도가 DFS보다 빠르다       최단 경로를 보장함과 동시에 반드시 찾을 수 있다          ","categories": ["study"],
        "tags": ["Algorithm","컴퓨터일반","Programming"],
        "url": "https://many258.github.io/study/algorithm-MST-graph-traversal/",
        "teaser": null
      },{
        "title": "[자료구조] 트리의 종류 및 특징",
        "excerpt":"트리의 종류  이진 트리(Binary Tree)  기본적으로 자식노드를 최대 2개 가지는 트리를 의미   완전 이진 트리(Complete Binary Tree)  왼쪽 자식노드부터 채워지며 마지막 레벨을 제외하고는 모든 자식노드가 채워져있는 트리      힙(Heap)  부모 자식 노드 간의 대소 관계는 정의되어 있으나 형제간의 대소관계는 정의되어 있지 않은 완전 이진트리 자료구조를 의미   힙에는 두가지 종류가 있으며, 부모노드의 키값이 자식노드의 키값보다 항상 큰 힙을 ‘최대 힙’, 부모노드의 키값이 자식노드의 키값보다 항상 작은 힙을 ‘최소 힙’이라고 명명한다.      포화 이진 트리(Perfect Binary Tree)  모든 노드가 0 or 2개의 자식노드를 가지며 모든 리프노드가 똑같은 레벨에 있는 경우의 트리   레벨의 수를 N이라 가정할 때, 2n-1 개의 노드를 가진다.      정 이진 트리(Full Binary Tree)  모든 노드가 0 or 2개의 자식노드를 가지는 트리를 의미      편향 이진 트리(Skewed Binary Tree)  노드들이 전부 한 방향으로 편향된 트리를 의미      이진 탐색 트리(BST : Binary Search Tree)  이진트리의 구조와 자료의 검색/삭제/삽입에 효율적이게 정렬의 개념이 추가된 형태   기본적인 특징은 이진 트리와 같지만 하나 다른 점은 자기 왼쪽에는 자신보다 값이 작은 노드가, 오른쪽에는 자신보다 값이 큰 노드가 존재해야 한다      중회 순회(Inorder) 시 순차적으로 데이터가 정렬된다.   자가 균형 이진 탐색 트리(Self-Balancing Binary Search Tree)  이진 탐색트리는 저장과 검색에 평균 logN시간이 소요되지만 편향으로 구성되어있거나 균형이 무너지면 N에 근접한 시간이 소요될 수 있다.   그래서, 고안해낸 것이 균형잡힌 이진탐색트리이다. 대표적으로 AVL트리와 레드블랙트리가 있으며 최악의 경우에도 이진트리의 균형이 잘 맞도록 유지한다.      AVL트리는 더욱 엄격한 균형을 이루고 있기 때문에 Red-Black 트리보다 더 빠른 검색을 제공   Red-Black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어지지 않기 때문에 AVL트리보다 빠르게 삽입/제거 작업을 수행   AVL트리는 각 노드에 대해 BF를 저장하므로 노드 당 int 저장이 필요 Red-Black 트리는 노드당 1bit의 정보만 필요   AVL 트리  스스로 균형을 잡는 이진 탐색 트리   검색/삽입/삭제 평균과 최악의 경우 O(log N)의 시간복잡도를 가지며,  노드가 삽입 또는 삭제될 때 회전을 통해 트리를 재구성하여 높이 균형 성질을 유지시킨다   균형인수(BF : Balance Factor)를 구성하며 왼쪽과 오른쪽 서브트리의 높이 차를 나타낸다      BF = hL - hR    값이 -1, 0, 1일 때만 균형있는 트리라고 할 수 있다.      레드블랙 트리(RB Tree : Red-Black Tree)  레드-블랙 트리는 자료의 삽입과 삭제, 검색에서 최악의 경우에도 일정한 실행 시간을 보장한다.  이는 실시간 처리와 같은 실행 시간이 중요한 경우에 유용하며 일정한 실행 시간을 보장하는 다른 자료구조(대표적으로 STL의 Map)를 만드는 데에도 사용된다.      RB Tree는 다음과 같은 특성을 가진다.           각 모든 노드는 레드 or 블랙 색상을 갖는다            Root Property  트리의 루트는 항상 블랙이다            External Property  모든 리프 노드(NIL)들은 블랙이다            Internal Property  노드가 레드이면 그 노드의 자식은 반드시 블랙이다            Depth Property  특정 노드에서 아래에 있는 모든 NULL 노드까지의 경로에서 만나는 블랙 색상의 노드의 수가 동일하다       다원 탐색 트리 (MST : M-way Search Tree)  균형을 유지한다는 점에서 균형 이진 트리와 유사하지만 트리의 각 노드가 여러 개의 자료를 가질 수 있고, 하위 트리의 수를 임의로 설정 가능하다는 차이점이 존재한다.   MST는 한개의 노드에 여러개의 키가 있을 수 있다. 자식 노드에도 여러 개의 키가 들어갈 수 있다.      특징            각 노드는 0에서 최대 M개의 서브 트리를 가진다       K개의 서브 트리를 가지는 노드는 (K-1)개의 자료를 가진다(단, K&lt;=M)       각 노드 안에서 자료들은 검색 키에 의해 정렬           B-트리(B Tree)  M원 탐색 트리의 차수가 많아져서 트리의 높이도 증가하면 점점 비효율적으로 변하게 된다. 그래서 B-트리를 고안해 규칙이 있는 MST를 구상했다.   대량의 데이터를 처리해야 하는 검색 구조 주로 데이터베이스, 파일시스템에서 인덱스 저장 방법으로 사용하는 자료구조이다.   노드 내 데이터 수가 N개라면 자식 노드의 수는 (N+1)이며, 노드의 데이터는 항상 정렬된 상태여야 한다.   노드 내 최대 데이터 수에 따라 2차 B-Tree(2개), 3차 B-Tree(3개), …라 명명         특징            루트 노드의 자식 수는 2 이상이어야 한다       모든 단말노드는 같은 레벨을 가진다       Internal 노드는 ⌈M/2⌉이상 M이하의 자식을 갖는다.       각 노드의 원소 수는 최소[M/2-1]개 이상 최대[M-1]개를 가진다           B+트리(B Plus Tree)  B-트리는 특성상 순회 작업이 상당히 난감하다. B+ 트리는 색인구조에서 순차접근에 대한 문제의 해결책으로 제시되었다.   B트리의 특징을 가지고 있지만 모든 키 값들이 Leaf 노드에 정렬되어 있는 트리 구조.   Leaf 노드들은 연결 리스트 형태로 서로 연결되어 있고 이를 순차집합(sequence set)이라고 하며 오름차순으로 정렬이 되어 있다      B+ 트리의 비단말 노드(not leaf)들은 데이터의 빠른 접근을 위한 인덱스 역할 수행(Index Set)   오직 리프노드에만 데이터 저장 가능하고 리프 노드에 모든 데이터가 있기 때문에 키 중복이 있다   리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용 가능   하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.   B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다      B*트리(B Star Tree)  삽입 또는 삭제 작업 수행 시 발생하는 노드 분리를 줄이기 위해 노드의 약 2/3 이상이 채워지는 B트리.   노드가 꽉 차면 분리하지 않고 키와 포인터를 재배치하여 다른 형제 노드로 옮김      리프를 제외한 모든 노드는 m개의 서브트리 이상을 가질 수 없다   루트와 리프를 제외한 모든 노드는 적어도 [(2m-2)/3]+1개의 서브트리를 갖는다   루트는 리프가 아닌 이상 최소 2개, 적어도 2[(2m-2)/3]+1개의 서브트리를 갖는다.   모든 단말노드는 같은 레벨을 가진다   각 리프노드는 최소[(2m-2)/3]개, 최대 m-1개의 키 값을 갖는다   노드에 저장되는 자료가 넘치는 경우(Overflow), 일단 형제 노드들로 재분배하는 과정 수행. 모든 형제 노드들이 가득 찬 경우에만 B-트리의 분할 연산을 수행(보조 연산 최소화)   트라이(Trie)  문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조 주로 검색어 자동완성, 사전찾기, 문자열 검사에서 사용   원하는 원소를 찾을 때, 원소의 길이가 L일 경우 O(L)의 시간복잡도를 가진다.   빠르게 탐색이 가능하다는 장점이 있으나 각 노드에서 자식들에 대한 포인터들을 배열로 모두 저장하고 있다는 점에서 저장공간의 크기(공간복잡도)가 크다는 단점을 지니고 있다.      ","categories": ["study"],
        "tags": ["자료구조","컴퓨터일반","Programming"],
        "url": "https://many258.github.io/study/data-structure-tree-type/",
        "teaser": null
      },{
        "title": "[배민커넥트] 도보로 시작하기 및 주의사항과 소소한팁",
        "excerpt":"개요  몸이 굳어있던 추운 계절이 지나고 나들이나 운동을 하기 좋은 계절이 오고 있습니다.  하지만 코로나의 영향으로 아직까지는 헬스장을 가는게 꺼려지는 것은 제 주관적이지만 솔직히 말해서 사실입니다.   이 때, 배민커넥트를 시작하기에 최적의 시기라고 생각합니다.   필자는 걷는 것을 좋아해서 작년 여름에 주변 지인의 추천으로 배민 커넥트에 입문하였습니다.      간단히 말해, 내가 원하는 시간에 운동과 동시에 부수입을 얻을 수 있다는 것이 배민커넥트의 최대 장점이라 할 수 있겠습니다   마지막 이유로 현재 진행중인 친구초대 이벤트를 후술하겠습니다.   도보로 시작하기   다른 수단들과 비교하여 별다른 준비 없이 핸드폰, 보온가방, 튼튼한 두 다리만 있다면 가능하지만, 만약 ‘나는 수입이 목적이에요~’라는 사람이 있다면 권유는 드리지 않습니다.   커넥트의 장점은 내가 원하는 시간에 할 수 있다는 것이지, 수입을 목적으로 하기엔 어려운 면이 있습니다. 아무래도 당일 주문의 양에 따라 그 날 수입이 들쑥날쑥하고 한 건당 시간 소요가 크기 때문에 안타깝게도 어떤 날은 최저시급으로 계산한 것 보다 적게 지급받을 수도 있습니다.   가방과 보조장비들은 우아한스토어에서 구매(가방만 구매시 26,400원)를 하시거나 중고 마켓을 이용하는 것도 방법 중 하나입니다.   또한 매주 배송할 수 있는 20시간으로 제한되어 있으며 이는 수요일에 초기화되며 가장 중요한 정산은 별다른 공지가 없으면 매주 금요일에 진행됩니다. 정산의 경우 한 건 이상을 배달을 수행하였다면, 약 3천원 정도의 산재보험료가 부과된다는 점 알고 계시기 바랍니다.   마지막으로 산업안전보건법에 따라 PC에서 2시간의 안전보건교육 이수 후에 첫 배달을 시작할 수 있습니다.   무엇보다도 뚜벅이 커넥터일지라도 안전이 최우선으로 중요합니다!   배송 과정  처음 시도하는 입장에서 까다로울 것 같지만 한 두번 해보게 되면 전혀 어렵지않습니다.   주문을 받는 시스템으로 일반 배차, AI배차가 있으며   일반 배차의 경우 실시간으로 주문(콜)이 올라오며 커넥터가 이 콜을 직접 선택하는 방식이고   AI배차의 경우 AI가 경로를 파악하며 고객에게 예정 시간에 배달이 가능한지 등을 종합적으로 고려해서 특정 배달 주문을 수행하기에 가장 적합한 위치의 커넥터에게 우선적으로 콜을 보내는 방식입니다. 이 때, 약 30초간 선택할 수 있는 시간이 주어지고 시간이 초과될 때까지 결정을 못했다면 다른 커넥터/라이더에게 주문이 넘어갑니다.   필자는 다른 커넥터/라이더들과 경쟁으로 인해 빨리빨리 콜을 잡아햐하는 일반배차보다 품목을 세부적으로 꼼꼼히 확인할 수 있는 AI배차를 더 추천하는 바입니다.   실제 배송 과정은 다음과 같습니다.     신규배달 알림이 도착한다(AI배차로 선택한 경우)   알림을 눌러 배송가능한 품목들인지 확인을 한다   가능할 것 같다면 승낙을 누르고 다음 단계로, 어려울 것 같다면 거절을 누르고 1단계로 다시 돌아가 알림올 때까지 기다린다.   매장까지 이동하고 매장에 도착했다면 매장도착 버튼을 누른다   음식/물품이 완료될 때 까지 기다리고 주문번호 확인 후 받았으면 픽업완료를 누른다   고객에게 이동한 후 음식/물품을 건내주고 전달완료를 누른다               자세한 사항은 배민커넥트 홈페이지에서 확인하실 수 있습니다.   주의 사항  핸드폰은 생명이나 다름 없다  핸드폰이 방전되었다면 사실상 할 수 있는 것이 없습니다.   가능하다면 필히 보조배터리를 소지하고 다니고 만약 고장이 난 경우, 주변 사람들의 도움을 받아 배달의 민족 고객센터 1600-9880으로  연락 후 조치를 취하는 것이 가장 현명한 방법이라 생각합니다.   모든 항목을 꼼꼼히 검토한다. 욕심은 금물  배송 중에는 단지 힘들다고 또는 거리가 멀다고 중간에 그만두거나 배송 취소하기가 상당히 어렵습니다.   그래서, 항!상! 품목을 확인하고 내가 배송을 갈 수 있는 것인지 아닌지 판단하고 행동하는 것이 중요합니다. 자유에는 책임이 따른다는 명언이 생각나네요   또한 고객요청사항 중에 특히나 벨을 울리지 말아달라는 요청도 많으니 이 점 확실하게 유의해주셔야 합니다.   면/국물 요리는 자신이 있을 때 잡자  면/국물 요리는 특히 시간이 생명이라는 거 잘 알고 계실거라 생각됩니다.   도보커넥터들은 보통 다른 운송수단보다 상대적으로 시간이 더 소요되기 때문에 보온/보냉가방을 사용하고 있고 거리가 가까운 경우가 아니라면 다른 커넥터/라이더 분께 양보해드리는 게 더 좋을 것 같습니다.   현금/카드 결제는 미리 확인하자  비마트의 경우에는 무조건 선결제로 이뤄지지만 일반 매장일 경우 현금이나 카드로 결제를 신청하는 분들이 꽤 있으십니다.   그러므로, 배송수락 전 잔돈이 있는지 확인하는 것을 습관화합시다.   손님에게 직접 건네주지 않는 한 사진을 꼭 찍어두자  코로나로 인해 직접 대면하여 음식/물건을 전달하는 것보다 ‘집 앞에 놓아주세요’라고 요청하는 고객님들이 부쩍 늘었습니다.   어플 기능 중에 고객에게 사진 전송하는 기능이 있는데 실제로 고객님이 사용하는 어플에 푸쉬알림으로 전해지게 됩니다. 혹여나 음식이나 물건을 전달받았음에도 불구하고 받지 못했다고 클레임을 진행하는 고객이 있을 수도 있으니(한번도 만나보지 못했지만..) 배송업무를 끝내고 증거(?)로 남겨두는 목적입니다.   미세한 팁들  거점을 정하자  배민커넥트 카카오톡 플러스친구에서는 주마다 어느 지역에 배달이 많았는지 분포도로 알려주고 있습니다.   이를 참고하여 어느 지점을 타겟팅을 할 것인지 개방화장실의 위치정도는 미리 파악해두는 것이 도움이 될 것입니다.   점심시간과 저녁시간이 피크타임  가능하면 시간대를 12시 ~ 2시, 6시 ~ 8시로 움직이는 것을 추천합니다.   이 때가 가장 주문이 많은 편이며 각종 프로모션으로 배송비도 또한 많이 오르는 편입니다.   휴식할 곳을 미리 파악하자  뚜벅이 커넥터들은 항상 다리가 아픕니다.   배송이 끝난 후 남는 시간에 미리미리 휴식할 장소(특히 공원 벤치)을 찾아 체력을 비축해두는 것을 추천합니다.   만보기 어플을 이용하자  우리의 목표는 운동과 부수입이라는 두 마리 토끼를 잡는 것입니다.   이 만보기나 헬스케어 어플은 운동을 시각화해줌으로써 목표를 달성하면 하루의 보람을 느끼게 해주기도 하고 다음 날에도 계속 커넥트를 할 수 있게 끔 추진력과 원동력을 만들어 주기에 많은 도움을 줍니다.   웨어러블 장비를 마련하자  이건 진짜 알려주기 싫을 정도로 꿀정보라고 할 수 있는데 필자는 현재 미밴드를 착용하면서 커넥트를 하고 있습니다.   미밴드 뿐만 아니라 다른 스마트워치에도 대부분 존재하는 기능 중에 따로 지정한 어플에서 푸쉬알림이 오면 진동으로 알려주는 시스템이 있는데, 이 때, 핸드폰을 굳이 보고있지 않아도 알림이 오면 손목에서 진동으로 자칫 못보고 넘어갈 수 있는 알림을 알려주니까 확인하기 편해서 강력히 추천드립니다.   마치며..  앞서 말씀드린 것처럼 배민에서는 친구초대 이벤트를 현재 진행중입니다.   기존 이벤트의 경우 추천인 코드를 입력한 사람이 배송임무를 진행할 경우, 추천받은 사람과 추천한 사람 모두 1만원을 제공하였으나 금일부로(3월20일) 2만원으로 인상되었습니다.      이번에 한시적으로 진행하므로 이 기회에 지인과 함께 하시거나 저의 추천인코드(BC642005)와 한 번 도전해보시는 것도 좋은 선택이라 생각됩니다.   포스팅을 하는 지금 당장 생각나는 내용들은 이것으로 마무리하겠습니다.  블로그를 운영하지 얼마 지나지 않았고 글을 쓰는 재주도 없는 터라 많은 도움이 되셨는지는 모르겠습니다.   그 밖에도 궁금하신 내용이나 질문들은 제가 경험한 선에서 답해드릴 수 있으니 좌측이나 우측에 있는 카카오톡 오픈톡방 링크로 문의부탁드리겠습니다.   감사합니다 XD  ","categories": ["life"],
        "tags": ["배민커넥트"],
        "url": "https://many258.github.io/life/baemin-connect/",
        "teaser": null
      },{
        "title": "[알고리즘/데이터보안] 블록체인(Block-Chain)",
        "excerpt":"블록 체인  관리 대상 데이터를 블록이라고 하는 소규모 데이터들이 P2P방식을 기반으로 모여 이룬 체인 연결고리 분산 데이터 저장 환경   즉, 네트워크에 중앙 서버가 아닌 참여하는 모든 사용자가 모든 거래 내역 등을 공동으로 기록, 관리하여 데이터를 분산, 저장하는 기술을 의미      특징  편집이 불가능하고 추가 작업(APPEND)만 가능한 데이터베이스   탈중앙화(Decentralization) 데이터베이스의 복제본을 모두가 소유하고 있기 때문에 개인의 위조를 방지할 수 있다   블록의 구성       블록 헤더            블록의 정체성                    비전           이전블록의 해시 : 현재 블록이 이전 블록과 연결되어 있음을 의미           타임스탬프 : 채굴 경쟁과 직접적 연관이 있는 부분           난이도 목표 : 채굴 경쟁과 직접적 연관이 있는 부분           논스: 채굴 경쟁과 직접적 연관이 있는 부분           머클루트                           거래 카운터 : 거래의 개수   거래 : 블록에 기록된 거래 내역   해시      단방향 암호화, 결정론적   임의의 길이를 갖는 문자열을 입력받아 고정된 길이의 해시 값을 출력하는 함수를 해시 함수라 하는데 이 함수로 인해서 출력된 값을 해쉬 값이라 부른다. 이 때 해쉬 값으로부터 기존 메시지를 역산할 수는 없는 성질을 단방향성이라고 한다.   또한, 메시지가 다르면 비슷하다 할지라도 해시값도 다르다는 특징이 있는데 해당 특징으로 인해 해시 함수를 무결성을 확인하기 위한 방안으로 사용하며 결정론적이다라는 의미는 해시 알고리즘은 특정 입력 대해 항상 같은 해시 값을 반환한다는 것을 뜻한다.   일반적인 해싱 알고리즘은 MD4, MD5, SHA, RIPEMD, WHIRLPOOL, TIGER가 있다.   이전 블록 해쉬 + 데이터 =&gt; 자기 자신만의 블록 해쉬 값 이렇게 해쉬 값을 가지고 블록을 연결시킨다는 의미에서 체인이라는 단어를 사용하는 것이다.   데이터가 조금이라도 변경된다면 해쉬값도 변경되고 그 이후 블록에도 영향을 미치기 때문에 올바른 체인을 생성할 수 없게 된다.   블록체인을 사용하는 모든 사용자들이 같은 체인을 가지고 있으며, 각자의 체인을 비교함으로서 같은 체인인지 검증이 가능하다.   머클 루트(Merkle Root)      이진트리라는 이름으로도 알려져 있으며,   두 개씩 거래를 묶은 다음 해싱 알고리즘을 통해 해시 값으로 나타내고 또 그렇게 묶은 값들을 다시 두 개씩 묶어서 다시 해싱하여 수 백개의 거래 값들을 가장 꼭대기에 위치한 하나의 데이터로 만들어준다.   이렇게 이진트리 방식으로 구성하게되면 거래량이 기하급수적으로 늘어나도 특정 거래를 찾는 경로는 단순하다는 이점이 있다. 그렇기에 거래 내역을 위조하려는 시도가 있어도 머클트리의 경로를 따라가면 해시값이 다른 것이 나오게 되어 거래의 위변조도 쉽고 빠르게 알 수 있게 되고 이를 방지할 수 있다.   종류          퍼블릭 블록체인(Public BlockChain)  개방형 블록체인으로 누구나 트랜잭션을 생성할 수 있다            프라이빗 블록체인(Private BlockChain)  폐쇠형 블록체인으로 주로 기업에서 사용하기에 엔터프라이즈 블록체인(Enterprise BlockChain)이라고도 한다.서비스 제공자의 승인을 받아야만 참여가 가능한 방식            콘소시엄 블록체인(Consortium BloackChain)  프라이빗 블록체인을 확장한 방식으로 여러 기업또는 기관이 공동으로 참여한다.       작업증명(PoW : Proof of Work)  모든 블록(노드)가 포함된 거래 내역이 악의적인 공격자에 의해 변조되지 않은 올바른 블록체인을 공유하는 있다는 것을 입증하기 위해 P2P 네트워크, 공개키-개인키 암호, 공유된 데이터베이스에 정보를 저장하고 검증하는 방법을 관리하는 합의 알고리즘(Consensus Mechanism)이라는 것을 활용하는데 여러 종류 중에서도 비트코인의 경우 PoW(작업증명 : Proof of Work)라는 합의 알고리즘을 사용한다.   블록체인은 이와 같은 요소 기술들을 결합해 네트워크 상에서 투명성을 확보하며 데이터의 위조/변조 방지 및 보안성을 강화한 기술이다   마이닝(Mining)  PoW란 컴퓨팅 파워를 이용해 블록의 해쉬 값을 추적하여 블록체인 네트워크에 새로운 블록을 추가하는 방식의 알고리즘이다   위 과정이 채굴(Mining)에 해당한다.      비트코인의 경우  채굴자가 네트워크에 새로운 블록들을 추가할 때 마다 받을 수 있으며 새로운 블록들을 추가하기 위해서는 네트워크의 질문에 원하는 답을 찾아서 논스 값을 변경해야 한다.   논스(Nonce)는 채굴자가 변경할 수 있는 유일한 값이며 Nonce 값을 변경할 때 마다 해쉬 값이 달라지는데, 채굴자는 그중에서도 현재 난이도에 맞춰서 네트워크가 던지는 질문에 적절한 값을 가지는 해쉬를 만들어내야 한다.   활용     암호화폐 거래   ICO(Initial Coin Offering)   NFT(Non-Fungible Token)   DEX(Decebtrakuzed Exchange)   스마트 컨트랙트(Smart Contract)            사전에 정해진 임의의 규칙에 따라 디지털 자산을 자동적으로 이전하는 시스템 - Vitalik Buter                  블록체인이 지니고 있는 탈중앙화를 기반으로 금융거래, 부동산 계약, 공증 등 다양한 형태의 계약을 체결하고 이행하는 것. (블록체인 2.0)       다른사람들과의 교류와 코드로 소통이 가능하며 또한 공유 네트워크에 업로드할 수 있다       수정은 불가하나 공유/검증/실행은 가능하다       원하는 소스를 다 활용할 수 없음(블록체인 네트워크 위에서만 실행 가능)       신뢰 기반이 아닌 특수한 네트워크, 환경을 요구       스마트 컨트랙 지원 암호화폐  이더리움, Kusama, Polkadot, Cardano, Cosmos       개발자들은 이더리움 상에서 스마트 컨트랙트를 활용하여 암호화폐 지갑, 금융 애플리케이션, 마켓, 게임과 같이 새로운 종류의 탈중앙화된 애플리케이션(DApps)을 개발할 수 있다.           단점  블록체인 네트워크는 그 특성상 노드의 신뢰를 기반으로 하기 때문에, 신뢰가 무너지는 순간 블록체인 역시 급격하게 무너질 수 있다는 치명적인 맹점이 있다.   또한 참여하는 노드 수(분산되어 데이터를 저장되는 주체의 수)가 매우 적을 경우에 외부 공격자와 침입에 취약하다   탈중앙화, 보안성, 확장성의 문제로 이 세 가지 문제 중 어떠한 두 가지는 만족시킬 수 있지만, 남은 한 가지는 만족시킬 수 없는 트릴레마의 문제가 있으며 이 문제를 보완하기 위해 사이드체인, 샤딩, 인터체인, 라이트닝 네트워크, 플라즈마 기술이 있다.   레퍼런스  블록체인-개념-완벽-정리(뱅크샐러드)   머클트리란? - 불곰님 티스토리 블로그   블록체인의 이해   노마드 코더 유튜브  ","categories": ["study"],
        "tags": ["Algorithm","데이터 보안"],
        "url": "https://many258.github.io/study/block-chain/",
        "teaser": null
      },{
        "title": "[데이터보안] 재해복구시스템(DRS:Disater Recovery System)",
        "excerpt":"재해복구시스템(DRS : Disaster Recovery System)      천재지변이나 해킹 등 각종 재난/재해로 인해 IT 인프라에 장애가 발생하여 제 기능을 수행하지 못하게 되었을 경우, 서비스 연속성을 보장하기 위해 이를 대체하거나 복구하여 제 기능을 수행할 수 있도록 하는 시스템   재해복구 대책에 대한 법적인 규제 추세(금융감독원 권고안 발표)이다   구성 요소          BIA(Business Impact Analysis)  재해가 비지니스에 영향을 미치는 정도를 분석하는 작업            DOMAIN  영향도 별 그룹화(복구 우선순위 별 그룹화)            RTO(Recovery Time Object)  재해 상황에서 서비스가 복구되어야 할 최대 시간            RPO(Recovery Point Objective)  재해 상황에서 수용할 수 있는 최대 허용 데이터 손실            DR 센터 선정  주 센터와 복구 센터 위치 선정            백업 방안  Hot Standby, DB Shadowing, 원격 백업, OS 백업, 단순백업            운영 방안  조직체계, 평상시/재해시 운영절차, 모의 훈련 절차       기술적 요소             HA(고가용성 : High Availability)  서버와 네트워크 등의 정보 시스템이 지속적으로 정상 운영이 가능한 성질  2개의 서버 중 1대의 서버에서 장애가 발생하면 다른 서버가 대처  레이드(RAID) 방식과 샌(SAN) 방식을 주로 사용            결함 허용(FT)  시스템을 구성하는 푸품의 일부에서 결함(Fault) 또는 고장(Failure)이 발생하여도 정상적 혹은 부분적으로 기능을 수행할 수 있는 시스템            SAN(Storage Area Network)  대량의 데이터를 집중시켜 보관하고 이를 구성하는 장비들을 이용, 공유하여 사용할 수 있도록 하는 기술.  다만, 별도의 Fibre Channel 네트워크를 구성해야 한다            IP-SAN  기존의 TCP/IP 망을 그대로 이용하여 별도의 Fibre Channel 네트워크를 구성해야하는 기존 SAN의 단점을 보완, 속도는 크게 떨어지지 않는 기술            Fibre Channel(파이버 채널 : FC)  주로 스토리지 네트워킹에 쓰이는 기가 비트 속도의 네트워크 기술            WDM(파장 분할 다중화 :Wavelength Division Multiplexing)  한 가닥의 광섬유에 여러 채널을 통해 파장을 동시에 전송하는 기술            DWDM(Dense WDM)  일정 파장 대역에 걸쳐  수십, 수백개의 파장의 광 신호를 동시에 변조시켜서 하나의 광섬유를 통해 전송하는 WDM의 발전된 기술            CWDM(Coarse WDM)  DWDM과 유사하나, 파장 간격이 보다 넓고(~10nm 이상) 광증폭기를 잘 사용하지 않는 단거리 전송에 주로 사용       재해복구 구축 절차          업무 영향 분석  BIA, DOMAIN, RTO, RPO 등의 적용과정  재해로 인한 핵심 프로그램 들의 가동 중단 시 파급영향 분석 및 그에 따른 복구 우선순위를 설정            재해복구 전략 수립  대상 별 복구 전략, 복구 솔루션 선전 및 재해복구센터 선정            시스템 구축 및 복구 계획 수립  재해복구 시스템 구축 및 업무와 전산시스템의 복구를 위한 상세 계획 수립            운영 및 모의 훈련  수립된 계획의 주기적 테스트를 통한 미비점 파악 및 보완       계획 수립 시 고려사항          RSO(복구 목표 대상/범위 : Recovery Scope Objective)  정보의 중요성과 복구 우선순위 지정의 기본 지표가 된다            RTO(복구 목표 시간 : Recovery Time Objective)  시스템 복구까지 허용할 수 있는 최대 시간            RPO(복구 목표 지점 : Recovery Point Objective)  목표 복구 시점, 데이터 손실을 시간으로 환산한 개념            RCO(통신 복구 목표 : Recovery Communications Objective)  네트워크 복구 수준            BCO(목표 백업 센터 : Backup Center Objective)  백업 센터 구축 및 관리 방법       구축 형태          독자구축  단일 기관 전용의 DRS를 독자적으로 구축  보안 유지 및 복구의 신뢰성이 가장 높음  구축 및 유지비용이 가장 많이 소요            공동구축  두 개 이상의 기관이 DRS를 공동으로 구축 및 이용  비교적 적은 구축 및 유지비용  보안 및 운용 측면에서 고려할 사항이 많고, 광역재해 발생 시 공동이용기관간의 동시 재해복구 불가            상호구축  단일 기관의 여러 개 사이트 또는 두 개 이상 기관의 사이트 상호간 DRS의 역할을 수행  가장 적은 구축 및 유지 비용  상호 기관 작업에 종속  서로 다른 기관간의 보안성 및 재해복구에 대한 신뢰성이 낮음            외부위탁  재해 복구 전문 서비스 업체에 위탁하여 운영  전문기술 지원 가능  정보 유출, 보안 및 신뢰성 문제       시스템 구성요소 별 복제방식          H/W (Disk) 복제  디스크 간 복제  안정성/고성능, 높은비용  Shadow Copy, True Copy            S/W (OS) 복제  OS 수준 솔루션  안정성/효율성, 비교적 낮은 비용  Shareplex, Oracle Golden Gate            S/W (DBMS) 복제  DBMS 기능 기용  안정성/효율성, 비교적 낮은 비용  Orcle RAC       데이터 동기화 기법  스토리지 데이터 복제 방식  Active-Active 스토리지 방식  동기방식으로 스토리지 1, 2가 하나의 저장공간으로 ㄷ오작하며 웹서버1(Active), 웹서버2(Active)가 각각 로컬 스토리지에 Write/Read가 가능   구성 시 CWDM/DWDM으로 구현, 지연시간에 따라 센터간 50KM이내 권장   스토리지 데이터 동기 복제 기법  실시간 동기 방식(Synchronous Data Replication)  서버가 로컬 스토리지에 저장 시 원격 스토리지에도 저장 후 응답을 받고 나서 서버에게 최종 응답을 전달 - Zero RPO, 거리 제약(50Km ~ 300Km)   동기 복제 : SCSI(FC)는 한 번 동작이 메시지를 2차례를 주고 받는다. 즉, 50KM 거리에서 SCSI 한 번 동작 시 1ms 지연 발생   스토리지 데이터 비동기 복제 기법  비동기 방식(Asynchronous Data Replication)  서버가 로컬 스토리지에 저장 이후 리모트 스토리지에 저장 - 거리 제약 없음   수준별 유형  미러사이트(Mirror Site)     주 센터와 동일한 수준의 정보기술자원을 원격지에 구축, Active Active 상태로 실시간 동시 서비스 제공   복구소요시간(RTO) : 즉시   데이터 최신성, 높은 안정성, 신속한 업무 재개   높은 초기투자비용, 높은 유지보수 비용, 데이터 업데이트가 많은 경우 과부하 야기   핫사이트(Hot Site)     주센터와 동일한 수준의 정보기술자원을 원격지에 구축 후 Active Stanby 상태로 유지   재해 발생 시 Active 상태로 전환   데이터는 동기적 또는 비동기적 방식으로 실시간 미러링을 통하여 최신상태 유지   복구소요시간(RTO) : 수 시간 이내   데이터 최신성, 높은 안정성, 신속한 업무 재개, 데이터 업데이트가 많은 경우 적합   높은 초기투자비용, 높은 유지보수비용   웜사이트(Warm Site)     중요성이 높은 정보기술자원만 부분적으로 재해복수센터에 보유   데이터는 주기적으로 백업   복구소요시간(RTO) : 일 단위 ~ 주 단위   구축 및 유지비용이 핫사이트에 비해 저렴   데이터 손실 다소 발생, 초기복구수준이 부분적, 복구소요시간이 길다   콜드사이트(Cold Site)     데이터만 원격지에 보관하고 이의 서비스를 위한 정보자원은 확보하지 않거나 장소 등 최소한으로 확보   재해 발생 시 데이터를 근간으로 필요한 정보자원을 조달하여 정보시스템의 복구 개시   데이터는 주기적으로 원격지에 백업   복구소요시간(RTO) : 주 단위 ~ 달 단위   구축 및 유지비용이 가장 저렴   데이터 손실 발생, 복구에 매우 긴 시간 소요, 복구 신뢰성이 낮다   DRS 도입 효과          재무적 관점  ROI, TCO  서비스 연속성을 통한 투자 대비 효과  비용 증가 대비 가시성 효과 증대            고객 관점  위험 대비 체계적 고품질 서비스  서비스 안정화로 고객 만족            프로세스 관점  서비스 안정성 기반 생산성 증대  체계적 관리로 업무 효율성 향상       BCP(Business Continuous Planning)과의 비교                  구분       DRS       BCP                       적용시점       재해 사후       재해 사전/후(평시, 비상시 연속)                 목적       정보시스템 인프라와 사업 운영에 필수적인 정보자산의 복구를 촉직하기 위한 상세한 절차를 제공       심각한 중단 상황에서 복구가 진행되는 동안에 필수적인 사업을 유지하기 위한 절차를 제공                 범위       IT서비스 중심. BIA에 따른 RTO, RPO를 고려한 서버, 스토리지, 네트워크 구축       실제의 업무 프로세스와 업무 프로세스를 지원하기 위한 IT 영역에 집중                 실행 주체       정보시스템 부서가 절차중심으로 수행       각 비지니스 부서가 계획중심으로 수행                 대상       IT운영팀을 중심으로 운영시설을 사업단위 중심으로 수행       업무는 물론 사람, 물리적 사무공간, 중요 문서등을 포함하여 사전에 준비하기 어려운 수많은 항목이 대상                 구축 결과물       DRP(Disaster Recovery Plan)과 사전 계획 문서       재해복구계획, 업무복구계획, 대체프로세스계획, 업무비상계획           레퍼런스   도리의 디지털 라이프   바보상자의 개발 블로그  ","categories": ["study"],
        "tags": ["데이터 보안"],
        "url": "https://many258.github.io/study/disaster-recovery-system/",
        "teaser": null
      },{
        "title": "[프로그래밍] 함수형 프로그래밍",
        "excerpt":"함수형 프로그래밍  함수의 동작에 의한 변수의 부수적인 값 변경을 원천 배제함으로써 오류를 방지하는 패러다임   함수 내부에 상태가 존재하지 않으며, 함수의 출력 값은 항상 함수의 입력 값의 영향만 받는다      높은 표현력을 통해 불필요한 코드를 줄일 수 있다.   함수형 프로그래밍의 언어군은 프로그래밍 언어론의 최신 연구 결과를 반영하고 있다   불변성(Immutability)으로 인해 다양한 최적화 및 검증이 용이   이전에 계산한 함수의 값을 캐싱해 두었다가 필요할 때 다시 사용하는 메모이제이션이 가능   함수형 프로그래밍 언어에서는 변경 가능한 상태를 원천적으로 배제하기 때문에 멀티프로세서, 멀티스레드 환경에서 동작하는 동시성 프로그램을 개발할 때 용이   대표 함수형 프로그래밍 언어 : Scala, LISP, Haskell, F#, Erlang   일급 객체  다음 조건을 만족하면 일급 객체라고 할 수 있다.     변수나 데이터에 할당할 수 있어야 한다   객체의 인자로 넘길 수 있어야 한다   객체의 리턴값으로 리턴할 수 있어야 한다   즉, 객체처럼 동작할 수 있는 함수를 지칭한다   순수 함수     항상 같은 인풋에는 항상 같은 아웃풋(멱등성, 참조 투명성)    외부의 인자를 변화시키지 않고 최대한 지역변수만을 사용해서 구현되는 함수   고차 함수 = 고계 함수  함수를 값이라 생각하고 함수를 인자값으로 넣어주는 형태   인자로 다른 함수를 받아 결과값을 내보내는 함수를 의미   커링  여러 인자를 받는 함수에 일부 인자만 넣어서 나머지 인자를 받는 다른 함수를 만들어낼 수 있는 함수형 프로그래밍 기법을 의미   함수 합성  함수형 프로그래밍을 위한 라이브러리들에는 컬렉션 내 요소들을 다양하게, 연속적으로 처리할 수 있는 많은 도구   새로운 함수를 생성하거나 어떤 계산을 수행하기 위해 둘 이상의 함수를 결합하는 프로세스이다   재귀와 꼬리 재귀 최적화   모나드(Monad)     모나드는 값을 캡슐화하고, 추가 기능을 더해 새로운 타입을 생성하는 구조체    모나드는 하나의 타입이며 인자를 Type 타입으로 받아 값을 캡슐화하여 값을 가공할 수 있는 추가기능 오퍼레이터를 사용할 수 있는 Functor를 사용하여 최종적으로 이러한 프로세스를 구현하는 구조를 새롭게 생성하는 특징을 가지고 있다.   다음 세 가지를 충족하면 모나드라 할 수 있다.     타입을 인자로 받는 타입   unit(return) 오퍼레이터가 있어야 한다   bind 오퍼레이터가 있어야 한다   모나드가 필요한 이유 ?   비동기 연산 처리, NULL 처리           Map  컬렉션의 원소를 순회하는 방법의 의미보다  T 타입의 Functor를 R 타입의 Functor로 바꾸는 기능이라고 생각하는 중요!            flatMap  위 맵의 역할을 하지만 캡슐화가 된 자료구조를 Serialize했다고 생각하면 편하다       import java.util.function.Function;  interface Functor&lt;T&gt;{   &lt;R&gt; Functor &lt;R&gt; map(Function&lt;T, R&gt; f); }  # 1. 함수를 인자를 받는 map 메소드만 가진다 # 2. 타입 인자 &lt;T&gt;를 가짐 # 3. 전달인자인 함수 f는 &lt;T&gt; 타입 값을 받아 &lt;R&gt; 타입 값을 반환하는 함수 # 4. Functor는 map함수를 거쳐 &lt;R&gt; 타입의 Functor를 반환   map메소드로 값을 변경하는 것 뿐인데 왜 Functor를 사용할까?  =&gt; Functor를 이용하면 일반적으로 모델링할 수 없는 상황을 모델링 할 수 있다.      타입안정성을 유지하면서 NULL을 인코딩하는 방법   아직 값을 가지고 있지 않아도 동일하게 map 메소드를 적용할 수 있음 (문법적으로나 의미적으로 완전 동일)   비동기 로직을 동기 로직을 구현하는 것과 동일한 형태로 구현하면서도, 함수의 합성 및 완전한 Non-Blocking Pipeline을 구현 가능      Functor의 문제점  =&gt; Functor가 Functor안에 감싸져 있으면, 함수의 합성과 체이닝을 저해하므로 제 기능을 하지 못하게 될 수 있음   Monad = Functor + flatMap   interface Monad&lt;T, M extends Monad&lt;?, ?&gt;&gt; extends Functor&lt;T, M&gt;{   M flatMap(Function&lt;T, M&gt; f); }   지연 연산(Lazy Evaluation)  어떤 값이 실제로 쓰이기 전까지 그 값의 계산을 최대한 연기하는 것을 의미.   값을 미리 계산하여 저장하지 않기때문에 공간을 절약할 수 있고 값이 꼭 필요할 때만 계산하기 때문에 프로그램 성능에도 긍정적인 영향을 준다.   ","categories": ["study"],
        "tags": ["Programming"],
        "url": "https://many258.github.io/study/functional-programming/",
        "teaser": null
      },{
        "title": "[소프트웨어공학] 소프트웨어 설계",
        "excerpt":"설계의 기본 개념  소프트웨어 설계 절차     DFD, DD 분석   외부 설계  파일 설계, 입출력 설계 등 S/W의 내적인 기능보다는 외부적은 특성을 설계   내부 설계(기본설계)  S/W의 내부 설계이며 주로 모듈의 기능을 정의하거나 모듈 간의 관계를 정의하는 설계   내부 설계(상세설계)  모듈 내부의 알고리즘을 정의   설계 명세서   설계 모형     문서량 기준                     데이터(Data) 설계  요구분석의 자료 사전(DD, 메타 데이터)을 분석                        구조(Architectural) 설계  구조도 작성(외부 설계)                        관계(Interface) 설계  모듈 간의 관계를 표현(기본 설계)                        절차(Procedure) 설계  PDL로 알고리즘을 작성(상세 설계)                   노력 기준            절차 설계       관계 설계       구조 설계       데이터 설계           설계의 종류     상위 설계(High-Level Design) : 아키텍처/예비 설계, 하위 설계를 위한 바탕            구조 설계       DB 설계       인터페이스 설계           하위 설계(Low-Level Design) : 시스템 수준에서의 소프트웨어 구성 컴포넌트 간의 관계            컴포넌트 설계       자료구조 설계       알고리즘 설계           구조적 설계의 원칙          모듈화(Modularization)  단일 기능을 갖출 수 있도록 부분적으로 묶어서 처리하는 기술  단위 프로그램, 함수, 서브 프로그램을 작성하기 위한 설계 기법       추상화(Abstraction)  세부적은 설계를 배제하고 전체 흐름과 구조를 알아볼 수 있도록 개관적인 설계부터 점차 세부적으로 진행하는 설계 기법            기능 추상화 : 수행의 흐름만을 정의       제어 추상화 : 선택, 반복, 분기 등의 설계를 추상화       자료 추상화 : 변수 및 레코드 등을 추상화                구조화(Structured)  모듈을 수행하기 위한 위치나 시기를 전체 구조에 적절하게 배치시키는 설계 기법            정보 은닉(Information Hiding)  모듈 간의 관계성을 최소화시키는 설계 기법.(S/W 변경 용이)  설계상의 결정 사항들이 각 모듈 안에 숨겨져 있어 다른 모듈이 접근하거나 변경을 못한다            분할과 정복  Bottom-Up 방식으로 작은 시스템을 개발하고, 이를 합쳐 큰 시스템을 만든다       단계적 분해  하향식 설계에서 사용. 문제를 상위 수준에서 점증적으로 더 구체적인 하위 수준으로 분할하는 기법            문제를 하위 수준의 독립된 단위로 나눈다       구분된 문제의 자세한 내용은 가능한 뒤로 미룬다       점증적으로 구체화 작업을 계속한다           좋은 설계     요구사항을 모두 표현(완전성)   유지보수하기 쉽고(변경이 용이) 가독성이 좋고 객관성 있게 작성   구현 관점에서 데이터/기능/행위 영역을 설명하는 완전한 그림을 제공   모듈적이어야 하며, 두 모듈 간의 상호 의존도는 약하게 해야 한다   모듈화  모듈의 특징     구현, 컴파일, 설계는 독립적으로 수행, 실행은 종속적으로 수행   다른 모듈을 호출할 수도, 호출당할 수 있다   모듈 호출 시 매개변수를 전달하거나 전달받을 수 있다   모듈화의 장점     단위 프로그램을 독립적으로 설계할 수 있기 때문에 설계가 용이   모듈만을 구분하면 되므로 프로그램의 복잡도를 감소   다른 모듈에 영향을 주지 않을 수 있으므로 수정이 용이   공유도 / 제어도     공유도(Fan-in) 얼마나 많은 모듈이 주어진 모듈을 호출하는가를 나타내는 척도.   제어도(Fan-out) 주어진 모듈이 호출하는 모듈의 개수   모듈의 응집력(Cohesion)  모듈 안의 요소들이 서로 관련되어 있는 정도로 강할수록 좋은 설계(좋은 설계 순서)           기능적(Functional) 응집  모듈 내부가 하나의 단일 기능으로 존재하는 경우            순차적(Sequential) 응집  모듈 내부의 루틴들이 이전의 명령어로부터 나온 출력 결과를 그 다음 명령어의 입력자료로 사용하는 경우            교환적(Communication) 응집  모듈 내부의 루틴들이 작업 대상이 같은 기능끼리 존재하는 경우나 동일한 입력과 출력을 사용하는 작업들이 모인 경우  예시) 하나의 파일을 대상으로 갱신 작업을 하는 루틴끼리 묶인 루틴            절차적(Procedural) 응집  모듈 내부의 루틴들이 수행 시기에 순위가 있는 기능끼리 존재하는 경우            시간적(Temporal) 응집  모듈 내부의 루틴들이 시간상으로 수행 시기가 같은 기능끼리 존재            논리적(Logical) 응집  모듈 내부의 루틴들이 같은 범주에 속하는 기능끼리 묶은 모듈.  유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 하나의 모듈로 형성            우연적(Coincidental) 응집  모듈 내부의 루틴들이 뚜렷한 관계없이 묶인 경우       모듈의 결합도(Coupling)  두 모듈 간의 관계성(상호 의존성)의 척도로, 약할수록 좋은 설계(좋은 설계 순서)           자료(Data) 결합도  두 모듈 간의 인터페이스가 자료 요소만으로 구성된 결합도  Call By Value 기법으로 결합된 모듈            구조(Stamp) 결합도  두 모듈 간의 인터페이스로 배열이나 레코드같은 자료 구조가 전달            제어(Control) 결합도  호출 모듈에서 전달된 자료에 의해서 운용되는 피 호출 모듈의 관계(종속적인 관계)            외부(Extern) 결합도  외부 변수에 의해 영향을 받는 두 모듈이 결합된 관계. 전역 변수 관련            공통(Common) 결합도  공유되는 공통 데이터 영역을 여러 모듈이 사용하는 모듈 관계.  Call By Referrence, 메모리 번지의 공유            내용(Content) 결합도  모듈이 다른 모듈 내부 기능 및 그 내부 자료를 참조하는 형태의 결합       구조적 설계 표기법  N-S(Nassi-Schneiderman) Chart  IBM사에 의해 개발되었으며 입출력 자료와 소프트웨어 모듈들 사이의 관계를 표현하는 뛰어난 능력을 가지고 있다.      고려사항            도표는 항상 직사각형       도표의 제어 흐름은 맨 위에서 시작       제어 흐름은 위에서 아래로 흐른다(하향식)       수평으로 그어진 줄은 모두 평행이 되어야 한다       사각형 안의 내용이 수행된 후에는 아래 방향으로 빠져나온다       사각형에 빈 공간이 있을 수 있다                 특징            논리적 기술에 중점을 둔 도형을 이용한 표현 방법       연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현       임의의 제어 이동이 어렵다       상자 도표라고도 하며 프로그램으로 구현이 쉽다       조건이 복합된 곳의 처리를 시각적으로 명확히 식별하는데 적합           HIPO(Hierarchy plus Input Process Output)  IBM에서 개발한 방법으로 프로그램을 기능 위주로 문서화하는 하향식 설계 기법.   입력/처리/출력으로 구성되어 시각적으로 알아보기 쉽게 표현할 수 있으며 구조화된 방법으로 구현될 수 있도록 한다.      종류                     도식 목차(가시적 도표, Visual Table of Contents)  전체적인 흐름과 구조를 나타내는 도표                        총괄 도표(총체적 도표, Overview Diagram)  입력/처리/출력 등의 기능을 명확히 표현한 도표(사용자관점)                        상세 도표(세부적 도표, Detail Diagram)  총괄 도표의 일부 기능을 구체적으로 표현한 모듈 도표(개발자관점)                   특징            분석 및 설계 도구로 사용       하향식(Top-Down) 개발에 적당       수정 및 유지보수가 용이       소규모 프로젝트에 적합       기능과 자료의 관계를 동시에 표현할 수 있다           설계 방법론  구조적 설계 방법론     기본구조            순차(Sequence) 구조       선택(Condition) 구조       반복(Repetition) 구조           특징            단일 입출력으로 처리       실행 효율성을 중시할 때 한정된 범위 내에서 GOTO문을 사용       프로그램의 이해가 쉽고 유지보수와 검증이 용이           자료 흐름 중심 설계 방법론     자료 흐름 설계 과정            정보 흐름의 유형을 설정       흐름의 경계(Flow Boundaries)를 표시       자료 흐름도를 프로그램 구조로 사상 → 변환 사상       제어 계층을 분해시켜서 정의       경험적 방법을 구체화           변환 사상(Transform Mapping)  변환 흐름에 특성을 갖는 DFD(Data Flow Diagram) 을 전체 혹은 일부를 분할해서 구조도로 변화하는 작업   자료 구조 중심 설계 방법론  입출력 자료의 구조 파악으로 소프트웨어 구조를 추출   DSSD 방법론 (Warnier-Orr 기법)  Warnier가 개발한 LCP(Logical of Program)를 Orr와 공동으로 개발한 자료 구조 지향 설계 방법으로 출력 자료를 중심으로 입력 자료를 설계하고 제어 구조도 설계하는 방법      출력 자료 정의 : 출력할 자료를 파악하여 배열   논리적 레코드 정의 : 출력할 레코드의 구조를 정의   사건 분석 : 출력할 레코드 항목을 기준으로 입력 항목을 정의   물리적 레코드 정의 : 입력할 레코드의 구조를 정의   논리적 절차 정의 : 입력/처리/출력 모듈로 구분하여 Warnier-Orr 도표를 그림   물리적 절차 정의 : 명시된 도표를 보고 알고리즘 기술   JSD 방법론 (Jackson 기법)  프로그램의 입력과 출력 자료의 구조를 대응시켜서 설계하는 자료 구조 지향 설계 방법론으로 자료 구조를 정의하면서 제어 구조를 유도하는 방식      자료 구조 정의  입출력 구조를 정의하여 일치되지 않는 부분을 처리 루틴으로 모듈화하고 일치하는 부분은 입력과 출력 루틴으로 모듈화   구조도 작성  입력/처리/출력으로 분류하여 잭슨 표기법으로 구조도를 세분화하여 작성        연산 목록 작성    구조도를 보고 필요한 제어 구조 명시       구조문 작성    명시된 제어 구조를 보고 알고리즘 기술   소프트웨어 설계 SOLID 원칙  Single Responsibility Priciple(단일 책임 원칙 : SRP)     소프트웨어의 설계 부품은 반드시 한 개의 책임을 가져야 한다는 원칙    책임 대신 기능이라 해석해도 무방하다.   Open-Closed Principle(개방 폐쇠 원칙 : OCP)     기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야한다는 원칙    한 번 설계가 되고 단위 테스트가 완료된 객체는 향후 외부에 변경 사항이 발생하더라도 객체 자체는 변경되지 않아야 한다는 것을 의미   Liskov Substitution Principle(리스코프 치환 원칙 : LSP)     자식 클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다는 원칙    MIT 컴퓨터 사이언스 교수인 리스코프가 제안한 설계 원칙으로 상속관계에 있는 두 객체에 있어서 부모 클래스의 인스턴스가 사용된 자리에 자식 클래스의 인스턴스를 넣어도 코드의 맥락이 변하지 않아야 한다는 것을 의미한다.   자식 클래스가 부모 클래스를 대체하기 위해서는 부모의 기능에 대해 오버라이드되지 않도록 하면 된다. 즉, 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않과 확장만 수행하도록 해야 LSP를 만족하게 된다.   LSP의 만족 여부는 [자식 클래스 is a kind of 부모 클래스]의 참/거짓으로 간단히 파악이 가능   Interface Segregation Principle(인터페이스 분리 원칙 : ISP)     객체 자신이 사용하지 않을 인터페이스는 구현하면 안된다는 원칙    즉, 자신이 사용하지 않는 기능에는 영향을 받지 말아야 한다는 것을 의미한다   가능한 경우라면, 범용 인터페이스를 구현하는 것보다 객체에 특화된 인터페이스를 분리해내어 구현한다.   Dependency Inversion Principle(의존 역전 원칙 : DIP)     의존 관계를 맺을 때, 변화하기 쉬운 것(구체화)보다 변화하기 어려운 것(추상화)에 의존해야 한다는 원칙    구체적인 클래스보다 추상성이 높은 인터페이스나 추상클래스와 관계를 맺는다는 것을 의미. 일반적으로 Interface를 활용 시 이 원칙을 준수할 수 있다.   ","categories": ["study"],
        "tags": ["SW Engineering"],
        "url": "https://many258.github.io/study/software-engineering-sw-design/",
        "teaser": null
      },{
        "title": "[소프트웨어공학] 비용 산정 방법론",
        "excerpt":"소프트웨어 개발비용 산정기법   상향식  단계별로 측정한 결과들을 모아서 총비용을 측정하는 방법      LOC 기법 (원시 코드 라인 수 : Line Of Code)  프로젝트의 각 기능별 라인 수를 측정(비관치, 기대치, 낙관치)하여 비용을 산정하는 방법            비관치 : 기능을 코딩할 때, 가장 많이 측정된 라인 수       기대치 : 기능을 코딩할 때, 제시한 측정된 라인 수의 평균       낙관치 : 기능을 코딩할 때, 가장 적게 측정된 라인 수       예측치 : $\\frac{(비관치 + 4 \\cdot 기대치 + 낙관치)}{6}$       평방 편차 : $({\\frac{(비관치-낙관치)}6})^2$           개발 단계별 인월 수 방법  LOC 기법을 보완하기 위한 방법으로, 각 기능을 구현시키는데 필요한 노력을 생명주기의 각 단계별로 산정   수학적 산정 기법     Walston Felix 모형  60여 개 개발 업체의 다양한 규모의 프로젝트 비용 측정 자료를 모아 통계적으로 분석한 공식으로 개발 비용을 측정하는 방법  인월 수를 계산하는데 KDSI(원시코드에서 주석라인, 라이브러리 루틴, 공백을 제외한 실제 수행 코드 라인 수)를 사용한다            COCOMO 비용 산정 공식의 모체이다           COCOMO(COnstructive COst MOdel)  Boehm이 제시한 원시 프로그램의 규모에 의한 비용 예측 모형 변화 모형과 규모 유형이 존재한다            변화 모형                    Basic : S/W 크기 + 개발 유형           Intermediate : Basic Model + 가중치           Detailed : Intermediate Model + 시스템 세분화                       규모 모형                    Organic(유기형)                            인월(MM) = $2.4 \\times [KDSI]^{1.05}$  개발기간(TDEV) = $2.5 \\times [KDSI]^{0.38}$                                    Semi-detached(준 분리형)                            인월(MM) = $3.0 \\times [KDSI]^{1.12}$  개발기간(TDEV) = $2.5 \\times [KDSI]^{0.35}$                                    Embedded(내재형)                            인월(MM) = $3.6 \\times [KDSI]^{1.20}$  개발기간(TDEV) = $2.5 \\times [KDSI]^{0.32}$                                                         PUTNAM  시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 한다  개발 기간이 연장될수록 프로젝트 적용 인원의 노력이 감소하므로 대형 프로젝트의 노력 분포 산정으로 적당  Putnam 모형을 기초로 해서 만든 자동화 추정 도구는 SLIM이다              MM = $\\frac{DSI^3}{[개발 기술 지수]^3 \\times [개발 기간]^4\\frac{3}{4}}$  LOC =  $[개발 기술 지수] \\times[총인월]^{\\frac{1}{3}} \\times [개발 기간]^{\\frac{3}{4}}$            Albrecht 모형(기능점수, FP)  프로젝트를 기능 별로 분해하고 경험을 바탕으로 단순/보통/복잡한 정도에 따라 가중치를 부여  요인별 가중치를 합산하여 총 기능점수 산출  총 기능점수와 영향도를 이용하여 실질 기능 점수를 구한 후 최종 비용 산정  FP 모형을 기초로 하여 개발된 자동화 도구는 ESTIMACS            실질 기능 점수(FP) = $총기능점수 \\times [0.65+ (0.1 \\times 총영향도)]$            하향식  프로젝트의 총비용을 측정한 후 단계별로 비용을 세분화하는 방법      전문가 감정 기법            조직 내 경험이 많은 두명 이상의 전문가에게 비용산정 의뢰       의뢰자로부터 신뢰를 얻을 수 있다       새로운 프로젝트와 유사한 프로젝트에 대한 경험이 없을 수 있고 개인직이고 주관적일 가능성이 있다           델파이 기법            많은 전문가의 의견을 종합 후 산정하는 방법으로 전문가 감정 기법의 단점을 보완       전문가들의 의견을 중재하는 중재자가 반드시 필요          ","categories": ["study"],
        "tags": ["SW Engineering"],
        "url": "https://many258.github.io/study/software-engineering-cost-model/",
        "teaser": null
      },{
        "title": "[소프트웨어공학] 객체지향 개발 방법론",
        "excerpt":"객체지향 개발 방법론  객체지향 방법론의 정의  현실 세계의 개체(Entity)를 속성(Attribute)과 메소드(Method)가 결합된 형태의 객체(Object)로 표현하는 개념으로 객체간의 메시지 통신을 통해 시스템을 구현하는 개발 방법   객체지향 기술의 장점     규모가 큰 대형 프로젝트에 적합   소프트웨어의 재사용률/확장성/유지보수 향상   신속하게 개발이 가능   사용자 타입 중심   대화식 프로그램 개발에 용이   객체지향 기술의 단점     설계의 어려움   규모가 크기 때문에 실행속도 저하   구성요소     클래스(Class)  같은 종류(또는 문제 해결을 위한)의 집단에 속한 속성(attribute)과 행위(behavior)를 정의한 것   객체(Object)  자신 고유의 데이터(attribute)를 가지며 클래스에서 정의한 행위(behavior)를 수행   인스턴스(Instance)  어떤 클래스에 속하는 구체적인 객체를 의미하며 클래스로 정의된 객체의 요소로 객체의 복사본이라 할 수 있다   어트리뷰트(Attribute)  객체 안에 존재하는 절대적 자료형.  객체에 존재하는 함수들이 동작하게 될 경우 같은 객체에 존재하는 어트리뷰트 값을 변경한다.   메서드(Method)  객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것   메시지(Message)  Sender와 Receiver객체들간의 상호작용의 수단으로 다른 객체에 특정 작업을 요청하는 신호   주요 특징     캡슐화(Encapsulation)  연관된 속성(데이터)과 메소드(연산)을 하나로 묶어서 객체로 구성   추상화(Abstraction)  하위 객체의 공통된 특성을 묘사하기 위한 객체를 추상적인 객체. 이러한 추상적인 객체는 문제 대상의 공통 특성을 추출하여 객체를 정의하기에 유용하고 편리함을 제공한다   다형성(Polymorphism)  같은 상위 객체에서 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질   정보은닉(Information Hiding)  캡슐화된 객체 내부에 자료 구조나 함수의 기능을 외부의 영향을 받거나 주지 않도록 설계하는 방법   상속성(Inheritance)  상위클래스가 갖는 속성과 연산을 그대로 물려받는 것을 의미   객체지향 개발 순서  전통적인 구조적 개발 순서 구분처럼 단계가 분명하게 구분되지는 않는다.      계획   분석(OOA)            객체 모델링       동적 모델링       기능 모델링           설계(OOD)            객체 설계       시스템 설계           구현(OOP)   테스트 및 검증            단위 테스트       통합 테스트       검증과 시스템 테스팅           객체지향 분석(OOA : Object Oriented Analysis)     특징            문제 영역의 분석 대상을 형식적인 전략으로 기술하는 단계       E-R 다이어그램은 객체지향 분석의 표기법으로 적합       클래스, 객체, 속성, 연산들을 표현해서 문제를 모형화       객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해내는 기법           객체지향 분석의 순서(OMT : Object Modeling Technique, 람바우 방법)            객체 모델링(Object Modeling)  객체를 찾아내고 객체의 속성, 연산을 식별하는 단계       동적 모델링(Dynamic Modeling)  객체 모형들의 행위/상태/조건을 파악하는 단계       기능 모델링(Functional Modeling)                    입출력 결정           자료 흐름도                            객체들의 제어 흐름, 상호 반응 연산 순서를 나타내주는 과정                                   기능의 내용을 상세히 기술           제약사항을 결정하고 최소화                           객체지향 설계(OOD : Object Oriented Design)     특징            문제 영역의 분석 모형을 구체적인 절차로 표현       사용자 중심, 대화식 프로그램의 개발에 적합       시스템을 구성하는 클래스와 속성, 연산을 인식하여 클래스를 객체로, 속성을 자료 구조로, 연산을 알고리즘으로 표현하는 것           객체지향 설계의 순서            문제의 정의       요구 명세화       객체 연산자 정의(객체 설계)  객체 분석에서 정의된 요구 명세서를 기반으로 객체 연산자를 정의하여 설계       객체 인터페이스 결정(시스템 설계)  객체 설계 단계에서 정의된 객체 간의 인터페이스를 정하여 전체적인 시스템을 설계  데이터, 자원 관리 방법을 결정  객체는 순차적으로 또는 동시적으로 제어할지를 결정       객체 구현           객체지향 설계의 계층                     Responsibilities Layer  속성과 연산들에 대한 메타 데이터와 알고리즘을 표현                        Message Layer  객체와 객체 간의 인터페이스를 표현                        Class &amp; Object Layer  전체 객체를 구체적으로 표현                        Subsystem Layer  요구사항을 지원하는 기술적인 기반 구조를 구현                   객체지향 테스트     쓰레드 기반 테스트(Thread-Based Testing)  시스템에 대한 하나의 입력이나 이벤트에 응답하는데 요구되는 클래스들의 집합을 통합(구조적 검사 기법의 하향식 통합 검사 방법과 유사)   사용-기반 테스트(Use-Based Testing)  상위 클래스와 관계를 갖지 않는 수준에서 클래스들을 독립적으로 검사한 후 상위 클래스와 결합(구조적 검사 기법의 상향식 통합 방법과 유사)   검증과 시스템 테스트  사용자의 요구가 객체에 정확히 반영되었는지, 성능이나 인터페이스상 오류는 없는지 검사   객체지향 분석 방법론의 종류          람바우(Rumbaugh) Method  객체 모형, 동적 모형, 기능 모형으로 분리하여 접근하는 방법            E-R 다이어그램  데이터 구조들과 그들 간의 관계를 표현하고 객체 모형을 만드는 방법론            Booch Method  미시적 개발 프로세스, 거시적 개발 프로세스로 접근하는 방법.  각 작업에 대한 다이어그램, 클래스 계층 정의, 클래스들의 클러스터링 작업 수행            Coad &amp; Yourdon Method  E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성되는 방법            Jacobson Method  사용자가 제품 또는 시스템과 어떻게 상호 작용하는지를 서술한 시나리오로 접근            Wirfs-Brocks Method  분석과 설계 프로세스 간에 뚜렷한 구분이 없고, 고객 명세의 평가로 시작하여 설계로 끝나는 연속적인 프로세스로 접근한 방법      ","categories": ["study"],
        "tags": ["SW Engineering","(구)정보처리기사"],
        "url": "https://many258.github.io/study/software-engineering-object-oriented/",
        "teaser": null
      },{
        "title": "[소프트웨어공학] 소프트웨어 유지보수",
        "excerpt":"소프트웨어 유지보수  소프트웨어가 사용자에게 인수, 설치된 이후에 발생하는 모든 공학적인 작업 활동을 의미      소프트웨어 비용 중 유지보수 비용이 가장 큰 비중을 차지   명세서의 유지보수란 명세서를 항상 최신의 상태로 만드는 것을 의미   소프트웨어는 계속 수정, 보완되기 때문에 명세서도 따라서 보완되지 않으면 일관성을 유지하기 어려움   소프트웨어 유지보수의 과정은 유지보수 요구, 현 시스템에 대한 이해, 수정 및 시험순으로 반복하여 일어남   문서화(Documentation)     유지보수와 시스템 개발을 위한 분석 설계가 용이하고, 확장성이 좋다   여러 사람이 알아보기 쉽고, 유지보수 작업이 용이하려면 문서화 작업이 표준화되어야 한다   문서의 표준화가 되었다고 해서 신뢰성이 높아지거나 프로그램 처리 속도가 향상되거나 개발 인력이 감소하는 것은 아니다   유지보수 작업의 종류     수리보수(Corrective Maintenance, 수정보수)            밝혀지지 않은 모든 잠재적인 오류를 찾아 수정하는 활동           완전보수(Perfective Maintenance, 기능개선/향상보수)            기능의 수정, 새 기능의 추가, 전반적인 기능 개선 등       유지보수 유형 중 제일 많은 비용이 소요           적응보수(Adaptive Maintenance, 환경적응)            환경 변화에 대응하여 소프트웨어를 변경하는 경우           예방보수(Preventive Maintenance, 예비조치)            프로그램의 변경을 미리 예측하여 준비하는 활동           유지보수 비용 측정 방법     BL(Belady와 Lehman) 방법            M=$P+K\\cdot e^{(c-d)}$  M:유지보수를 위한 노력(인원/월)  P:생산적인 활동에 드는 비용(개발 비용)  K:통계값에 구한 상수(주관적평가)  c:복잡도  d:소프트웨어에 대한 지식 정도            COCOMO 방법            M = $ACT \\times DE \\times EAF$  ACT:유지보수 비율  DE:생산적인 활동에 드는 비용(개발 비용)  EAF:노력 조정 수치(주관적 평가)            Vessey &amp; Webber 방법            M = $ACT \\times 2.4 \\times [KDSI]^{1.05}$  M:생산적인 활동에 드는 비용(개발 비용)  ACT:유지보수 비율  KDSI:1000당 명령어 라인 수            소프트웨어 품질 목표 항목     정확성   신뢰성   효율성   무결성 : 허용하지 않은 사용이나 자료의 변경을 제어하는 정도   유지보수 용이성   사용 용이성   검사 용이성   이식성   상호 운용성 : 다른 소프트웨어와 정보를 교환할 수 있는 정도   유연성 : 소프트웨어 품질 목표 중 새로운 요구사항에 접하여 쉽게 수정될 수 있는 시스템 능력을 요구하는 것의 정도   재사용성   소프트웨어 신뢰성  신뢰성(Reliability) : 주어진 시간 동안 주어진 환경에서 프로그램이 고장 없이 운영될 확률을 의미   가용성(Availability) : 프로그램이 주어진 시점에서 요구사항을 수행하는 확률      평균 사용 시간(MTBF : Mean Time Between Failures)  고장 수리가 끝난 시간부터 다음 고장이 발생할 때까지의 시간 평균치            $\\frac{(사용1 + 사용2 + … + 사용n)}{n}$            평균 수리 시간(MTTR : Mean Time to Repair)  고장이 일어난 시점부터 고장 수리가 완료되는 시점까지의 평균치            $\\frac{(고장1 + 고장2 + … + 고장n)}{n}$            평균 고장 시간(MTTF : Mean Time To Failures)  고장이 발생한 시점부터 다음 고장이 발생할 때까지의 평균치            MTBF + MTTR            가용도 : 전체 시간 중에서 설계 가동하여 사용 중인 시간을 의미            $\\frac{MTBF}{MTTF}$ = $\\frac{MTBF}{MTBF+MTTR}$            소프트웨어 재사용(S/W Reuse)  이미 개발된 소프트웨어를 반복 사용하여 생산성을 향상시키는 방법      생성 중심(Generation Based, 모듈화)  재사용 단위를 찾아 발전시키는 기술        합성 중심(Composition Based, 모듈화)  모듈을 생산성있게 조립하는 기술       특징            모듈의 크기는 작을수록 재사용 비율이 높다       개발시간과 비용을 단축       개발 지식을 공유할 수 있다       소프트웨어 품질과 생산성을 향상           소프트웨어 재공학(S/W Re-Engineering)  과거에 사용하던 소프트웨어를 수명 연장을 위해 효과적으로 사용할 수 있도록 접근하는 기술   출현 배경  소프트웨어의 위기를 개발의 생산성이 아닌 유지보수의 생산성으로 해결하기 위해 출현   문서화 하는 과정에서 소프트웨어의 문제점들이 발견되고 이런 문제점을 수정 보완하여 다시금 소프트웨어를 수정하게 된 것이 재공학이 출현된 배경이다   이미 개발된 소프트웨어를 보고 문서화했으므로 역으로 진행했다하여 역공학의 개념이 출현하였고, 재공학은 역공학 이후에 출현된 기술 개념   정의  기존의 있던 소프트웨어를 파기하지 않고 변경된 사용자의 요구사항이나 수정된 환경으로 기존 소프트웨어를 수정, 보완하여 재구축하는 기술   노후된 시스템에 대한 재분석/문서화 작업을 통해 공학적으로 우수한 시스템을 만드는 것을 의미   재구조화(Restructuring) : 재공학의 한 유형으로 사용자의 요구사항이나 기술적인 변경 없이 프로그램을 개선   역공학(Reverse Engineering) : 기존 소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 분석 및 설계 정보를 재발견하거나 다시 만들어 내는 작업.  원시 프로그램으로부터 데이터, 아키텍처, 절차에 관한 분석 및 설계 정보를 추출하는 기술     코드의 역공학 : 소스 코드로부터 자료 흐름도를 추출하고 분석하여 변경   데이터의 역공학 : 소스 코드로부터 자료 사전을 추출하고 분석하여 변경   특징     재공학은 유지보수 중 예비 조치(Preventive)의 문제를 해결하기 위한 학문이다   자동화된 도구를 사용하여 소프트웨어를 분석하고 수정하는 과정을 포함   재공학 활동은 분석, 재구성, 역공학, 이식 활동 등으로 구분   목표     유지보수성, 생산성, 품질의 향상이 목적   소프트웨어 사용 기간을 연장시키고 비용을 감소시킨다   고수준의 추상을 합성할 수 있다  ","categories": ["study"],
        "tags": ["SW Engineering"],
        "url": "https://many258.github.io/study/software-engineering-maintenance/",
        "teaser": null
      },{
        "title": "[소프트웨어공학] 소프트웨어 검사",
        "excerpt":"검사 관련 용어정의     검사(Testing)  오류를 찾는 작업   검증(Verification)  개발된 소프트웨어와 사용자의 요구분석 명세서와의 차이를 확인하는 작업   디버깅(Debugging)  검사로 찾아낸 오류를 수정하는 작업   검토 회의(Walk-through)  소프트웨어 생명주기의 단계마다 산출된 명세서를 가지고 다음 단계로 넘어가기 전에 오류를 찾아내는 작업   정형 기술 검토(FTR)  소프트웨어에 관련된 여러 사람이 모여 회의하는 정형화된 오류 검토 회의   검사방법  화이트 박스 검사  상자 안을 들여다 볼 수 있다는 뜻으로 원시 프로그램을 직접 보면서 프로그램 상 허용되는 논리적인 모든 경로를 직접 검사하는 방법      프로그램 모듈의 논리적 구조를 체계적으로 점검하는 구조 검사   원시 코드의 모든 문장을 한 번 이상 수행함으로써 진행되는 구조 검사   검사 대상의 가능한 경로를 어느 정도 통과하는 지의 적용 범위성을 측정 기준으로 한다        프로그램의 제어 구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적인 경로를 검사       종류            기초 경로 검사(Basic Path Testing)  모든 논리적인 경로를 복잡도로 계산하여 구한 후 경로를 수행할 수 있는 검사 경우를 직접 입력하여 오류를 검출하는 방법                    오일러의 공식 : V - E + R = 2  V: 노드의 수, E: 간선의 수, R:영역의 수                        루프 검사(Loop Testing)  반복문 관련 오류 검출       데이터 흐름 검사(Data Flow Testing)  제어 흐름 그래프에 데이터 사용 현황(정의, 소멸, 사용)을 테스트       조건 검사(Condition Testing)  조건문 관련 오류 검출           찾을 수 있는 오류            자세하고 세부적 오류 검출 가능       반복문, 참거짓을 판단할 수 있는 논리 구조 상의 오류 검출 가능           블랙 박스 검사  상자 안을 볼 수 없다는 뜻으로 원시 프로그램은 보지 않고 프로그램만 실행시켜 데이터 입력에 대한 결과만을 보고 오류를 판단하는 방법      종류            균등 분할(Equivalence Partitioning)  입력 자료에 초점을 맞춰 검사 사례를 만드는 방법.  타당한 자료와 타당하지 않은 자료의 개수를 균등하게 하여 정함       한계값 분석(Boundary Value Analysis)  입력조건의 중간값에서 보다 경계값에서 에러가 발생될 확률이 높다는 점을 이용하여 이를 실행하는 테스크 케이스를 만드는 방법       원인-결과 그래프(Cause-Effect Graphing)  입력 데이터 간의 관계가 출력에 미치는 영향을 그래프로 표현하여 오류 검출       오류 예측(Error Guessing)  각 시험기법들이 놓치기 쉬운 오류들을 감각 및 경험으로 찾아보는 것       비교 검사(Comparison Testing)  여러 버전의 프로그램에 동일한 검사 자료를 제공하여 동일한 결과가 출력되는 지 비교 및 확인하는 검사       페어 와이즈 조합 테스트  모든 가능한 입력 값들의 조합들을 테스트하는 대신에 모든 Pair의 조합을 테스트하는 방법       상태 전이 검사  시스템의 상태가 변화함에 따른 검사           비정상적인 자료를 입력해도 오류 처리를 수행하지 않은 경우의 오류 검출 가능   정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우의 오류를 검출 가능   성능 오류, 자료 구조 상의 오류, 인터페이스, 시작과 종결 상의 오류를 찾을 수 있다   검사 순서     단위(코드) 검사   통합(설계) 검사   검증(요구사항) 검사   시스템 검사   단위 검사  원시 프로그램의 모듈을 대상으로 화이트 검사를 실시하는 방법      인터페이스 검사   자료 구조 검사   경로 검사   오류 처리 검사   한계값 검사   통합 검사  단위 검사를 성공적으로 실시한 후에 단위별로 결합하면서 오류를 검출하는 방법   하향식(Top-Down) 통합 검사  상위 모듈에서 하위 모듈로 결합하면서 오류를 찾는 방법으로 가짜 모듈(Stub)이 필요하다      전체 프로그램을 매번 실행하고 종속적인 모듈은 가짜 모듈(Stub)로 대치한다   통합 방법에 따라 가짜 모듈을 실제 모듈로 대치한다   각 모듈이 통합되면 검사를 실시   통합될 때마다 회귀 검사를 실시      프로그램 전체를 실행하면서 검사 가능   중요 모듈을 우선 검사할 때에는 부적합   독립적인 구조로 검사할 수 있다   상향식(Bottom-Up) 통합 검사  최하위의 모듈부터 상위로 진행하면서 통합하는 방식으로 가짜 모듈은 필요없지만 통합 시에 통합된 클러스터(Cluster)를 실행할 수 있는 시험 가동기(Driver)가 필요하다    클러스터 : 여러 개의 모듈을 하나로 묶어 놓은 단위  드라이버 : 임시로 실행시켜 검사해 보기 위한 임시 프로그램 모듈         낮은 수준의 모듈들을 클러스터로 결합   검사 사례 입/출력을 조정하기 위해 드라이버 작성   클러스터 검사   드라이버 제거하고 클러스터를 상위로 결합      중요 모듈을 우선 검사할 때 유리   혼합식(Mixed) 통합 검사  하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 검사하는 방법. 샌드위치식 통합 방식이라고도 한다.   검증 검사  소프트웨어가 사용자의 요구사항을 충족시키는가에 중점을 두고 검사하는 방법. 요구사항 명세서를 토대로 블랙 박스 테스트를 사용      형상 검사 : 소프트웨어 구성요소, 목록, 유지보수를 지원하기 위해 필요한 사항 표현 검사   알파 검사 : 개발자의 장소에서 사용자가 개발자 앞에서 실행하는 검사   베타 검사 : 다수의 사용자를 제한되지 않은 환경에서 프로그램을 사용하게 하고 오류가 발견되면 개발자에게 통보하는 방식   시스템 검사  개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 검사      확인 검사 : 이해관계가 있는 모든 사람이 참석하여 오류 검출하는 방법   보안 검사   무결성 검사   스트레스 검사   부피 검사   메모리 검사   성능 검사   호환성 검사   신뢰성 검사   회복 검사   사용 용이성 검사   유지보수 용이성 검사   정형 기술 검토(FTR : Formal Technical Review)     목적            소프트웨어가 요구사항에 일치되는 정도를 확인       소프트웨어가 표준화되었는지 검토       정형화된 소프트웨어가 개발되도록 지원       프로젝트 관리           검토 지침            제품 검토의 집중성 : 수정이 아닌 제품의 검토에 집중       사전 준비성 : 검토를 위한 자료를 사전에 배포하여 검토       의제의 제한성 : 의견을 제한하되 충분히 받아들인다       안건 고수성       논쟁 반박의 제한성       문제 공개성       참가 인원의 제한성       문서성 : 발견된 오류는 문서화한다           오류 증폭 모형  소프트웨어 개발 생명주기 중 검사 단계에서 오류를 찾는 것보다 생명주기의 단계마다 확인하고 검사하면 많은 양의 오류 검출 및 수정이 가능하다.   이러한 방법을 검토 회의(Walk-through)라고 하며 검토 회의를 할 경우에 예측할 수 있는 오류 감소 비율을 이론적으로 정립한 것을 오류 증폭 모델이라 한다.      (전달된 오류수 + 오류 증폭수 + 생성된 오류수) X (100% - 오류 제거 비율)  오류 증폭수 = (이전 단계에서 전달된 오류수 - 전달된 오류 수) X 오류 증폭 비율   ","categories": ["study"],
        "tags": ["SW Engineering"],
        "url": "https://many258.github.io/study/software-engineering-testing/",
        "teaser": null
      },{
        "title": "[소프트웨어공학] 미들웨어(Middleware)",
        "excerpt":"미들웨어(Middleware)  운영체제와 사용자 응용 프로그램 사이에 또는 다른 종류의 사용자 응용프로그램 사이에서 조정 및 중개 역할을 하는 프로그램   특징     두 개 이상의 응용 프로그램 간 데이터를 공유시킨다   표준화된 인터페이스 제공 가능   서버와 클라이언트 사이에서 작업량의 감소, 부하 분산, 트랜잭션 처리, 보안 등 역할을 담당   분산된 업무를 동시에 처리 가능하여 자료의 일관성 유지   종류  RPC(Remote Procedure Call) : 원격 프로시져 호출  원격 프로시져를 마치 로컬 프로시져처럼 호출하는 방식의 미들웨어   한 프로그램이 네트워크 상의 다른 컴퓨터에 위치하고 있는 프로그램에 서비스를 요청하는데 사용되는 프로토콜로서, 이때 서비스를 요청하는 프로그램은 네트워크에 대한 상세 내용을 알 필요가 없다   제품 종류 : Entera(이큐브시스템), ONC/RPC(OSF)   MOM(Message Oriented Middleware) : 메시지 지향 미들웨어  주로 비동기형 메시지 처리를 전달하는 미들웨어.  이 기종 분산 데이터 시스템의 데이터 동기를 위해 주로 사용  제품 종류 : MQ(IBM), Message Q(Oracle), JMS(JCP)   TP-모니터  온라인 트랜잭션 업무에서 트랜잭션을 처리, 감시하는 미들웨어.  사용자 수가 증가하여도 빠른 응답속도를 유지해야 하는 OLTP성의 업무에 적합 제품 종류 : Tuxedo(Oracle), Tmax(Tmax Soft)      OLTP(Online Transaction Processing)  네트워크 상의 여러 이용자가 실시간으로 데이터베이스의 데이터를 갱신하거나 조회하는 등의 단위 작업을 처리하는 방식   OLAP(Online Analytical Processing)  사용자가 다양한 각도에서 직접 대화식으로 정보를 분석하는 과정.  데이터웨어하우스 등의 시스템과 연관되어 자료를 분석하고 의미있는 정보로 치환하거나, 복잡한 모델링을 가능하게끔 하는 분석 방법   CORBA(Common Object Request Broker Architecture)  네트워크에서 분산 프로그램 객체를 생성, 배포, 관리하기 위한 규격으로 네트워크 상의 서로 다른 장소에 있는 프로그램들이 “인터페이스 브로커”를 통해 통신이 가능하도록 해준다           OMG(Object Management Group)  여러 대의 컴퓨터를 연결하여 사용하는 환경하에서 응용 프로그램 간에 기술적인 문제를 지원하고 표준을 위해 설립된 비영리 단체.  분산 네트워크 시스템에서 하드웨어나 운영체제에 영향을 받지 않고 응용 프로그램을 통합할 수 있는 공통된 작업 환경을 제공한다            OMA(Object Management Architecture)  OMG의 활동 방향과 목적에 부합되는 모델로서 ORB, 객체 서비스, 공통 기능, 응용 인터페이스, 도메인 인터페이스 등으로 구성            ORB(Object Request Broker)  객체지향 시스템에서 객체 및 서비스를 요청하고 전송할 수 있도록 지원하는 미들웨어로 CORBA 표준 스펙을 구현한 미들웨어  제품 종류 : Orbix(Micro Focus), CORBA(OMG)       COM(Component Object Model)  MS사가 개발한 객체 응용 프로그램 간의 통신 방식으로 응용 프로그램의 컴포넌트 객체들을 개발하고 지원하기 위한 미들웨어.   모든 기능을 여러 개의 단위 프로그램으로 분할함으로써 코드의 재사용성을 극대화하고 효율적인 유지보수를 보장한다. 단위 소프트웨어, 컴포넌트들을 재사용하기 위해서는 표준화된 방법이 필요했는데 단위 소프트웨어,컴포넌트들이 서로 통신할 수 있게 마이크로소프트가 표준화를 규정하였다.   객체를 재사용하는 개념이 없기 때문에 객체지향의 이점은 누릴 수 없지만 다양한 응용 프로그램을 관리하는 면에서는 CORBA보다 우월           IPC(Inter Process Communication)  두 프로세스가 상호 통신하며 정보를 교환하는 방법       멀티태스킹 환경에서는 여러가지 프로그램들이 동시에 실행된다. 각 프로세스들은 메모리와 CPU를 공유하고 있을 뿐, 독립된 일을 하며 상호 간섭하지 않고 간섭할 수도 없다. 하지만 필요에 따라 프로세스간의 정보를 교환해야 하는 경우가 생기는데 이 때 사용한다.       DCOM(Distributed Component Object Model)  인터넷이나 LAN환경에서 서로 다른 컴퓨터끼리의 통신을 지원하는 분산확장형 COM   사용자 응용 프로그램 객체는 파일 이름 대신에 URL을 사용하여 서버 객체를 사용할 수 있으므로 인터넷에서 분산 처리를 실현할 수 있다   COM+(Component Object Model+)  분산형 트랜잭션을 동시 처리할 목적으로 출현   COM/DCOM과 약간 다른 개념으로 MTS라고 불리는 일종에 서비스.  쉽게 말하자면 COM을 네트워크에서 사용가능하도록 해주는 서비스   WAS(Web Application Server) : 웹 애플리케이션 서버  정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어  종류 : 아파치 톰캣(Apache Tomcat), JBoss, Jetty, WebLogic, JRun, Jeus, WebSphere   ESB(Enterprise Service Bus) : 엔터프라이즈 서비스 버스  메시지 기반으로 느슨한 결합형태의 표준 인터페이스 통신을 통해 전사 시스템 환경을 연동하는 미들웨어      SOA에서 사용되는 개념        EAI와 유사하게 사용된다. 기관 간, 서비스 간 연계가 이루어진다.            SOA(서비스 지향 아키텍쳐 : Service Oritented Architecture)  대규모 컴퓨터 시스템을 구축할 때의 개념으로 업무상에 일 처리에 해당하는 소프트웨어 기능을 서비스로 판단하여 그 서비스를 네트워크 상에 연동하여 시스템 전체를 구축해 나가는 방법론       EAI(기업 응용 프로그램 통합 : Enterprise Application Integration)  DW, ERP, CRM, SCM, B2B 등 기업에서 운영하는 서로 다른 어플리케이션 및 시스템을 통합시키는 것을 의미.  업무의 효율성, 확장성 향상, 유지보수 및 비용 절감, 편의성 증대시키는 솔루션  ","categories": ["study"],
        "tags": ["SW Engineering"],
        "url": "https://many258.github.io/study/software-engineering-middleware/",
        "teaser": null
      },{
        "title": "[데이터통신] 데이터 통신 시스템의 기본",
        "excerpt":"통신의 3요소     정보원(Source)   수신원(Destination)   전송매체(Transmission Media)   데이터 통신 시스템의 발달 과정     SAGE(Semi-Automatic Ground Enviroment)            미국의 군사용 반자동 방공 시스테믕로 사용된 최초의 데이터 통신 시스템           SABRE(Semi-Automatic Business Research Enviroment)            항공기 좌석 예약 시스템으로 최초의 상업용 통신 시스템           CTSS(Compatible Time Sharing System)            대학 내 대형컴퓨터 공동 이용을 목적으로 시행한 최초의 시분할 시스템           ARPANET(Advanced Research Project Agency Network)            최소의 유선 패킷 시스템       인터넷 기술의 모체           ALOHA(Additive Links On-line Hawaii Area)            최초의 무선 패킷 네트워크 시스템       공유 회선 점유방식 중 경쟁방식(CSMA, CSMA/CD)의 모체           SNA(System Network Architecture)            IBM 사에서 발표한 컴퓨터 간 접속 네트워크 시스템 표준           데이터 통신 시스템     데이터 전송계            단말장치(DTE: Data Terminal Equipment)       데이터 전송 회선                    신호 변환기(DCE: Data Circuit Equipment)           통신 회선                       통신 제어 장치(CCU: Communication Control Unit)           데이터 처리계            컴퓨터                    하드웨어           통신 소프트웨어                           데이터 통신 시스템의 3대 구성요소            단말장치       통신 제어 장치       전송 장치           데이터 전송 시스템의 3대 구성요소            단말장치       통신 제어 장치       데이터 전송 회선           단말장치(DTE: Data Terminal Equipment)     통신 시스템과 사용자의 접점에 위치하여 데이터를 입력하거나 처리된 결과를 출력하는 기능 담당   전송 제어 기능(입출력 제어, 오류 제어, 송수신 제어) 수행   통신 회선을 통하여 송수신될 때 속도의 차이를 극복시켜 주는 임시 기억 장치의 역할   데이터 전송 회선  전송 신호를 송/수신하기 위한 통로      전송로에 적합한 신호로 변경   데이터 송수신 시에 동기(시간 맞춤 행위)를 제어   오류를 검출하거나 정정   전송 조작 절차를 제어   신호 변환기(DCE: Data Circuit Equipment)  단말장치와 통신 회선 사이에서 적합한 신호나 데이터로 변환시켜주는 장치로서 데이터 회선 종단 장치라고도 한다.  MODEM, CODEC, DSU가 존재   통신 회선  데이터가 실질적으로 전송되는 선로.  꼬임선/동축케이블/광섬유 케이블 등 전송 매체 존재   통신 제어 장치(CCU: Communication Control Unit)  데이터 전송회선과 컴퓨터를 연결하는 장치. 컴퓨터가 데이터 처리에 전념할 수 있도록 컴퓨터를 대신해 데이터 전송에 관한 전반적인 제어 기능을 수행      통신 회선을 통하여 송수신되는 자료를 제어하고 감시   통신 회선의 전송 속도와 CPU의 처리 속도 사이에서 조정을 수행   통신 회선과 전기적으로 결합   통신 방식과 다중 접속을 제어   전송 문자 및 메시지를 조립 또는 분해   동기 제어 : 컴퓨터의 처리 속도와 통신 회선 상의 전송 속도 차이 조정   오류 제어 : 통신 회선과 단말장치에서 발생하는 오류 제어   흐름 제어 : 수신 가능한 데이터의 양을 송신측에 알려 원할한 정보 전송이 가능하도록 조정   응답 제어 : 수신 정보 확인   투과성 : 전송할 실제 데이터에 대한 비트 열에 확장 비트를 부가 또는 소거   우선권 제어   제어 정보 식별 : 일반 데이터와 제어 정보 구분   기밀 보호 : 암호화 등 제어   관리 기능 : 통신에 관한 통계 정보 수집  ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-base/",
        "teaser": null
      },{
        "title": "[데이터통신] 신호 변환기",
        "excerpt":"신호 변환기의 종류     MODEM   디지털 데이터를 아날로그 신호로 변환시키는 장비로 PSTN(공중 전화망)에 접속되는 장비   DSU  디지털 데이터를 전송망에 적합한 디지털 신호로 변환시키는 장비로 PSDN(공중 데이터망)에 접속되는 장비   CODEC  아날로그 데이터를 디지털 신호로 변환시키는 장비로 PCM이 대표적인 예   Telephone  아날로그 데이터를 아날로그 신호로 변환시키는 장비로 빠르고 멀리 전송하기 위해 음성 대역 의 낮은 주파수를 높은 주파수로 변환   MODEM(Modulator / Demodulator)     기존의 공중 통신망을 이용하여 데이터 전송을 하기 위해 사용   음성 통신 회선은 사람의 음성 신호와 같은 아날로그 신호를 전송하기에 적합   공중 전화망을 음성 정보뿐만 아니라 디지털 전송으로 재사용하기 위해 사용   기능     변/복조 기능이 존재   펄스를 전송 신호로 변환   자동 호출 / 자동 응답 기능 존재   고장 장애 시험이 가능   데이터 통신 및 속도를 제어할 수 있음   분류     동기 방식에 의한 분류            비동기식 모뎀 방식 : 진폭 편이 변조(ASK), 주파수 편이 변조(FSK)       동기식 모뎀 방식 : 위상 편이 변조(PSK), 진폭 위상 편이 변조(QAM)           포트 수에 의한 분류            단 포트 모뎀  중속도(2,400bps 이하)에 사용되는 모뎀으로 하나의 포트에 연결       멀티 포트 모뎀  포트의 수가 2/4/6개 등 여러 개의 포트가 내장되어 있는 모뎀       널 모뎀  중간에 모뎀 또는 기타 데이터 통신 기기(DCE)를 사용하지 않고 터미널과 컴퓨터 사이에 RS-232C를 이용하여 직접 접속하는 모뎀           속도에 의한 분류            저속도 모뎀(300bps 이하) : ASK       중속도 모뎀(1200 ~ 4800bps) : FSK, PSK       고속 모뎀(4800 ~ ) : QAM           모뎀의 신호 변환 방식  ASK(Amplitutde Shift Keying : 진폭 편이 변조)  디지털 데이터의 ‘1’과 ‘0’을 진폭의 크기만 다르게 하여 전송하는 방식   FSK(Frequency Shift Keying : 주파수 편이 변조)  디지털 데이터의 ‘1’과 ‘0’을 주파수의 주기 수를 다르게 하여 전송하는 방식   PSK(Phase Shift Keying : 위상 편이 변조)  디지털 데이터의 ‘1’과 ‘0’을 위상(각도, 위치)을 다르게 하여 전송하는 방식           DPSK(Differential PSK)  차등 인코딩을 사용하는 2위상 PSK            QDPSK(Quadrature DPSK)  차등 인코딩을 사용하는 4위상 PSK            M위상(M진) PSK             $M=2^{전송\\ 비트}, 전송\\ 비트 = \\log_2M$            QSK(Quadrature Amplitude Modulation : 진폭 위상 변조, 직교 위상 변조)  디지털 데이터의 진폭과 위상을 변조하여 전송하는 방식      Coherent 방식  단일 주파수, 같은 모양의 위상. 동기와 유사   Non-Coherent 방식  다양한 주파수와 진폭, 다양한 모양의 위상. 비동기와 유사   DSU(Digital Service Unit)  네트워크 간에 서로 다른 디지털 신호를 사용하기 때문에 필요한 네트워크 연결 장비(네트워크 간의 상호 보안 문제가 있기 때문)   하나의 통합된 디지털 신호(Bipolar)를 사용하자는 취지에서 등장한 ISDN이 계속 발전하지 못한 이유 또한 보안 문제가 발생했기 때문이다   특징     디지털 신호를 변조하지 않고 DTE를 데이터 교환망에 접속하기 위한 장비   먼 거리까지 디지털 데이터를 전송하기 위해 사용   모뎀의 회로 구성보다 간단하고 속도가 빠르다   DSU의 신호 변환 방식  단극 RZ(Return to Zero)  전압을 양극이나 음극 하나만 사용하므로 단극이라고 하며 입력 데이터가 ‘1’이면 양극이나 음극 중에서 전압을 주고 ‘0’이면 전압을 주지 않는 방식      송수신 회로 구성이 간단하지만 잡음이 많아 단거리 구간에 사용되며 ‘1’과 ‘0’이 연속되면 동기가 용이하지 않다   양극 NRZ(Non Return to Zero)  전압을 양극과 음극 모두 사용하므로 양극이라고 하며 입력 데이터가 ‘1’이면 양극, ‘0’이면 음극의 전압을 주는 방식      NRZ-L(Level)  ‘1’인 경우에는 양극, ‘0’인 경우에는 음극을 사용   NRZ-M(Mark=’1’)  비트 간격의 시점에서는 항상 천이(변화)가 발생하며  ‘1‘의 경우에는 비트 간격의 중간에서 천이가 발생하고,  ‘0’의 경우에는 비트 간격의 중간에서 천이가 없는 방식   NRZ-S(Space=’0’)  비트 간격의 시점에서는 항상 천이(변화)가 발생하며  ‘0‘의 경우에는 비트 간격의 중간에서 천이가 발생하고,  ‘1’의 경우에는 비트 간격의 중간에서 천이가 없는 방식   NRZ-I(Inversion)  ‘0’에서 ‘1’로, ‘1’에서’ 1’로 비트가 변할 때만 Interval 중간에서 변화가 있고,  ‘1’에서 ‘0’으로 변하거나 ‘0’이 지속될 때는 ‘0’의 상태 변화 없이 같은 신호 레벨로 지속   Bipolar  AMI(교호 반전 부호), 3원 부호, ISDN 신호 방식이며 양극, 음극, Zero를 모두 사용한다.   ‘0’은 Zero로 ‘1’은 양극과 음극을 교대로 변환시키는 방식      직류 성분이 포함되지 않는 장점이 있지만 동기화의 어려움 존재   Manchester  하나의 펄스폭을 2개로 나누어 ‘1’과 ‘0’을 반대로 구성하여 사용      IEEE 802.3의 CSMA/CD LAN에서의 전송 부호로 사용   매 비트 구간에서는 반드시 한 번 이상의 신호 준위 천이가 발생하므로 이를 이용하여 클록 신호를 추출할 수 있어 동기화 능력을 가지게 된다   CODEC  아날로그 데이터를 전송하기 위해서 디지털 신호로 변환시키고, 다시 디지털 신호를 아날로그로 복귀시키는 장비      펄스 코드 변조(PCM)   델타 변조(DM)   PCM(Pulse Code Modulation)     점유 주파수 대역이 넓은 단점이 존재   잡음과 누화에 강하다   저질의 전송으로도 사용이 가능   광통신의 실현으로 대용량 전송 가능   IC의 저가격화에 의해 경제적   표본화(Sampling)  연속적으로 변하는 아날로그 신호를 주기적인 간격으로 표본 값을 구하는 과정(PAM신호를 얻는 과정)      표본화 정리(Nyquist-Shannon Sampling Theorem)  어떤 신호 f(t)가 의미를 지니는 최고의 주파수보다 2배 이상의 속도의 균일한 시간 간격으로 채집된다면 이 채집된 데이터는 원래의 신호가 가진 모든 정보를 포함한다는 이론   양자화(Quantization)  표본화한 표본 값을 정수화하는 단계로 실수형의 표본 값을 정수가 되도록 반올림을 수행한다. 이 때 발생하는 오차를 양자화 잡음이라고 하는데, PCM극 장치에서 발생한다.      양자화 스텝 : 표본화 된 하나의 PAM(Pulse Amplitude Modulation) 신호를 부호화 할 때, 다음과 같은 공식이 성립한다            $M = 2^n$  M : 양자화 스탭 / n : 표본당 전송 비트 수            Companding : 압축과 신장의 합성어로 전송될 일부분의 신호가 일정한 범위 내에 있지 않고 급격한 차이가 있을 경우 급격한 일부분의 신호에 의하여 많은 스탭 수가 필요하게 된다. 이 때 사용하는 방법으로 급격한 신호를 압축하여 압축 정보와 함께 전송하면 수신측에서는 압축된 정보를 참조하여 원래로 신호로 신장하는 방법   부호화(Encoding)  양자화된 표본 펄스의 진폭 값을 디지털 신호 ‘1’과 ‘0’의 조합으로 변환하는 단계   인접 부호 간 1bit만 변화시키는 Gray Code를 가장 많이 사용      원천 부호화(Source Coding)  정보 신호를 전송하기에 적합하도록 효율적으로 부호화하는 방식으로 정보 신호를 디지털 신호로 바꾸고 데이터를 압축하여 제한된 대역폭에서 고속으로 전송되도록 한다            DM(Delta Modulation), PCM(Pulse Code Modulation), 허프만 코딩(Huffiman Coding), LPC(Linear Predictive Coding), PNM(펄스 수 변조)           채널 부호화(Channel Coding)  원천 부호화된 원래의 정보에 에러 검출 및 정정을 위한 비트들을 추가하여 전송하는 방법으로 수신측에서 에러를 검사하여 데이터의 재전송을 요청하거나 자체적으로 에러를 검출하여 정정하도록 하는 목적            ARQ(Automatic Repeat Request), FEC(Forward Error Correction)           복호화(Decoding)  수신된 디지털 신호를 원래의 신호로 복원하는 단계. 부호를 PAM 신호로 변환   여파화(Filtering)  인접한 PAM 신호의 정점을 연결하여 계단 모양의 파형으로 만들고 저역 필터기를 통과시킨다. 약간의 일그러짐이 있지만 표본화되기 전 원래의 신호와 비슷하게 복원된다.   PCM/TDM(Time Division Multiplexing)  PCM화된 다수의 음성 채널을 하나의 전송로를 이용하여 전송하는 방식      T1(DS-1) 방식 : 북미 표준   E1(DE-1) 방식 : 유럽 표준   아이 패턴  디지털 신호는 시간이 흐름에 따라 단계적인 레벨을 이동하면서 파형을 그리게 되는데 이러한 단계적인 레벨 이동의 흐름을 특정 시간단위 내에서 중첩하여 보여준 파형이 바로 눈 패턴(Eye Pattern)이다.   채널을 통과하면 아이 패턴의 모양이 변하게 되는데, 변화는 위치와 특성에 따라 여러 가지 통신 특성의 변화를 가늠해볼 수 있다.          Optimum Sampling Time  아이 패턴이 열린 최대 높이가 최적의 샘플링 순간            Sensitivity to Timing Error  아이 패턴의 기울기를 통해 시간 오차에 대한 민감도를 평가            Noise Margin  아이 패턴이 눈이 열린 높이 만큼을 잡음에 대한 여분으로 잡을 수 있다            Maximum Distortion  아이 패턴의 맨 위와 맨 아래의 파형들의 진동폭은 신호가 샘플링되는 순간 왜곡되는 최대값을 나타낸다                                             출처 : http://www.rfdh.com/bas_com/1-8.htm          ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-signal-converter/",
        "teaser": null
      },{
        "title": "[데이터통신] 데이터 전송",
        "excerpt":"데이터 전송 방식     아날로그 전송            전송 매체를 통해 전달되는 신호가 아날로그 형태인 것(사람의 음성, 화상)       신호의 감쇠 현상이 심하기 때문에 증폭기에 의해 신호를 중간에 다시 증폭하여 전송해야 하는데 신호에 포함된 잡음까지 같이 증폭           디지털 전송            전송 매체를 통해 전달되는 신호가 디지털 형태인 것       신호에 포함된 잡음은 제거하고 0과 1만을 추출하여 증폭되므로 왜곡 현상이 없다       아날로그 전송과 비교하여 유지 비용이 적다       디지털 신호 변환에 의해 아날로그나 디지털 정보의 암호화가 쉽게 구현 가능       전송 용량을 다중화함으로써 효율성이 높음       아날로그 전송보다 훨씬 많은 대역폭을 필요로 하고, 전송 거리가 짧기 때문에 증폭기가 많이 사용           데이터 비트의 전송 방법     직렬 전송            정보를 구성하는 각 비트들이 하나의 전송 매체를 통해 한 비트씩 순서적으로 전송되는 형태       하나의 전송 매체만 사용하므로 속도는 느리지만 구성 비용이 적다       원거리 전송에 적합           병렬 전송            정보를 구성하는 각 비트들이 여러 개의 전송 매체를 통해 동시에 전송되는 형태       여러 개의 전송 매체를 사용하므로 전송 속도는 빠르지만 구성 비용이 많이 소요       근거리 전송에 적합하며 주로 컴퓨터와 주변장치 사이의 데이터 전송에 사용       흐름 제어 필요 :                    수신측이 현재 데이터 수신중임을 알리기 위해 Busy 신호 사용           문자와 문자 단위를 식별하기 위해 Strobe 사용                           데이터 전송 방향          단방향 전송(Simplex)  한쪽 방향으로만 데이터 전송이 이루어지는 방식            양방향 전송(Duplex)             반이중 전송(Half-Duplex)                    한쪽에서 데이터 전송이 되면 다른 한쪽에서는 전송이 끝나기를 기다리는 방식           전송 방향을 바꾸는 시간이 필요           통신 회선이 비교적 적을 때 사용           2선식 선로를 두어 송신과 수신을 번갈아 전송           전송 지연에 문제가 있으며 반환 시간(Turn-Around Time)이 길다.                       전이중 전송(Full-Duplex)                    전송 시간에 구애를 받지 않는다           전송량이 많고 통신 회선의 용량이 클 때 사용           통신 회선의 효율이 높다           4선식 선로를 두어 송신과 수신을 별도로 전송                           동기화  송신 측과 수신 측이 정확히 데이터를 주고 받을 수 있도록 양측에 시간을 맞추는 것을 의미. 이 때 양측의 시간을 일치시키는 것을 동기식 전송, 송신 측에 관계없이 수신 측에서 수신 신호로 시간을 식별하는 것을 비동기식 전송이라고 한다.   비동기식 전송  시작 비트, 전송 문자(정보 비트), 정지 비트로 구성된 한 문자를 단위로 전송하며, 오류 검출을 위한 패리티 비트를 추가하기도 한다      간헐적으로 시간을 맞춘다   독립적, 문자 단위 전송   문자와 문자 사이의 휴지 기간이 존재   한꺼번에 많은 데이터를 보내면 프레이밍 에러의 가능성이 높아진다   약 2Kbps 이하의 저속, 단거리 전송에 사용   대화용 전송에 적당   버퍼를 적게 사용   ASK, FSK 방식에 적합      전송 효율 = $\\frac{정보 비트}{전송 비트} \\times 100\\%$  전송 비트 = 정보 비트 + 제어 비트(동기 문자, 오류 검출 비트)       프레이밍 에러(Framing Error) : 송신 측과 수신 측의 샘플링 시점이 달라서 발생하는 오류. 비동기 전송에서 start bit 와 stop bit 사이에 더 많은 비트들을 전송함으로써 오버헤드 비율을 줄일 수 있으나 비트들이 많을 수록 프레이밍 에러가 발생할 가능성이 높아진다.    동기식 전송  미리 정해진 수만큼의 문자열을 한 블록(프레임)으로 만들어 일시에 전송하는 방식      연속적으로 시간을 맞춘다   종속적, 블록(프레임) 단위 전송   송신, 수신 양쪽의 동기를 유지하기 위해 타이밍 신호를 계속적으로 공급하거나 동기 문자를 전송   프레임 단위로 전송하므로 속도가 빠르다   시작/종료 비트로 인한 오버헤드가 없고, 휴지 기간이 없으므로 전송 효율이 좋다   단말기는 반드시 버퍼 기억장치에 내장하여야 한다   PSK, QAM 방식에 적당   문자 동기 방식 : SYN 등의 전송 제어 문자에 의해 동기를 맞추는 방식으로 BSC 프로토콜에서 사용   비트 동기 방식 : 데이터 블록의 처음과 끝에 8비트의 플래그 비트를 표시하여 동기를 맞추는 방식으로, HDLC/SDLC/ADCCP 프로토콜에서 사용(전송 에러 검출을 위해 FSC(Frame Check Sequence) 이용)   데이터 전송 형태  베이스밴드 전송(기저 대역 전송, Baseband Transmission)  원래의 신호를 다른 주파수 대역으로 변조하지 않고 전송하거나 정보를 0과 1로 표시하고 이것을 직류의 전기 신호로 전송하는 방식      보통 하나의 회선에 하나의 채널을 사용   10Mbps 이하의 전송 속도   소규모 데이터 전송에 적합   신호는 양방향으로 진행   모뎀이 필요 없어 비용이 저렴하나 전송거리가 짧음   단극 RZ, 양극 NRZ-L, NRZ-M, Bipolar, Manchester 등이 있다   CSMA/CD 방식, Token Ring 방식에서 채택   브로드밴드 전송(반송 대역 전송, Broadband Transmission)  디지털 신호를 반송파의 진폭, 주파수, 위상 등으로 변환하여 아날로그를 전송하는 방식      회선당 20 ~ 30개의 채널을 사용   150Mbps 이하의 전송속도   대규모의 멀티미디어에 적합한 방식   신호는 단방향으로 진행   Token Bus 방식에서 채택   데이터 전송 속도     데이터 신호 속도(bps)  부호를 구성하는 데이터의 비트 수가 1초 동안에 얼마나 전송되었는가를 나타내는 단위            데이터 신호 속도(bps) = 변조 속도(Baud) X 변조 시 상태 변화 수            변조 속도(Baud)  신호의 변조 과정에서 1초 동안 몇 회의 변조가 행해졌는가를 나타내는 것을 의미.            B = $\\frac{1}{T}$ T: 단위 시간당 펄스의 수  $= \\frac{bps}{변조 시 상태 변화 수}$                 베어러 속도  보통 베어러 속도를 반송 속도라고 하며 데이터 신호에 동기 신호와 상태 신호를 합한 속도(단위 bps = bit/sec)       Nyquist의 공식  잡음이 없는 채널의 전송 속도(bps)와 주파수(W)의 관계식            $C = 2W\\log_2L$  C : bps / W : 대역폭 / L : 신호 레벨            Shannon의 공식  잡음이 있는 채널의 전송 속도(bps)와 주파수(W)의 관계식            $C=W\\log_2(1+S/N)$  C : bps / W : 대역폭 / S/N : 신호 대 잡음비            데이터 전송 코드  Baudot 코드     초기의 전송용 코드로 5비트로 구성   오류 검출 코드가 없다   코드의 확장 기능이 있다   텔렉스(최초의 문자 전송 시스템으로 문자 정보를 텔렉스 교환기를 사용해서 전송하는 시스템) 코드로 이용   ASCII Code     (American Standard Code for Information Interchange)   ISO에서 제정한 코드이며 7비트(패리티 비트 추가 시 8비트)로 구성된 데이터 통신용 코드   순차적인 코드(알파벳이나 숫자가 순서적 코드로 되어 있다)   정보 문자와 제어 문자로 구분   ASCII 코드 제어 문자     전송 제어 : 통신 선로의 데이터 흐름을 제어            SOH(Start Of Head) : 머리말의 시작       STX(Start of TeXt) : 본문의 시작 혹은 머리말의 종료       ETX(End of TeXt) : 본문을 종료       EOT(End Of Transmission) : 전송의 종료, 링크 해제를 요청       ENQ(ENQuire) : 링크 설정 요청, 상대국의 응답을 요청한다       ACK(ACKnowledge) : 긍정적인 응답, 다음 프레임을 요청       DLE(Data Link Escape) : 보조적인 제어 문자, 통신망에서 전송 제어 문자를 구분       NAK(Negative AcKnowledge) : 부정적인 응답 및 재전송 요구       SYN(SYNchronous) : 시간 맞춤 행위를 위한 동기 문자       ETB(End of Transmission Block) : 블록의 종료를 표시           포멧 제어 : 데이터의 출력 및 정보의 레이아웃을 제어            BS(Back Space)       HT(Horizontal Tabulation)       LF(Line Feed)       VT(Vertical Tab)       FF(Form Feed)       CR(Carriage Return)           장치 제어 : 단말기의 보조 장치를 제어   정보 분리 : 데이터의 논리적 요소를 분리            US(Unit Separator)       RS(Record Separator)       GS(Group Separator)       FS(File Separator)           BCD(Binary Coded Decimal)  컴퓨터 내부 코드로 10진수를 표현하기 위하여 주로 사용  데이터 비트가 6비트로 구성되므로 총 64개의 문자 표현이 가능   EBCDIC(Extended Binary Coded Decimal Interchange Code)  IBM 컴퓨터의 내부 코드로 사용되며 컴퓨터와 컴퓨터 사이에 데이터 전송 코드로 사용   8비트로 구성되며 총 256문자 표현이 가능   UNICODE  서로 다른 언어를 사용하는 컴퓨터들이 문제없이 통신하도록 모든 문자 체계를 하나의 문자 집합으로 만든 것. 숫자와 글자(키와 값)가 1:1 매핑된 형태의 코드   Character set = UTF(Unicode Transformation Format) : 포함시키고자 하는 문자 집합을 정의      UTF-8            하나의 문자를 1 ~ 4바이트의 가변 길이로 표현       현재 인터넷에서 가장 많이 쓰이면 인코딩이며 뛰어난 크로스 플랫폼 호환성을 지님       웹, 데이터베이스에서 주로 사용           UTF-16            모든 문자를 2바이트의 고정 길이로 표현       바이트 순서가 정해지지 않아 리틀/빅 에디안 문제가 발생하기 때문에 인터넷 상에서의 사용을 권고하지 않음       윈도우 계열에서 사용           UTF-32            모든 문자를 4바이트의 고정 길이로 표현       저장 공간의 낭비가 심하다는 단점이 존재          ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-transmission/",
        "teaser": null
      },{
        "title": "[데이터통신] 데이터 전송 제어",
        "excerpt":"데이터 링크 제어  데이터 통신망에 접속된 컴퓨터나 단말 장치가 오류 없이 투명한 정보를 효율적이고 원할하게 송/수신하기 위하여 데이터 통신 시스템이 갖추어야 할 제어 기술로 데이터 입출력, 동기 제어, 오류 제어 등을 포함한다   데이터 전송 제어 절차          회선접속    일반 교환망에서의 물리적인 접속 단계            데이터 링크의 확립    데이터 송수신을 위한 논리적인 경로를 구성하는 단계    (링크 확립 방법 : Selection, Polling)            데이터 전송    송수신측 간의 메시지 전송 단계            데이터 링크의 해제 통보     링크 확립을 종료하는 단계로 논리적인 경로를 해제하는 단계            회선 절단    교환망에 연결된 회선 접속 단계로 물리적인 접속을 해제하는 단계       데이터 전송 프레임  전송 프레임 : 수신측의 입장에서 보면 전송되는 모든 정보가 ‘1’과 ‘0’으로 수신되는데, 이 때 수신된 비트열이 어디서부터 제어 영역이고 어디서부터 정보 영역인지를 미리 약속하지 않는다면 정상적으로 수신된 비트 열일지라도 다른 의미를 갖는 정보로 해석될 수 있다.   따라서, 7비트(문자 지향 프레임), 8비트(바이트 지향 프레임, DEC사의 DDCMP), 비트 지향 프레임을 부여하여 송수신하도록 해야 한다. 이처럼 송신측에서 발생된 정보의 정확한 전송을 위해 사용자 정보에 헤더와 트레일러를 부과하는 과정을 캡슐화라고 하며, 이러한 형식화된 데이터 블록을 프레임이라고 한다   문자 지향 프레임     IBM사의 BASIC   전송 방향은 반이중 방식으로만 사용   회선 연결은 점 대 점 방식뿐만 아니라 멀티 포인트 링크에서도 사용될 수 있다   같은 전송 회선만 가능(종속적)   오류 제어 방식은 Stop-And-Wait ARQ를 사용   오류 검출이 어렵고, 전송 효율이 나쁘다   주로 동기 전송 방식을 사용하나 비동기 전송 방식을 사용하기도 한다                                         BCC(Block Check Character) 검사 범위 : [Heading - STX - Text - ETX]                 source : http://egloos.zum.com/nooriry/v/1598115           비트 지향 프레임     ISO의 HDLC, IBM사의 SDLC, 미 국방성 TCP                                         source : http://www.rhyshaden.com/hdlc.htm           FLAG  프레임 구조의 앞과 뒤를 구분하는 비트 열('01111110', ‘7E’)   통신 회선을 공유하는 모든 다른 프레임들과 구분하는 비트 열로 송신측에서는 송신하기 전에 송신 메시지 앞과 뒤에 추가하여 전송 FLAG 비트를 제외한 모든 비트는 연속된 ‘1’의 비트가 6개 이상이 되지 않도록 강제적으로 ‘0’을 추가하여 송신.   수신측은 FLAG 비트를 제외한 비트 열에 ‘1’의 문자가 연속적으로 5개가 입력되면 5개 다음에 입력된 ‘0’ 비트를 제거한다. 이처럼 ‘0’을 삽입하고 ‘0’을 제거하여 기본적인 오류를 검출하고 신뢰성 있는 송수신이 되도록 하는 기능을 비트 투과성(Bit Transparency) 또는 비트 스터핑(Bit Stuffing)이라고 한다      프레임의 앞과 뒤를 구분   동기를 유지   비트 투과성으로 기본적인 오류를 검출   ADDRESS  상대국이나 복합국의 주소를 지정할 때 사용하는 블록으로 기본적으로 8비트를 사용하며 8바이트까지 확장 가능      1바이트를 사용할 시, 방송용 주소(11111111)와 시험용(00000000)을 제외하면 실제 주소는 254개 부여 가능   CONTROL     I(Information) 프레임            순수한 정보만을 전송하는 프레임       첫 번째 비트가 '0'       사용자 데이터를 전달하거나 피기백킹 기법을 통해 데이터에 대한 확인 응답을 보낼 때 사용       피기백킹 : 데이터 프레임에 확인응답을 포함시켜 전송하는 것           S(Supervisor) 프레임            정보 전송 프레임을 감시/감독하는 프레임으로 흐름제어, 에러 제어를 담당하는 프레임       상위 두 비트가 '10'       RR(00, 수신 완료), REJ(01, 수신 거부), RNR(10, 수신 준비 안 됨)등의 제어 명령이 존재           U(Unnumbered) 프레임            통신하기 위한 초기 설정 및 링크 확립과 해제 등의 명령이 있는 프레임       상위 두 비트가 '11'       SMD(Set Mode)의 기능                                 NRM(Normal Response Mode, UNC, 표준 응답 모드)  주 스테이션이 링크 제어를 담당하며, 부 스테이션은 주 스테이션으로부터 메시지를 수신한 경우에만 데이터를 전송할 수 있다(반이중 통신)  점 대 점이나 멀티 포인트 불균형 링크 구성에 사용                                    ARM(Asynchronous Response Mode, UAC, 비동기 응답 모드)  주 스테이션이 링크 제어를 담당하며, 부 스테이션은 주 스테이션으로부터 메시지가 없어도 데이터를 전송할 수 있다(전이중 통신)  점 대 점이나 멀티포인트 불균형 링크 구성에 사용                                    ABM(Asynchronous Balance Mode, BAC, 비동기 균형 모드)  주 스테이션과 부 스테이션의 구분이 없이 동등하다  링형이나 망형 구조의 균형 링크 구성에 사용(전이중 통신)                                    SIM(Set Initial Mode, 모드 설정 초기화)                                       정보부  사용자 사이에서 교환되는 정보 메시지 블록의 길이, 구성과 관계없이 송수신 간 협의에 따른다   FCS(Frame Check Sequence, 프레임 검사 순서부)  주소부/제어부/정보부 블록의 오류를 검사하는 블록으로 오류 검사 방법은 주로 CRC 방식을 사용   HDLC 특징     전송 방향 : 단방향/반이중/전이중 방식 모두 사용 가능   회선 연결 : 점 대 점, 멀티포인트, 루프 방식 모두 사용 가능   오류 제어 방식 : ARQ(Go-Back-N, Seletive-repeat) 사용   다른 전송 회선도 가능(독립적)   동기식 전송으로 전송 효율과 신뢰성이 높다   기타 프레임     SDLC(Synchronous Data Link Control)            HDLC를 기반으로 하는 비트 위주 데이터 링크 제어 프로토콜       X.25 패킷 교환망 표준의 한 부분으로 ITU-T에 의해 제정           LAP-B(Link Access Procedure Balanced)            X.25 패킷 교환망의 표준으로 ITU-T에서 제정한 HDLC 기반으로 하는 비트 위주 프레임           LAP-D(Link Access Procedure D channel)            ISDN의 D채널을 위한 프레임 혹은 데이터 링크 제어 프로토콜       LAP-B와는 달리 다중화된 채널을 성립시킬 수 있다           LLC(Logical Link Control)            LAN에서 사용되는 대표적인 프레임.(IEEE802 표준 계열)           SLIP(Serial Line Internet Protocol)            전화선과 모뎀을 이용하여 인터넷에 접속하기 위한 프레임           PPP(Point-to-Point Protocol)            전화선과 모뎀을 이용하여 인터넷에 접속하기 위한 프레임       SLIP을 개선하여 에러를 검출하고 복구하는 기능 존재       HDLC와 유사한 점이 있으나 문자 위주 프레임이다          ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-transmission-control/",
        "teaser": null
      },{
        "title": "[IT이슈] 2021년 가트너 9가지 기술 전략",
        "excerpt":"2021년 가트너 기술 전략               사람 중심(People Centricity)     팬데믹 사태가 사람들의 일하는 방식 그리고 조직과 상호작용하는 방식을 변화시켰을지라도 여전히 사람이 모든 기업의 중심입니다. 따라서, 현재와 같은 환경에서 기업이 작동하기 위해선 프로세스를 디지털화해야 할 필요가 있습니다.    행동인터넷(IoB, Internet of Behaviors)  IoB는 데이터를 수집하고 사용하여 사람의 행동을 유도하거나 변경하는 것을 의미한다.   디지털과 물리적인 세계에서 일상 생활에 대한 데이터를 수집할 수 있는 기술이 증가함에 따라, 데이터를 사람들의 행동에 영향을 미치는 데 사용할 수 있게 되었습니다. 그러나 행동 인터넷은 사용 목적과 결과에 따라 윤리적, 사회적인 영향을 주기도 한다는 점을 유의해야 합니다.   전체 경험(TX, Total Experience = 통합 경험)  다중 경험(MX, MultieXperience), 고객 경험(CX, Customer eXperience), 직원 경험(EX, Employee eXperience) 및 사용자 경험(UX, User eXperience)을 결합한 것을 의미한다. 전체 경험 목표는 기술부터 직원, 고객 및 사용자에 이르기까지의 이러한 모든 요소가 교차하는 전반적인 경험을 개선하는 것이다.   개인정보보호 강화 컴퓨팅(Privacy-Enhancing Computation)  개인 정보 보호 강화 컴퓨팅에는 사용되는 동안 데이터 처리와 분석을 통해 데이터를 보호하는 세 가지 기술이다.     민감한 데이터를 처리하거나 분석할 수 있는 신뢰할 수 있는 환경을 제공한다.   분산된 방식으로 처리 및 분석을 수행한다.   처리 또는 분석 전에 데이터와 알고리즘을 암호화한다.   이처럼 개인정보보호 강화 컴퓨팅 기술은 개인적인 데이터를 노출하지 않으며, 이 접근 방식은 개인 정보 또는 보안을 유지하면서 데이터를 공유해야 하는 필요성이 증가할 수 있도록 특별히 설계되어야 한다.   위치 독립성(Location Independence)     COVID-19는 조직의 생태계에서 물리적인 공간을 사라지게 했습니다. 이러한 새로운 형태로 비즈니스가 유지되기 위해선 기술의 전환이 필요합니다.    분산 클라우드(Distributed Cloud)  분산 클라우드는 퍼블릭 클라우드 서비스가 서로 다른 물리적 위치에 분산되어 있지만 운영, 업데이트, 서비스 개선 등은 퍼블릭 클라우드 제공자가 담당하는 것을 의미한다.   분산 클라우드는 다음과 같은 이점을 지니고 있습니다.     데이터 비용을 절감시키고 특정한 지역에 있어야 하는 데이터 관련 규제 법률을 수용할 수 있게 합니다.   클라우드 서비스가 로컬 또는 반 로컬 서브넷에 존재하기 때문에 네트워크 장애 위험을 감소시켜 줍니다.   클라우드 서비스를 호스팅하거나 사용할 수 있는 영역의 수와 가용성을 매우 증가시킬 수 있습니다.   가트너는 분산 클라우드가 클라우드의 미래라고 보며, 2024년까지 대부분의 클라우드 서비스 플랫폼이 필요에 따라 분산 클라우드 서비스를 제공할 것으로 전망하고 있습니다.   어디서나 운영(Anywhere Operation)  COVID-19에서 기업이 성공적으로 부상하려면 어디서나 운영 모델이 필수적이다. 핵심적으로 이 운영 모델은 고객, 고용주 및 비즈니스 파트너가 물리적으로 원격 환경에서 운영되는 곳 어디에서나 비즈니스에 접근하고 제공하고 활성화할 수 있도록 해야 한다.   어디서나 작동하는 모델은 ‘디지털 우선, 원격 우선(Digital first, Remote first)’이다.   사이버 보안 메시(Cybersecurity Mesh)  자신 또는 개인이 어디에 있든 보안 경계 밖에 존재하는 모든 디지털 자산에 안전하게 접근할 수 있도록 하는 기술을 의미하며, 확장 가능하고 유연하며 안정적인 사이버 보안 제어에 대한 분산 아키텍처 접근 방식이다.   이제 많은 자산이 기존 보안 경계 외부에 존재한다. 사이버 보안망은 기본적으로 사람이나 사물의 신원과 위치를 중심으로 보안의 경계가 정의되도록 합니다. 이러한 사이버 보안망은 정책 조정을 중앙 집중화하고 정책 시행을 분산하여 더욱 모듈화되고 주의가 필요한 보안 접근 방식을 가능하게 합니다.   회복 탄력성(Resilient Delivery)     전 세계의 불황은 언제나 존재해왔습니다. 조직이 이에 대응하고 적응한다면 수 많은 혼란을 극복할 수 있을 것입니다.    지능형 구성 가능한 비지니스(Intelligent Composable Business)  현재 상황에 따라 적응하고 근본적으로 재정렬할 수 있는 비즈니스를 의미한다.   끊임없이 증가하는 속도 변화에 따라 조직이 나아가기 위해선 모듈화, 자율성, 조정, 발견을 기반으로 결합을 강조하는 사고방식을 갖추어야 합니다. 또한 조직이 디지털 트렌스포메이션을 더욱 빠르게 추진하려면 디지털 비즈니스 전략을 가속화하고, 이에 따라 현재 이용할 수 있는 데이터를 기반으로 민첩하고 빠른 비즈니스 결정을 내려야 합니다.   이를 성공적으로 수행하기 위해 조직은 정보에 대한 더 나은 액세스를 가능하게 하고 더 나은 통찰력으로 정보를 보강하며 해당 통찰력의 의미에 신속하게 대응할 수 있는 능력을 갖추어야 한다. 여기에는 조직 전체의 자율성과 민주화가 포함되어 비효율적인 프로세스에 의해 방해받지 않고 기업의 일부가 신속하게 대응할 수 있다.   AI 엔지니어링(AI Engineering)  강력한 AI 엔지니어링 전략은 AI 투자의 전체 가치를 제공하면서 AI 모델의 성능, 확장성, 해석 가능성 및 안정성을 촉진한다. AI 프로젝트는 종종 유지 보수성, 확장성 및 거버넌스와 관련된 문제에 직면하여 대부분의 조직에 문제가 될 수 있다.   AI 엔지니어링은 경로를 제공하여 AI를 전문적이고 격리된 프로젝트 세트가 아닌 주류 DevOps 프로세스의 일부로 구현된다. 여러 AI 기술의 조합을 운영할 때 가치에 대한 명확한 경로를 제공하면서 AI 과대광고를 자제시키기 위해 다양한 분야를 통합한다. 또 AI 엔지니어링의 거버넌스 측면으로 인해 ‘책임감있는 AI (Responsible AI)’가 신뢰, 투명성, 윤리, 공정성, 해석 가능성 및 규정 준수 문제를 처리하기 위해 등장하고 있다. 이에 대응해야 될 것이다.   즉, 그것은 AI 책임의 운영화로 AI 솔루션을 개발하거나 사용하는 모든 조직은 AI 위험이 브랜드를 위태롭게 하거나 규제 조치를 취하거나 보이콧으로 이어지거나 비즈니스 가치를 파괴하지 않도록 사전에 대처해야 한다.   초자동화(Hyperautomation)  조직에서 자동화할 수 있는 것은 무엇이든 자동화해야 한다는 것이다.   초자동화는 효율적이지 않은 레거시 비즈니스 프로세스를 보유한 조직이 주도하여 조직에 막대한 비용과 광범위한 문제를 야기한다. 많은 조직들이 희박하거나, 최적화되거나, 연결되거나, 깨끗하거나, 명시적이지 않은 기술의 ‘패치워크(patchwork)’에 의해 지원을 받는다. 동시에 디지털 비즈니스의 가속화는 효율성과 속도, 민주화를 필요로 한다. 효율성, 효율성, 비즈니스 민첩성에 집중하지 않는 조직은 뒤처질 것이다.   참고자료  2021 가트너 전략 기술 트랜드  https://www.wedesignx.com/knowledge/2021-gartner-strategic-technology-trend-top-9  ","categories": ["study"],
        "tags": ["IT트랜드"],
        "url": "https://many258.github.io/study/it-issue-gartner/",
        "teaser": null
      },{
        "title": "[데이터통신] 데이터 오류 제어",
        "excerpt":"데이터 오류 제어  오류 발생 원인          상호 변조 잡음(Inter Modulation Noise)  서로 다른 주파수들이 똑같은 전송 매체를 공유할 때 이 주파수들이 서로의 합과 차의 신호를 발생함으로써 발생되는 채널의 간섭 현상            누화 잡음(Cross Talk Noise)  인접한 전송 매체의 전기적인 신호의 결합으로 생기는 잡음            동일 채널 잡음  두 개 이상의 채널이 동일한 주파수를 사용하게 될 때 발생하는 잡음  위성 통신에서 사용하는 주파수와 도심속에서 사용하는 주파수가 가끔 동일할 때 이러한 잡음이 발생한다.            방사 잡음  높은 주파수 대역을 사용하는 위성 통신에서 주로 발생하는 잡음으로 전송 신호의 주 신호에서 새어 나가는 신호를 의미            지연 왜곡(Delay Distortion)  주로 하드와이어 전송 매체에서 발생되며, 전송 매체를 통한 신호 전달이 주파수에 따라 그 속도를 달리함으로써 유발되는 신호 손상 현상으로 주파수의 중심 주파수와 양쪽 끝 주파수 강도의 차이 때문에 발생하는 오류            열 잡음(Thermal Noise), 백색 잡음(White Noise)  전송 매체 내에서 온도 변화에 따른 전자 운동량이 변함으로써 발생하는 잡음으로 모든 전자/전기적인 전송 매체에서 발생. 열 잡음은 위성 통신에서는 발생하지 않음            손실, 감쇠 현상, 누화 잡음, 충격성 잡음       오류 제어 방식  순방향(전진) 오류 수정(FEC : Forward Error Correction)  송신측에서 전송 프레임에 잉여 비트를 추가하여 수신츠겡서 오류를 검사하고 수정까지 할 수 있도록 하여 송신측에서는 같은 프레임을 재전송하는 일이 없도록 하는 방식      종류 : 해밍코드, 상승 코드   송신 측이 한 개이고 수신측이 여러 개일 경우에 사용하는 방식   역방향(후진) 오류 수정(BEC : Backward Error Correction)  송신측에서 전송되어 온 프레임들 중 오류가 있는 프레임을 판단하여 오류가 발생되면 송신측에 통보하여 다시 재전송 받는 방식      종류 : CRC, 패리티 비트, BSC(블록 합 : Block Sum Check)   ARQ(Automatic Repeat reQuest)   ARQ(Automatic Repeat reQuest : 오류 검출 후 재전송)          Stop-And-Wait ARQ  한 번에 한 개의 프레임을 전송  한 개의 프레임을 전송한 후 수신측의 ACK나 NAK를 기다린다  ACK → 다음 프레임 전송  NAK, 일정시간 무응답 → 같은 프레임 재전송  재전송이 있을 수 있으므로 송신측에 버퍼가 한 개 필요  오버헤드로 인한 부담이 크다  BASIC 전송 절차에서 사용하는 오류 제어 방식            Go-Back-N ARQ  여러 개의 프레임을 전송  수신측의 NAK 신호가 도착하지 않으면 계속적으로 전송  수신측의 응답이 없으면 긍정적인 응답으로 간주  오류가 발생하면 오류가 발생한 프레임부터 다시 전송  중복 전송 문제가 발생  오류가 적은 전송일 때 효율적  HDLC, SDLC 전송 절차에서 사용되는 오류 제어 방식            Selective-Repeat ARQ  여러 개의 프레임을 전송  수신측의 NAK 신호가 도착하지 않으면 계속적으로 전송  수신측의 응답이 없으면 긍정적인 응답으로 간주  오류가 발생하면 오류가 발생한 프레임만 재전송  중복 전송 문제를 보완한 방식  일부분을 재전송하면 수신측에서는 재결합을 해야 하므로 많은 버퍼가 필요  기술적으로 복잡하여 Go-Back-N ARQ에 비해 사용되는 경우가 적다  오류가 많을 때 주로 사용  HDLC 전송 절차에서 사용되는 오류 제어 방식            Dynamically ARQ  동적으로 프레임을 전송  수신측에서는 오류 발생 확률을 송신측에 전송  송신측은 적절한 개수를 수신측에 동적으로 전송  전송 효율의 향상 기대  제어 기술이 매우 복잡하고 비용 문제로 인해 거의 사용하지 않음       오류 검출 방식  해밍코드(Hamming Code)  데이터비트에 몇 개의 체크비트가 추가된 형태로 수신측에서 에러 비트의 위치와 정정이 가능하므로 자기 정정 부호라고 한다      1비트의 오류만 수정이 가능하며, 2비트의 오류 검출은 가능하나 수정을 불가능하다   정보 비트 외에 잉여 비트가 많이 필요하므로 많은 양의 데이터 전송에 유리하다      $2^p &gt;= d + p + 1$  d: 데이터 비트 / p: 체크 비트     패리티 비트의 위치 = $2^n, (n=0,1,2…)$    데이터 크기가 8비트라 가정할 때, 위 식에 대입 시 패리티 비트는 4가 되어 4비트의 추가 비트가 필요하다      짝수패리티라 가정할 때, 각 검사 시 총 ‘1’의 개수가 짝수가 되도록 확인하여 Pn 값을 입력한다   P1 : 1번째 비트에서 시작하여 1비트 간격으로 검사  P2 : 2번째 비트에서 시작하여 2비트 간격으로 검사  P3 : 4번째 비트에서 시작하여 4비트 간격으로 검사  P4 : 8번째 비트에서 시작하여 8비트 간격으로 검사  = Pn : P$^{n-1}$번째 비트에서 시작하여 P$^{n-1}$비트 간격으로 검사      위 테이블에서 P1, P3을 보면 총 ‘1’의 개수가 홀수이므로 오류임을 알 수 있다. 그렇기 때문에 P1, P3을 ‘1’로 오류가 없는 P2, P3를 ‘0’으로 가정한다.   이 때, P4/P3/P2/P1(컴퓨터가 인식하는 2진수는 오른쪽부터 시작하므로)으로 나열했을 때 각 위의 값을 넣어주면 최종적으로 0101 값이 구해지고 결과값은 5이므로 5번째 비트가 오류임을 확인할 수 있다.   상승 코드(부호) 방식  순차적 디코딩과 한계값 디코딩을 사용하여 오류를 수정      여러 개의 비트 오류가 있더라도 모두 수정할 수 있는 방식   군 계수 검사 방식  전송되는 정보 비트열 중 ‘1’의 개수를 세어서 2진수로 변환한 다음 2진수 끝의 두 비트를 전송되는 정보 비트열에 추가하여 전송하는 방식   패리티 비트  잉여 비트를 추가하여 전송 오류의 검출을 위해 사용한다      전송 비트 내 ‘1’의 개수가 짝수 또는 홀수 개가 되도록 결정   짝수 개의 비트가 오류가 발생할 경우 검출률이 낮아지는 단점 존재   수직 중복 검사(VRC: Vertical Redundancy Check, 1차원 패리티)  오류 검출 방식에서 가장 적은 비용이 들며 가장 널리 사용되는 기법으로 보통 패리티 검사라고 한다.      패리티 비트를 각 정보 비트에 추가하여 패리티 비트를 포함한 정보 비트 내의 ‘1’의 전체 개수를 짝수가 되도록 한다   패리티 비티의 위치는 고정되지 않고 앞/뒤/중간 어디든 사용 가능   세로 중복 검사(LRC: Longitudinal Redundancy Check, 2차원 패리티)  전송 비트를 일정량의 블록으로 묶어서 블록의 맨 마지막에 패리티 비트를 부여   순환 중복 방식(CRC: Cycle Redundancy Check)  다항식 코드를 사용하여 오류를 검출하는 방식  정보 비트열 전부를 한 번에 검사하지 않고 부분적으로 중첩되게 검사하므로, 집단/군집 오류 검출 방식이라고도 한다      동기식 전송에 주로 사용   HDLC 프레임의 FCS 블록에서 사용   가장 많이 사용되는 오류 검출 방식   1개, 2개, 홀수 개의 오류는 완벽하게 검출   매우 복잡하나 오류를 수정할 수 있는 방식이 아님을 주의   검사 합(Checksum)  패리티 검사나 CRC와 같이 중복의 개념을 기반으로 하여 네트워크를 통해 전달된 값이 변경되었는지를 검사하는 값으로 무결성을 제공   송신측에서 전송할 모든 데이터를 16 비트 워드 단위로 구분하고 1의 보수를 취한 뒤 그 합에 대한 결과를 전송한다. 수신측은 같은 합을 하여 오류를 검출한다(검사합의 값이 0 이면 오류 없음, 0이 아니면 오류 있음)      간단한 방식이나 워드의 순서가 바뀌는 오류에 대한 검출은 불가   보통 16비트 워드 단위로 사용   RS 부호(Reed–Solomon error correction)  Reed와 Solomon이 개발한 군집 형태의 오류를 수정할 수 있는 코드로 콤팩트 디스크에 사용되는 CIRC(교차 인터리브 리드 솔로몬 부호)이다. 하드 디스크에 사용된 LDC(긴거리 부호) 와 DVD에 사용된 RSPC(리드 솔로몬 적부호) 등이 있다.  ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-error-control/",
        "teaser": null
      },{
        "title": "[데이터통신] 회선 공유 기술",
        "excerpt":"회선 공유 기술  하나의 컴퓨터에 여러 개의 단말기가 원거리에서 접속할 경우 단말기 각각에 직접 접속하는 것은 통신 회선의 비용이 높아지므로 경제적인 시스템을 구축할 수 없다.   따라서, 단말기로부터 근접한 곳에 통신 회선을 공유할 수 있는 장비 및 프로그램을 설치하여 다수의 단말기가 컴퓨터에 접속할 수 있도록 하는 것이 경제적이다.   이처럼 통신 회선을 공유하는 장비 및 프로그램에는 통신 회선을 정적으로 나누어 사용하는 다중화기와 동적으로 사용하는 집중화기가 존재한다.   다중화기  하나의 고속 통신 회선을 통해 일정한 시간이나 주파수를 규칙적으로 나누어 사용하는 방식      여러 개의 채널들이 하나의 통신 회선을 통하여 결합된 신호의 형태로 전송되고 수신측에서 다시 이를 여러 개의 채널 신호로 분리하는 역할 수행   전송 효율을 높일 수 있다는 것이 가장 중요한 특징   구조가 단순, 규칙적인 전송에 사용   입출력 각각의 채널 대역폭이 동일   M개의 입력 회선을 M개의 출력 회선으로 다중화하는 장치   입력 회선의 수는 출력 회선의 수와 같아야 한다   모든 단말기가 항상 사용하는 것이 아니므로 통신 회선에 분배된 시간이나 주파수가 낭비되는 단점 존재   집중화기  하나의 고속 통신 회선을 통해 하나의 단말기만을 사용할 수 있도록 제한  하나의 단말기가 고속의 통신 회선을 사용하고 있는 동안 다른 단말기에서 요청한 자원은 버퍼에서 대기      통신 회선을 효율적으로 사용할 수 있으나 각 단말기에서 요청한 신호에 의한 충돌의 문제가 존재   구조가 복잡하며, 불규칙적인 전송에 사용   입출력 각각의 채널 대역폭이 다르다   입력 회선의 수는 출력 회선의 수보다 같거나 많아야 한다        M개의 입력 회선을 N개의 출력 회선으로 집중화하는 장치       전위 처리기(FEP: Front End Processor)  특정한 컴퓨터 시스템이 많은 양의 통신 처리 능력을 갖게 해주는 역할을 수행하는 장치   다중화기 분류  주파수 분할 다중화(FDM: Frequency Division Multiplexing)  통신 회선의 주파수를 여러 개의 작은 대역 폭으로 분할하여 여러 대의 단말기가 동시에 사용할 수 있도록 한 방식      채널 간의 상호 간섭을 막기 위해 보호 대역이 필요(대신 채널의 이용률을 저하)   전송 매체의 유효 대역폭이 클 때 사용   전송 매체를 지나는 신호는 아날로그 신호   비용 저렴, 구조 간단   비동기식 전송이며, 멀티 포인트 방식에 적합   모뎀의 역할을 겸하므로 별도 모뎀이 필요 없음   전송 지연없이 실시간 전송 가능   누화 잡음 및 상호 변조 잡음이 발생   시간 분할 다중화(TDM: Time Division Multiplexing)  한 통신 회선의 대역폭을 일정한 시간 폭(Time Slot)으로 나누어 여러 개의 단말기가 하나의 통신 회선을 사용할 수 있도록 하는 기술      전송 매체의 유효 전송률이 클 때 사용   전송 매체를 지나는 신호는 디지털 신호   고가의 비용, 복잡한 기술   별도의 모뎀 필요, 누화 잡음 및 상호 변조 잡음이 발생하지 않음   전송 지연 없이 실시간 전송이 가능   대역폭이 낭비되지 않음   동기식 시분할 다중화(STDM: Synchronous TDM)  모든 단말기에 고정된 시간 폭을 제공      매체의 데이터 전송률이 전송 디지털 신호의 데이터 전송률을 능가할 때 사용   전송할 데이터가 없는 단말 장치에도 타임 슬롯을 할당(전송 용량의 낭비가 크다)   고가의 가격, 접속에 소요되는 시간이 늘어난다   전송 용량보다 많은 터미널 수에 접속할 수 없다   다중화된 회선의 데이터 전송률 &gt;= 접속 장치들의 데이터 전송률의 합   비동기식 시분할 다중화(ATDM: Asynchronous TDM, 통계적/지능적/확률적)  접속된 단말기 중 실제로 전송할 데이터가 있는 단말기에만 시간 폭을 제공      매체의 데이터 전송률이 전송 디지털 신호의 데이터 전송률을 능가하지 않을 때 사용하는 다중화 방식   전송 매체상의 전송 프레임마다 해당 채널의 시간 슬롯이 가변적으로 할당   전송 용량의 낭비가 적다   저가의 가격, 접속에 소요되는 시간이 단축   같은 속도일 경우 동기식 다중화기보다 더 많은 수의 터미널에 접속 가능   다중화된 회선의 데이터 전송률 &lt; 접속 장치들의 데이터 전송률의 합   코드 분할 다중화(CDM: Code Division Multiplexing)  아날로그 형태인 음성을 디지털 신호로 전환한 후 난수를 부가하여, 여러 개의 디지털 코드로 변환해 다중화하는 것으로 각 채널에 고유한 코드를 부여하여 해당 코드를 가진 단말기만을 인식하게 하는 방식      확산 대역 방식(하나의 채널로 전달되는 데이터가 여러 경로를 통해 전달)   다원 접속 방식은 FDMA, TDMA, CDMA를 모두 사용   전송 용량 증가, 전송 품질 및 보안성 향상   이동 통신에 사용되는 통신 방식               WAP(Wireless Application Protocol, 무선 응용 프로그램)  무선 단말기상에서 인터넷을 이용할 수 있도록 해주는 프로토콜의 총칭       WAP에서 사용되는 주 언어가 WML(무선 마크업 언어)이며 휴대 전화와 같은 소형 이동 장비에 맞게 XML 기반으로 설계  HTML을 수신하는 경우 이를 컴파일해서 최적화된 이진 데이터로 변환하여 이동 단말에 송신            Cell  전파 출력을 낮추어 발사하면 전파가 미치는 영역은 좁아지지만 서비스 지역을 여러 개의 작은 영역으로 분할할 수 있게 된다. 작은 영역마다 기지국을 두어 주파수를 발사하면 동일한 주파수를 다른 작은 영역에서도 사용할 수 있게 된다.       이 때, 작은 영역을 셀이라고 하며 일정한 영역을 여러 개의 셀로 구분하여 사용하면 채널 수를 셀의 영역 수의 배수만큼 늘릴 수 있다는 장점이 있다       Hand-Off  이동 전화 이용자가 하나의 기지국에서 다른 기지국으로 이동하는 과정에서 통화가 끊기지 않게 이어주는 기능                     소프트(Soft) 핸드오프  기지국과 기지국 간에 발생하는 핸드오프 방식으로 하나의 기지국이 이동 전화 이용자의 채널을 먼저 확보하여 연결한 후, 현재 사용 중인 채널의 연결을 끊는 방식                        하드(Hard) 핸드오프  교환기와 교환기 간에 발생하는 핸드오프 방식으로 기지국이 기존 신호를 끊은 뒤 다른 기지국으로 신호를 넘기는 방식                        소프터(Softer) 핸드오프  기지국 내 섹터 간에 발생하는 핸드오프 방식으로 같은 기지국 내의 특정 섹터에서 통화하다가 다른 섹터 영역으로 통화 접근을 할 때 소프트 핸드오프와 같은 방법으로 통화 채널을 연결                        Roaming  이동 통신 가입자가 가입된 관리 지역을 벗어나 어디서나 자유롭게 통신할 수 있는 기술            Bluetooth  휴대폰끼리 또는 휴대폰과 PC 간에 사진이나 벨소리 등의 파일을 전송하는 무선 전송 기술            L2CAP(Logical Link Control And Adaptation Protocol)  블루투스 베이스밴드의 상위에 위치하는 프로토콜이며 상위의 프로토콜 스택에 대하여 다중 통신 기능, 데이터의 분할과 조합, 오류 제어, 인증, 암호화를 정의       기본적으로 Connection-Oriented 프로토콜을 제공하지만 Connectionless 방식도 제공한다. 하지만 Connectionless 방식은 많이 사용 되지 않는다. 고정된 최대 크기 만큼의 Reliable한 전송을 제공한다. L2CAP의 전송 Reliability는 설정이 가능하며 3가지 정책이 사용 가능하다.             재전송를 하지 않는다       모든 전송이 실패하기 전까지 재전송 시도       특정 시간(0-1279 miliseconds) 후까지 ack이 오지 않았을 경우 패킷을 버리고 큐에 보관된 다음 패킷을 전송.(이 경우는 시간에 따라서 데이터가 전송되어야 할 경우 유효하다)           역 다중화기(Inverse Multiplexer)  하나의 통신 회선으로 데이터를 전송받은 것을 두 개의 음성 대역 회선으로 나누는 장치   광대역 통신 회선을 사용하기 않고 9600bps 이상의 광대역 속도를 얻을 수 있어 통신 비용을 줄일 수 있다      고속의 선로를 두 개의 낮은 선로로 전송한 후 다시 원래 속도로 변환   두 개의 음성 대역 회선을 이용하여 광 대역 통신 속도를 얻을 수 있다   두 회선의 전송 속도의 차이로 상대적인 전송 지연이 발생할 수 있고 이를 조절하기 위한 순환 기억 장치 필요   여러 가지 변화에 대응해 여러 가지의 전송 속도를 얻을 수 있다   음성 대역의 변/복조기 역할을 수행   위성 통신  인공위성을 통하여 지구상의 어느 곳이든 통신할 수 있도록 하는 통신 방법      주로 3 ~ 30GHz인 SHF(Super high frequency, 초고주파) 주파수를 이용하여 통신 위성의 중계를 거쳐 먼 거리까지 통신하는 방식   항상 마주 보이는 안테나가 있어야 통신이 가능(많은 곳에 위성 중계기가 필요)   하나의 정지 위성 Cover 비율이 이론적으로 지구 표면에 42.4%이므로 3개의 정지 위성만 있으면 극 지역을 제외한 지구상의 어떤 지점과도 통신이 가능   점 대 점에서만 가능   전송 지연이 존재   지구국은 교외에 설치해야 한다(동일 채널 잡음이 발생하므로)   보안성이 떨어지며 기후에 영향을 받는다          위성 통신의 기본 구조            기기계 : 구조계, 자세 제어계, 열 제어계, 전력계, 추진계, 원격 측정 명령계       통신계 :                    위성 중계기(트랜스 폰더) : 지구국(지상)으로부터 송신되어 온 신호 주파수를 송신 주파수로 바꿔 증폭하는 역할 수행                           ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-line-sharing/",
        "teaser": null
      },{
        "title": "[데이터통신] 매체 접근 기술(MAC)",
        "excerpt":"매체 접속 제어(MAC : Media Access Control)  호스트 컴퓨터에 연결되어 있는 여러 개의 단말기들은 통신 회선을 공유하고 있다. 이 단말기들이 어떻게 통신 회선을 점유하는가에 따라 통신 시스템 효율에 영향을 주게 된다.   공유 회선을 동적으로 점유하는 것을 공유 회선 점유 방식이라고 한다   예약 방식(Reservation)  길고 연속적인 정보(Stream)에 적당한 방식으로 통신 회선의 시간 폭(Slot Time)을 미리 예약하는 방식.   2차국에서 1차국에 송신할 자료가 있다는 신호를 보내면 1차국에서는 통신 회선 점유표(Time Stamp)를 참조하여 통신 회선의 사용을 허가   경쟁 방식(Contention)  트래픽이 적은 소량의 데이터 전송에 적합한 방식으로 모든 단말기가 컴퓨터에 전송하기 위해 순서와 규칙이 없이 경쟁하여 선로를 점유하는 방식     즉, 송신 요구를 먼저 한 쪽이 송신권을 갖는 방식    구현이 쉽고 전송량이 소량일 때는 적합하지만 전송량이 많을 때는 성능이 저하   ALOHA  Ethernet 모델에서 사용되는 공유 회선 점유 기술인 CSMA/CD의 기본 원리로 이 기법은 모든 단말기에 자유롭게 적용된다.   우선 단말기는 전송할 데이터가 있으면 점유 허가 신호를 컴퓨터에 전송하고 컴퓨터에서 긍정적인 응답(ACK)이 도착할 때까지 일정한 시간(최대 가능한 왕복 전파 지연 시간 : 전송 신호가 한 노드에서 다음 노드로 도달할 때 걸리는 시간)을 기다리다가 응답이 없으면 포기하는 방식      충돌이 발생하면 수신측에서는 전송을 포기   Slot-ALOHA  ALOHA 기법의 성능이 떨어지는 단점을 보완한 방법으로 모든 단말기의 공유 회선에 접근할 수 있는 시간 폭(Time Slot, 채널)을 할당하여 동기화한다. 각 단말기의 데이터 전송은 해당되는 접근 시간에 전송이 가능하며 시간이 겹칠 경우에는 충돌로 간주   CSMA  각 단말기가 1차국의 허가(ACK)를 기다리지 않고 서로 경쟁하면서 접근하며, 충돌을 피해가지 않고 충돌을 이용하는 형태로 변경되었다.   채널이 휴지 시간(Idle Time)이면 점유한다. 채널이 사용 중이면(충돌) 사용이 끝나기를 기다린 후 즉시 점유하거나 일정한 규칙을 정하여 접근      1-Persistent CSMA            낙천형 : 충돌되지 않으리라는 확률 1을 갖고 사용중이지 않은 것을 감지하자마자 즉시 매체에 접근하여 데이터 프레임 송출       충돌발생 가능성이 가장 크므로 채널사용률이 낮은 대신에 대기시간은 짧다       유선 LAN 이더넷           Non-Persistent CSMA            비관형 : 반드시 충돌될 것이라고 비관하여 비록 사용중이지 않은 것을 감지하여도, 확률분포에서 얻어진 임의 시간 만큼 무조건 기다린 후 매체 접근       충돌이 적어 채널사용률은 높아지나 대기 시간이 많이 소요           P-Persistent CSMA            의심염려형 : 사용중이지 않은 것을 감지하면, 전체 중 확률 P가 충돌되지 않을 것으로 판단하여 매체에 접근하고, 의심을 갖는 나머지 확률(1-P)는 한 단위 시간만큼 기다린 후 매체에 접근       충돌을 줄이고(Non-Persistent 방식) 대기시간을 줄이고자(1-Persistent 방식) 하는 상호보완 방식           CSMA/CD(Carrier Sense Multiple Access / Collision Detection)  통신 채널의 상태를 파악하여 통신 채널이 데이터 전송을 하지 않을 때 정보를 전송하는 방식   데이터 프레임 간의 충돌 발생을 해소하기 위해 CSMA 방식에 충돌 검출 기능과 충돌 발생 시 재송신하는 기능을 추가      송신 요구를 먼저 한쪽이 송신권을 갖는 방식   전송로상의 데이터가 흐르지 않는 것을 확인한 후 데이터를 보내는 방식으로 LAN의 매체 접근 방식   통신 회선이 사용중이면 일정 시간 대기하고 통신 회선상에 데이터가 없을 때에만 데이터를 송신(송신중에도 전송로의 상태를 계속 감시)   송신 도중 충돌이 발생하면 송신을 중지하고, 모든 노드에게 충돌을 알린 후 일정시간이 지난 다음 데이터를 재송신   버스형 구조에서 주로 사용   통신량이 많아지면 충돌이 잦아져 채널의 이용률이 저하되고 전송 지연 시간이 급격히 증가(회선 이용률이 10% 이하이면 충돌이 빈번하게 발생하는 시점)   통신량이 적을 때 유리하며 데이터가 일정한 길이 이하일 경우에는 충돌 신호를 검출할 수 없다   충돌이 발생한 경우 지연 시간을 예측하기 어려움   Ethernet 모델과 개선된 모델에서 계속 사용하는 MAC 기술   IEEE 802.3의 표준 규약   CSMA/CA(Carrier Sense Multiple Access / Collision Avoidance)  무선 네트워크상에서는 충돌을 감지하기 힘들기 때문에 데이터 흐름을 감지하여 네트워크가 사용 중이 아니면 바로 패킷을 보내지 않고, 예비 신호를 먼저 전송해 데이터 전송 중 패킷 충돌을 피하는 방법으로 데이터를 전송한 후에는 충돌 하지 않음   DCF(Distributed Coordination Function: 동등한 우선 순위를 가지고 경쟁하는 방식)이라고도 한다  PCF(Point Coordination Function: 우선 순위 기반 경쟁 방식) - 상용화 안 됨  순서적 할당 방식(Round Robin)  컴퓨터가 단말기에게 전송할 데이터의 유무를 순서적으로 묻는 방식   각 단말기에게 순서적으로 하나뿐은 공유 회선을 점유할 수 있는 기회를 제공   중앙형(Polling 방식, Roll-Call Polling, Bus Polling)  컴퓨터에서 정해준 순서에 따라 단말기를 선택하여 통신 회선 사용의 유무를 문의(Polling Message)하여 사용하도록 허가하는 방식         중앙 컴퓨터에 공유 회선 점유 제어 장치 및 프로그램이 존재   우선권이나 대역폭을 확보하는데 유리   중앙 컴퓨터에서 통제를 하기에 단말기 간 전송 지연이 거의 없다   통신 중에 다른 단말기의 영향을 받지 않는다   중앙 컴퓨터가 고장이 날 경우 통신이 모두 중단   효율성이나 경제성이 떨어진다   공유 회선의 독점이 불가능   분산형(Token 방식, Hub-go-ahead Polling, Hub Polling)  컴퓨터가 가장 멀리 떨어진 단말기에 폴링 메시지를 보내면 폴링 메시지를 받은 단말기는 통신 회선을 점유하여 데이터를 전송한다. 전송할 데이터가 없으면 즉시 자신이 가리키고 있는 다음 단말기에 폴링 메시지를 넘겨주어 통신 회선을 사용할 수 있도록 한다      단말기에 공유 회선 제어 장치 및 프로그램이 존재   중앙에서 통제가 불가하기에 단말기 간에 전송 지연이 발생할 수 있다   통신 중에도 다른 단말기의 영향을 받는다   효율성이나 경제성이 좋다   단말기가 능동적으로 동작한다   공유 회선이 독점될 수 있다   토큰 버스(Token Bus)  허가권(토큰)이 각 단말기를 순서적으로 옮겨 다니는 방식         각 단말기의 전송 시간을 가변적으로 조절이 가능한 장점이 있지만 CSMA/CD 방식에 비해 복잡하고 지연시간이 길다는 단점이 존재   하나의 단말기에는 토큰이 이동해야 할 단말기의 정보를 보유하고 있다   전송량이 많을 때도 안정적이며 액세스 시간이 일정하다   하나의 단말기가 고장나면 통신은 전면 중단   각 단말기에 공유 회선 점유 시간을 조절할 수 있다   전송 데이터의 길이에 제한이 없다   버스형이나 트리형에 적합한 방식   IEEE 802.4의 표준 규약   토큰 링(Token Ring)  링을 따라 순환하는 토큰을 이용하는 방식으로 토큰 버스의 토큰과는 다소 차이가 있다      토큰은 자유 토큰(Free Token) 형태로 링을 회전하다가 임의의 단말기에서 통신 회선의 사용 요청 신호가 들어오면 회선 사용을 허가하고 바쁜 토큰(Busy Token)으로 변경된다. 통신 회선 사용이 종료되면 다시 자유 토큰 형태로 변환하여 링을 따라 순환한다.      단말기를 모두 경유해야 하거나 하나의 단말기가 고장나면 중단되는 토큰 버스의 단점을 보완   모든 단말기에 공평한 기회 제공   하나의 단말기가 고장나더라도 우회하여 다른 단말기와 통신 가능   공유 회선의 사용률을 높이기 위해 토큰을 여러 개 사용할 수 있다   IEEE 802.5의 표준 규약   토큰 패싱(Token Passing)  네트워크 형태(물리적)는 버스 구조 사용, 토큰 운영(논리적)은 링 형태로 사용      데이터 전송 시 반드시 토큰을 취득하여야 하고, 전송을 마친 후에는 토큰을 반납   모든 단말기에 공평한 기회 부여   하나의 단말기가 고장나더라도 우회하여 다른 단말기와 통신 가능   기술이 복잡하여 비용이 많이 든다   부하가 크고, 거리 제한이 없다   슬롯 링(Slotted Ring)  링 구조를 하나의 토큰을 사용하지 않고 전체의 링을 일정한 간격으로 분해하여 각 슬롯마다 토큰을 사용      시스템이 간결하고 각 스테이션에서 링과의 상호 작용이 작기 때문에 신뢰도가 높은 방식   선택 방식(Selection)  멀티포인트 방식에 있어서 중앙 컴퓨터가 주변의 단말기로 데이터를 전공하고자 하는 경우 수신측 단말기의 상태를 확인하는 절차로, 컴퓨터에서 다수의 단말기에 데이터를 전송할 때 사용하는 방식           Select-Hold  컴퓨터에서 단말기로 데이터를 전송할 때 단말기의 수신 가능한 응답을 받고 데이터를 전송하는 방식  즉, 단말기의 수신을 준비시키고 데이터를 전송시키는 방식  BASIC 프레임에서 사용            Fast-Select  컴퓨터에서 단말기로 데이터를 전송할 때 단말기의 수신 가능한 응답을 받지 않고 전송할 데이터와 응답 요청을 동시에 전송하는 방식  즉, 단말기의 수신 상황을 고려하지 않고 데이터를 전송하는 방식       IEEE 802 Standard Family  IEEE는 LAN 기술의 표준화를 목적으로 설립한 소위원회다. 위원회에서 결정된 표준안은 ANSI(미국표준협회)를 통해 ISO(국제표준화기구)의 심사 절차를 거쳐 대부분 국제표준으로 채택되고 있으며 LAN의 국제 표준화에 크게 기여하고 있다.                  표준 규정       규격                       IEEE 802.3       CSMA/CD                 IEEE 802.4       Token Bus                 IEEE 802.5       Token Ring                 IEEE 802.6       MAN 표준안의 DQDB                 IEEE 802.7       Broadband LANs                 IEEE 802.8       Fiber optic LANs                 IEEE 802.9       음성/데이터 통합 LAN                 IEEE 802.10       Security LAN                 IEEE 802.11       무선 LAN, CSMA/CA                 IEEE 802.12       Cable-TV 프로토콜                 IEEE 802.15       블루투스          ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-media-access-control/",
        "teaser": null
      },{
        "title": "[알뜰폰] 기존 SKT에서 헬로모바일로 환승하기(광고 아님)",
        "excerpt":"잠깐! 이 포스트는 4월 5일에 작성되었음을 미리 알려드립니다.   개요  기존에 SKT를 사용하고 있었는데 그 중에서도 T멤버쉽을 잘 애용하고 있었습니다.   하지만, 요즘 FLO, WAVVE와 같은 결합 구독이 생겨나면서 SKT는 고객 유치를 위해 구독 전용과 일반으로 나누어 혜택을 주기 시작했고  구독하고 싶은 상품이 있으면 겸사겸사 같이 사용하는건데 막상 필요가 없는 것들이라 사실상 T멤버쉽 혜택을 받지 못한다고 느낀 부분도 있었고 ‘기존에 쓰던 통신비를 더 아낄수 없을까’라는 생각을 하게 되면서 알뜰폰 정보를 찾아보게 되었습니다   주변 지인도 하나둘씩 사용하기 시작하면서 딱히 품질의 차이가 느껴지지도 않는다고 들었고 아무래도 통신비 지출이 절반으로 줄어든다는 게 큰 메리트로 작용했던 것 같습니다.   암튼, 알뜰폰 정보를 찾아보던 중 여러 통신사가 있다는 것을 알았고 마침 헬로모바일에서 유심을 이벤트가에 판매하고 있어서 환승을 결심하게 되었습니다ㅎㅎ   추가로 통신사 상관이 없다면, 각 알뜰폰 통신사에서 가입 시 제공하는 상품도 한 번 보고 신청하는 것도 좋은 방법이라 생각됩니다.   대략적으로 알뜰폰과 관련해 찾아본 정보에 의하면,     대기업의 통신망을 작은기업이 빌려다 쓰는 것이기 때문에 고객센터와 연결이 잘 안된다   유심의 불량   GPS가 느리다   이 정도의 단점이 있을 수 있다고 하는 것 같습니다.   주의사항     위약금 확인 필수   가족 할인과 같은 결합 상품 확인하기   토요일에도 개통이 가능하나, 혹시라도 오류가 있으면 주말동안 꽤 골치아파지기 때문에 가급적 평일(월요일)을 추천드리는 바입니다.   번호 이동 인증 시 기존 통신사와 자동 해지된다는 점 유의바랍니다   준비물     신분증 : 더 이상 말할 것도 없이 반드시 필요(운전면허증으로 대체 가능)        유심  저의 경우 네이버 헬로모바일 스마트스토어에서 저렴하게 구매했습니다.                     그 밖에도, 편의점(CU, e-Mart24)에서도 구매가 가능합니다만, 무조건 판매하는 것이 아니기에 현재 판매중인지 확인전화 해보셔야 합니다            본인 명의의 신용카드 or 범용 인증서 or 네이버 인증서(헬로모바일의 경우)  아직 네이버 인증서를 발급하지 않으셨다면 신규발급시 네이버페이 지급하니(4월 5일) 한 번 확인해보세요       전 발급받고나서 이벤트를 확인해서 보상을 받을 수 없었습니다 ㅠㅠ       추가로 범용 인증서를 발급받으려면 4,400원이 필요한데 일주일 내로 폐기하면 환불 처리가 된다고하니 참고하세요       공인인증서 : 자동이체 신청 시 필요        요금제 선택  조금만 찾아봐도 요금제가 생각보다 많이 있었습니다.  막상 선택하기 어렵다면 나에게 맞는 요금제 찾기 링크를 통해 어떤 상품으로 선택할 지 골라보세요.            기존 통신비 납부 방법  셀프 개통 시 요금을 납부하는 방법에서 카드 및 계좌를 통해 인증을 진행하는데 3번 이상 틀릴 시 상담원과 연결해야 한다고 합니다       저는 체크카드랑 몇 안되는 계좌를 사용 중이라 다행히도 1번 틀리고 인증 성공했습니다.      방법      1. 가입정보 확인       신청 사이트로 가기      아래 스크린샷처럼 네이버 인증서로도 가입할 수 있습니다.      본인정보를 빠짐없이 기입합니다.         2. 번호이동 인증      3. 개통신청 완료   문자를 기다리다가 ARS 방식으로 하려고 했는데 그 때 마침 문자가 와서 문자동의 방식으로 진행하였습니다. 한 5분 정도 기다렸던 것 같습니다      1630일.. 자급제 폰에다가 기본 요금 때문에 저렇게 오래 사용해도 VIP를 못갔다는 게 함정..그래도 그 동안 잘 썼다       웹페이지에서 셀프 개통이 완료되었다는 메시지를 보고 나서 바로 핸드폰을 끄고 유심을 장착하고 켜봤더니 한 번에 바로 인식이 되었습니다   -끝-   기타 문의      외국인 가입 불가   후불 요금제 상품(선불 요금제 가입 불가)   오프라인 유심 구매를 하지 못한 경우, 신청서 작성 시 택배로 배송 받을 수도 있습니다.   유심은 꼭 셀프 개통 완료 후 휴대폰에 장착 해 주세요.   셀프개통 이용 시간을 확인하시고 개통 신청 해 주세요.   신규 가입 : 08시 ~ 19시 50분 (요일 제한 없음)   번호 이동 : 10시 ~ 19시 50분 (일요일, 신정/설/추석 당일 제외)   이전 통신사가 KCT, 세종(온세)텔레콤은 토/일/공휴일 불가   셀프개통은 LGU+의 유심 신규가입 및 번호이동만 신청 가능합니다.   ※CU 선구매유심을 제외한 신규가입(택배/퀵배송)건의 경우 선개통 배송되며 셀프개통 신청이 불가합니다.   미성년자는 셀프개통 대상에서 제외됩니다.   번호이동의 경우 이전 통신사에서 가입 혹은 명의변경 하신 후 90일이 지나야 신청이 가능합니다.   번호이동 인증 정보는 반드시 이전 사업자에게 등록되어 있는 정보(계좌, 휴대폰 뒷자리, 납부 신용카드 등)가 필요합니다.   번호이동 할 휴대폰 개통 작업 중 전산 해지로 모바일 데이터가 통신 단절 될 수 있으니 꼭 WI-FI환경에서 진행 해주세요.   제휴카드 신청 고객은 카드 발급 후 해당 카드로 납부 방법을 변경하셔야 할인이 적용됩니다.   유심 장착 후 신호가 잡히지 않을 경우, 전원을 3~4회 껐다 켰다를 반복   새로운 휴대폰에 유심을 꽂았는데, 번호등록 중이라고만 뜨면서 이용이 안되는 경우, 정보 등록이 되지 않는다면 기기 등록이 필요하므로 고객행복센터(114 / 1855-1140) 및 헬로모바일 홈페이지&gt;고객센터&gt;기기등록/해외구매폰 VoLTE 등록으로 신청   간단 후기  유심의 경우, 이벤트 진행 중일 때 구매하여 배송비 없이 신속하게 도착해서 놀랐고 신청방법또한 어렵지 않아 접근성이 좋아졌다는 것(세상 많이 좋아졌다..?)을 새삼 느낄 수 있었습니다.   오후에 잠시 일이 있어 외출하다가 실험 겸 GPS를 켜봤는데 전 통신사보다는 잘 튀네요. 그래도 일상 생활에서 크게 문제는 일어나지 않을 정도라 넘어갔습니다   전화하면서 통화 품질은 나쁘지 않다는 느낌을 받았지만 고객센터 어플은 버벅거림이 있고 이 글 작성하고 있는 저녁까지도 실시간으로 갱신되지 않고 있습니다.   앞으로 1달정도 써보고 조금은 자세한 장점이나 문제점을 작성해보려고 합니다   이상입니다   감사합니다  ","categories": ["life"],
        "tags": [],
        "url": "https://many258.github.io/life/hello-mobile/",
        "teaser": null
      },{
        "title": "[데이터통신] 데이터 회선망",
        "excerpt":"전용 회선  두 개 이상의 단말기가 점 대 점 방식으로 통신 회선이 항상 고정적으로 연결되어 있는 회선      비경제적이지만 고속의 데이터 전송을 할 수 있고 전송 오류가 적은 방법   전용 회선으로 연결된 단말기의 개수가 N개이면 통신 회선의 수는 $\\frac{N(N-1)}{2}$개          같은 회선만 사용할 수 있다   경로 선택 기술이 필요 없다   보안성이 좋다   교환 회선  송신측의 단말기에서 송신한 데이터를 교환기가 식별하여 수신측에 있는 해당 단말기에 전송하는 방식   전용 회선에 비해 고속 전송과 전송 데이터의 품질은 보장할 수 없으나 통신 장치와 회선 비용을 줄일 수 있어 경제적      통신 범위가 넓다   회선 사용 효율이 좋다   교환 기술의 성능 비교          전파 지연 시간(Propagation Delay)  신호가 한 교환기에서 다음 교환기로 도달할 때까지 걸리는 시간            전송 시간(Transport)  데이터가 출발지로부터 목적지까지 도달할 때까지 걸리는 시간            노드 지연 시간(Node Delay)  축적 교환망에서 데이터가 다음 경로를 배정 받아 전달될 때까지 축적 교환기에 대기하는 시간            데이터 처리율(Data Processing Rate)  정해진 시간 동안에 데이터를 교환시키는 양의 비율       데이터 교환 방식  회선 교환 방식(Circuit Switching)  경로가 확보되고 수신측에 응답이 있는 상태라면 교환 방식 중에 전파 지연이 가장 짧으며 실시간 통신이 가능한 방식   하지만 데이터 전송 전에 경로를 확보하기 위해 긴 시간이 필요하므로 전체 시간으로 볼 때는 많은 시간이 소요된다      제어 신호 종류                     관리 제어 신호  상대편과 통화를 하기 위해 필요한 자원의 이용 가능성이 있는 지를 파악하여 알려준다                        주소 제어 신호  상대편의 전화번호를 식별하여 상대편과 통화할 수 있는 경로를 확보하는 작업을 수행                        호 정보 제어 신호  현재 호(링크 확립)의 상태 정보를 전화를 거는 사람에게 제공                        감시 제어 신호  망의 전체적인 운영/유지/오류 제어/고장 수리 등을 위해 사용되는 제어 신호                   기억 장치를 사용하지 않는다   코드와 속도가 다른 단말기 간에는 통신이 불가능   전체 경로가 미리 확보되어야 한다   일정한 데이터 전송률을 제공하므로 동일한 전송 속도가 유지   연결만 되면 실시간 통신이 가능   연결되면 통신 회선은 공유되지 않고 일 대 일 방식으로 데이터를 송수신   통신 회선이 독점되므로 비용이 고가   고정 대역폭을 사용   공간 분할 교환 방식(SDS: Space Division Switch)  두 단말기 간의 경로가 공간적으로 분할된 방식으로 두 단말기 사이에 신호를 전송하는 교환기가 필요하고 이 교환기를 거친 물리적인 경로가 설정되는 방식(교환기를 거치지만 1:1로 연결)           단일 단계 교환 방식(Single Stage Switch, 크로스 매트릭스 교환 방식)  N개의 입력과 N개의 출력으로 구성되어 있으며 N X N의 교차점이 있는 교환기로 연결하는 방식            다단계 교환 방식(Multi-Stage Switch, 3단계 교환기)  단일 단계 교환 방식의 단점을 보완한 방식으로 N개의 입력 선을 분할하여 교환기 수가 줄고 경제적인 교환을 가능하게 한다       시간 분할 교환 방식(TDS: Time Division Swtich)          TDM 버스 교환(TDM Bus Switch)  한 전송 회선을 시간으로 분할하여 다중 신호가 이 회선을 공유하는 방식.  주로 동기식 TDM 버스 교환을 사용            시간 슬롯 상호 교환(TSI: Time Slot Interchange)  전 2중 동작을 위하여 한 쌍의 슬롯을 교환함으로써 시간 슬롯 또는 채널의 동기화된 TDM 열을 이룬다.  대부분 시간 분할 교환 방식이 채택하는 기술            시간 다중화 교환(TMS: Time-Multiplex Switch)  TSI 장치는 제한된 수의 접속만을 제공하는데 특히 액세스 속도가 고정되었을 때 TSI의 크기가 커지면 지연은 더욱 커지게 된다.  이러한 문제점을 해결하고 많은 양의 채널을 확보하기 위해 사용되는 방식       축적 교환 방식(Store and Forward Swtiching)  회선 교환처럼 직접적으로 전기적인 연결은 없지만 일시적으로 저장 기능이 있어 네트워크의 흐름이나 변화에 충분히 대처할 수 있는 장점이 있다.   또한, 통신 회선을 공동으로 사용할 수 있으므로 경제적인 통신이 가능      전달되는 데이터가 축적 교환기에 일시적으로 저장되었다가 전달되기 때문에 저장 시에 데이터를 변환시킬 수 있다   기종이 다른 어떠한 통신 장비와도 통신이 가능   저장되기 때문에 전달 속도가 느린 문제점 존재   호출자와 피 호출자가 동시에 운영 상태에 있지 않아도 된다   데이터 전송량이 폭주하는 혼란을 피할 수 있다   같은 내용의 메시지를 여러 곳에 전송할 수 있다(=통신 비용 저렴)   데이터의 손실을 막기 위해 부가적인 내용(번호, 시간)을 추가할 수 있다   메시지 교환 방식(Message Switching, 전문 교환)  전체 데이터를 한 번에 전송한다. 그렇기에 빠른 응답을 요구하는 전송에는 부적합하며 전송되는 데이터는 전송 순서를 기다리는 동안 교환기의 임시 기억 장치에 기억되었다가 순서가 되면 차례로 전송      교환 방식 중 전송 지연 시간이 가장 길다   수신측이 준비가 안 된 경우에도 지연 후 전송이 가능   패킷 교환 방식(Packet Switching)  빠른 응답 시간을 제공하고 통신 회선의 효율적인 사용을 위하여 전송할 전체 데이터를 일정한 크기로 나누어 전송(패킷)하는 방식      패킷망에서 전달할 수 있는 패킷의 최대 크기는 1024비트나 2048비트로 제한을 두고 있다   데이터 흐름이 많거나 교환기가 고장이 있어도 우회해서 전달될 수 있는 융통성이 존재   전송에 실패한 패킷의 경우 재전송이 가능   패킷 단위로 헤더를 추가하므로 패킷별 오버헤드가 발생   실시간 전송은 이루어지지 않는다   다수의 사용자 간에 비대칭적 데이터 전송을 원할하게 하기 위함        채널과 포트의 통계적 다중화 기능을 제공하기 위해서 사용       패킷 교환망의 주요 기능                     패킷 다중화  패킷들이 여러 개의 경로를 공유할 수 있도록 한다                        논리 채널  컴퓨터나 교환기 간에 가상 회선 교환 채널이나 데이터그램 교환 채널을 설정                        경로 선택 제어  최적의 경로를 설정                        순서 제어  패킷이 서로 다른 경로를 통하면 패킷의 전송 순서와 다르게 도착할 수 있으므로 순서적으로 조립되도록 한다                        트래픽 제어  흐름 제어, 체증 제어, 교착상태 회피, 룩업 상태 해결 등을 지원                        오류 제어  패킷의 오류를 제거한다든지 패킷을 삭제한다                        PAD(Packet Assembler/Disassembler)  패킷화할 수 없는 일반 컴퓨터는 패킷망에 접속할 수 있도록 메시지를 패킷화하는 기능을 갖도록 해야 한다. 이처럼 비패킷 단말기를 패킷화하는 시스템이나 프로그램을 PAD라고 한다       패킷망 기술의 표준(CCITT 규정)            X.28 : 문자형 비패킷 단말기와 PAD 간에 주고받는 명령과 응답에 대한 규정       X.3 : PAD가 문자형 비단말기를 제어하기 위해 사용되는 변수들에 대한 규정       X.25 : 패킷망에서 패킷형 단말기를 위한 DTE와 DCE 사이의 접속 규정       X.29 : 패킷형 단말기와 문자형 비패킷 단말기의 통신 규정       X.75 : 패킷망 상호 간의 접속을 위한 신호 방식 규정                 X.25 프로토콜 패킷 교환 3단계            호 설정(Call Setup)                    호 요구(Request) : 호 설정 요청 신호를 보낸다           호 연결(Connected) : 호 요청 신호를 받은 측에서 응답                       데이터 전송(Data Transfer)                    데이터 : 패킷의 순서 번호 순으로 송수신           인터럽트 : 문제가 발생하면 인터럽트 패킷을 전달하여 문제점 해결                       호 제거(Call Cleaning)                    흐름 제어, 오류 제어 : 패킷이 정상 속도를 유지할 수 있도록 조절           호 제거 요청(Request) : 호 설정 해제 신호를 보낸다           호 제거 확인(Confirmation) : 호 설정 해제 신호를 받은 측에서 응답                           데이터그램(Datagram) 패킷 교환 방식  특정 경로의 설정 없이 전송되는 방식. 패킷의 독립성을 부여하여 중간 노드에 문제가 발생하여도 우회하여 목적지에 도착할 수 있는 방식   목적지가 같은 패킷이라도 다른 전송로로 진행할 수 있어서 매우 융통성 있고 소수의 패킷을 전송하는 경우에 유리   데이터그램 패킷은 언제든 순서가 뒤바뀔 수 있기 때문에 수신측에서는 순서적으로 재조립해야 한다      경로를 확보하지 않는다 = 독립적   호 설정, 초기 설정 불필요하며 목적지 주소를 각각 부여   오류 발생 시 교환기에서 삭제   미국식   가상 회선(Virtual Circuit) 패킷 교환 방식  패킷을 전송하기 전에 미리 가상적인 경로를 확보(초기 설정 필요)하여 전송하는 방식. 삽입 흐름이나 오류 제어를 서브 넷에서 지원하기 때문에 데이터그램 방식보다 오류가 적다.   또한, 패킷의 송신 순서와 수신 순서가 바뀌지 않기 때문에 데이터그램에 비해 복잡하지 않다      경로를 확보하고 패킷을 전송한다 = 종속적   호 설정, 초기 설정(목적지 주소 부여) 필요   오류 발생 시 교환기에서 지원   유럽식  ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-line-network/",
        "teaser": null
      },{
        "title": "[데이터통신] 경로 선택 제어",
        "excerpt":"경로 선택(Routing)  송/수신 간에 중간 서브넷을 거쳐 최적의 경로를 선택하는 기술   서브넷 자원의 이용을 최대화하여 평균 패킷 전송 시간을 최소화한다   경로 선택 요소     성능 기준(Performance Criterion)            홉수의 최소화 : 가장 적게 교환기를 경유할 수 있도록 한다       최저 비용 경로 : 경로를 배정하는 기술이나 비용이 적게 사용되도록 한다       최고의 처리율 : 정해진 시간 안에 패킷의 경로 배정을 최대로 진행하게 한다       지연의 최소화 : 패킷이 교환기에 저장된 시간이 최소가 되도록 한다           결정 시간(Decision Time)            데이터그램 방식 : 패킷의 경로 결정 시간을 환경에 맞게 정한다       가상 회선 방식 : 패킷의 경로 결정 시간은 이미 정해져 있게 한다           결정 장소(Decision Place)            분산식 : 주변 네트워크 정보를 참조       집중식 : 경로 정보 센터(RCC)의 정보를 참조           네트워크 정보 발생지(Network Information Source)            네트워크 형태 : 패킷이 처음 만들어진 네트워크 형태를 의미       트래픽 양 : 정해진 시간 안에 패킷들의 송/수신 개수를 의미           경로 배정 전략(Routing Plan)            고정형 : 패킷의 경로가 항상 일정하게 전달       범람형 : 패킷을 여러 개로 복사하여 전달       적응형 : 경로 선택기의 진행 정보를 이용하여 전달           적응 경로 배정 갱신 시간(Adaptive Routing Update Time)            연속적 : 경로 선택기의 정보를 계속 변경해준다       주기적 : 경로 선택기의 정보를 주기적으로 변경해준다           경로 선택 프로토콜      현재의 인터넷 상에서 운영되는 모든 네트워크에서는 서로 다른 경로 선택 프로토콜들이 사용되고 있다. 인터넷은 하나의 네트워크 관리 조직이 운영하는 지역인 AS의 집합으로 이루어져 있다   AS(Autonomous Systems, 자율 시스템) : 동일한 라우팅 프로토콜을 사용하는 네트워크   모든 AS는 AS 안에 있는 경로 선택기들과 통신을 하기 위하여 경로 선택 프로토콜을 사용           거리벡터 알고리즘  행렬로 이루어진 거리 정보 값을 인접 라우터와 주기적으로 교환하여 테이블을 갱신하고 이를 통해 경로를 선택하는 구조.       교환되는 정보가 기본적으로 거리 정보뿐이기 때문에 단순하고 다루기 쉬운 반면, 장애 등의 원인을 알아내기에는 어렵다는 단점이 존재              라우터와 라우터 간의 거리를 더하여 계산       라우팅 메트릭 값의 설정 요소                                 네트워크 지연  하나의 패킷이 네트워크를 통하여 전송측에서 목적지까지 전송되는 데 소요되는 시간으로 링크의 대역폭, 실제 거리, 포트의 큐, 네트워크의 과부하 등 다양한 요인에 의해 결정                                    대역폭  연결된 네트워크 구간에서 사용 가능한 트래픽의 양                                    신뢰성  각 네트워크 연결 상태에 있어서 얼마만큼의 신뢰를 유지하는 가를 수치로 표현                                    부하  네트워크 트래픽의 바쁜 정도                                            링크상태 알고리즘  거리벡터 라우팅 프로토콜의 단점을 보완하기 위해 개발.       모든 라우터가 모든 링크 정보를 가지며 라우팅 정보가 변경될 경우(이벤트 기반)에 변경된 라우팅 정보만을 전파시키는 구조(트래픽 발생량 감소 =&gt; 규모 큰 네트워크에서도 사용이 가능, 라우팅 루프같은 오류가 발생하지 않음)              시간 지연 문제의 발생이 적다       복잡한 구조로 경로설정이 구현되므로 주소 배분이나 장치 설정의 어려움이 발생           IGP(Interior Gateway Protocol, 내부 게이트웨이 프로토콜)  AS 내부의 라우터들끼리 라우팅 정보를 교환하는 데 사용되는 라우팅 프로토콜   RIP(Routing Information Protocol, 인터넷 라우팅 프로토콜)     거리벡터 알고리즘을 사용하는 가장 단순하고 일반적인 프로토콜   라우팅 테이블은 데이터그램 패킷을 통하여 모든 라우터에 전달   매 30초마다 라우팅 정보를 전달, 라우팅 정보는 180초 동안만 유효   최대 홉을 15로 제한하므로 소/중규모 네트워크에 적합   Broadcast 방식을 사용해서 인접한 라우터 간의 정보를 교환하므로 네트워크 대역폭의 낭비가 초래되고 네트워크에 연결되어 있는 모든 호스트들은 라우팅 처리와 무관하게 관련된 패킷을 처리해야 하므로 연결된 모든 장치에 오버헤드가 발생   RIPv2(RFC1723)     RIP와 동일한 기본 알고리즘을 사용하면서 단점을 보완한 프로토콜   인증 메커니즘을 제공하고 인터넷 전체에 VLSM을 사용할 수 있도록 보완   인식 기능이 제공되기 때문에 Broadcast 방식이나 Multicast 방식으로 갱신 정보를 전송하는 것이 가능   서브넷 마스크 기능 포함   EGP에서 얻어진 AS 번호 등의 정보를 통지하기 위해 사용되는 외부 루트태그 기능 존재   RIP에서는 서브넷 마스크를 바이트 단위로 인식을 하여 A/B/C 클래스 단위로 인식하였으나, RIPv2에서는 비트 단위로 인식   멀티라우팅 프로토콜 환경에서 라우팅 수행 중에 다음에 전송될 라우터 중 최적 라우터의 선택이 가능하도록 하는 ‘다음 홉 주소’ 사용   멀티캐스트 방식을 사용하기 때문에 라우팅 프로토콜이 지원하지 않는 호스트의 부하를 경감시킬 수 있으며, 또한 RIP 외는 지원하지 않는 라우터에서 해석할 수 없는 정보를 RIPv2 라우터 사이에 공유하도록 함으로써 신뢰성을 향상시킨다   OSPF(Open Shortest Path First)  RIP의 한계를 극복하기 위해 IETF(Internet Engineering Task Force)에서 고안한 방식으로 네트워크 변화가 있을 때에만 갱신함으로 대역을 효과적으로 사용할 수 있는 라우팅 프로토콜      망 구성이 계층적 구조로 구성되어 있으며 Area라는 구간을 나누어 사용(대규모 네트워크에서 효율적으로 사용이 가능)   Area를 나누면 서로 교환해야 되는 상태정보도 줄어들고 링크 계산 속도, 빈도가 줄어들게 되며 라우팅 테이블의 크기도 줄어 관리하기가 용이해진다   라우팅 정보를 인접한 라우터에 모두 전송하는 플러딩 방식을 사용하므로 토폴로지에 관한 정보가 전체 네트워크 상의 라우터에서 동일하게 유지   거리의 제한이 없다   SPF 알고리즘을 통해 직접 경로계산을 하기 때문에 리소스 소모량이 많다   LSA : 라우팅 정보를 담아 주고 받는 광고 패킷   IGRP(Internet Gateway Routing Protocol)  BGP를 보완한 기술로 중간 규모의 네트워크에서 사용하는 경로 설정 프로토콜      시스코 사에서 독자적으로 개발한 프로토콜   독립적인 네트워크 내에서만 사용하기 위해 개발   RIP와 유사하게 Hop수를 기준으로 한 정보를 전송   복수의 경로상에서 로드 밸런싱 기능을 지원   RIP와 유사하지만, 크고 복잡한 네트워크를 위해 개발   EIGRP(Enhanced Interior Gateway Routing Protocol)  거리 벡터 알고리즘을 사용하는 IGRP를 발전시켜 개발한 라우팅 프로토콜.      IGRP의 매트릭 방식을 그대로 사용하여 최적경로를 선택   링크제어 알고리즘처럼 네트워크 변화에 즉시 업데이트를 수행   Router 정보 전송을 위해 IP 프로토콜 88번 사용   DUAL(Diffusing Update Algorithm)을 사용하여 최적 경로(Successor)와 후속 경로(Feasible Successor)를 선출   메트릭 값이 같은 경로만 부하 분산이 가능한 RIP와 OSPF와는 다르게 메트릭 값이 다른 경로로 부하 분산이 가능(Unequal Cost 부하 분산 지원)   대규모 네트워크에 적용 시 SIA(Stuck In Active)현상이 발생할 수 있다   EGP/ERP(Exterior Gateway/Routing Protocol, 외부 게이트웨이 프로토콜)  RIP만으로는 패킷망의 모든 경로를 가상으로 확보할 수 없기에 TCP/IP를 사용하는 네트워크와의 연합으로 패킷 경로를 확보한다.   즉, AS 상호 간에 라우팅 정보를 교환하는 데 사용되는 프로토콜   BGP(Border Gateway Protocol, 경계 게이트웨이 프토토콜)  인터넷상의 게이트웨이 호스트들 간에 흔히 사용되는 프로토콜로 관리자에 의해 독자적인 경로 설정이 필요할 때 사용하는 프로토콜  ISP 업체 연결하거나, 두개이상 ISP 동시 접속할때 (Multihoming), BGP를 사용 한다.      라우팅정보를 유니캐스트 방식으로 전송한다.   경로 선택 전략   비적응적 방법  경로 선택이 단순하고 중간 노드의 상태를 전혀 고려하지 않는다.   패킷을 전송할 때 경로를 선택할 수 잇는 프로그램을 미리 패킷에 삽입하면 패킷은 패킷에 있는 경로 선택 프로그램대로 진행되도록 하는 정적이고 수동적인 방법   고정 경로 선택(Fixed Routing, 착국 부호 방식)  교환기마다 접속하려는 상대방에 미리 붙여둔 번호를 해석하여 진행 경로를 선정하는 방식      이미 정해진 경로로 진행하기 때문에 유연성이 없다   지나간 경로로 되돌아가는 루프가 없다   범람 경로 선택(Flooding Routing, 플러딩)  입력된 경로를 제외하고 모든 경로에 패킷의 복사본이 전송되는 방법으로 신뢰성과 최단 경로가 보장되지만 복사된 패킷의 증가로 체증이 유발될 수 있다      홉카운트를 이용하여 체증 유발을 방지할 수 있다   중간 네트워크(서브넷) 정보를 이용하지 않는다   적응적 방법  중간 노드의 상태가 원활하지 않는 경우 체증과 지연이 심화될 수 있다. 이러한 단점을 보완한 적응적 방법은 중간 노드의 체증이나 교착상태 등의 변화에 대한 정보를 얻어 능동적으로 경로를 선택하는 동적인 방법   국부적 경로 선택(Isolated Routing)  지역적으로 외부 노드의 정보를 얻지 않고 국부적인 노드의 독립적인 판단에 의하여 결정되는 방법으로 거시적인 관점보다는 근시안적이기 때문에 체증 유발 가능성이 존재           짧은 큐 경로 선택(Shortest Queue Routing, Hot Potato Routing)  인접 노드의 버퍼의 개수가 가장 적은 쪽으로 패킷을 보내는 방식  패킷이 목적지와 멀어질 수 있다는 단점이 있지만 패킷을 노드 밖으로 보내는 방법으로는 가장 확실한 방법            국부 지연 평가 방법(Local Delay Estimate, Backward Learning)  이미 지나간 패킷의 정보를 충분한 시간을 갖고 평가하여 경로를 선택하는 방법  정확도나 경로 선택의 시기를 놓칠 수 있다는 단점 존재       분산 경로 선택(Distribute Routing)  체증이 발생하는 문제점과 효율적인 경로 선택을 위해 사용하며 자신을 중심으로 인접해있는 모든 경로 선택기의 정보를 분석하여 광범위한 지역까지의 경로를 확보하는 방식   집중 경로 선택(Centralized Routing)  전체 네트워크의 경로 흐름을 파악하고 제어하는 RCC(Routing Control Center)의 정보로 경로를 선택하는 방법으로 RCC의 고장 시 전체 통신망은 마비된다  ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-routing/",
        "teaser": null
      },{
        "title": "[데이터통신] 트래픽 제어",
        "excerpt":"트래픽 제어(Traffic Control)  네트워크 내로 송/수신되는 패킷의 수를 일정하게 조절하여 네트워크를 효율적으로 이용할 수 있도록하는 기술로 수신측의 버퍼량이 한계점을 초과하지 않도록 한다   흐름 제어(Flow Control)  패킷 교환 방식에서 통신망 내 트래픽 제어의 원할한 흐름을 위해 네트워크 내의 노드와 노드 사이에 전송하는 패킷의 양이나 속도를 규제하는 기술. 혹은 수신기 버퍼의 오버플로우를 예방하기 위한 것으로 데이터 프레임의 전송률을 조정하는 것을 의미   일정한 시간(Choke Packet)  수신측에서 송신측에 전송하는 전송 지연 신호로 송신측의 데이터 전송 속도를 조절하는 방법. 수신측에서 일정한 시간(Choke Packet)을 송신측에 전송할 때마다 송신측은 일정한 시간만큼 점증적으로 데이터 전송 시간을 늦춘다. 지원 중지 시간(Time Out) 동안 수신측에서 Choke Packet이 없는 경우 송신측은 다시 원래의 속도로 복귀한다   단일 승낙          Wait-Before-Go  수신측의 Go 명령이 오면 전송하고 아무런 신호가 도착하지 않으면 대기(송신측이 수동적)            Ask-And-Wait  송신측에서 전송 여부를 물어보고 수신이 가능하다는 신호가 도착하면 전송(송신측이 능동적)       다중 승낙     Window-Edge  수신측의 버퍼의 개수를 송신측에 전송 하면 송신측에서는 임의로 데이터의 개수를 정하여 전송하는 방법   WBAT(Wait Before And Transmission)  수신측에서는 수신할 데이터의 개수를 임의로 정하여 송신측에 전달하면 송신측은 수신측에서 요구한 개수만큼만을 송신. 수신측에는 아무런 신호가 도착하지 않으면 무한정 대기   슬라이딩 윈도(Sliding Window)  전송측이 전송한 프레임에 대한 ACK 프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송하도록 허용하는 방법      한 번에 여러 개의 프레임을 전송할 경우 가장 효율적인 기법으로 송신측에서는 수신측으로 부터 전송할 프레임의 개수(윈도 크기)를 미리 지정받는다.   지정받은 개수만큼 송신 측에서는 자율적으로 프레임의 개수를 전송할 수 있다. 송신측에서는 지정받은 프레임의 개수만큼을 모두 전송하고 나면 더 이상 전송할 수 없게 된다   수신측에서 전송할 프레임의 개수를 다시 지정하게 되면 그때서야 다시 전송할 수 있게 된다   혼잡 제어(Congestion Control)  네트워크 내에서 패킷의 대기 지연이 너무 높아지게 되어 트래픽이 붕괴되지 않도록 네트워크 측면에서 패킷의 흐름을 제어하는 트래픽 제어 기술   네트워크 상에 패킷 수를 조절하는 기술로 네트워크 상에 각 노드들의 패킷 수신 버퍼를 한계점 이하로 사용하도록 조절한다         느린 시작(Slow Start)  윈도우의 크기를 1/2/4/8… 지수적으로 증가시켜 초기에는 느리지만 갈수록 빨라진다   혼잡 회피(Congestion Avoidance)  느린 시작의 지수적 증가가 임계값에 도달하면 혼잡으로 간주하고 회피를 위해 윈도우의 크기를 1씩 선형적으로 증가시켜 혼잡을 예방하는 방식   네트워크상에 체증 제어가 실패하면 패킷의 흐름이 전혀 없는 교착상태가 발생하여 궁극적으로 인접한 모든 노드까지 영향을 주게 되는 룩업 상태가 된다      흐름 제어 : 두 노드 사이에 패킷 수를 조절하는 기술   체증 제어 : 네트워크에서 패킷 수를 조절하는 기술   교착상태 회피  노드 간에 패킷을 기억할 수 있는 버퍼가 디스크의 용량이 넘쳐 패킷을 전송할 수 없는 상태로 흐름 제어가 실패하면 체증이 유발되고 패킷의 흐름이 정지되는 교착상태가 발생   이러한 교착상태가 발생되는 경우는 같은 목적지를 갖는 패킷을 모두 할당하지 않도록 조절해야 한다. 교착상태 발생 후 계속적으로 심화되면 룩업 상태가 발생하므로 그 전에 교착상태에 있는 노드 중에 하나를 선택하여 패킷 버퍼를 모두 폐기하면 룩업 상태를 방지할 수 있다.   이 때 폐기되는 패킷들은 사용자에 의하여 재전송되어야 한다.   룩업 상태(Lock-Up)  패킷 교환망에서 교환기를 여러 사용자가 공유함으로써 패킷의 개수가 급속히 증가하거나 교환기 버퍼 용량의 부족으로 교착상태가 발생한다.   이러한 부분적인 교착상태는 계속 확대되어 근접한 교환기까지도 영향을 주게 되며, 이로 인하여 네트워크 전체의 패킷 흐름이 멈추게 되는 현상을 말한다.  ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-traffic-control/",
        "teaser": null
      },{
        "title": "[데이터통신] 인터넷 고속 접속 서비스",
        "excerpt":"종합 정보 통신망(ISDN : Integrated Service Digital Network)  음성 및 비음성의 다양한 통신 서비스를 하나의 통신망을 통하여 종합적으로 서비스해주는 통신 시스템   즉, 기존의 음성 서비스를 제공하는 공중 교환 전화망(PSTN), 데이터 통신 서비스를 제공하는 공중 교환 데이터망(PSDN)과 무선이나 별개의 통신망을 통하여 화상 서비스 받는 등 모든 통신망을 하나의 디지털 네트워크를 통하여 제공하는 통신망 기술      모든 정보 통신망을 하나의 통신망으로 통폐합하여 확장성과 재배치성이 좋다   동시에 복수 통신이 가능   모든 통신 선로와 교환기를 디지털화   기존 전화망은 디지털 교환기와 연결하여 기본 서비스(2B+D)를 제공   규모가 큰 사용자와 기업은 광케이블을 설치하여 1차군 서비스(23B+D, 30B+D)를 제공   통신망의 중복 투자를 피할 수 있어 경제적   통신망의 교환 접속 기능에는 회선 교환 방식과 패킷 교환 방식이 존재   64Kbps 1회선 교환 서비스가 기본   ISDN 서비스          베어러 서비스(Bearer Service)  통신망이 제공할 수 있는 회선 교환, 패킷 교환 등 전달되는 데이터에 변형을 주지 않고 그대로 전달만 하는 서비스.       OSI 모델의 하위 계층(물리 계층, 데이터 링크 계층, 네트워크 계층)의 기능을 제공하는 서비스            텔레 서비스(Tele Service)  실제로 단말을 조작하고 통신하는 이용자측의 서비스. 전화/비디오텍스/팩시밀리/텔렉스 등 협대역 서비스와 고품질의 음성, 화상 회의 등 64Kbps에서 2Mbps까지 이르는 광대역 서비스.       전송 기능 외에 정보 처리 기능까지 서비스하며 OSI 모델의 전 계층의 기능을 제공       ISDN이 제공하는 채널의 종류                  채널       신호 속도       내용                       B(Bearer)       64Kbps       - 음성이나 데이터 전송을 위한 디지털 채널 - 기본적인 이용자 데이터 채널로 PCM화된 디지털 음성이나 회선 교환 혹은 패킷 교환 등에 이용 - 고속의 데이터는 회석 교환 방식이나 패킷 교환 방식을 이용 - 팩시밀리, 저속의 비디오 데이터를 전송할 때 사용되기도 한다                 D(Data)       16Kbps/64Kbps       - 회선 교환의 신호 채널로 사용 - 소량의 사용자 데이터를 전송하는 기능 제공 - 서비스 제어를 위한 채널과 저속의 패킷 전송 채널로 사용 - 패킷 교환이나 신호를 기다리지 않는 저속 원격 계측에도 사용 - 텔레텍스, 비상 서비스, 에너지 관리 등에 이용                 H(Hybrid)       384Kbps(H0) 1536Kbps(H11) 1920Kbps(H12)       - 고속의 사용자 정보를 위해 사용 - 고속의 회선 교환, 패킷 교환, 디지털 전용선에서 이용                 A       4Khz       - 아날로그   가입자선 정보 채널                 C       8Kbps       - 아날로그   디지털 복합 가이자선 정보 채널              BRI(Basic Rate Interface, 기본 속도 인터페이스)  가정이나 소규모 사무실 등의 사용자를 위한 ISDN 서비스  2B+D라 불리는 두 개의 B채널과 한 개의 D 채널로 구성            물리적 속도 : 2B + D + 오버헤드 = 192Kbps            PRI(Primary Rate Interface, 1차군 접속 서비스)  ISDN 회선을 많이 사용하는 기업체나 학교 등에서 사용되는 서비스  23B+D(북미식, 1536Mbps), 30B+D(유럽식, 1920Mbps) 등 다양한 방식이 존재  D채널은 64Kbps를 사용하고 오버헤드로 8Kbps를 사용   기능 그룹  각 장치들의 경계점을 명확하게 규정하기 위해 사용     NT(Network Terminal, 망 종단장치)   TE(Terminal Equipment, 사용자 관련 장비)                  기능 그룹       기능       사용 예                       TE1       - ISDN 접속 기능을 가진 단말기       ISDN 전화기, ISDN용 컴퓨터                 TA       - Terminal Adapter - 아날로그 접속 기능 단말기       일반 전화기                 TE2       - TE2 단말 장치에 ISDN 접속 기능을 제공 - 프로토콜 변환 기능, 속도 변환 기능을 제공       ISDN용 모뎀(S-Card)                 NT1       - 선로의 종단점으로 다중화기 기능, DSU 기능   제공 - 1계층 지원, 비트 동기                         NT2       - 교환 기능, 집중화 기능, 라우터 기능 제공 - 2, 3계층 지원                   접속점  전산망 기기가 타인의 전산망 기기와 접속되는 경우에 그 설치와 보전에 관한 책임의 한계를 명확하게 구분하기 위한 접속점           U(User)  외부망과 내부망을 구분하는 경계점            T(Terminal)  NT1과 NT2 사이에 기준점으로 사용자와 네트워크와의 경계점            S(System)  각각의 ISDN 단말기들에게 제공되는 인터페이스로 사용자 단말기와 네트워크 장비가 구분되는 경계점            R(Rate)  비 ISDN 단말기와 TA사이의 인터페이스로서 일반 단말기와 ISDN용 장비를 구분하는 경계점       ATM(Asynchronous Transfer Mode, 비동기 전송 방식)  80년대에 N-ISDN(협대역 종합 정보 통신망)이 완성되었으나, N-ISDN으로는 HDTV 등의 화질을 수용한다는 것이 불가능하였고, 결국 B-ISDN(광대역 ISDN)이 출현하게 되었다. 이를 실현하기 위한 방법으로 등장한 것이 ATM이다      데이터를 일정한 크기인 셀로 구분하여 순서대로 전송하는 자료의 전송방식   고정 길이 패킷(셀)을 전송하므로 송수신 처리가 단순   셀 단위로 동기가 이루어지기 때문에 오버헤드가 줄어들어 고속 전송이 가능   B-ISDN과 결합하여 전 세계 네트워크의 고속 상호 연결을 가능하게 한다   비동기식 다중화 방식을 사용   양 끝단 간 오류와 흐름을 제어하므로 어떤 종류의 서비스라도 제공할 수 있다   멀티미디어 서비스에 적합   프로토콜 구조     단계            관리 단계(Management Plane) : 망 관리를 담당                    단계 관리(Plane Management)           계층 관리(Layer Management)                       제어 단계(Control Plane) : 제어 정보를 전송       사용자 단계(User Plane) : 사용자 정보 전송           계층            제어 상위 계층(Control Higher Layer) - 어플리케이션 담당       사용자 정보 상위 계층(User Information Higher Layer)       ATM 변환 계층(ATM Adaptation Layer) - 48바이트 이내로 데이터를 잘라내서 페이로드를 제작       ATM 계층(ATM Layer) - 프레임 제작, 헤더 정의       물리 계층(Physical Layer) - 전송에 적합한 신호 혹은 비트로 변환           셀의 구조  총 53바이트이며, 5바이트의 헤더와 48바이트 페이로드로 구성           GFC(Generic Flow Control, 4Bit)  트래픽 제어 정보를 표시            VPI(Virtual Path Identifier, 8Bit)  경로 배정용으로 사용            VCI(Virtual Channel Identifier, 16Bit)  채널 배정용으로 사용            PT(Payload Type, 3Bit)  사용자 정보와 망 정보를 구분            CLP(Cell Lose Priority, 1Bit)  셀 폐기 우선순위를 표시            HEC(Header Error Control, 8Bit)  셀 헤더의 오류 제어       ADSL(Asymmetric Digital Subscriber, 비대칭 디지털 가입자 회선)  기존에 전화망을 이용한 통신은 최대 56Kbps까지의 속도를 보장하였으나, 멀티미디어 통신은 불가능하였고 인터넷의 폭발적 사용 증대로 인해 저렴하고 빠른 데이터 통신이 요구되었다.   전화망은 음성 신호를 실어 나르기 위해 설계된 네트워크이다. 음성 대역만을 전송하면 되므로 보호 대역을 고려하고 4,000Hz의 기본 주파수만을 사용하였다. 하지만 고속의 데이터 통신이 요구되면서 비 사용중인 4,400Hz에서 1MHz인 대역폭을 이용하여 고속의 데이터 전송을 제공하는 기술      ADSL(Asymmetric Digital Subscriber Line)   HDSL(High-data rate Digital Subscriber Line)   SDSL(Single line Digital Subscriber Line)   VDSL(Very High bit rate Digital Subscriber Line)          전화 음성 신호를 실어 나르는 기존의 전화망은 그대로 사용하면서 고속의 데이터 통신 서비스를 제공받을 수 있다   데이터 통신을 사용하기 위해서는 전화를 걸어야 하는 단점은 있지만 일단 접속이 되면 사용 시간과 무관하게 계속적으로 사용 가능   인터넷 사용 시 데이터 흐름은 서버로부터 받는 데이터가 대부분인데 반해 사용자가 발생하는 데이터는 그리 많지 않다. 따라서 이러한 데이터 흐름을 반영하여 하향/상향 채널화하고 각각 다른 대역을 할당하여 회선 효율을 높일 수 있게 하였다   CATV(Cable Television)  원래 난시청 지역에서 안테나 또는 공동 안테나를 설치하여 수신된 TV 방송국의 전파를 유선으로 각 가정에 분배/공급하기 위해 탄생하였으나 오늘날에는 다양한 영상 통신 시스템으로 발전하고 있다      동축 케이블 이용   PSTN을 이용하는 ADSL이나 ISDN처럼 접속과정이 필요 없다   24시간 내내 시간에 관계없이 인터넷 서비스를 제공받을 수 있다   케이블 TV와 다른 주파수를 사용하므로 TV 시청에 영향을 주기 않는다   케이블 모뎀이 사용된다  ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-digital-network-service/",
        "teaser": null
      },{
        "title": "[데이터통신] 근거리 네트워킹(LAN)",
        "excerpt":"LAN(Local Area Network)  동일 빌딩 내 또는 한정된 지역 내 등 비교적 좁은 지역에 분산 배치된 컴퓨터와 프린터 등의 단말기를 통신 회선으로 연결하여 각종 정보를 교환할 수 있는 통신 네트워크      단일 기관의 소유 및 제한된 지역 내의 네트워크   어떤 종류의 통신 시스템 기기와도 연결이 가능   광대역 전송 매체의 사용으로 고속 통신 가능   오류 발생률이 낮으며, 전송 지연을 최소화할 수 있다   공유 매체의 사용으로 경로 선택없이 매체에 연결된 모든 장치로 데이터 전송 가능   통신 기기의 재배치와 확장성이 좋다   노드 값이 저렴   기본 형태는 스타형, 링형, 버스형, 계층형으로 분류   LAN의 평가 요소     지연 시간(Turn Around Time)   시스템 신뢰성(System Reliability)   응답 시간(Reponse Time)   처리량(Throughput)   LAN의 서비스 영역에 따른 구분          CO-LAN(Central Office LAN)  대학, 병원 및 연구소, 기업체 등 LAN 구성 여건이 미비한 지역과 지역 사이를 기존의 통신망을 연결시켜 제공한 망으로 보통 공중 기업 데이터망이라 한다            MAN(Metropolitan Area Network)  LAN의 지역적인 협소성을 경제적으로 개선한 망으로 서비스 범위는 대략 50Km 영역으로 규정짓고 있다. 도시형 통신망이라고도 하며, 대단위 아파트 단지 등을 대상으로 구성하는 통신망            WAN(Wide Area Network)  지역적인 거리와 무관하게 같은 이해 단체 간을 연결한 망 형태로 각기 다른 LAN을 통합해야 하는 어려움이 있지만 망간의 폐쇄성 때문에 안전성이 뛰어나 많이 사용되는 형태            VAN(Value Added Network)  통신회선을 직접 보유하거나 통신 사업자의 회선을 임차하여 단순한 정보 기능 이상의 부가가치를 부여하고 음성 또는 데이터 정보를 제공하는 광범위하고도 복합적인 통신 서비스 형태       LAN의 통신 방식에 따른 구분     베이스밴드 방식            디지털 신호       채널이 1개       전송 속도는 1~10Mbps       양방향 통신       데이터 전송에 응용           브로드밴드 방식            아날로그 신호       채널이 20~30개       전송 속도는 150Mbps       단방향 통신       음성, 영상 전송에 응용           LAN의 기본 형태   스타형(성형)  중앙에 컴퓨터가 있고 이를 중심으로 단말기가 연결된 형태      네트워크 구성의 가장 기본적인 형태로 교환 노드의 수가 적다   온라인 시스템의 전형적인 방식   중앙 집중 제어용이므로 보수 관리와 단말기의 추가, 삭제가 용이   각 단말기마다 전송 속도를 다르게 할 수 있다   하나의 단말기가 고장나도 다른 단말기에 영향을 주지 않는다   단말기의 고장 발견이 쉽다   독립된 경로를 갖고 있으므로 보안성이 뛰어나다   중앙 컴퓨터가 고장나면 전체 시스템이 마비   링형  서로 이웃하고 있는 단말기가 컴퓨터끼리만 연결시킨 형태      양쪽 방향으로 접근이 가능하여 통신 장애에 대한 융통성이 존재   LAN에서 가장 많이 채택되고 있는 방식   중계기의 수가 많아진다   한 노드가 절단되어도 우회로를 구성하여 통신이 가능한 형태의 통신망   단말기의 추가 및 삭제가 복잡   공유하는 경로를 갖고 있으므로 보안성이 떨어진다   버스형  1개의 통신 회선에 여러 개의 단말기를 접속하는 형태      통신 회선이 1개이므로 물리적 구조가 간단   단말기의 추가 및 삭제가 용이   하나의 단말기가 고장나도 다른 단말기에 영향을 주지 않는다   공유하는 경로를 갖고 있으므로 보안성이 떨어진다   LAN의 전송 매체     케이블 규격            X BASE/BROAD Y  X : 데이터 전송 속도(단위-1Mbps)  Y : 길이(단위-100M)            꼬임선 케이블(Twisted Cable)            전기적 간섭 현상을 줄이기 위해서 균일하게 서로 감겨있는 형태의 케이블       하나의 케이블에 여러 쌍의 꼬임선들을 절연체로 피복하여 구성       다른 전송 매체에 비해서 거리/대역폭/데이터 전송률 면에서 제한적       가격이 저렴하고 설치가 간편한 이점       주파수 대역이 좁기 때문에 채널 수가 제한적       내구성이 약하다       스타형/링형/버스형에서 주로 사용           동축 케이블(Coaxial Cable)            신뢰성/경제성/내구성 우수       버스형/링형에 주로 사용       베이스밴드 방식  디지털 신호를 변조하지 않고 사용하며 데이터 통신에 적합       브로드밴드 방식  주파수를 다중화시켜 사용하며 CATV에 적합           광 케이블(Optical Fiber Cable)            LAN의 전송 매체 중 가장 우수       대역폭이 넓어 정보 전송 능력이 향상되며, 동축 케이블보다 신호 감쇠 현상이 매우 적다       전기적 잡음 영향을 받지 않기 때문에 신뢰성이 좋다       광을 이용하여 전송하기 때문에 보안성이 뛰어나다       동축 케이블에 비해 무게와 크기에서 이점을 가진다       전기적으로 무 유도성, 무 누화이다       고속의 데이터 전송과 대량의 데이터 전송이 가능       작은 크기와 적은 무게로 설치가 용이       많은 중계 급 전선이 필요하지 않다(증폭기 간격 최대 119Km)       버스형과 링형에 주로 사용           VAN  통신 회선을 직접 보유하거나 통신 사업자의 회선을 임차하여 단순한 정보 기능이상의 부가가치를 부여하고 음성 또는 데이터 정보를 제공하는 광범위하고도 복합적인 통신 서비스   VAN 계층     정보 처리 계층(응용 계층) - 정보 처리 기능            업무 처리, DB 관리, 고객 관리, 회계 관리 등 제공           통신 처리 계층(표현/세션/전송 계층) - 통신 처리 기능            속도 변환, 코드 변환, 포맷 변환, 미디어 변환, 프로토콜 변환       메일 박스 : 메시지를 축적해두고 필요시 꺼내는 기능       동보 통신 : 1번의 통신으로 다수의 상대방에게 동일한 메시지를 보내는 기능       시각 지정 통신 : 정해진 시간에 메시지를 전송하는 기능           네트워크 계층(네트워크 계층) - 교환 기능            패킷 교환, 회선 교환           기본 처리 계층(데이터링크/물리) - 전송 기능            물리적 회선을 의미하여 정보를 단순히 전송하는 고유 기능           이더넷(Ethernet)  LAN의 가장 대표적인 버스 구조 방식으로 DEC, Intel, Xerox가 공동으로 개발시킨 표준 LAN을 이더넷이라고 부른다.   이더넷은 데이터를 보내려는 컴퓨터가 먼저 통신망이 사용중인지 아닌지 판별한 후에 비어 있을 때 데이터를 보내는 CSMA/CD 방식을 사용      접근 방법 : CSMA/CD   주소 지정 : 6바이트의 물리적인 주소   신호 방식 : 맨체스터 디지털 부호   데이터 전송률 : 1~100Mbps          교환형 이더넷(Switched Ethernet)            10BASE-T형 이더넷의 성능을 향상시킨 모델       물리적으로 스타형, 논리적으로 버스형의 형태       이론적인 전송속도 : 10Mbps * N(교환기의 수)       스위칭 기술의 도입으로 불필요한 패킷의 흐름을 막을 수 있다           고속 이더넷(Fast Ethernet)            영상처리/실시간 오디오/비디오와 같은 새로운 응용들이 구현되면서 10Mbps보다 높은 전송 속도가 필요하여 개발된 모델       데이터 전송률 : 100Mbps       변형된 스타형의 형태       전송 속도가 증가되었으며 충돌 영역도 감소           기가비트 이더넷(Gigabit Ethernet)            광 케이블을 사용하며, 전송속도는 1Gbps       전이중, 반이중 통신 방식 지원       최소한의 충돌 감지를 위하여 프레임 크기를 64바이트에서 512바이트로 확장       기존 네트워크와의 호환성          ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-lan/",
        "teaser": null
      },{
        "title": "[데이터통신] 인터네트워킹",
        "excerpt":"인터네트워킹  근거리 네트워크망 혹은 광역망 간에 상호 접속시키는 제반 기법으로 인터네트워킹의 전체 구성을 인터넷이라고 하며 그 구성 요소를 서브넷이라고 한다      TCP/IP를 기본 프로토콜로 한다   X.25 네트워크를 통한 가상 회선, 데이터그램 서비스를 제공   로컬 네트워크 상호 간 연결에는 브리지가 사용   외부 네트워크와 연결할 경우에는 게이트웨이와 라우터가 필수적   IP는 여러 개의 패킷 교환망들의 상호 연결을 위한 범용 비연결성 프로토콜   TCP는 데이터 전송 프로토콜   HTTP, FTP, Telnet, Mail, IRC가 주요 서비스   다른 네트워크 또는 같은 네트워크를 연결하여 그 중추 역할을 하는 네트워크로 보통 인터넷의 주가 되는 기간망을 백본이라고 한다   인터네트워킹의 4계층     링크 계층(물리 계층, 데이터 링크 계층)            통신망을 액세스할 수 있는 프로토콜로 흐름제어나 에러 제어의 서비스를 제공       Ethernet, IEEE802, X.25           인터넷 계층(네트워크 계층)            데이터를 전송하기 위한 절차, 순서 제어 등의 서비스 제공       IP           전송 계층(세션 계층, 전송 계층)            호스트들 간의 신뢰성 있는 통신 제공       연결 위주의 데이터 프로토콜, 데이터그램 프로토콜, 음성 프로토콜, 실시간 데이터 프로토콜       TCP           응용 계층(표현 계층, 응용 계층)            응용 프로그램 간의 데이터 송수신을 제공       FTP, SMTP, Telnet 등           인터넷 프로토콜 스위트(Internet Protocol Suite)  인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 통신규약 모음이다. 인터넷 프로토콜 슈트 중 TCP와 IP가 가장 많이 쓰이기 때문에 TCP/IP 프로토콜 슈트라고도 불린다   링크 계층                  프토토콜       기능                       OSPF       - Open Shortest Path First, 최단 경로 우선 프로토콜 - 인터넷 프로토콜 네트워크를 위한 링크 스테이트 라우팅 프로토콜                 SLIP       - Serial Line Internet Protocol, 직렬 회선 인터넷 프로토콜 - 대부분의 컴퓨터에 내장된 직렬 포트에서 인터넷 등의 TCP/IP 네트워크에 전화선 등 직렬 통신 회선을 통해 일시적으로 접속하기 위한 프로토콜                 PPP       - Point-to-Point  Protocol, 점 대 점 프로토콜 - 두 통신 노드 간의 직접적인 연결을 위해 일반적으로 사용되는 데이터 링크 프로토콜 - 인증, 암호화를 통한 전송 및 데이터 압축 기능 제공 - SLIP, LAPB와 같은 프로토콜에 대한 대안으로 사용                 MAC       - Media Access Control, 매체 접근 제어 - 자료 전송 프로토콜의 하부 계층이며 OSI 모델에 규정된 데이터 링크 계층의 일부                 Ethernet       - OSI 모델의 물리 계층에서 신호와 배선, 데이터 링크 계층에서 MAC 패킷과 프로토콜의 형식을 정의 - 현재 가장 널리 사용되고 있으며, 토큰 링, FDDI 등의 다른 표준을 대부분 대체                 DSL       - Digital Subscriver Line, 디지털 가입자 회선 - 지역 전화망을 통해 디지털 데이터 전송을 제공하는 기술의 계열                 ISDN       - Integrated Service Digital Network, 광대역 종합 통신망 - 모든 정보를 디지털 신호로 만들어 하나의 네트워크를 통하여 문자, 그림, 음성, 화상, 비디오, 팩시밀리 등과 같은 모든 종류의   서비스를 제공하는 통신망                 FDDI       - Fiber Distributed Data Interface, 파이버 분산형 데이터 인터페이스 - 근거리 통신망의 데이터 전송을 위한 100Mbit/sec의 광 표준을 제공                 RARP       - Reverse Address Resolution Protocol, 역순 주소 결정 프로토콜 - IP호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP주소를 모르는 경우에 서버로부터 IP주소를 요청하기 위해 사용           인터넷 계층                  프로토콜       기능                       IP       - Internet Protocol, 인터넷 프로토콜 - 송신 호스트와 수신 호스트가 패킷 교환 네트워크에서 정보를 주고받는 데 사용하는 정보 위주의 규약 - 호스트의 주소 지정과 패킷 분할 및 재조립 기능 담당 - 비신뢰성(Unreliability), 비연결성(Connectionlessness) - IPv4, IPv6                 ARP       - Address Resolution Protocol, 주소 결정 프로토콜 - 네트워크 상에서 IP주소를 물리적 네트워크 주소로 대응시키기 위해 사용되는 프로토콜                 ICMP       - Internet Control Message Protocol, 인터넷 제어 메시지 프로토콜 - 네트워크 컴퓨터 위에서 돌아가는 운영체제에서 오류메시지를 전송하는 데 주로 사용                 IGMP       - Internet Group Management Protocol, 인터넷 그룹 관리 프로토콜 - 호스트 컴퓨터와 인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는 데 사용하는 통신 프로토콜                 IPSec       - Internet Protocol Security - 통신 세션의 각 IP패킷을 암호화하고 인증하는 안전한 인터넷 프로토콜 통신을 위한 인터넷 프로토콜 스위트           전송 계층                  프로토콜       기능                       TCP       - Transmission Control Protocol, 전송 제어 프로토콜 - 네트워크의 정보 전달을 통제하는 프로토콜이자 인터넷을 이루는 핵심 프로토콜 - 연결형, 신뢰성 확보, 복구 기능 제공, 순서 재조정 기능                 QUIC       - 범용 목적의 전송 계층 통신 프로토콜 - TCP를 사용하는 연결 지향 웹 애플리케이션의 성능을 개선                 UDP       - User/Universal Datagram Protocol, 사용자 데이터그램 프로토콜 - 인터넷 프로토콜 스위트의 주요 프로토콜 - 주로 DNS, IPTV, VoIP, TFTP, IP터널에서 사용                 DCCP       - Datagram Congestion Control Protocol, 데이터그램 혼잡 제어 프로토콜 - 메시지 지향적인 전송 계층 통신 프로토콜                 SCTP       - Stream Control Transmission Protocol, 스트림 제어 전송 프로토콜 - 컴퓨터 네트워킹에서 프로토콜 번호 132를 사용하는 전송 계층 프로토콜 - TCP와 UDP의 동일한 서비스 기능들 가운데 일부를 제공                 RSVP       - Resource ReSerVation Protocol, 자원 예약 프로토콜 - RFC 2205에 기술된 전송 계층 프로토콜 - 네트워크 상에서 자원을 예약할 수 있도록 디자인된 프로토콜           응용 계층                  프로토콜       기능                       BGP       - Border Gateway Protocol, 경계 경로 프로토콜 - 인터넷에서 자율시스템(AS) 중 라우팅 및 도달 가능성 정보를 교환하기 위해 설계된, 표준화된 외부 게이트웨이 프로토콜의 하나                 NSP       - Name Service Protocol - DNS가 발표되기 전 사용되던 호스크와 IP 어드레스의 매핑 프로토콜                 DNS       - Domain Name System, 도메인 네임 시스템 - 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 하기 위해 개발                 LLMNR       - Link-Local Multicast Name Resolution - DNS을 기반으로 고완된 프로토콜 - 패킷 포맷 IPv4, IPv6 호스트 상에서 모두 사용 가능                 Archie       FTP 지원 프로토콜로 전 세계의 FTP Host를 검색하는 프로토콜                 FTP       - File Transfer Protocol, 파일 전송 프로토콜 - TCP/IP 프로토콜을 가지고 서버와 클라이언트 사이의 파일 전송을 하기 위한 프로토콜                 TFTP       - Trivial File Transfer Protocol - FTP보다 더 단순한 방식으로 파일을 전송(불안정하다는 단점이 존재)                 SFTP       - SSH/Secure File Transfer Protocol - 신뢰할 수 있는 데이터 스트림을 통해 파일 접근, 파일 전송, 파일 관리를 제공하는 네트워크 프로토콜                 HTTP       - Hyper Text Transfer Protocol(80 Port) - 인터넷에서 고급화된 파일(텍스트, 그래픽, 사운드, 오디오 등)을 송수신하는 서비스                 POP3       - Post Office Protocol - 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오는데 사용                 IMAP       - Internet Message Access Protocol, 인터넷 메시지 접속 프로토콜 - 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오는데 사용 - 온라인/오프라인을 지원하므로 POP3와 달리 이메일 메시지를 서버에 남겨 두었다가 나중에 삭제 가능                 LDAP       - Lightweight Directory Access Protocol, 경량 디렉토리 접근 프로토콜 - TCP/IP위에서 디렉터리 서비스를 조회하고 수정하는 응용 프로토콜                 MQTT       - Message Queuing Telemetry Transport - ISO 표준 발생-구독 기반의 메시징 프로토콜                 NNTP       - Network News Transfer Protocol - 뉴스 서버 간에 유즈넷 뉴스 기사를 전송하고 최종 사용자 클라이언트 애플리케이션에 의해 기사를 구독, 게시할 수 있게 하기 위한 애플리케이션 프로토콜                 NTP       - Network Time Protocol - 패킷 교환, 가변 레이턴시 데이터 네트워크를 통해 컴퓨터 시스템 간 시간 동기화를 위한 네트워크 프로토콜                 RTP       - Real-Time Transport Protocol - 네트워크상에서 음성이나 영상 또는 시뮬레이션 데이터 등 실시간 전송이 필요한 응용에 대하여 편리한 전송 기능을 제공                 RTCP       - Real-Time Control Protocol - 세션의 모든 참여자에게 컨트롤 패킷을 주기적으로 전송 - 데이터 전송을 모니터링하고 최소한의 제어와 인증 기능을 제공 - RTP 세션의 대역 외 통계 및 제어 정보를 제공 - RTCP가 직접 미디어 데이터를 전송하지는 않는다                 RTSP       - Real Time Streaming Protocol - 스트리밍 미디어 서버를 제어할 목적으로 엔터테인먼트, 통신 시스템에 사용하도록 설계된 네트워크 제어 프로토콜                 RIP       - Routing Information Protocol - UDP/IP 상에서 동작하는 라우팅 프로토콜                 SIP       - Session Initiation Protocol - IETE에서 정의한 시그널링 프로토콜로 음성과 화상통화같은 멀티미디어 세션을 제어하기 위해 널리 사용                 SMTP       - Simple Mail Transfer Protocol(25 Port) - 인터넷에서 이메일을 보내기 위해 이용되는 프로토콜                 SNMP       - Simple Network Management Protocol, 간이 망 관리 프로토콜 - IP 네트워크상의 장치로부터 정보를 수집 및 관리하며, 또한 정보를 수정하여 장치의 동작을 변경하는 데 사용                 SSH       - Secure SHell, 시큐어 셸 (22 Port) - 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해주는 응용 프로그램 또는 프로토콜                 Telnet       - 멀리 떨어진 호스트에 원격 접속하여 사용할 수 있는 가상 터미널(VT) 서비스 프로토콜                 TLS/SSL       - Transport Layer Security/Secure Sockets Layer - 컴퓨터 네트워크에 통신 보안을 제공하기 위해 설계된 암호 규약 - TCP/IP 네트워크를 사용하는 통신에 적용되며 통신 과정에서 전송 계층 종단간 보안과 데이터 무결성을 확보해준다                 XMPP       - eXtensible Messaging and Presense Protocol - XML에 기반한 메시지 지향 미들웨어용 통신 프로토콜                 Gopher       - 인터넷을 위해 고안된 문서 검색 프로토콜                 IRC       - Internet Relay Chat - 인터넷 채팅 서비스 프로토콜                 DHCP       - Dynamic Host Configuration Protocol - 호스트 IP 구성 관리를 단순화하는 IP 표준 - 네트워크에 연결되어 있는 컴퓨터가 시동될 때 DHCP 서버로부터 IP 주소와 구성 매개 변수를 동적으로 할당받아 자동으로 TCP/IP 설정이 이루어진다           프로토콜 구조  TCP Header     SRC(Source Port) : 송신측의 포트 주소 기록   DEST(Destination) : 수신측의 포트 주소 기록   SEQ(Sequence Number) : 전체 데이터의 세그먼트 위치 기록(상위)   ACK(Acknowledgment) : 전체 데이터 세그먼트 위치를 기록(하위)   DO(Data Offset) : TCP 헤더 길이 기록   RES(Reserved) : 확장될 때 사용할 예비 영역   CF(Control Flags) : 패킷의 종류를 표시하는 플래그   WINDOW : 수신 가능한 최대 세그먼트 길이를 기록   CS(Checksum) : 오류를 체크하는 알고리즘 기록   URGPTR(Urgent Pointer) : 긴급 데이터 포인트 기록   UDP Header (8Byte)     Source Port Number : 송신 포트번호   Destination Port Number : 수신 포트번호   UDP Total length : UDP 헤더와 데이터를 합친 길이   UDP Checksum : UDP 헤더와 데이터를 모두 포함하여 검사   RTP Header     Padding(P)  세팅되어 있는 경우는 그 패킷의 끝에 전송하려는 데이터 외에 추가적인 데이터들이 포함되어 있다   Marker(M)  패킷 스트림에서 프레임 간의 경계에 존재하는 특별한 경우를 표시   Extension(X)  세팅되어 있는 경우는 RTP 헤더 마지막에 확장 헤더가 있음을 의미   Payload Type(PT)  데이터가 어떤 형식인지를 지정   Timestamp  데이터그램에 포함된 데이터의 생성 시기를 나타낸다   RTCP 패킷 유형     SR(Sender Report) : 세션의 품질에 대한 정보를 포함   RR(Receiver Report) : 세션의 품질에 대한 정보를 포함   SDES(Source Description) : 세션에 속한 각 참가자의 ID에 대한 정보를 포함   BYE(Goodbye) : 세션에서 하나 이상의 소스가 더 이상 활성화 상태가 아님을 나타낸다   APP(APPlication-defined) : 새 응용 프로그램에서 실험적으로 사용          RR/SR Header            버전       패딩 : 1로 설정된 경우, 추가 패딩 옥텟의 개수       수신 보고서 개수 : RTCP 패킷에 포함된 수신 블록의 개수       패킷 유형 : RR(201), SR(200)       길이 : 1을 뺀 32비트 단어에 RTCP 패킷의 길이를 포함       식별자 : 패킷의 동기화 소스 식별자를 포함           IP Header     VER(Version, 4bit)        IHL(Internet Header Length, 4bit)  IP 헤더 길이로 보통 24바이트 정도이다. 4비트로 표현된 길이에 4바이트를 곱하면 IP 헤더의 길이            TOS(Type Source, 8bit)  IP 서비스 형태로 상위층에 의해 결정            TL(Total Length, 16bit)  IP 헤더 길이와 TCP 헤더와 TCP 데이터의 길이를 더한 길이            ID(IDentification, 16bit)  참고 정보들이 기록            FL(Flags, 3bit)  패킷 분할의 정보로 첫 번째 비트는 사용하지 않고, 2번째 비트가 ‘1’이면 분할 가능, ‘0’이면 분할 불가를 의미하고 3번째 비트가 ‘0’이면 분할된 패킷의 최후 패킷을 의미            TTL(Time To Live, 8bit)  패킷을 처리하는 데 필요한 시간으로 데이터그램 패킷의 최대 수명 시간은 255초. 범람 라우팅에서는 Hop Count로 사용하는 블록            PROT(PROTocol, 8bit)  IP 계층에서 서비스를 받을 상위 계층의 프로토콜 번호로 TCP 계층의 TCP(6)/UDP(17)을 기입하는 블록            HC(Header Checksum, 16bit)  IP헤더의 오류 체크 블록            SOURCE(Source address, 32bit)  송신측의 IP 어드레스            DEST(DESTination, 32bit)  수신측의 IP 어드레스       OPT(OPTion)  표준 IP헤더에는 없는 정보를 송신할 때 사용하는 블록  ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-internetworking/",
        "teaser": null
      },{
        "title": "[데이터통신] 통신 프로토콜",
        "excerpt":"통신 프로토콜  서로 다른 시스템에 존재하는 개체 간의 원활한 통신을 위한 소프트웨어적 하드웨어적 약속이나 규칙 및 규약을 의미   통신 프로토콜 기본 구성 요소     구문(Syntax) : 데이터 형식, 부호화, 신호 레벨 등의 요소   의미(Semantics) : 전송 제어 및 오류 처리를 위한 정보 등을 규정   시간(Timing) : 두 개체 간의 통신 속도를 조정하거나 메시지의 전송 및 순서에 대한 특성을 가리킨다   통신 프로토콜 주요 기능                  기능       내용                       단편화와 재결합 (Fragmentation &amp; Reassembly)       많은 양의 데이터 블록을 효율적인 전송이 되도록 작은 단위의 블록으로 단편화하여 전송하며, 수신된 작은 단위 블록은 다시 원래의 데이터가 될 수 있도록 재결합되어야 한다 효과적으로 오류 제어를 할 수 있고 응답 시간이 빠르다 재결합 시 프레임에 순서 번호 부여를 하는 등 부수적인 데이터의 증가와 처리 시간이 길어져서 비효율적이다                 캡슐화 (Encapsulation)       데이터의 플래그, 주소, 제어 정보 등 정보 데이터와 정보   데이터를 오류 없이 전송하기 위한 구조적인 묶음을 의미 HDSL, BASIC, DDCMP, TCP                 캡슐의 주요 제어 정보       주소, 에러 검출 코드, 프로토콜 제어                 연결 제어 (Connection Control)       회선 접속 → 링크 확립 → 데이터 전송 → 링크 해제 → 회선 절단에서 링크 확립과 링크 해제 단계를 제어하는 기능                 흐름 제어 (Flow Control)       두 개체 사이에 데이터의 개수나 속도의 조절하는   기능 Sliding Window                 오류 제어 (Error Control)       수신된 오류를 검출하고 재전송을 요구하는 기능 ARQ, Hamming Code, Parity                 동기화 (Synchronization)       데이터 전송은 직렬 전송으로 이루어진다. 따라서 송신측의 정보를 수신측에서 정확하게 수신하려면 직렬 입력 파형으로부터 비트와 문자를 정확하게 시간에 맞추어 수신해야 한다. 이처럼 송신측과 수신측이   같은 시간으로 동작하게 하는 기능                 순서 제어 (Sequencing)       연결 제어의 순서적 절차 기능으로 데이터 조각에 순서를 부여하여 전송하거나 수신된 데이터 조각을 순서에 맞게 조립하는 기능                 주소 지정 (Addressing)       데이터를 목적지까지 전송할 수 있도록 데이터에 목적지 위치를 추가하고 관리하는 기능 IP주소, 서브넷 마스크, NIC 주소, ARP, RARP                 다중화 (Multiplexing)       여러 개의 회선에서 데이터를 받아 한 개의 고속 회선으로 송신하거나 반대로 고속 회선에서 데이터를 입력받아 여러 개의 회선으로 분할하는 기능 FDM, TDM, CDM                 경로   선택 (Routing)       송/수신 간에 중간 서브넷을 거쳐 최적의 경로를 선택하는 기술로 서브넷 자원의 이용을 최대화하여 평균 패킷 전송 시간을 최소화하는 기능 Fixed, Flooding, RIP, ERP, BGP, EGP           통신 프로토콜의 종류          ARPANET(Advanced Research Projects Agency Network)  현재 사용 중인 인터넷의 모체가 된 네트워크.       패킷 교환 기술을 이용하여 전용 회선으로 연결된 여러 대의 컴퓨터로 구성되었으며, 미 국방성의 지원으로 개발된 최초의 유선형 패킷 교환 시스템            SNA(System Network Architecture)  특정한 시스템이나 프로그램이 아닌 네트워크상의 통신 규약.       사용자와 하드웨어, 각 세부적인 기술들을 분리시켜 네트워크의 모든 구성 요소가 다른 네트워크와 통신이 원활할 수 있도록 제시한 네트워크 구조            X.25  패킷 교환망에 광범위하게 사용되는 네트워크 프로토콜로서 CCITT에 의해 표준으로 채택되었다.       패킷형으로 동작하는 데이터 단말 장치(DTE)와 데이터 회선 종단 장치(DCE) 간의 인터페이스로, 사용자 단말 장치와 패킷 교환망(PSDN) 간의 데이터 교환 절차를 정의              공중 패킷 교환망에 대한 ITU-T의 권고안       물리 계층, 데이터 링크 계층, 패킷 계층들에 대한 기능으로 구성       연결형 네트워크 프로토콜       흐름 및 오류 제어 기능을 제공                OSI(Open Systems Interconnection, 개방형 시스템 간 상호 접속)  국제 표준화 기구인 ISO에서 개발된 OSI는 통신 네트워크 간에 어떻게 데이터를 전송할 것인가에 대한 표준 규약 또는 참조 모델            ISDN(Integrated Services Digital Network)  발신 가입자로부터 수신자까지의 모든 전송, 교환 과정이 디지털 방식으로 처리되며 음성과 비음성, 영상 등 서비스를 종합적으로 처리하는 종합 정보 통신망            IN(Intelligent Network, 지능망)  기존의 통신망에 컴퓨터를 연결하여 새로운 기술을 쉽게 접목할 수 있게 한 지능화된 네트워크를 의미.       기존의 공중 전화망(PSTN)에 컴퓨터를 연결하고, 서비스 교환 시스템(SSP), 서비스 제어 시스템(SCP), 서비스 관리 시스템(SMS) 등의 소프트웨어를 설치한 것            PPP(Point to Point Protocol)  전화선과 모뎀을 이용하여 인터넷을 접속하기 위한 프레임 프로토콜로 이전에 사용했던 방식인 SLIP을 개선하여 에러 검출 기능과 복구 기능을 추가한 프로토콜.              문자 위주 프레임       IETF의 표준 프로토콜       주로 두 개의 라우터를 접속할 때 사용       다중 프로토콜 지원       오류 검출만 제공되며, 재전송을 통한 오류 복구와 흐름 제어은 제공 되지 않음       비동기식 링크도 지원해야 하기 때문에 프레임은 반드시 바이트의 정수배가 되어야 한다       동기/비동기 회선 모두를 통하여 전송       압축 기능 제공       구조 : [Flag][Address][Control][Protocol][Data][FCS][Flag]                    PAP(Password Authentication Protocol)  초기 접속 시 아이디와 비밀번호를 미리 입력해 놓으면 자동으로 접속할 수 있는 프로토콜           CHAP(Challenge Handshake Authentication Protocol)  초기 접속이 이루어질 때 매번 3단계의 핸드세이크 인증을 수행하는 방법                           통신 프로토콜 계층 간 관계도      통신 제어 프로그램  데이터 전송 회선과 통신 제어 장치를 이용하여 컴퓨터와 단말기 간, 단말기와 단말기 간, 컴퓨터와 컴퓨터 간에 정보를 송/수신하기 위한 프로그램을 총칭하여 통신 제어 프로그램 혹은 통신 소프트웨어라 한다   통신 제어 프로그램의 3가지 기능          데이터 송/수신 기능  두 노드 간에 정보 교환을 위해서는 사전에 송/수신측 간 통신제어 프로그램의 명령이나 응답에 관한 신호의 제어 및 전달방식을 약속하여야 한다. 이러한 약속을 프로토콜이라고 하며 통신소프트웨어가 지원            통신 하드웨어 제어 기능 통신에 필요한 하드웨어와의 신호 및 데이터 송/수신을 행하는 모든 통신 제어를 소프트웨어가 지원            이용자 인터페이스 제어 기능 이용자가 통신 시스템을 쉽게 지시하고 통신 기능을 원만히 수행할 수 있도록 하는 기본 명령을 소프트웨어가 지원      ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-protocol/",
        "teaser": null
      },{
        "title": "[데이터통신] OSI 참조 모델",
        "excerpt":"OSI 참조 모델  각 업체의 독자적인 기술은 통신의 유용성 및 타사 제품 간 통신 네트워크 문제가 대두되면서 이를 위해 국제 표준화 기구(ISO)에서는 단말기로부터 컴퓨터, 네트워크, 프로세스, 사용자 간의 표준화된 절차를 규정하도록 한 표준 프로토콜(OSI: Open System Interconnection)을 발표하였다   설계 원칙     적절한 수의 계층을 두어 시스템의 복잡도를 최소화   서비스 접점의 경계를 두어 되도록 적은 상호 작용이 되도록 하였다   비슷한 층은 하나의 계층으로 묶어서 효율성을 증진시켰다   인접 층의 서비스를 변형시키지 않는 범위에서 계층에 서비스를 개발할 수 있도록 하였다   OSI 7계층의 구조와 기능      물리 계층(Physical Layer)  전송 매체와 전송 신호를 액세스하기 위한 기계적, 전기적, 기능적, 절차적 특성을 규정짓는 최하위 계층      통신 케이블, 전송 신호 방식, 물리적 정비를 정의   PDU : 비트(스트림)   데이터 링크 계층(Data Link Layer)  인접한 장치 간에 원활한 데이터의 전송을 하도록 하며, 물리적 연결 간의 신뢰성 있는 정보를 전송하는 계층      동기화, 오류, 흐름 제어로 프레임을 효과적으로 전송   전화를 이용한 인터넷 접속 프로토콜(PPP) 기능을 담당   프레임 동기화(BASIC 동기, HDLC 동기, SDLC 동기)   신뢰성 있고 효율적인 데이터 전송   매체 액세스 제어(CSMA/CD, Token-Bus, Token-Ring)   전송 제어 기능 담당   논리적 연결인 링크를 확립하거나 해제 수행   PDU : 프레임   네트워크 계층(Network Layer)  통신 시스템 간의 경로를 선택하는 기능, 통신 트래픽의 흐름을 제어하는 기능 및 통신 중에 패킷의 분실로 재전송을 요청할 수 있는 오류 제어 기능을 수행      패킷 정보를 목적지까지 전송   논리적 어드레싱   정보 교환 및 중계 기능을 담당   경로 선택, 트래픽 제어, 체증 제어   네트워크 연결을 관리   PDU : 패킷 or 데이터그램   전송 계층(Transport Layer)  네트워크 종단 시스템 간의 데이터를 일관성 있고 투명한 데이터 전송을 제공할 수 있도록 종단 간에 통신을 지원      종단 사용자 간에 에러 복구와 흐름 제어를 제공   공유 회선을 다중화, 집중화   주소를 지정   PDU : TCP 세그먼트   세션 계층(Session Layer)  응용 프로그램 간의 대화를 구성하고, 동기를 취하며 데이터 교환을 관리하기 위한 수단을 지원      데이터가 전달되었으나 오류가 있는 데이터를 회복하기 위해 사용   전송 방향 결정(전이중/반이중/단방향)   데이터 교환, 대화를 관리   전자 사서함 기능을 제공   통신 시스템 간의 회화 기능을 관리   대동기점은 데이터 교환을 대화 단위로 분할하여 오류를 확인한다   소동기점은 대화의 중간에 삽입되며, 응용 프로그램에 따라 오류 확인이 요구되지 않을 수도 있다   PDU : 메시지/데이터   표현 계층(Presentation Layer)     데이터 코드 변환, 압축, 번역, 암호화/해독   표현 형식을 제어   정보 형식을 지정   구문 검색, 문맥 관리   PDU : 메시지/데이터   응용 계층(Application Layer)     사용자가 OSI 환경에 접근이 가능하도록 한다   OSI 네트워크 환경에서 사용자에게 서비스를 제공하는 계층   PDU : 메시지/데이터   계층 간 데이터 단위              PCI(Protocol Control Information)  각 계층에서 처리되는 프로토콜 제어 정보로 하위 계층으로 전달되는 PDU에 추가되는 블록. 일반적으로 각 계층의 기능 및 프로그램이라 할 수 있다            PDU(Protocol Data Unit)  아래 계층으로 전달되는 데이터 단위로 PCI와 결합되어 전달            SDU(Service Data Unit)  상위 계층에서 전달받은 데이터 단위로 SDU는 PCI와 결합되어 하위 계층에 PDU 데이터 단위로 전달            SAP(Service Access Point)  (N)층이 (N+1)층에 제공하는 서비스를 의미. (N)계층에서 (N+1)계층으로 전달되는 서비스를 (N)-SAP라고 한다.      ","categories": ["study"],
        "tags": ["데이터통신"],
        "url": "https://many258.github.io/study/data-communication-osi-7-layer/",
        "teaser": null
      },{
        "title": "[운영체제/OS] 운영체제의 기본 개념",
        "excerpt":"운영체제(OS: Operating System)     하드웨어를 제어하는 소프트웨어       하드웨어를 활용할 수 있도록 펌웨어나 소프트웨어로 만들어진 프로그램   컴퓨터 본체 및 각 주변 장치를 가장 능률적이고 경제적으로 사용할 수 있도록 하는 프로그램   컴퓨터를 편리하게 사용하고 하드웨어를 효율적으로 사용할 수 있도록 하는 프로그램   컴퓨터 자원들인 프로세서, 기억 장치, 파일 및 정보, 네트워크 및 보호 등을 효율적으로 관리할 수 있는 프로그램의 집합   운영체제의 목적     컴퓨터 시스템의 처리량, 신뢰성을 최대화   컴퓨터 시스템의 반환 시간, 응답 시간, 처리 시간, 대기 시간, 경과 시간을 최소화   컴퓨터를 구성하고 있는 자원을 효율적으로 운영하고 제어   사용자와 컴퓨터 시스템과의 인터페이스 제공   제한된 자원을 효율적으로 공유하기 위해 스케줄링 수행   데이터를 공유   주변 장치를 관리   시스템의 이식성/호환성 증대   운영체제의 역할     운영체제는 스스로 어떤 기능도 수행하지 않고 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공   하드웨어와 사용자 사이에 내부 및 외부 인터페이스 제공   컴퓨터 자원을 여러 사용자가 효율적으로 나누어 사용할 수 있도록 자원을 관리   프로세서, 프로세스, 기억 장치, 입출력 장치를 관리   컴퓨터를 초기화시켜 작업을 수행할 수 있는 상태로 유지시키는 역할 수행   소프트웨어나 하드웨어에 오류가 발생하면 운영체제는 회복을 위해 활동   시스템 사용 도중 발생하는 내/외부적인 오류로부터 시스템을 보호   응용 프로그램들이 컴퓨터의 제한된 자원들을 공유할 수 있도록 자원을 관리   운영체제 계층 구조             명령어 해석기(Shell)  사용자 명령을 입력받아 시스템 기능을 수행하는 명령 해석기  사용자와 시스템 간의 인터페이스를 담당            제어 프로그램(Kernel)  하드웨어를 제어하는 프로그램으로 메모리, CPU, 단말기, 프린터 등 시스템의 자원 활용도를 높이기 위해 스케줄링과 자료 관리를 하는 핵심 요소            기계어(Machine Language)  0과 1로 표시되며 실행할 명령, 데이터, 기억 장소의 주소 등을 포함한다. 하드웨어를 직접 실행시킬 수 있는 형태로 구성되며 컴퓨터의 모든 하드웨어를 제어하기 위한 다양한 비트 형식의 명령어가 존재            마이크로프로그램(Micro-Program)  ROM이나 PROM에 영구히 기록되는 프로그램을 말하는 것으로 보통 펌웨어를 의미하며 마이크로코드(Microcode)라고도 한다      ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-base-concept/",
        "teaser": null
      },{
        "title": "[운영체제/OS] 시스템 소프트웨어",
        "excerpt":"시스템 소프트웨어  응용 프로그램들을 지원하기 위해서 개발된 소프트웨어로 사용자보다는 하드웨어 위주의 소프트웨어   시스템 소프트웨어에는 운영체제(UNIX, MS-DOS, Windows 등)나 유틸리티(컴파일러, 링커, 로더, 매크로 프로세서, 탐색기) 등이 있으며, 규모나 복잡도가 매우 커서 일반 사용자들이 개발하기에는 어렵다   시스템 소프트웨어를 개발하는 도구들에는 시스템 언어(어셈블리어, C언어) 및 번역 프로그램(어셈블러, 매크로 프로세서, 컴파일러 등)이 있으며 링커, 로더 등도 포함된다      프로그램을 기억 장치에 상주시킨다   인터럽트를 관리한다   기억/주변 장치 관리   파일 관리   시스템 소프트웨어 개발 도구  어셈블러(Assembler)  어셈블리어로 작성된 소스 프로그램을 기계어(0과 1로 구성된 언어)로 번역하고 로더(실행 가능한 파일로 만드는 프로그램)에 필요한 정보를 생성한다      프로그래머가 기계어로 작성하지 않아도 어셈블리어로 작성한 원시 프로그램을 기계어로 번역   어셈블리어로 작성된 원시 프로그램은 기계어보다 읽고 이해가 쉽다   프로그램의 주소가 기호 번지이다   프로그램에 데이터를 사용하기 쉽다   어셈블러 기능                  기능       상세                       명령어 생성       원시 프로그램에 있는 기호 명령어를 분서갛여 기계어 명령어로 변경                 기계 주소를 할당       원시 프로그램에 있는 기호 번지나 상수의 기억 장소를 할당                 의사 명령어 처리       프로그램의 시작과 종료, 재배치 정보 등 프로그램의 안내자 역할을 하는 명령어들을 처리           어셈블러 종류          단일 패스 어셈블러(1-Pass)  원시 프로그램을 한 번에 검색하여 일괄적으로 기계어 코드로 변경  잘못된 명령어를 사용하는 경우에는 실행할 수 없는 파일을 만든다. 따라서, 정확한 명령어나 기호번지를 사용해야 하는 어려움이 존재              기호 테이블을 정의       한 번에 번역하기 때문에 속도가 빠르다       프로그램 크기가 작으며 작성이 어렵다                이중 패스 어셈블러(2-Pass)  원시 프로그램을 1차 검색하여 명령어 및 기호 번지들을 데이터 베이스 테이블에 저장.       잘못 사용한 명령어나 기호 번지는 프로그래머가 수정할 수 있도록 오류 메시지를 출력하기도 한다. 이후에는 각 테이블에 저장된 정보들을 이용하여 기게어 코드나 기억 장소를 변환한다.       매크로 프로세서(Macro Processor)  어셈블리어를 사용하기 쉽도록 명령어들을 문자로 치환하여 확장해준다      매크로는 일종의 문자열 치환과 같이 사용된 횟수만큼 명령어를 생성, 삽입해서 실행   매크로 정의 내에 또 다른 매크로 정의 가능   파스칼 언어는 매크로 프로세서의 기능이 없다   매크로 라이브러리 : 여러 프로그램에서 공통적으로 자주 사용되는 매크로를 모아 놓은 라이브러리   매크로 프로세서 기능                  기본 기능       -                       매크로 정의 인식       원시 프로그램 내에 존재하는 매크로를 파악하여 매크로를 정의한 부분의 시작과 종료를 파악                 매크로 정의 저장       매크로 프로세서는 매크로 명과 정의된 내용을 매크로 호출 시 확장하기 위해 저장                 매크로 호출 인식       원시 프로그램 내에 매크로가 확장하기 위한 준비가 되어 있는 지 확인                 매크로 확장 및 인수       치환 매크로를 호출하면 매크로 명이 있는 원시 프로그램 위치에 저장된 내용과 인수를 치환           컴파일러(Compiler)  고급 언어로 작성된 프로그램을 기계에 적합한 프로그램으로 번역해주는 프로그램   원시 프로그램에 번역 프로그램을 수행하면 번역 프로그램은 기계가 이해할 수 있는 이진수로 구성된 목적 프로그램을 출력      COBOL, C, FORTRAN, PASCAL, ALGOL, Ada…   인터프리터(Interpreter)  고급 언어로 작성된 원시코드 명령어들을 한번에 한 줄씩 읽어들여서 실행하는 프로그램   인터프리터 과정에서는 최적화 단계를 거쳐 목적 프로그램을 출력하지 않는 것이 컴파일러와 크게 구분되는 점이다(기계어 명령어들이 만들어지는 컴파일 단계를 거칠 필요가 없다)      BASIC, LISP, Python, APL   링커(Linker)      컴파일러가 만들어낸 하나 이상의 목적 파일을 가져와 이를 단일 실행 프로그램으로 병합하는 프로그램   로더(Loader)      목적 프로그램을 실행 가능한 파일로 변환하기 위해 주기억 장소를 할당하거나, 여러 개의 목적 프로그램을 연계 편집하여 CPU가 처리될 수 있는 프로그램으로 변환   좁은 의미의 로더 :  프로그램을 실행하기 위하여 프로그램을 보조 기억 장치로부터 컴퓨터의 주기억 장치에 올려놓는 로더   넓은 의미의 로더 :  적재뿐만이 아닌 목적 프로그램들끼리 연결시키거나 주기억 장치를 재배치하는 등의 포괄적인 작업을 수행하는 로더   로더의 기능  일반적으로 로더는 프로그램을 실행하기 위하여 프로그램을 보조 기억 장치로부터 컴퓨터의 주기억 장치에 올려놓는 기능을 가진 프로그램으로 할당, 연결, 재배치, 적재 순서로 진행                      기능       내용                       할당(Allocation)       - 목적 프로그램이 실행된 주기억 장치 공간을 확보 - 단일 프로그램은 프로그램 전체를 적재하여 실행할 수 있는 주기억 장치 공간을 확보  - 다중 프로그램은 프로그램의 일부를 적재한 후 실행 도중에 필요한 부분을 적재할 수 있는 주기억 장치 공간을 확보                 연결(Linking)       - 여러 개의 독립적인 모듈을 연결  - 독립적인 주기억 장치의 일부 공간을 논리적인 주소 공간으로 연결  - 링키지 에디터는 프로그램 적재 시 필요한 프로그램들을 결합하여 주기억 장치에 적재함은 물론 보조 기억 장치에 로드 이미지를 보관해두는 역할을 수행                 재배치(Relocation)       - 프로그램이 주기억 장치 공간 안에서 위치를 변경할 수 있게 한다  - 베이스 레지스터를 관리                 적재(Loading)       프로그램 전체를 주기억 장치에 한 번에 적재하게 하거나 실행 시 필요한 일부분만을 차례로 적재하게 한다           로더의 종류                     로더의 종류       내용                       Compile and Go 로더       - 번역 프로그램과 로더가 하나로 구성되어 번역 프로그램이 로더의 역할(연결 기능은 수행하지 않는다)까지 담당하는 방식  - 매우 단순하여 프로그램하기가 용이하며 주기억 장소의 제한이 없다면 가장 이상적이라 할 수 있다                 절대 로더(Absolute Loader)       - 로더의 역할이 축수되어 가장 간단한 프로그램으로 구성된 것으로 기억 장소 할당이나 연결을 프로그래머가 직접 지정하는 방식(재배치: 번역 프로그램 / 적재 : 로더)  - 프로그래머 입장에서는 매우 어렵고 한 번 지정한 주기억 장소의 위치는 변경이 힘들다는 단점 존재                 직접 연결 로더       - 로더가 할당, 연결, 재배치, 적재를 모두 수행하는 일반적인 형태  - 기억 장소를 자동으로 재배치하고, 독립적으로 프로그래밍된 프로그램들을 연결하여 수행하기 때문에 재배치 로더 혹은 상대적 로더라고도 한다                 Binding 로더       - 할당, 연결, 재배치만 하는 로더로 프로그램을 실행하기 전 모든 준비만을 담당                 Module 로더       - 적재만을 담당하는 로더를 의미                 동적 적재 로더(Direct Linking Loader)       - CPU가 현재 사용 중인 부분만 전재하고 미사용 중인 프로그램은 보조 기억 장치에 저장해두는 방식으로 Load-On-Call이라고도 한다  - 오버레이(Overlay) : 프로그램 파일을 분할하여 순차적으로 적재하는 운영 방식 - 스와핑(Swapping) : 프로그램 파일을 분할하여 교체하면서 적재하는 운영 방식          ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-system-software/",
        "teaser": null
      },{
        "title": "[운영체제/OS] 운영체제 발달 과정",
        "excerpt":"운영체제 시스템의 발달 과정  일괄 처리(Batch Processing) 시스템  운영체제 형태 중 시대적으로 가장 먼저 생겨난 시스템으로 시스템의 효율 향상을 위하여 작업량이 일정한 수준이 될 때까지 모아두었다가 한꺼번에 처리      주기억 장치에 어셈블리어로 작성한 프로그램을 적재해 컴퓨터 시스템을 운영   컴퓨터 시스템을 중단 없이 효율적으로 사용 가능   다중 프로그래밍(Multiprogramming) 시스템  하나의 컴퓨터 시스템에서 여러 프로그램이 같이 컴퓨터 시스템에 입력되어 주기억 장치에 적재되고, 이들이 처리 장치를 번갈아 사용하며 실행하도록 하는 방식      하나뿐인 자원을 여러 개의 프로그램이 공동으로 사용   동일한 기억 장소를 둘 이상의 프로그램들이 사용하는 시스템   처리량의 극대화를 꾀한다   온라인(On-Line Processing) 시스템  통신 회선으로 각 시스템을 연결하여 처리하며 장소를 이동하지 않아도 처리 결과를 받아볼 수 있다.      다중 프로그램밍 방식, 일괄 처리 방식으로 처리된 결과를 원격지에서 받아볼 수 있다   대화식(Interactive) 처리로 운영체제에 적당   시분할 처리(Time-Sharing Processing) 시스템  사용자는 단말 장치를 이용하여 운영체제와 상호작용하며, 시스템은 일정 시간 단위(Time Slice / Quantum)로 CPU를 한 사용자에서 다음 사용자로 신속하게 전환함으로써, 각각의 사용자들은 실제로 자신만의 컴퓨터를 사용하고 있는 것처럼 사용할 수 있는 처리 방식      다중 프로그래밍 방식과 결합하여 모든 작업이 동시에 진행되는 것과 같은 대화식 처리를 진행   하나의 CPU를 여러 개의 작업이 정해진 시간 동안 번갈아 사용   라운드 로빈(Round-Robin) 방식이라고도 한다   응답 시간의 최소화를 꾀한다   컴퓨터 시스템의 전체 효율은 좋아지나 개인 사용자 입장에서는 반응 속도가 느려질 수 있다   다중 프로그램밍을 전제로 하기 때문에 다중 프로그래밍보다 복잡   H/W를 보다 능률적으로 사용할 수 있는 시스템   실시간 처리(Real Time Processing) 시스템  우주 왕복선이나 레이더 추적기 등 정해진 시간에 반드시 수행되어야 하는 작업들에 적당한 방식으로 한정된 시간 제약 조건에서 자료를 분석하여 처리하는 시스템      실행 결과를 즉시 받아볼 수 있어 응답 시간이 짧다   다중 모드(Multi Mode) 처리 시스템  일괄 처리, 시간 분할 처리, 실시간 처리를 모두 수행할 수 있는 운영 방식   분산 처리(Distributed) 시스템  하나의 작업을 여러 개의 컴퓨터 시스템이 공동으로 작업할 수 있는 운영 방식      각 컴퓨터 시스템은 독립적인 CPU와 메모리를 사용   약 결합(Loosely Coupled) 형태의 시스템 운영에 적합   통신 회선을 통하여 각 시스템에서 처리된 작업들을 모아 중앙 컴퓨터에서 처리   클라이언트 / 서버 운영체제        전송 지연이 길고 데이터 처리율이 낮다             약 결합 시스템 :  각 프로세스마다 독립된 메모리를 가진 시스템으로 분산 처리 시스템이라고도 한다. 둘 이상의 독립된 컴퓨터 시스템을 통신망을 통해 연결한 시스템.       각 시스템마다 독자적인 운영체제를 가지고 있으며, 독립적으로 작동할 수 있고 필요한 경우 메시지 전달이나 원격 프로시저 호출을 통해 프로세스 간 상호통신이 가능하다       병렬 처리(Parallel) 시스템  하나의 메모리를 여러 개의 CPU가 사용하는 컴퓨터 시스템      강 결합 형태의 시스템에 적합   복잡한 수치 연산, 과학 기술 처리에 적합한 방식         강 결합 시스템 :  동일 운영체제 하에서 여러 개의 프로세스가 하나의 메모리를 공유하여 사용하는 시스템으로 다중(병렬)처리 시스템이라고도 한다.       하나의 운영체제가 모든 프로세스와 시스템 하드웨어를 제어하며, 프로세스 간 통신은 공유메모리를 통해 이루어지기에 공유 메모리를 차지하려는 프로세스 간의 경쟁을 최소화하여야 한다. 하나의 메모리를 사용하므로 프로세스 간의 결합력은 강하다.       운영체제 성능 평가 기준          처리량(Throughput)  일정한 시간 내에서 얼마나 많은 작업량을 처리할 수 있는가의 척도       반환 시간(Turn-around Time)  요청한 작업에 대하여 그 결과를 사용자에게 되돌려 줄 때까지 소요되는 시간            대기 시간(Waiting Time) + 실행 시간(Running Time) + 응답 시간(Response Time)                 신뢰도(Reliability)  작업의 결과가 얼마나 정확하고 믿을 수 있는가의 기준.       사용 가능도(Availability)  컴퓨터 시스템 내의 한정된 각종 자원을 여러 사용자가 요구할 때, 어느 정도 신속하고 충분하게 지원해 줄 수 있는지의 정도   운영체제의 구성      제어 프로그램  운영체제에서 가장 기초적인 시스템의 기능을 담당하는 프로그램으로 프로세스 관리, CPU 스케줄링, 입출력 제어, 기억 장치 관리 등의 기능을 수행.   이러한 제어 프로그램이 항상 작동 중이라면 이를 커널(Kernel)이라고 한다                  종류       기능                       감시 프로그램(Supervisor Program)       - 제어 프로그램의 중추적인 역할을 담당하는 프로그램으로 각종 운영체제 제어 루틴의 호출을 인식하여 해당 제어 루틴을 지시하고 루틴의 동작을 감시/감독하는 프로그램.  - 운영체제 초기에는 감시 프로그램을 모니터라는 용어로 사용                 데이터 관리 프로그램(Data Management)       - 주기억 장치와 보조 기억 장치 사이의 자료 전송, 파일의 조작 및 처리, 입출력 자료와 프로그램의 논리적인 연결 등 운영체제 시스템에서 취급하는 파일과 데이터를 표준적인 방법으로 처리할 수 있도록 관리.  - IOCS(Input Ouput Control System)이라고도 한다.  - 세부적으로 구분하여 정리하면 다음과 같다.  　　Open/Close : 파일의 조작 및 처리, 입출력 자료와 프로그램을 논리적으로 연결  　　Read/Write : 주기억 장치와 보조 기억 장치 사이의 자료 전송  　　Blocking/Deblocking : OS에서 취급하는 파일과 데이터를 표준적인 방법으로 처리                 작업 제어 프로그램(Job Control Program)       - 어떤 업무를 처리한 후 다른 업무로의 이행을 자동적으로 수행하기 위한 준비 및 처리 완료를 담당하는 기능을 수행.  - 작업의 연속 처리를 위한 스케줄 및 시스템 자원 할당 등을 담당  - 운영체제의 각종 제어 루틴(프로세스 관리, CPU 스케줄링 등)의 수행 순서를 관리하며 사용자의 명령어 및 프로그램에 따라 제어 루틴들의 작업 시기를 조절해주는 기능 수행   작업 제어 스케줄러 　Master Scheduler : 사용자와 운영체제 사이의 통신을 담당 　Job Scheduler : 작업과 작업 사이에 존재하며 작업의 순서를 결정하는 행위를 담당           처리 프로그램                  종류       기능                       언어 번역 프로그램(Language Translator Program)       - 사용자가 저급이나 고급 언어를 사용하여 원시 프로그램을 작성하면, 목적 프로그램으로 번역해주는 프로그램 - 제어 프로그램들의 일부를 사용자에 의해 처리될 수 있게 서비스를 제공해주는 것으로 어셈블러, 컴파일러, 인터프리터, 프리프로세서가 존재                 서비스 프로그램(Service Program)       - 사용 빈도수가 높은 모듈이나 프로그램들을 사용자가 사용할 수 있도록 제공되는 프로그램 - 시스템 서비스에는 연계 편집기/라이브러리 등이 있고 사용자 서비스에는 정렬/병합/유틸리티 등과 같은 프로그램이 존재                 문제 프로그램(Problem Program)       - 편집기, 데이터베이스, 통신용 프로그램, 그래픽 프로그램 등 사용자의 응용 처리를 위해 사용되는 프로그램           ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-development-process/",
        "teaser": null
      },{
        "title": "[운영체제/OS] 인터럽트(Interrupt)",
        "excerpt":"인터럽트  프로세스가 수행 중에 다른 프로세스를 수행하기 위하여 현재 수행 중인 프로세스를 중단하거나 외부 입력 장치에 의해 프로세스가 중단되는 상태   인터럽트 작업 순서        인터럽트가 발생하면 운영체제가 제어권을 받는다   운영체제는 인터럽트 받은 현재의 프로세스 상태를 저장   운영체제는 인터럽트의 정보를 분석하여 지정되어 있는 루틴으로 제어권을 넘겨준다   인터럽트 처리 루틴이 인터럽트 처리   인터럽트가 걸렸던 이전 프로세스의 상태로 복구된다   인터럽트가 걸렸던 시점 이후부터 프로세스 실행   인터럽트 서비스 루틴(ISR, Interrupt Service Routine)  인터럽트 핸들러라고도 부르며, 인터럽트 접수에 의해 발생되는 인터럽트에 대응하여 특정 기능을 처리하는 기계어 코드 루틴이다   인터럽트 핸들러는 인터럽트 원인에 따라 각각 존재하고 인터럽트 핸들러가 작업을 마치는 데 걸리는 시간도 다양하다.   인터럽트 핸들러는 커널에 존재하고 응용 프로그램에는 넣지 않는다. 초기의 DOS는 인터럽트 핸들러를 응용 프로그램과 결합하여 작성하였지만, 윈도우가 본격적인 운영체제를 갖추면서 커널에서 처리하게 되었다   인터럽트 벡터 테이블(IVT, Interrupt Vector Table)  여러가지 인터럽트에 대해 해당 인터럽트 발생시 처리해야 할 루틴의 주소를 보관하고 있는 공간을 의미   인터럽트 종류  소프트웨어 인터럽트                  인터럽트 이름       내용                       SVC(SuperVisor Call) 인터럽트       - 운영체제의 제어 프로그램인 감시 프로그램을 호출하면 SVC 인터럽트가 발생.  - 운영체제에서 중추적인 역할을 하는 감시 프로그램의 호출은 사용자로부터 운영체제를 보호하거나 입출력 수행 루틴 호출, 기억 장치 할당 루틴, 오퍼레이터와의 대화 등을 위해 발생하는 인터럽트           외부 인터럽트                  인터럽트 이름       내용                       전원 이상(Power Fail) 인터럽트       - 정전, 파워 이상                 기계 착오(Machine Check) 인터럽트       - CPU의 기능적인 오류                 외부(External) 인터럽트       - 현재 운영 중인 운영체제 소속이 아닌 외적인 요인으로부터 발생 - 인터럽트 시계에 의해 프로세스가 시간 할당량이 종료된 경우 - 웹 서버나 프린트 서버를 운영하고 있는 상태에서 외부로부터 인터럽트 처리 신호가 왔을 경우                 입출력(I/O) 인터럽트       - 하드웨어적 인터럽트로 입출력 채널 확인, 준비, 할당, 완료 시에 발생 - 프로세스 실행 상태에서 I/O를 처리하기 위해 대기 상태로 전이되고 필요한 I/O를 요구할 때 발생(키 입력 및 프린터 출력하는 경우 등)           내부 인터럽트                  인터럽트 이름       내용                       프로그램 검사(Program Check) 인터럽트( =Trap)       - 프로그램 명령어를 수행하는 과정에서 부분적으로 발생하는 문제들에 의해 발생 - 데이터 연산 과정에서 Overflow나 Underflow 상태 시 - 나눗셈에서 분모가 0인 경우 - 기억 장치의 제한된 영역을 사용하는 명령 등 - 프로그램이 정상 수행되지 않고 시스템이 중지하거나 오류메시지를 출력하고 운영체제로 복귀하는 경우           인터럽트 우선순위  여러 장치에서 인터럽트가 동시에 발생하거나 인터럽트 서비스 루틴 수행 중 인터럽트가 발생한 경우 우선순위 판별이 필요      전원 이상   기계 착오   외부 신호   입출력   프로그램 검사   SVC   일반적으로 소프트웨어 인터럽트보다 하드웨어 인터럽트가, 내부 인터럽트 보다 외부 인터럽트가 우선 순위가 높다   우선순위 판별 방법  Polling(폴링, 소프트웨어적 방법)  CPU가 모든 제어기에 연결된 TEST I/O 선을 이용해 요청한 장치를 검사하는 방식      회로가 간단, 우선순위의 변경이 용이   검사할 때의 CPU의 자원이 필요해 반응 시간이 느리다   Vectored Interrupt(하드웨어적 방법)  인터럽트를 요청할 수 있는 장치에 버스를 직렬 또는 병렬로 연결해 인터럽트 요청 자치의 번호를 CPU에게 알리는 방식           데이지 체인(Daisy Chain)  어디에 인터럽트가 발생했는지 확인하는 회로를 직렬로 연결하는 하드웨어적 방법으로 INTR, INTA 선에 장치들을 우선순위에 따라 순서대로 연결하는 방식.       다른 방법에 비해 구성이 간단하나, 단순한 구조 때문에 CPU 가까이 연결된 장치에 비해 멀리있는 장치는 인터럽트 요청이 지연될 가능성이 존재            병렬 연결 방식  I/O 제어기 마다 별도의 버스 선을 이용하여 INTR, INTA선을 이용해서 확인하는 방법.       이 방법은 인터럽트를 요청한 장치를 쉽게 찾을 수 있는 장점이 있으나 하드웨어 구성이 매우 복잡하며, CPU가 가지고 있는 인터럽트 포트 수에 의해서 연결할 수 있는 장치의 수가 제한된다는 단점이 존재       문맥 교환(Context Switching)  다중 프로그래밍 시스템에서 CPU가 할당되는 프로세스를 변경하기 위하여 현재 CPU를 사용하여 실행되고 있는 프로세서의 상태 정보를 저장하고 제어권을 인터럽트 서비스 루틴(ISR)에게 넘기는 작업을 의미   　 CPU는 하나의 프로세스 정보만을 기억한다. 여러 개의 프로세스가 실행되는 다중 프로그래밍 환경에서 CPU는 각각의 프로세스의 정보를 저장했다 복귀하는 일을 반복한다. 프로세스의 저장과 복귀는 프로세스의 중단과 실행을 의미한다. 프로세스의 중단과 실행 시 인터럽트가 발생하므로, 문맥 교환이 많이 일어난다는 것은 인터럽트가 많이 발생한다는 의미이다.   　 프로세스들 시간 할당량은 시스템 성능의 중요한 역할을 한다. 시간 할당량이 적을수록 사용자 입장에서는 여러 개의 프로세스가 거의 동시에 수행되는 느낌을 갖지만 인터럽트의 수와 문맥 교환의 수가 증가한다. 프로세스의 실행을 위한 부가적인 활동을 오버헤드라고 하는데, 이 또한 문맥 교환 수가 같이 늘어나게 된다      시간 할당량 감소 :            문맥 교환 수, 인터럽트 횟수, 오버헤드  증가       여러 개의 프로세스가 동시에 수행되는 느낌을 받는다           시간 할당량 증가 :            문맥 교환 수, 인터럽트 횟수, 오버헤드  감소       여러 개의 프로세스가 동시에 수행되는 느낌을 갖지 못한다           프로세스 제어 블록(PCB, Process Control Block)  여러 개의 프로세스를 수행하는 다중 프로그래밍 환경 하에서 각 프로세스를 구분하기 위한 프로세스 정보 블록                  항목       상세 내용                       ① 프로세스 식별자       프로세스들을 구분할 수 있는 태그/명칭/고유 이름                 ② 프로세스 현재 상태       프로세스의 현재 상태                 ③ 프로그램 카운터(PC,계수기)       다음에 실행되는 명령어의 주소                 ④ 프로세스 우선순위       프로세스의 우선순위에 대한 정보 기억                 ⑤ 프로세스가 적재된 기억 장치 부분을 가리키는 포인터       프로세스가 시작되는 기억 장치의 시작 번지                 ⑥ 프로세스에 할당된 자원을 가리키는 포인터       프로세스 처리 중에 필요한 자원의 정보를 갖고 있는 기억 장소의 시작 번지                 ⑦ 처리기(CPU) 레지스터 정보       CPU 내 범용 레지스터(AX/BX/CX/DX), 데이터 레지스터(SP/BP/SI/DI), 세그먼트 레지스터(CS/DS/ES/SS) 등이 갖고 있는 값                 ⑧ CPU의 각종 레지스터 상태를 가리키는 포인터       CPU에 1비트로 구성된 상태 레지스터의 비트열 값                 ⑨ 계정 정보       CPU 사용 시간의 정보, 각종 스케줄러에 필요한 정보                 ⑩ 기억 장치 관리 정보       프로그램이 적재될 기억 장치의 상한치/하한치/페이지 테이블 등의 정보                 ⑪ 입출력 정보       프로세스 수행 시 필요한 주변 장치, 파일들의 정보                 ⑫ 부모 프로세스를 가리키는 포인터       자신을 생성한 상위 프로세스의 번지                 ⑬ 자식 프로세스를 가리키는 포인터       자신이 생성한 하위 프로세스의 번지          ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-interrupt/",
        "teaser": null
      },{
        "title": "[운영체제/OS] 프로세스",
        "excerpt":"프로세스(Process)  파일로 작성된 프로그램은 로더에 의해 주기억 장치에 상주되어 CPU에 의해서 처리된다. 이 때, 주기억 장치에 상주된 프로그램이 CPU에 의해서 처리되는 상태를 프로세스라고 한다      CPU에 의해서 현재 실행되고 있는 프로그램   PCB(Process Control Block, 프로세스 제어 블록)의 존재로서 명시되는 것   프로세서가 할당되는 개체로서 디스패치가 가능한 단위   지정된 결과를 얻기 위한 일련의 계통적 동작   목적 또는 결과에 따라 발생하는 사건들의 과정   비동기적 행위를 일으키는 주체   프로시저가 활동 중인 상태를 의미   실행 중인 프로시저의 제어 궤적   CPU가 할당되는 실체   운영체제가 관리하는 최소 단위의 작업   비동기적 행위 : 다중 프로그래밍 방식에서 CPU가 하나의 프로그램만을 연속적으로 처리하지 않고, 여러 프로그램의 일부분을 반복적으로 실행하고 중단하는 행위   프로세스의 상태전이도      프로세스 상태          New(생성)  프로세스가 막 생성된 상태       Ready(준비)  프로세스가 처리기를 사용하고 있지는 않지만 언제든 사용할 수 있는 상태를 의미            프로세스가 처리기의 배정을 기다리고 있는 상태       다른 프로세스 실행을 위해서 일시적으로 정지해있는 상태       CPU에 의해 처리되기 위해 주기억 장치에 존재하는 상태                Running(실행)  프로세스가 CPU를 차지하고 있는 상태 또는 프로세스의 명령이 실행되고 있는 상태를 의미       Block(Wait, 대기/보류)  프로세스가 어떤 사건이 일어나기를 기다리고 있는 상태            처리 속도가 느린 I/O 작업 중인 상태       외부적인 사건이 생길 때까지 실행할 수 없는 상태                Blocked Suspended  프로세스가 대기 상태에서 기억 장치를 잃은 상태            Suspended Ready  프로세스가 기억장치를 제외한 다른 모든 필요한 자원을 보유한 상태       Exit(Terminated)  프로세스의 실행을 완료되고 할당된 CPU를 반납한 상태   프로세스 상태 변화          Dispatch(디스패치, 준비실행)  준비 상태에 있는 여러 프로세스 중 프로세스를 선정하여 CPU를 할당하는 시점            Timer Run Out(할당 시간 종료, 실행준비)  할당된 시간만큼 CPU를 사용하고 준비 상태로 변하는 시점. 상태 변이 원인이 외부에 있어 외부 인터럽트에 의해 할당 시간이 종료            I/O 발생(Block, 실행대기)  프로세스가 CPU 사용 중에 I/O 행위가 필요하여 대기 상태로 이동하는 시점            Wake up(대기준비)  I/O 작업이 완료되거나 자원이 할당되어 다시 준비 상태로 이동하는 시점            Suspended(Swap-Out, 대기지연준비)  준비/대기 상태에서 기억 장치를 반납하고 지연 준비 상태로 전이            Resume(Swap-In, 지연 준비대기)  지연 준비/지연 대기 상태에서 기억 장치를 할당받아 준비(대기) 상태로 전이       프로세스 스케줄링          Long-Term(장기 스케줄러, Job Scheduler)  디스크에서 하나의 프로그램을 가져와 커널에 등록하면 프로세스가 되는데 이 때, 보조기억장치에서 어떤 프로그램을 가져와(Load) 커널(Job Queue)에 등록할 지 결정하는 역할을 수행            Middle-Term(중기 스케줄러)  메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러       만약 메모리에 많은 수의 프로세스가 적재되어 프로세스 당 보유하고 있는 메모리량이 극도로 적어지게 되면 CPU 수행에 당장 필요한 프로세스의 주소 공간 조차도 메모리에 올려놓기 힘든 상황이 발생할 수 있다. 이 때, 디스크 I/O가 수시로 발생하게 되어 시스템의 성능이 심각하게 저하될 수 있다       이런 경우에, 메모리를 올라와 있는 프로세스 중 일부로부터 메모리를 여유공간을 마련하기 위해 프로세스를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장한다(Swap-Out)            Short-Term(단기 스케줄러, CPU scheduler)  준비 상태의 프로세스 중에서 어떤 프로세스를 다음 번에 실행 상태로 만들 것인지를 결정하는 역할을 수행(메모리에 있는 프로그램들 중 어떤 프로세스를 CPU에 할당할 지 결정)       시분할 시스템에서 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다       스풀(Spool, Simultaneous Peripheral Operation On​-Line)  프로그램과 이를 이용하는 I/O 장치와의 속도 차를 극복하기 위한 장치로 대부분의 하드 디스크가 중재(프린트 작업에서도 사용)   버퍼링(Buffering)  CPU와 I/O 장치와의 속도 차이를 줄이기 위해 메모리가 중재   버퍼링은 한 레코드를 미리 읽어 CPU에 저장해 두고 CPU가 필요한 레코드를 일기 위해 기다리는 일이 없도록 한다  ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-process/",
        "teaser": null
      },{
        "title": "[운영체제/OS] CPU 스케줄링",
        "excerpt":"CPU 스케줄링  다중 프로그래밍 방식의 운영체제는 하나의 주기억 장소에 여러 개의 프로세스가 실행된다. 여러 개의 프로세스가 실행되지만, 컴퓨터 시스템에서 보유하고 있는 자원들은 극히 제한적이다.   　 이러한 제한된 환경 아래서 최적의 효과를 보기 위해서는 프로세스의 계획적인 실행 순서가 필요하다. 이러한 계획적인 실행 순서를 CPU 스케줄링 혹은 프로세스 스케줄링이라고 한다.   스케줄링 목적  CPU나 자원을 효과적이며 생산성 있게 사용하기 위한 소프트웨어적 계획을 의미. 이러한 프로세스 스케줄링은 필요한 하드웨어 레지스터를 설정함으로써 프로세스에게 CPU를 할당하고 문맥 교환을 하는 프로세스 관리 기능이다      모든 프로세스들에게 공정하게 배정해야 한다(공정성)   단위 시간당 가능한 최대한 많은 양이 처리될 수 있도록 해야 한다   응답 시간이 신속해야 한다   같은 종류의 작업은 거의 같은 시간과 비용으로 실행될 수 있어야 한다   오버헤드를 최소화해야 한다   시스템 내 자원을 사용하지 않는 시간이 없도록 유지해야 한다   응답 시간과 자원의 활용 간 적절한 균형이 유지되도록 해야 한다   프로세스가 무한정 기다리게 하는 것을 피해야 한다   프로세스의 상태를 파악하여 우선순위를 부여하는 것이 좋다   중요 자원을 차지하고 있는 프로세스에 우선권을 부여해야 한다   문제로 인해 불안하지 않은 프로세스에 서비스를 많이 제공하도록 한다   부하가 많은 경우 갑자기 체증이 발생하지 않도록 조절해야 한다   스케줄링 평가 기준     시스템 관점            CPU 이용률 : 최대화       처리 능력(Throughput) : 단위 시간당 처리할 수 있는 CPU의 작업량 최대화           프로세스 관점            대기(Waiting) 시간 : 준비 상태에서 대기하는 시간 최소화       응답(Response) 시간 : 입력에 대해 처음 반응하는 시간 최소화       반환(Turn-around) 시간 : 작업을 지시하고 결과가 되돌아오는 시간 최소화           스케줄링 알고리즘  다중 프로그래밍 방식은 메모리에 여러 개의 프로그램을 적재함으로써 CPU와 I/O 장치들의 유휴 시간을 줄여 사용 효율을 높이는 방식이다. 이러한 다중 프로그래밍 방식에서 CPU의 사용률과 처리율을 최대화 하기 위한 방법들을 프로세스 스케줄링 알고리즘이라고 한다   비선점형 방식(Non-Preemptive)  현재 실행 중인 프로세스가 자발적으로 CPU를 중단하는 경우에만 CPU 스케줄링을 수행하는 방법      일괄처리 방식에 적당   대화형/시간 분할/실시간 시스템 부적합   응답 시간 예측이 어렵다   문맥 교환이 적어 오버헤드가 적다   FCFS(First Come First Served, FIFO: First Input First Out)  먼저 입력된 작업을 먼저 처리하는 방식      가장 대표적인 비선점형 방식   공평하고 구현이 간단하나, 평균 반환 시간이 길다   짧은 작업이나 중요한 작업이 지연될 수 있다   SJF(Shortest Job First, 최단 작업 우선)  작업이 끝나기까지의 실행 시간 추정치가 가장 작은 작업을 먼저 실행시키는 방식. 비선점형이기 때문에 긴 작업일지라도 이미 CPU를 점유하고 있다면 뒤로 밀려나지 않고 처리되고 다음 작업들을 대상으로 재정리를 수행한다      평균 대기 시간을 최소화한다   프로세스의 다음 CPU 사용시간을 예측해야하는 어려움이 있다   긴 작업의 경우 계속해서 입력되는 짧은 작업들 때문에 우선순위가 계속 밀려나게 되고 무한 연기 상태가 발생하기도 한다   위 무한 연기 현상을 방지하기 위해 에이징(Aging) 기법을 사용하여 해결   에이징 기법 : 자원이 할당되기를 오랜 시간 동안 기다린 프로세스는 기다린 시간에 비례하는 높은 우선순위를 부여하여 가까운 시간 안에 자원이 할당되도록 하는 기법   HRN(Highest Response-ratio Next)  실행 시간 추정과 선점 기능 때문에 스케줄러가 복잡해지고 남은 계산 시간들을 저장해 놓아야 한다는 단점을 보완, 서비스 시간(실행 시간 추정치)과 대기 시간의 비율을 고려한 스케줄링 방식      우선순위 = $\\frac{대기 시간 + 서비스 시간}{서비스 시간}$       SJF를 개선한 방식   우선 순위 계산 공식을 이용하며, 계산된 값이 가장 큰 작업에게 우선권을 부여   우선순위(Priority)  대기 리스트에 있는 프로세스들에게 작업의 우선순위를 부여하여 CPU를 할당하는 방법      고정적 우선순위와 동적 우선순위 방식이 존재   기아 현상, 무한 봉쇄 현상 발생 가능   기한부(Deadline)  제한된 시간 내에 반드시 작업이 완료되도록 스케줄링하는 방식. 제한된 시간을 정확히 추정하여 그 시간 만큼에 CPU 사용 시간을 제한한다. 작업이 제한 시간 내에 처리되지 않으면 다시는 해당 작업이 CPU 사용 시간을 합당받을 수 없다      프로세스들이 마감 시간 내에 처리되지 않으면 폐기되거나 처음부터 다시 실행 필요   기한부 스케줄링에 필요한 집약적 자원 관리는 많은 오버헤드를 일으킬 수 있다   동시에 다수의 기한부 작업이 수행되면 스케줄링은 매우 어려워질 수 있다   사용자는 작업에 필요한 자원의 정확한 정보를 시스템에 제시하여야 한다   선점형 방식(Preemtive)  하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할수 있다      대화형, 시간 분할, 실시간 시스템에 적합   응답 시간 예측이 용이하다   문맥 교환이 많아 오버헤드가 많다   라운드 로빈(RR, Round-Robin)  시분할 시스템을 위해 고안되었으며 여러 개의 프로세스가 10 ~ 100msec 정도의 시간 할당량(Quantum, Time Slice)이라는 작은 단위 시간이 정의되어 시간 할당량만큼씩 CPU를 사용하는 방식      FIFO 스케줄링을 선점형으로 변환한 방식   적절한 응답 시간을 보장해주는 대화식 사용자에게 효과적          시간 할당량이 클 때,             FIFO 방식과 거의 같은 형태가 된다           시간 할당량이 작을 때,             프로세스 간의 전이가 많아지므로 프로세스가 전이되는 과정에서 필요한 문맥 교환 수 증가       실행 시간보다 문맥 교환의 교체에 사용되는 부가적인 시간이 증가하게 되므로 오버헤드가 증가       프로세서의 교환에서 시간을 소비하고 실제 사용자들의 연산은 거의 못하는 결과를 초래           SRT(Shortest Remaining Time)  작업이 끝나기까지 남아 있는 실행 시간의 추정치가 가장 작은 프로세스를 먼저 실행하는 방식으로 새로 입력되는 작업까지도 포함된다.      실행 시간 추적과 서비스 받은 시간을 기록해야 하므로 오버헤드가 증가   임계치(Threshold Value)를 사용   임계치 : CPU를 사용 중인 프로세스가 거의 마지막에 이르렀을 때 남아 있는 시간보다 조금 작은 프로세스가 입력된다면 순수 SRT는 조금 작은 프로세스에게 CPU 사용 권한을 넘겨주어야 한다. 하지만 이럴 경우 문맥 교환 횟수나 전체 정황으로 보았을 때 현재 현재 작업 중인 프로세스를 모두 마치고 조금 작은 프로세스를 다음에 처리하는 것이 더 효율적일 것이다. 이러한 경우를 추정해서 공식에 적용시켜 얻어진 수치를 의미한다   다단계 큐(MQ, Multi-level Queue)      준비 큐를 여러 종류의 그룹으로 나누고 여러 개의 큐에 다양한 알고리즘을 적용하는 스케줄링 기법. 일반적으로 멀티레벨 큐에서 준비 큐는 대화형 작업을 담기 위한 전위 큐(Foreground Queue)와 계산 위주의 작업을 담기 위한 후위 큐(Background Queue)로 분할되어 프로세스들은 자신의 우선순위 값에 해당하는 큐에 들어가며 우선순위가 낮은 하위 단계 큐의 작업은 실행중이더라도 상위 단계 큐에 프로세스가 도착하면 CPU를 뺏기는 선점 방식이다      선점, 비선점 방식   정적 우선순위를 사용하는 스케줄링을 구현 할 때 가장 적합   서로 다른 우선순위의 프로세스들을 구별하고 관리하기 위해 우선순위의 개수만큼 큐가 필요   큐를 특성별로 여러 개 가지며, 각 독립적인 스케줄링을 가진다   큐 간에 프로세스가 이동이 안된다   우선순위가 가장 높은 큐에서는 비선점형으로 사용   다단계 피드백 큐(MFQ, Multi level Feedback Queue)      짧은 작업이나 입출력 위주의 작업에 우선권을 부여하기 위해 개발된 방식으로 적응 기법의 개념을 적용. 큐 간에 프로세스가 이동이 불가한 다단계 큐(MQ)의 단점을 보완      큐마다 시간 할당량이 존재하며 낮은 큐일수록 시간 할당량은 커진다   각각의 큐들은 종속적으로 연결되어 있다   CPU를 시간 할당량만큼 사용한 프로세스는 낮은 큐로 이동   맨 위에 큐는 RR방식을 사용, 맨 마지막 큐는 FCFS방식 사용   우선순위가 낮은 프로세스는 계속 지연되는 기아(Starvation) 현상이 발생할 수 있다  Aging 기법 사용으로 해결  ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-cpu-scheduling/",
        "teaser": null
      },{
        "title": "[운영체제/OS] 병행 프로세스 동기화 유형",
        "excerpt":"임계 구역(Critical Section)  다중 프로그래밍 운영체제에서 한순간에 여러 개의 프로세스에 의하여 공유되는 데이터 및 자원에 대하여 반드시 하나의 프로세스에 의해서만 자원 또는 데이터가 사용되도록하는 것으로 자원이 프로세스에 의하여 반납된 후, 비로소 다른 프로세스에서 자원을 이용하거나 데이터를 접근할 수 있도록 지정된 영역이다.   하나의 컴퓨터 시스템에서 여러 개의 프로세스가 운영되고 있을 때 각 프로세스는 동시에 접근해서는 안 되는 공유 자원을 임계 구역이라 할 수 있으며 여기에는 메모리, 프린터, 디스크, CD-ROM이 있다      두 개 이상의 프로세스가 동시에 사용할 수 없다   순서를 지키면서 신속하게 사용   하나의 프로세스가 독점하게 해서는 안된다   사용 중에 중단, 무한 반복되어서는 안된다   인터럽트가 불가능한 상태로 만들어야 한다   상호 배제(Mutual Exclusion)  임계 구역을 어느 시점에서 단지 한 개의 프로세스만이 사용할 수 있도록 하며, 다른 프로세스가 현재 사용 중인 임계 구역에 대하여 접근하려고 할 때 금지하는 행위를 상호배제라고 한다. 상호배제 알고리즘은 인터럽트 불능 처리, 잠금, 엄격한 교대, TSL, 세마포어 등이 있다   상호 배제 알고리즘  인터럽트 불능 처리  하나의 프로세스가 하나의 공유 자원을 점유하게 되면 인터럽트를 발생하지 않도록 봉쇄한다.   인터럽트를 봉쇄한다는 것은 현시점에서 어떠한 프로세스도 새롭게 자원을 점유하기 위한 시도를 할 수 없게 된다는 의미히며 즉, 현재 공유 자원을 점유한 프로세스는 아무런 제약 없이 공유 자원을 사용하게 되므로 완벽한 상호배제를 할 수 있다.   하지만 하나의 프로세스가 공유 자원을 점유하고 있는 동안 다른 프로세스는 아무런 작업을 할수 없는 상태이므로 시스템 효율이 매우 낮아진다.   잠금(Lock)  공유 자원을 점유하게 되는 경우 그 자원을 어떠한 프로세스도 접근하지 못하도록 하는 방법   공유 자원을 점유하는 프로세스는 사용을 시작하면서 공유 자원에 접근하려는 모든 프로세스가 사용할 수 없도록 표시를 하게 된다. 이 때 이미 점유되어 있는 공유자원을 사용하기 위해 접근하고 있는 임의의 프로세스들은 표시를 계속 확인하게 되는데 이를 바쁜 대기(Busy Wait) 상태라고 한다   엄격한 교대(Dekker 알고리즘)  두 개 이상의 프로세스가 교대로 공유 자원을 점유하는 방식      프로세스 A가 공유 자원을 점유하고 나면 프로세스 B는 프로세스 A가 사용 해제를 통보하길 기다렸다가 사용한다   한쪽 프로세스가 점유 시간이 길어지면 나머지 프로세스는 사용 가능한가를 계속 감지하는 작업을 반복해야한다. 즉, 바쁜 대기 현상은 계속 발생한다.   하나의 프로세스가 우선권을 갖게 해야 하며, 한쪽이 작업량이 많아서 빈번해져도 반드시 교대로 점유해야한다(하나의 프로세스를 연속적으로 재사용 불가)   하나의 프로세스가 사용 중에 중단되면 다른 프로세스는 영원히 사용할 수 없는 교착상태에 빠지게 된다   TSL(Test &amp; Set Lock) 명령어 기법  엄격한 교대의 문제점을 해결하는 방법으로 특수한 하드웨어 자원을 필요로 하지만, 바쁜 대기 상태는 완벽히 해결하지는 못한다      프로세스 A,B 모두 각자의 변수 x,y를 갖게 되며 각 프로세스는 x,y값이 모두 0일 때 공유 자원을 사용할 수 있다   프로세스 A가 공유 자원을 사용하기 위해서는 y값이 0인가를 확인한다. y값이 1이라면 프로세스 B가 사용 중이다   프로세스 B가 공유 자원을 사용하기 위해서는 x값이 0인가를 확인한다. x값이 1이라면 프로세스 A가 사용 중이다   상대 프로세스가 가진 변수 값이 0인 경우에만 공유 자원을 점유할 수 있게 되고 점유하자마자 변수를 1로 변경하고 사용 후에는 0으로 변경한다           Sleep() / Wakeup()  TSL의 교착 상태와 바쁜 대기 현상의 단점 중 바쁜 대기의 문제점을 보완한 방법       하나의 공유 자원을 점유하기 위한 시도를 반복하지 않고 사용하려는 공유 자원이 이미 사용 중이라면 프로세스를 잠시 중단하게 한다(Sleep, Wait, P, Down), 이후 어느 정도의 시간이 지나서 공유 자원이 사용 가능하다면 잠시 중단하고 있던 프로세스를 활성화(Wakeup, Signal, V, Up)하여 바쁜 대기 현상을 방지하는 방법       세마포어(Semaphore)  프로세스 간의 상호배제 및 동기화 문제 해결 방법   P(S), V(S) 연산을 통해서 프로세스 사이의 동기를 유지하고 상호배제의 원리 보장      이진 세마포어            세마포어 변수가 오직 0과 1값을 가지며 하나의 임계 구역만을 상호배제하기 위한 알고리즘       잠금, 엄격한 교대, TSL           산술(계수형 세마포어)            세마포어 변수가 0과 양의 정수를 값으로 가지며 임계 구역을 여러 개 관리하기 위한 상호배제 알고리즘                  여러 개의 프로세스가 동시에 그값을 수정하지 못한다   세마포어에 대한 연산은 처리 중에 인터럽트 되어서는 안된다   세마포어데 대한 연산은 소프트웨어나 하드웨어로 구현 가능   V 조작은 블록 큐에 대기 중인 프로세스를 깨우는 신호로서, 흔히 Signal 동작이라 한다   P 조작은 임계 영역을 사용하려는 프로세서들의 진입 여부를 결정하는 것으로, 흔히 Wait 동작이라 한다   모니터(Monitor)  상호배제를 위한 데이터 및 프로그램 모듈로 운영체제 내부의 프로그램을 모니터라고 한다. 공유 자원을 사용하기 위해 기다리는 프로세스들은 모니터에 진입해도 좋다는 허가를 기다리며 모니터에서는 프로세스들의 공유 자원 점유 순서를 제어한다      두 개 이상의 프로세스가 특정 공유 자원을 순차적으로 할당하는 데 필요한 데이터 및 프로시저를 포함하는 병행성 구조(Concurrency Construct)이다   모니터 내의 자원을 원하는 프로세스는 반드시 해당 모니터의 진입부를 호출해야 한다   모니터 외부의 프로세스는 모니터 내부의 데이터를 직접 접근 불가   자료 추상화와 정보 은폐의 개념을 기초적으로 사용   스위치 개념을 사용하여 한순간에 하나의 프로세스만이 모니터에 진입 가능   모니터에서 사용되는 연산은 Wait와 Signal이 있다   모니터의 경계에서 상호배제가 시행   교착상태(Dead-Lock)      두 개 이상의 프로세스가 하나의 자원을 공유하여 사용하고 있을 때 서로가 사용 중인 자원을 요구하지만 요구를 영원히 들어줄 수 없는 상태를 의미   교착상태 발생 필수 4대 요소  상호배제(Mutual Exclusion)  여러 개의 프로세스를 동시에 운영하는 다중 프로그래밍 방식에서는 제한된 자원을 서로 공유하면서 효율적으로 사용해야 하기 때문에 상호배제를 해야 한다. 이러한 상호배제는 여러 개의 프로세스를 동시에 처리하기 위하여 공유 자원을 순차적 처리하면서, 동시에 접근하지 못하도록 해야 한다.   하지만, 이러한 상호배제가 실패하게 되면 교착상태가 발생할 수 있기 때문에 상호배제는 교착상태 발생의 필수 조건 중 하나가 된다   점유와 대기(Hold &amp; Wait)  시스템의 성능을 높이기 위해서는 여러 개의 프로세스를 동시에 운영하면서 사용 중이거나 사용 중이 아닌 공유 자원들을 순차적으로 배분해 주어야 시스템 성능이 향상될 것이다   따라서 점유와 대기는 존재할 수 밖에 없고 이는 교착상태 발생의 필수 조건 중 하나가 된다   비선점(Non-Preemption)  비선점이란, 이미 사용 중인 공유 자원들을 빼앗을 수 없다는 의미   하나의 프로세스가 특정 공유 자원을 사용하다가 프로그램 루틴의 문제로 임계 구역 내부에서 중단되었을 때 만약 이 자원을 빼앗을 수 없다면 이 자원을 사용하기 위해 대기 중이던 프로세스는 영원히 원하는 자원을 빼앗을 수 없다는 것은 비선점이고 이는 교착상태 발생의 필수 조건 중에 하나가 된다   순환 대기(Circular Wait, 환형 대기)  공유 자원들을 프로세스에게 분배할 때 입력 순으로 순차적으로 분배한다면 시간이 오래 걸려 성능이 떨어질 뿐 교착상태는 발생하지 않을 것이다. 순차적으로 분배하지 않고 당장 사용하지 않는 자원은 다른 프로세스가 사용하게 한다면 자원을 효율적으로 사용하게 될 것이다.   이처럼 모든 프로세스와 자원을 순차적으로 사용하지 않고 사용 시기와 순서를 융통성있게 조절하게 될 때 프로세스의 자원의 점유와 대기 상태는 환형 상태가 될 수 있다.   교착상태 해결 방안  예방(Prevention)  교착상태가 절대 발생하지 않도록 사전에 조치를 취하는 방안이지만, 성능은 낮아질 수 밖에 없다. 교착상태 발생의 네 가지 조건 중에서 하나를 제거함으로서 처리           상호배제 부정 단일 프로그램을 운영하거나, 자원을 독립적으로 사용하여 임계 구역을 없애고 상호배제를 하지 않는다면 교착상태는 절대 발생하지 않는다. 하지만 자원의 낭비나 신뢰성이 낮아지기 때문에 사용하기에 적절하지 않은 방법            점유와 대기 부정 각 프로세스는 한 번에 자신에게 필요한 모든 자원을 요구해야 하며, 이 요구가 만족되지 않으면 작업을 진행할 수 없다. 또한 어떤 자원을 갖고 있는 프로세스가 더 이상 요구가 수용되지 않으면 원래 갖고 있던 자원을 일단 반납하고 필요하다면 다시 그 자원이나 다른 자원을 요구해야 한다            비선점 부정 프로세스가 점유하고 있는 자원들을 언제든 빼앗을 수 있도록 한다            순환 대기 부정 한 프로세스가 주어진 유형의 자원을 할당받았으면 그 프로세스는 순서에 따라 나중에 위치하는 유형의 자원말을 요구할 수 있게 한다              모든 자원을 선형 순서로 분류           회피(Avoidance)  프로세스가 자원을 요구할 때 시스템이 안전(교착상태가 발생하지 않는 범위 내) 상태를 유지할 수 있는 프로세스의 자원 요구만을 할당해주는 방안   은행원 알고리즘(Banker’s Algorithm)      Dijkstra가 제안한 방식으로 불안전 상태와 안전 상태로 구분한다. 안전 상태에서는 교착상태가 발생하지 않으며, 은행원 알고리즘을 적용하기 위해서는 자원의 양과 사용자의 수가 일정해야 한다. 또한 모든 요구를 정해진 시간 안에 할당하는 것을 보장해야 한다.   하지만, 은행원 알고리즘은 응답 시간이 보장되어야 하는 대화식 시스템에 적용하기 어렵다      은행원 : 운영체제   대출자 : 프로세스   은행 보유 금액 : 자원 수   현재 대출 금액 : 각 프로세스가 점유하고 잇는 자원 수   대출 한도 금액 : 프로세스가 완료할 때까지 필요한 총 자원 수   발견(Detection)  자원 할당 그래프는 시스템이 주된 이유가 교착상태인가를 발견하는 기법. 교착상태임이 발견되면 해당 프로세스와 자원을 선점하거나 중단 시켜 교착상태 해결   회복(Recovery)  실행 중인 모든 프로세스가 정상적으로 작업을 완료할 수 없기 때문에 발생한 교착상태이므로 어느 정도의 희생은 감수해야 한다. 즉, 실행을 중단하거나 점유 중인 자원을 빼앗을 프로세스를 찾는 일로 가능한 손실이 적은 쪽을 선택해야 한다      선점을 통한 회복            보유하고 있는 자원을 빼앗아 교착상태를 해결하고 시스템을 정상으로 회복하는 방법       우선순위가 낮은, 진행 상태가 적은, 자원을 적게 사용하고 있는 프로세스의 자원을 선점하여 프로세스를 일시 중단           복귀(Rollback)를 통한 회복            교착상태가 발생하기 이전 상태로 복귀하여 다시 실행하는 방법       현재 실행 중인 전체 프로세스를 대상으로 할 수 있지만 더욱 효과적인 방법은 교착상태를 해결할 만큼의 프로세스들만을 선택하여 처음부터 다시 실행하는 것       현재까지 실행되고 있는 프로세스와 중단된 프로세스의 정보를 재구성해야하는 어려움이 존재           제거(Kill)를 통한 회복            우선순위가 낮은, 진행 상태가 적은, 자원을 적게 사용하고 있는 프로세스를 선택하여 제거       기아 상태나 문제가 있는 프로세스 제거       정상 수행이 불가능한 모든 프로세스를 제거하고 다시 시작           사용자의 조치 경로(Routing) 선택            Window OS : Ctrl + Alt + Delete를 입력하면 현재 작동 중인 프로세스 리스트가 나오게 되는데 이 때 문제가 있는 프로세스를 선택하여 제거       Unix OS : ps 명령을 입력하면 현재 프로세스들의 리스트가 출력되는데 이 때 문제가 있는 프로세스들을 kill/killall 명령으로 제거          ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-concurrent-process-synchronization/",
        "teaser": null
      },{
        "title": "[운영체제/OS] 기억 장치",
        "excerpt":"기억 장치  기억 장치 계층 구조      기억 장치의 사용 용도  가상 기억 장치(Virtual Memory)  프로그램 전체가 주기억 장치에 상주하면서 실행되는 것보다는 느리겠지만 주기억 장치를 효과적으로 사용할 수 있다는 측면에서는 최고의 기술이며 현재 대부분 이러한 방식을 채택하고 있다   가상 디스크(Virual Disk)  보조 기억 장치인 디스크 기술이 발전되기 전에는 주기억 장치의 일부를 디스크 드라이브로 분리하여 디스크처럼 사용했던 기술로, MS-DOS에서는 주기억 장치에 가상 디스크를 만들어 하드 디스크처럼 활용할 수 있게 하는 장치 제어기로 RAMDRIVE.SYS를 사용하며 지금은 보통 고장한 하드 디스크를 복구할 때 주로 사용   인터리빙(Interleaving)  주기억 장치의 액세스 속도를 빠르게 하기 위한 기술로 기억 장치의 연속된 위치를 서로 다른 뱅크로 구성하여 하나의 주소로 여러 개의 위치에 해당하는 기억 장치를 접근할 수 있도록 하는 방법   하나의 장치가 독립적인 기능을 하는 다른 장치의 상태를 검사할 수 있도록 허가하는 기법을 Polling이라 한다   DMA(Direct Memory Access)  사이클 스틸링(Cycle Stealing) 기법을 사용하여 중앙 처리 장치를 거치지 않고 직접 주기억 장치와 주변 장치 사이에서 데이터를 주고받는 입출력 제어기로 입출력에 대한 CPU의 부담을 줄이는 동시에 액세스 속도를 향상시킨다   사이클 스틸링 : 중앙 처리 장치와 입출력 장치가 동시에 주기억 장치에 접근하려고 하는 경우, 입출력 장치에 우선순위를 부여하는 것으로 적은 양의 사이클을 필요로 하는 채널에 우선순위를 높여주면 입출력 장비의 효율이 높아진다.   기억 장치의 관리 기법      주기억 장치의 다중 프로그래밍 사용 방식  제한된 주기억 장치 크기에서 다중 프로그래밍을 원만히 수행하기 위해서는 크게 두 가지 전제 조건이 있어야 한다. 하나는 주기억 장치를 여러 개의 독립적인 프로그램으로 분리해서 사용할 수 있도록 주기억 장치를 분할해야 한다는 것과 프로그램의 크기를 분할된 최대 크기보다 작거나 같도록 해야 한다는 것이다.   프로그램의 크기가 제한이 없어진 것은 가상 기억 장치를 사용하면서부터였고 주기억 장치만을 사용하는 시기에는 크기에 제한을 두었다.   고정(정적) 분할  주기억 장치의 크기를 다르게 분할하되 항상 고정된 크기를 갖는 형태로 분할하는 방식. 대부분 프로그램들의 크기가 다르기 때문에 분할된 영역의 크기는 항상 고정시키되 분할 크기를 다르게 하는 것이 유리하다.   문제는 프로그램들의 크기와 분할된 주기억 장치의 크기가 항상 같을 수는 없다는 것인데, 이런 크기 차이로 남거나 부족한 현상을 단편화(Fragmentation)라고 하며 이렇게 단편화된 주기억 장치의 영역은 통합과 집약을 통해서 재사용되어야 한다           내부(Internal) 단편화  정해진 크기에 프로그램을 할당하고 남은 기억 공간으로 사용되지 못하는 공간            외부(Eternal) 단편화  정해진 크기는 아니지만, 프로그램의 크기가 커서 기억할 수 없게 된 공간       가변(동적) 분할  고정 분할의 문제점을 보완한 방법으로 프로그램의 크기에 따라 주기억 장치 분할 크기를 동적으로 분할하는 방식.   내부 단편화 현상은 발생하지 않지만 외부 단편화는 계속 발생하며 차폐 레지스터의 값을 매번 변경해야 하기 때문에 고정 분할 방식보다 복잡하다.           베이스 레지스터(Base Register)  주기억 장치가 분할된 영역으로 나뉘어 관리될 때, 프로그램이 한 영역에서 다른 영역으로 옮겨지더라도 명령의 주소 부분을 바꾸지 않고 정상적으로 수행될 수 있도록 하기 위한 레지스터            차폐 레지스터(Fence Register)  주기억 장치가 분할된 영역으로 나뉘어 관리될 때, 분할된 영역을 다른 프로그램이 사용하지 못하도록 분할 영역의 위치를 기억하고 있어야 한다. 이를 차폐 레지스터라고 하며 고정 분할일 경우에는 차폐 레지스터에 기억된 값이 변하지 않지만 가변 분할 방식에서는 동적으로 변하게 된다            경계 레지스터(Boundary Register)  주기억 장치가 분할된 영역으로 나뉘어 관리될 때, 주기억 장치 내에 존재하는 프로그램은 크게 운영체제와 사용자 영역에 존재하는 프로그램으로 나뉜다. 이 때 사용자 영역에 존재하는 프로그램이 운영체제 영역을 침범하지 못하도록 하는 것이 경계 레지스터의 역할이다            기억 장치 보호 키(Storage Protection Key)  기억 장치 관리 기법 중 세그먼트 기법에서 사용하는 기억 장치 보호 방법이다. 주기억 장치 내에 하나의 프로그램이 여러 개의 분할된 프로그램 조각들로 분리되어 사용할 때 여러 개의 분할된 프로그램 조각들은 같은 종류의 프로그램이라는 것을 표시해야만 한다. 이러한 구분 표시는 다른 프로그램과 섞이지 않고 보호하게 된다       주기억 장치 재사용 기술          통합(Coalescing)  인접한 공백들을 더 큰 하나의 공백으로 만드는 과정으로 차폐 레지스터의 값을 변경하여 분할 영역의 크기를 변경하게 된다            집약(압축, Compaction)  서로 떨어져 있는 여러 개의 낭비 공간을 모아서 하나의 큰 기억 공간을 만드는 과정으로 사용되지 않은 기억 장치를 주기억 장치의 한 쪽 끝으로 옮기는 것이다. 압축 후에는 하나의 커다란 공백이 생기게 된다. 디스크에서의 집약은 보통 Garbage-Collection이라고 한다       가상 기억 장치의 사용 방식  보조 기억 장치를 주기억 장치처럼 사용하는 것으로, 주기억 장치보다 용량이 큰 프로그램도 처리가 가능하다. 프로그램을 여러 개의 작은 블록 단위로 나누어서 가상 기억 장치에 보관해 놓고 프로그램 실행 시 요구되는 블록만 주기억 장치에 불연속적으로 할당하여 처리한다   기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있으며 프로그램 크기를 줄이지 않고 순차적으로 수행하는 기법인 오버레이 문제는 자동적으로 해결되나 프로그램 실행 시 주소 변환 작업이 필요하기 때문에 설계가 복잡하다   가상 기억 장치를 이용하게 되는 것은 여러 개의 프로그램이 동시에 처리되는 다중 프로그래밍 방식에서 대부분 사용하므로 단일 프로그래밍에서 사용하는 방식은 무의미하다   가상 기억 장치의 다중 프로그래밍 사용 방식  고정 분할(Paging)  디스크에 존재하는 같은 크기로 분할된 프로그램, 즉 페이지와 주기억 장치에 분할된 영역과 페이지가 교체되면서 프로그램이 실행되는데 이러한 기술을 보통 페이지 기법 혹은 페이징이라 한다.   페이지 기법의 기본적인 이점으로는 프로그램 크기에 제한이 없으며 주기억 장치를 효율적으로 사용할 수 있다는 것이다.   외부 단편화는 존재하지 않지만 내부 단편화는 발생한다      페이지 크기가 작을 수록             많은 페이지 사상 테이블 필요       내부 단편화는 줄어든다       자주 사용하는 페이지의 집합을 효율적으로 운영할 수 있다       특정한 참조 구역성만을 포함하기 때문에 기억 장치 효율이 높을 수 있다       총 입출력 시간 증가           페이지 크기가 클 수록             페이지 테이블의 크기가 작아지므로 주기억 장치의 공간이 절약       참조되는 정보와는 무관한 많은 양의 정보가 주기억 장치에 남는다       페이지 테이블이 복잡하지 않으므로 관리가 용이       디스크로부터 입출력 전송에 소모되는 시간은 커진다           동적 분할(Segmentation)  프로그램을 여러 개의 다른 크기로 분할하고 주기억 장치에서는 분할된 크기에 맞게 동적으로 분할하여 적재시키는 방법   크기가 다른 모듈을 고정된 길이를 갖는 페이지로 구분하여 사용할 경우, 고정된 페이지의 크기보다 작거나 큰 모듈은 주기억 장치에서 사용하지 않는 부분이 많이 발생될 것이다. 이로 인해 메모리 효율과 전체적인 성능은 낮아진다   세그먼트 사상 테이블과 기억 장치 보호 키가 필요하며 외부 단편화만 발생한다. 세그먼트 기법에서 빈 공간이 생기는 현상을 체커 보딩(Checker-boarding)이라 한다   각 프로그램은 분할된 자신만의 영역이 없으므로 다른 프로그램의 세그먼트들은 같은 기억 공간을 공유한다   가상 기억 장치 주요 기술  오버레이(Overlay)  단일 사용자 시스템에서 프로그램의 크기가 주기억 장치의 용량보다 클 수 없다. 하지만 더 이상 사용하지 않는 프로그램을 보조 기억 장치로 옮긴 후 그 기억 공간을 다른 프로그램이 사용하게 하면 실제 영역보다 더 큰 프로그램을 실행할 수 있다. 오버레이는 분할된 프로그램들을 순차적으로 적재하여 실행한다.   스와핑(Swapping)  실행되어야 할 작업의 크기가 커서 사용자 기억 공간에 수용될 수 없을 때 작업의 모든 부분들이 동시에 주기억 장치에 상주해 있을 필요가 없다. 이 때 작업을 분할하여 필요한 부분만 교체하여 실행할 수 있다   페이지 부재(Page Fault)  가상 기억 장치 시스템에서 가상 페이지 주소를 사용하여 데이터를 접근하는 프로그램이 실행될 때, 프로그램에서 접근하려고 하는 페이지가 주기억 장치에 있지 않은 경우 발생하는 현상      실행하고자 하는 페이지가 주기억 장치 내에 존재하지 않는 경우 운영체제에게 트랩(Trap)을 요청   운영체제는 현재 진행 중인 사용자 레지스트라와 프로그램 상태를 저장   현재 사용 가능한 페이지를 페이지 사상 테이블에서 검색   가상 기억 장치에 존재하는 해당 페이지를 주기억 장치로 가져온다   페이지 사상 테이블을 조정   프로그램 실행을 계속   스레싱(Thrashing)  다중 프로그래밍 시스템 또는 가상 기억 장치를 사용하는 시스템에서 하나의 프로세스가 작업 수행 과정 중 지나치게 페이지 부재가 발생함으로 인하여 전체 시스템의 성능이 저하되는 현상   구역성(Locality)  프로그램이 실행할 때 기억 장치 내의 모든 정보를 균일하게 참조하는 것이 아니라 어느 한 순간에 특정 부문을 집중적으로 참조하는 프로그램의 순차적인 성질.   디스크로부터 주기억 장치에 읽어들일 수 있는 블록의 크기로 여러 개의 페이지를 주기억 장치에 가져올 수 있다. 그중에 한 개의 페이지만이 필요하다면 이왕이면 앞으로 사용할 가능성이 높은 페이지들을 같이 읽어들이는 것이 좋다는 의미      시간(Temporal) 구역성            최근에 참조된 기억 장소가 가까운 장래에도 계속 참조될 가능성이 높음을 의미       반복, 부 프로그램, 스택, 집계 시 사용되는 변수들           공간(Spatial) 구역성            하나의 기억 장소가 참조되면 그 근처의 기억 장소가 계속 참조될 가능성이 높음을 의미       배열 순회, 프로그램의 순차적 코드 실행, 프로그램에서 관련된 변수들을 서로 근처에 선언하는 경우           작업 집합(Working Set)  프로세스를 효과적으로 실행하기 위해서는 주기억 장치에 유지되어야 하는 페이지들의 집합을 의미한다. 자주 참조되는 페이지의 집합은 주기억 장치에 미리 적재해두면 페이지 폴트를 최소화할 수 있고 효율적인 실행이 가능  ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-memory/",
        "teaser": null
      },{
        "title": "[운영체제/OS] 기억 장치의 관리 전략",
        "excerpt":"기억 장치 관리 전략의 종류  반입 전략(Fetch Strategy)  프로그램/데이터를 주기억 장치로 가져오는 시기를 결정하는 전략(When)   요구(Demand) 반입  요구가 있을 때마다 주기억 장치로 옮기는 방식(응용 프로그램을 실행하는 것은 사용자의 요구에 의해 주기억 장치에 적재하는 것)   예상(Anticipatory)반입  앞으로 요구될 가능성이 큰 데이터 또는 프로그램을 예상하여 주기억 장치로 미리 옮기는 방법   가상 기억 장치를 사용하게 될 때 주로 사용되며 자주 사용하는 페이지는 미리 주기억 장치에 가져다 놓는다(워킹 셋, Working Set). 앞으로 사용할 가능성이 높은 페이지를 가져다 놓는다(지역성, Locality)   예상이 성공하면 프로그램의 실행 속도가 빨라지지만 실패하면 오버헤드가 발생한다   배치 전략(Placement Strategy)  주기억 장치에 프로그램/데이터의 위치를 정하는 전략(Where)      최초 적합(First Fit)  입력된 작업을 주기억 장치 내에서 작업을 수용할 수 있는 첫 번째 공백에 배치      초기 결정력이 가장 빠르나, 내부 단편화의 크기에 상관없이 단편화가 많이 발생   최적 적합(Best Fit)  입력된 작업을 주기억 장치 내의 공백 중에서 작업에 가장 잘 맞는 공백에 배치(주기억 장치 내의 여러 공백에 대해서 프로세스 크기를 차감하여 그 결과값이 가장 작은 공백에 배치)      내부 단편화가 가장 적게 발생하나, 검색 시간이 길어 결정력이 가장 느리다   최악 적합(Worst Fit)  입력된 작업을 주기억 장치 내에서 가장 잘 맞지 않는 공백에 배치(주기억 장치 내의 여러 공백 각각에 대해서 프로세스 크기를 차감하여 그 결과값이 가장 큰 공백에 배치)   교체(재배치) 전략(Replacement Strategy)  주기억 장치 내의 빈 공간 확보를 위해 제거할 프로그램/데이터를 선택하는 전략(What/How)   OPT(OPTimal Replacement, 최적)  페이지 사용 횟수를 정확히 예측하여 교체하는 방법      앞으로 가장 오랫동안 사용되지 않을 페이지와 교체한다(이론상 페이지 부재 횟수가 가장 적으므로 성공률이 크다)   Belady의 알고리즘으로 가장 이상적이지만 실현 가능성이 희박하다   FIFO(First Input First Out)  주기억 장치에 들어와 있는 페이지에 타임 스탬프를 찍어 그 시간을 기억하고 있다가 가장 먼저 들어와 있던 페이지를 교체하는 방법      주기억 장치 내에 가장 오래된 페이지와 교체   알고리즘이 가장 간단하지만 페이지 교체가 가장 많다   Belady 모순 : 프로세스에 할당된 페이지 프레임 수가 증가하면 페이지 부재의 수가 감소하는 것이 당연하지만 페이지 프레임 수가 증가할 때, 오히려 현실적으로 페이지 부재가 더 증가하는 모순 현상이 발생한다   LRU(Least Recently Used)  참조된 지 가장 오래된 페이지를 대체 대상으로 선정하여 현 시점에서 가장 오랫동안 사용하지 않은 페이지와 교체한다      각 페이지마다 계수기(시간 기억 영역)를 두어 사용하는 기법   LFU(Least Frequently Used)  페이지별로 사용된 횟수를 기억할 참조 변수를 확보한 후에 페이지가 참조될 때마다 1씩 증가한다. 주기억 장치에 기억된 페이지 중 하나를 교체하려고 할 때 참조 변수에 기억된 값이 가장 적은 페이지를 교체 대상으로 선정하는 기법      사용한 횟수가 가장 적은 페이지와 교체   사용한 횟수가 기억될 참조 변수를 각 페이지에 두어 사용   NUR(Not Used Recently)  페이지 당 두 개의 정보비트(참조 비트, 변형 비트)를 이용하여 교체하는 방법   참조 비트는 해당 페이지를 호출했는가를 파악하는 비트이고, 변형 비트는 주기억 장치 내에 있던 페이지를 사용했는가의 의미로 사용하는 비트이다. 비트 값이 1이면 최근에, 0이면 오래전으로 판단한다   PFF(Page Fault Frequently)  자주 사용하는 페이지들은 주기억 장치에 미리 적재하여 페이지 폴트가 최소가 되도록 해야 한다.   자주 사용하는 페이지의 집합을 워킹 셋이라고 하는데 PFF는 워킹 셋에 존재하는 페이지들을 관찰하여 최근에 자주 사용되고 있지 않은 페이지와 워킹 셋에 속하지 않은 페이지 중에 최근에 자주 사용하는 페이지와 교체하여 교체 효율을 향상시키는 기법   Second Chance(FIFO의 2차 기회 부여)  가장 먼저 입력되었던 페이지를 제거 대상으로 삼는 FIFO의 단점을 보완한 것으로 가장 오래된 페이지를 제거하기 전에 한 번의 기회를 더 주는 방식   각 페이지에 프레임을 FIFO 순으로 유지시키면서 LRU 근사 알고리즘처럼 참조 비트를 갖게 한다. 또한 가장 오래된 페이지를 다시 처음에 입력된 페이지로 되돌리기 위해서는 LRU의 계수기를 필요로 하게 된다. (FIFO + LRU)   주기억 장치의 할당과 회수  주기억 장치에 프로그램이 적재될 때 빈 공간이 있는지 또는 크기는 어느 정도인지 우선 파악해야 한다. 이러한 정보를 파악하여 표시해두면 프로그램이 신속하게 적재할 수 있게 된다   비트 맵(Bit Map)  분할된 기억 장치 영역의 정보를 0(사용하지 않음),1(영역 사용중)로 구분하며 분할된 블록의 크기가 크면 비트 맵 용량이 줄어든다   사용되지 않는 영역이 있거나 단편화가 발생해도 합병, 집약이 어려우며 사용 여부를 알아내기 위해 순차 검색만을 수행하므로 검색 속도가 느리다   연결된 리스트(Linked List)  분할된 영역의 정보를 구조적인 변수로 확보하여 동적인 연결 구조인 링크드 리스트 구조로 관리   구조적 변수의 항목으로 P(프로그램이 존재, Process), H(비어 있음, Hole), 시작 위치, 크기, 연결 정보로 구성   배치 전략에서 사용하기 적합하며 추가 삭제가 용이하므로 통합, 압축에 효과적으로 이용될 수 있지만 검색 속도는 비트 맴보다 다소 느리다   버디 시스템(Buddy System)  큰 버퍼들을 반복적으로 반으로 나누어 작은 버퍼들을 만들며(버디 : 버퍼가 나누어질 때 각 공간을 의미), 가능할 때마다 인접한 자유로운 버퍼들을 합치는 과정을 반복(2의 거듭제곱 값으로 메모리를 할당)      약간의 외부 단편화와 메모리 간결화를 하는 오버헤드를 가지고 있다   요청된 메모리가 작은 블록보다 조금 더 크면 메모리가 낭비된다   기억 장치의 주소 사상 방법         블록 사상(페이지, 세그먼트) 주소 양식            V = (B, D)  B: Page, Segment 번호  D: Displacement(Offset)            블록(페이지, 세그먼트) 주소 사상 기법 종류          직접 사상(Direct Mapping)  페이지 번호와 변위로 구성된 가상 주소 중 페이지 번호로 페이지 사상 표에서 구한 실기억 장치의 주소와 가상 주소 중의 변위를 실제 주소로 변환하는 방법을 갖는 페이지 사상 기법              모든 페이지 항목은 페이지 사상 테이블에 존재       총 2번의 메모리 접근이 필요(주소 변환에 시간을 많이 소비하게 되는 방식)                연관 사상(Associative Mapping)  직접 사상은 페이지의 분할 개수가 많을수록 해당 페이지를 검색하는 시간이 많은 소요되며, 프로그램을 가상 기억 장치로 실행하게 될 때 페이지 교체 속도가 늦어져 전체 프로그램 실행 속도에 영향을 주게 된다       이러한 단점을 보완하기 위해 고속의 연관 메모리에 자주 사용하는 페이지만 혹은 현재 적재된 페이지 만을 기억시켜 속도를 향상시키는 방법              매핑된 값들을 캐쉬 메모리에 저장(프로세스 번호, 페이지 번호, 매칭된 메인 메모리의 주소가 함께 매칭되어 입력)       연관 기억장치에 저장한 연관 사상표를 이용       빠른 주소 변환 수행                연관/직접 사상(Set Associative Mapping)  연관 사상 기법으로 사용하게 될 때 모든 페이지의 정보를 기억하려면 값비싼 고속의 메모리를 많이 사용해야 하므로 비용의 낭비가 많다. 따라서 우선 연관 사상 기법으로 해당 페이지를 찾고, 페이지가 존재하지 않으면 직접 사상 기법으로 검색하여 사용하는 방법              저렴한 비용으로 캐쉬나 연관 기억 장치의 장점을 이용하는 방식       국부성에 근거하여 최근에 가장 많이 참조된 페이지만 유지          ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-memory-strategy/",
        "teaser": null
      },{
        "title": "[운영체제/OS] 디스크 관리",
        "excerpt":"디스크 구조              Track(트랙)  디스크의 회전축을 중심으로 데이터가 기록되는 동심원으로 디스크의 종류마다 개수가 다르다            Sector(섹터)  하나의 트랙을 몇 개로 분할한 블록으로 한 개의 섹터는 보통 512~1024Byte 용량으로 기록할 수 있다. 데이터를 기록하는 단위를 클러스터라고 하며 1개 또는 여러 개의 섹터로 구성된다            IPL(Initial Program Loader)  디스크 드라이브가 디스크에 접근할 때 디스크의 물리적인 정보를 제공하는 것으로 보통 부트 섹터라고 한다.       이 섹터에는 다음의 정보를 가진다             부팅 시스템의 위치       제작사 명칭       버전       섹터 당 바이트 수       클러스터 당 섹터 수       FAT의 수       FAT에 할당된 섹터 수       디스크면 수 등                FAT(File Allocation Table)  사용자가 해당 블록의 포인트를 실수로 지워지게 하는 것을 예방하고 블록 접근을 빠르게 하기 위하여 포인터를 모아 놓은 곳으로 디스크 데이터 영역에 위치를 1:1로 사상한 정보들을 갖고 있다       보통 2개 이상의 복사본을 갖고 있으며, 디스크에 문제가 발생하면 언제든지 복사본을 이용해 복구            Directory  디스크에 저장된 파일의 기본적인 정보를 수록하는 공간으로 다음 정보를 가진다             파일명       파일 속성       작성 날짜       작성 시간       파일 위치       파일의 크기           디스크 접근 시간              탐색 시간(Seek Time)  디스크 상의 원하는 데이터를 액세스하기 위해 트랙 또는 실린더에 헤드를 위치시키는데 소요되는 시간을 의미            회전 지연 시간(Latency Time, Rotational Delay, RPM 지연 시간)  지정된 트랙에 위치한 헤드가 원하는 섹터에 도달하는데 소요되는 시간            전송 시간(Transmission Time)  디스크로부터 주기억 장치로 데이터가 이동하는 시간       디스크 스케줄링  디스크에 존재하는 파일의 데이터들은 연속되지 않은 많은 섹터에 저장되어 있다. 물리적으로 회적하는 디스크에서 어떻게 하면 신속하게 많은 양의 데이터를 가져오느냐를 운영체제는 고민하고 계획하는 과정을 의미   디스크는 한쪽 방향으로 회전시키면서 사용해야 기계적인 부담이 없다. 회전 지연 시간이 빠르다해서 디스크를 양쪽 방향으로 회전시킨다면 디스크 드라이브는 오래 사용할 수 없을 것이다.   해당 섹터에서 데이터를 주기적 장치로 가져오는 전송 시간은 CPU의 성능과 관계가 있으므로 스케줄링의 영향을 받지 못한다. 따라서 디스크 상의 원하는 데이터를 액세스하기 위해 트랙 또는 실린더에 헤드를 위치시키는데 걸리는 탐색 시간을 중심으로 스케줄링을 수행한다.      목적            처리량을 최대화       응답 시간을 최소화       응답 시간의 편차를 최소화           디스크 스케줄링 종류  FCFS(First Come First Served, FIFO)  가장 간단한 스케줄링 형태로 대기 큐에 들어온 작업에 CPU를 할당하는 기법      도착 순서에 따라 실행 순서가 고정된다는 점에서 공평하다   요청한 순서대로 진행하기 때문에 순서가 변경되는 일이 없다   디스크의 부하가 적을 때 유리   디스크의 부하가 커지면 응답 시간이 길어진다   탐색 시간을 최적화하려는 시도가 없다   SSTF(Shortest Seek Time First)      헤드의 탐색 거리가 가장 짧은 요청을 먼저 서비스하는 방식      가운데 트랙이 안쪽이나 바깥쪽보다 서비스받을 확률이 높다   헤드에서 멀리 떨어진 요청은 기아 상태가 발생할 수 있다   FCFS보다 처리량이 많고 평균 응답 시간이 짧다   처리량이 많기 때문에 일괄 처리에 적합   응답 시간의 편차가 크기 때문에 대화형 시스템에는 부적합   SCAN      SSTF의 문제점인 응답 시간의 편차를 극복하기 위해 Denning이 개발한 방법으로 헤드가 디스크 표면을 양방향(안쪽/바깥쪽)으로 이동하면서 I/O 요청을 서비스. 이 때 헤드는 이동하는 방향의 앞쪽에 I/O 요청이 없을 경우에만 후퇴가 가능하다      진행 방향상의 가장 짧은 거리에 있는 요청을 먼저 수행   진행 방향으로 끝까지 진행   부하가 적은 경우 가장 좋은 결과   C-SCAN      SCAN의 문제점인 안쪽과 바깥쪽의 차별 대우를 모두 없애기 위해 항상 바깥쪽 실린더에서 안쪽으로 움직이면서 가장 짧은 탐색 시간을 가진 요청을 우선 서비스   헤드는 트랙의 안쪽으로 한방향으로만 이동하며 안쪽에 더 이상 I/O 요청이 없으면 다시 바깥쪽에서 안쪽으로 이동하면서 I/O 요청을 서비스한다      안쪽 방향으로 끝까지 진행   응답 시간의 편차가 매우 작다   부하가 많을 경우 C-SCAN 기법이 가장 좋은 결과를 가진다   LOOK / C-LOOK      SCAN과 C-SCAN은 헤드를 디스크의 끝까지 이동한다. 요청이 없는 경우에도 끝까지 진행한다는 것은 시간 낭비이다.   따라서 헤드는 각 방향으로 요청에 따르는 거리만큼을 이동하고, 현재 방향에서 더 이상의 요청이 없다면 헤드의 이동 방향이 바뀌는 방법이 효과적이다   SCAN, C-SCAN에서 이런 형태를 추가한 것이 LOOK, C-LOOK이다. 진행 방향에 더 이상의 요청이 있는지를 확인한다는 의미로 “LOOK“이란 단어를 사용하였다. 엘리베이터 운행 방식과 동일하여 엘리베이터 스케줄링이라고도 한다   N-Step SCAN  어떤 방향의 진행이 시작될 당시 대기 중이던 요청들만 서비스하고, 진행 도중 도착한 요청들은 한데 모아서 다음 진행 때 최적으로 서비스할 수 있도록 배열된다.   대기 중에 있는 요청들을 1차적으로 받아서 진행시키고, 진행을 시작하고 들어온 요청은 받아들이지 않는다. 진행이 모두 끝나고 난 후에 2차적으로 서비스한다   Eschenbach(에센바흐)  부하가 매우 큰 항공 예약 시스템을 위해 개발되었으며 탐색 시간뿐만 아니라 회전 지연 시간의 최적화를 위해 개발된 기법   헤드는 C-SCAN처럼 움직이며 예외적으로 모든 실런더는 그 실린더에 요청이 있거나 없어도 전체 트랙이 한 바퀴 회전할 동안의 서비스를 받는다. 탐색 시간, 회전 지연 시간을 모두 고려해서 개발된 스케줄링이나 디스크 드라이브의 물리적인 성질 때문에 오히려 응답시간이 늘어나서 거의 사용하지 않는 기법   Sector Queuing, SLTF(Shortest Latency Time First)  탐색 시간과 회전 지연 시간을 줄이는 스케줄링.   회전 지연 시간을 최적화하기 위한 스케줄링 기법은 탐색 시간이 필요하지 않는 고정 헤드 디스크 시스템이나 트랙마다 헤드를 갖는 드럼 등의 보조 기억 장치에서 사용  ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-disk-management/",
        "teaser": null
      },{
        "title": "[운영체제/OS] 파일 시스템",
        "excerpt":"파일 시스템  컴퓨터 시스템의 편리한 사용을 위해 정보를 저장하고 관리하는 시스템   저장 장치의 물리적인 특성을 고려하여 논리적으로 저장하고 사용하는 체계   컴퓨터에서 사용되는 파일들을 다루는 운영체제의 파일 관리 체계      성능 판단 요소            소멸성(Volatility) - 파일의 추가나 삭제의 빈도수       활성율(Activity) - 주어진 시간에 접근한 파일 레코드의 백분율       크기(Size) - 저장된 정보의 양                  파일 시스템 요구사항            대량의 정보를 파일로 저장할 수 있어야 한다       파일로 저장된 정보가 사용 중에 파괴되어서는 안 된다       하나 이상의 프로세스가 공동으로 사용할 수 있어야 한다                  파일 시스템 기능            사용자가 파일을 생성, 변경, 제거할 수 있다       파일 간의 정보 전송을 할 수 있어야 한다       파일을 공유한다       여러 종류의 접근 제어 방법을 제공       다양한 응용 처리 수행       백업 및 복구 수행       사용자가 물리적 이름을 사용하는 대신 기호형 이름을 사용하여 자신의 파일을 참조할 수 있도록 장치 독립성 제공           파일 구조  순차 접근 파일(Sequential Access File)      입력되는 데이터의 논리적인 순서에 따라 물리적으로 연속적인 위치에 기록하는 파일 방식      저장 매체의 효율이 높다   물리적으로 연속적인 저장이 되기 때문에 접근 시간이 가장 빠르다   특정한 데이터를 검색하는데 비교 횟수가 많아지므로 검색 시간이 느리다   저장 정보를 따로 구성하지 않아도 되므로 공간의 낭비가 없다   구현이 쉽기 때문에 어떤 매체라도 쉽게 사용 가능   대화식 처리보다 일괄 처리에 적합   순차 파일은 테이프를 모형화한 것이다   직접 접근 파일(Direct Access File)  데이터 내의 키 필드를 해싱 사상 함수에 의해 물리적인 주소로 변환하여 데이터를 기록하거나 검색하는 방식의 파일      DASD(Direct Access Storage Device)의 물리적 주소를 통하여 직접 액세스   특정 레코드를 검색하기 위하여 키와 보조 기억 장치 사이의 물리적인 주소로 변환할 수 있는 사상 함수(Mapping Function)가 필요   해싱 사상 함수를 사용하므로 검색 속도가 가장 빠르다   한 번 파일을 개방하면 읽거나 쓰기를 자유롭게 가능   어떤 레코드라도 평균 접근 시간 내에 접근 가능   키 변환법에 따라 공간의 낭비를 초래할 수 있다   일반적으로 디스크 기억 장치에 많이 사용   색인 순차 접근 파일(ISAM, Indexed Sequential Access File)      순차 파일과 직접 파일에서 지원하는 편성 방법이 결합된 형태로 순차 처리와 직접 처리가 모두 가능한 방식      디스크 기억 장치에 많이 이용   각 레코드는 레코드 키 값에 따라 논리적으로 배열   시스템은 각 레코드의 실제 주소가 저장된 인덱스를 관리한다   순차 접근과 직접 접근을 병행할 수 있기 때문에 융통성이 우수   레코드를 추가 및 삽입하는 경우, 파일 전체를 복사할 필요가 없다   실제 데이터 처리 외에 인덱스를 처리하는 추가적인 시간이 소모되므로 파일 처리 속도가 느리다   인덱스를 저장하기 위한 공간과 오버플로 처리를 위한 별도의 공간이 필요하므로 기억 공간의 낭비가 있다   파일을 구성하는 블록의 번호는 절대 블록 번호여야 사용자가 자신의 파일이 아닌 부분에 접근하는 것을 방지할 수 있다   파일이 정렬되어 있어야 하므로 추가, 삭제가 많으면 효율이 낮아진다   삽입, 삭제가 많아지면 파일에 대한 재편성이 이뤄져야 한다       인덱스와 순차 데이터 파일을 구성하는 방법에 따라 정적 인덱스 방법과 동적 인덱스 방법으로 구분되며, 탐색 횟수를 줄이기 위해서 다단계 인덱스를 사용      ISAM(Index Sequential Access Method)  데이터 파일에 레코드가 삽입되거나 삭제될 때 인덱스의 내용은 변하지만 인덱스 구조 자체는 변경되지 않는 방법으로 정적 인덱스 방법이라고도 한다            기본 데이터 구역(Prime Data Area) : 실제 데이터가 기록된 구역       3단계 색인 구역(Index Area)                    Master Index : 실린더 색인 구역의 정보가 많을 경우 그것을 일정한 크기의 블록으로 구성하는데 이 때 해당 레코드가 어느 실린더 색인 구역에 기록되어 있는 지를 기록하는 색인           Cylinder Index : 각 트랙 색인의 최대키 값과 해당 레코드가 기록된 실린더의 정보가 기록되는 색인으로 한 파일당 한 개씩 만들어진다           Track Index : 처리할 레코드가 실제로 어느 트랙에 기록되어 있는지를 판별하는 구역                       오버플로 구역(Overflow Area)                    Cylinder Overflow : 각 실린더마다 만들어지는 오버플로 구역으로 해당 실린더의 기본 구역에서 오버플로된 데이터를 기록           Independent Overflow : 실린더 오버플로 구역에 더 이상 오버플로된 데이터를 기록할 수 없을 때 사용할 수 있는 예비 공간으로 실린더 오버플로 구역과는 별도로 만들어진다                           VSAM(Virtual Storage Access Method)  인덱스나 데이터 파일을 블록으로 구성하고 각 블록에는 추가로 삽입될 레코드를 감안하여 빈 공간을 미리 예비해두는 방법으로 동적 인덱스 방법이라고도 한다            제어 구간(Control Interval) : 데이터 레코드가 저장되는 부분       제어 구역(Control Area) : 몇 개의 제어 구간을 모아 놓은 구역       순차 세트(Sequence Set) : 제어 구역에 대한 인덱스를 저장하는 구역       인덱스 세트(Index Set) : 순차 세트의 상위 요소           파일 제어 블록(FCB, File Control Block, File Descriptor)  파일을 관리하기 위해 운영체제가 필요로 하는 정보를 갖고 있는 제어 블록으로 파일마다 독립적으로 갖고 있다. 프로세스가 필요에 따라 파일을 Open하면 FCB의 항목은 주기억 장치로 옮겨진다. FCB는 운영체제 시스템에 따라 다른 자료 구조를 가질 수 있다      파일명   보조 기억 장치의 파일 위치   파일의 구조   보조 기억 장치 유형   접근 제어 정보   파일 유형   제거 시기   생성 날짜, 시간   제거 날짜   최종 수정 날짜   접근 횟수   파일의 디스크 공간 할당과 회수  파일의 데이터를 디스크에 물리적으로 저장하고 삭제하는 방법을 의미   연속 블록 할당(Contiguous Block Allocation)      물리적으로 연속적인 공간에 저장되고 저장할 크기를 미리 지정하는 방식으로 파일마다 크기가 다르고 추가, 삭제가 빈번히 발생할 경우에 단편화 현상이 많이 발생한다.   따라서 디스크 활용을 최대화하기 위한 통합, 집약, Garbage Collection 필요      파일의 크기보다 큰 연속 공간이 없을 경우에는 파일을 생성할 수 없다   다중 프로그래밍에 적용하기 어렵다   가상 기억 장치를 응용하여 사용할 수 없다   용적률이 줄어든다   불연속 블록 할당(링크 블록 할당)      디스크 공간을 일정한 길이를 갖는 단위(섹터/블록)로 나누어 할당하는 기법. 분할된 영역은 독립적으로 취급되며 파일의 데이터들은 분할된 영역에 순차적, 분산적으로 저장할 수 있는 방법이다. 분할 저장된 파일의 각 데이터들은 파일 Open 시에 연결된 정보를 이용해 사용된다.   실제 데이터를 저장하는 공간 외에 분할된 정보와 파일의 연결된 데이터 정보를 저장해야 하는 영역이 필요하므로 부가적인 저장 공간이 연속 블록 할당보다는 많이 사용되고 그에 따른 구현 방법도 복잡하다.           섹터 단위  디스크 섹터 단위로 파일의 데이터가 분산되어 저장되며 각 섹터는 연결 리스트 구조 형태로 연결. 파일의 크기가 커지면 비어있는 섹터를 사용하고 작아지면 사용하지 않은 섹터를 반납한다            블록 단위             블록 체인 기법 : 여러 개의 섹터를 묶은 블록을 체인처럼 연결한 방식       인덱스 블록 체인 기법 : 인덱스에 블록의 주소를 링크시켜 사용 - Unix       블록 단위 파일 사상 기법 : 파일 정보의 해당 블록을 사상시켜 연결하여 사용한다 - Windows, MS-DOS                  파일의 크기보다 큰 연속 공간이 없을 경우라도 파일을 생성할 수 있다   다중 프로그래밍에 유용하게 사용   가상 기억 장치를 응용하여 사용   용적률이 좋아진다   액세스 시간이 증가한다   디렉터리  파일 시스템 내부에 있는 기능으로 디스크 내에 존재하는 많은 파일을 쉽게 사용(저장/검색/관리)할 수 있도록 하는 조직화된 기법   단(일) 단계 디렉터리         디렉터리 시스템에 보관된 모든 파일의 정보를 포함해야 한다   파일이 같은 디렉터리 내에 있어야 하므로 유일한 파일명으로 작성해야 한다   파일명의 길이를 제한한다   2 단계 디렉터리         중앙에 마스터 디렉터리가 존재하며 그 아래 사용자 디렉터리가 있는 구조   다른 사용자와의 파일 공유가 어렵다   파일명의 길이가 길어 사용하기 매우 어렵다   2단계 이상으로 깊어지면 트리 구조 디렉터리가 된다   트리 구조 디렉터리         하나의 루트 디렉터리와 여러 개의 부 디렉터리로 구성   부 디렉터리는 그 하위로 또 다른 디렉터리를 구성할 수 있다   각 디렉터리의 생성과 파괴가 용이   동일한 이름의 여러 디렉터리 생성이 가능   Unix, MS-DOS, Windows 운영체제에서 사용   비순환(주기) 그래프 디렉터리         기본적으로 트리 구조와 유사하나 사이클을 허용하지 않는다   하나의 파일이나 디렉터리를 상위 디렉터리에서 공유할 수 없다   링크 수만큼 파일을 공유하고 있으며 링크 수가 0이면 완전히 제거할 수 있다   하나의 파일을 여러 사용자가 공유하기 때문에 삭제 시 문제점이 많이 발생   융통성이 있으며 기억 공간을 절약할 수 있으나 복잡하다   공용된 파일이나 디렉터리는 물리적으로 한 개만 존재한다   하나의 파일이 다수의 이름으로 존재할 수 있다   공유하고 있는 파일 제거 시 Dangling Pointer(사용할 수 없는 해제된 주소를 가리키는 것)가 발생할 수 있다   Unix 운영체제에서 사용   일반 그래프 디렉터리         사이클을 인정하므로 파일 접근이 용이하다   그래프 탐색 알고리즘이 간단   하나의 파일이나 디렉터리를 상위 디렉터리에서 공용할 수 있다   상위 파일이나 디렉터리를 자신의 파일이나 하위 디렉터리로 구성할 수 있다   파일을 제거하기 위한 Garbage-Collection을 위한 참조 계수기가 필요  ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-file-system/",
        "teaser": null
      },{
        "title": "[운영체제/OS] 컴퓨터 시스템",
        "excerpt":"컴퓨터 시스템 구조   SISD(Single Instruction Single Data)  단일 처리기 컴퓨터로서 한 번에 한 명령어만 처리      1명의 사용자가 1개의 CPU를 사용한다   다수의 기계어 명령들이 동시에 서로 다른 단계에서 수행할 수 있게 하는 파이프라인 기법에 응용할 수 있다   SIMD(Single Instruction Multiple Data)  다중 처리기 컴퓨터로서 한 번에 한 명령어만을 처리      1명의 사용자가 여러 개의 CPU를 사용   슈퍼 컴퓨터, 과학 기술용 컴퓨터 급 수준   어레이 처리 기법에 응용할 수 있다   MISD(Multiple Instruction Single Data)  단일 처리기 컴퓨터로서 한 번에 여러 개의 명령어를 처리      여러 명의 사용자가 1개의 CPU를 사용   MIMD(Multiple Instruction Multiple Data)  다중 처리기 컴퓨터로서 한 번에 여러 개의 명령어를 처리      여러 명의 사용자가 여러 개의 CPU를 사용   일반적으로 다중 처리기 혹은 다중 컴퓨터라고도 한다   다중 처리기(Multi-Processor)  여러 개의 CPU가 하나의 메모리를 공유하는 형태로 CPU 끼리의 결합력이 강하며, 병렬 처리에 적합한 컴퓨터 시스템 구조      강 결합(Tightly-Coupled) 시스템   전송 지연이 짧고 데이터 처리율이 높다   프로세스간 통신은 공유 메모리를 통해 이루어진다   공유 메모리를 차지하려는 프로세스 간의 경쟁이 발생   기억 장소가 하나이므로 운영체제도 종속적으로 사용   모든 CPU는 하나의 운영체제에서 통제되는 대칭적인 구조   다중 컴퓨터(Multi-Computer)  여러 개의 CPU가 자신만의 독립적인 메모리를 사용하는 형태로 CPU 끼리 결합력이 약하며, 분산 처리에 적합한 컴퓨터 시스템 구조      약 결합(Loosely-Coupled) 시스템   전송 지연이 길고 데이터 처리율이 낮다   프로세스 간의 통신은 통신망에 메시지 전달로 통신 가능   구성 요소의 추가 또는 삭제가 용이   기억 장소가 CPU와 독립적으로 사용되므로 운영체제도 독립적으로 사용하는 분리 수행 구조   MIMD의 위상에 따른 분류     다중 처리기의 위상            버스형                교환형                       크로스바 교환 행렬 (a)           오메가 교환 행렬 (b)                           다중 컴퓨터의 위상            버스형                교환형                       그리드 교환형 (a)           하이퍼 큐브 교환형 (b)                           다중 처리기와 운영체제 구성  주/종 프로세서 구조  하나의 컴퓨터 시스템에 두 개의 프로세서가 있을 경우 입출력과 연산을 각각 독립적으로 수행하지 않고 주 프로세서는 입출력과 연산, 종 프로세서는 연산을 일부 담당하게 한다.   주 프로세서가 중단되면 시스템이 중지되지만 종 프로세서가 중단되면 컴퓨터 시스템은 계속 동작할 수 있다      주 프로세서만이 운영체제를 수행   종 프로세서는 사용자 프로그램만을 수행   분리 수행(개별적 관리자, Separate-Excution)  각 프로세서가 독립적인 운영체제를 가진다      각 프로세서에서 발생하는 인터럽트도 해당 프로세스에서 독립적으로 수행   각 프로세서는 자신만의 파일과 입출력 장치를 제어   프로세서가 독립적이므로 프로세서에 따라 유휴 상태이거나 매우 바쁠 수 있다   한 프로세서의 고장으로 전 시스템이 중지되지 않으므로 신뢰성이 우수   대칭적(Symmetric) 구조  여러 프로세서가 하나의 운영체제에서 동시에 운영      가장 강력한 시스템이나 매우 복잡한 구조   운영체제는 동등한 프로세서의 Pool(프로세서 정보 테이블)을 가진다   하나의 프로세서가 중단되면 능력이 다소 낮아지지만 중단 없이 계속 진행   프로세서의 수를 늘린다고 해도 시스템 효율은 향상되지 않는다   분산 운영체제  각 호스트에 고유한 운영체제가 있는 것이 아니라 전체 네트워크에 공통적으로 단일 운영체제가 실행되는 시스템으로 원격에 있는 자원을 마치 지역 자원인 것처럼 쉽게 접근하여 사용할 수 있는 방식   분산 운영체제의 목적          자원 공유의 증대성  각 시스템이 통신망을 통해 연결되어 있으므로 유용한 자원을 공유하여 사용할 수 있다            연산 속도의 향상  하나의 일을 여러 시스템에 분산하여 처리하기 때문에 연산 속도가 향상된다            신뢰성 향상  하나의 시스템에 오류가 발생하더라도 다른 시스템은 계속 작업을 수행할 수 있기 때문에 신뢰도가 향상된다            컴퓨터 통신  지리적으로 떨어진 시스템에 통신망을 두어 정보를 교환할 수 있다       분산 운영체제의 장점     CPU의 처리 능력 한계를 극복할 수 있다   CPU의 처리 능력을 한 단계 높이려면 현재 가격의 제곱만큼 비싸다. 따라서 처리 속도가 낮은 여러 개의 CPU를 연결하여 처리 속도를 향상시킬 수 있기 때문에 경제적   반응 시간이 빠르면 계산 능력, 처리량, 신뢰성, 가용성 모두 향상   특정한 시스템의 병목 현상을 제거하기 위해 필요한 자원을 추가할 수 있으므로 확장성이 우수   부하를 균등하게 배분할 수 있어 처리 효율이 향상   다수의 사용자가 데이터를 공유할 수 있으며 통신이 용이   분산 운영체제의 단점     여러 개의 컴퓨터 시스템이 연결되어 있으므로 보안이 매우 취약   여러 개의 컴퓨터를 하나의 컴퓨터처럼 운영해야 하므로 소프트웨어 개발이 매우 어렵다   적응성이 하나의 CPU를 사용할 때보다는 떨어진다   에러 발생 시 원인 파악이 힘들다   분산 운영체제의 결함     링크 결함 - 두 개의 사이트 간에 연결이 잘못되어 발생하는 결함   사이트 결함 - 사이트 자체에서 발생할 수 있는 결함   메시지의 분실 - 통신 회선을 통해 해당 사이트로 메시지가 전달되는 과정에서 시간 지연이나 다른 이유로 메시지를 잃어버리는 결함   분산 운영체제의 위상  성형 연결(Star Connected) 구조  각 노드가 점 대 점 형태로 중앙 컴퓨터에 연결되고 중앙 컴퓨터를 경유한다      제어가 집중되고 모든 동작이 중앙 컴퓨터에 의해 감시   중앙 컴퓨터에 과부하가 걸리면 성능이 현저히 감소   중앙 컴퓨터에 장애가 발생되면 전체 시스템 마비   한 노드의 고장은 다른 노드에 영향을 주지 않는다   터미널의 증가에 따라 통신 회선 수도 증가   최소 두 개의 노드만 사용할 수 있으므로 통신 비용이 저렴   환형 연결(Ring Connected) 구조  각 사이트는 정확히 다른 두 사이트와 물리적으로 연결되어 있는 구조      정보 전달 방향은 단방향 혹은 양방향일 수 있다   기본 비용은 사이트의 수에 비례   메시지가 링을 순환할 경우 통신 비용은 증가   근거리 네트워크 구조로 가장 많이 채택   다중 접근 버스 연결(Multi-access Bus Connected) 구조  공유되는 하나의 버스가 시스템 내의 모든 노드와 연결되어 있는 구조      한 사이트의 고장은 나머지 사이트들 간의 통신에 아무런 영향을 주지 않는다   버스에 이상이 생기면 전체 시스템이 마비   한 시점에 단지 하나의 전송만이 가능   처리기나 기타 장치의 증설 절차가 단순   버스의 사용을 위한 경쟁 상태가 발생하여 시스템 성능의 심각한 저해를 가져올 수 있다   시스템의 전체 통신량이 전송률에 의한 제한을 받는다   완전 연결(Fully Connected) 구조  네트워크의 각 사이트는 시스템 내의 다른 모든 사이트와 직접 연결된 구조      기본 비용이 매우 높다   사이트 간의 메시지는 매우 빠르게 전달 가능   하나의 링크가 고장나도 다른 링크를 이용할 수 있으므로 신뢰성이 우수   부분 연결(Partially Connected) 구조  시스템 내의 사이트 간에만 부분적으로 연결된 구조      기본 비용이 완전 연결보다는 낮다   메시지 전달이 중간 사이트를 경유할 수 있으므로 늦어질 수 있다   완전 연결에 비해 신뢰성이 낮다   계층 연결(Hierarchy Connected) 구조  사이트들이 트리 형태로 구성된 구조      루트 사이트와 서브 사이트가 존재   루트 사이트를 제외한 다른 사이트는 하나의 부모 사이트와 여러 개의 자식 사이트를 갖는다   마지막 사이트를 제외한 사이트의 고장은 자식 사이트의 중단을 초래   분산 운영체제의 투명성(Transparency)  네트워크 상에 분산된 컴퓨팅 자원을 여러 다른 컴퓨터에서 이용하는 기술로써 중앙집중형과 달리 네트워크 상에 여러 컴퓨팅 플랫폼에 프로세스를 분산시키고, 분산된 프로세스를 논리적으로 마치 하나의 프로세스처럼 수행하도록 하는 기술           위치 투명성  사용자가 원하는 파일이나 데이터베이스, 프린터 등의 자원들이 지역 컴퓨터 또는 네트워크 내의 다른 원격지 컴퓨터에 존재하더라도 위치에 관계없이 그의 사용을 보장            이주 투명성  자원들이 이동하여도 사용자는 자원의 이름이나 위치를 고려할 필요가 없다            복제 투명성  사용자에게 통보없이 파일들과 자원들의 부가적인 복사를 자유롭게 할 수 있다            병행(동시) 투명성  다중 사용자들이 자원을 자동으로 공유할 수 있다            병렬 투명성  몇 개의 처리기가 사용되는지 알 필요가 없다            접근 투명성  각 프로세서의 로그인처럼 지역이나 원격 자원에 접근할 수 있다            성능 투명성  여러 부하에 대해 성능을 증가시키기 위해 시스템을 재구성할 수 있다            규모 투명성  시스템이나 응용프로그램이 시스템 구조나 응용 알고리즘에 대한 변경없이 규모에 따라 확장이 가능하다            고장 투명성  분산 시스템 내의 구성요소(트랜잭션, DBMS, 네트워크, 컴퓨터)가 장애를 발생시켜도 영속성을 제공할 수 있다       스레드(Thread)  어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다. 이러한 실행 방식을 멀티스레드(Multithread)라고 한다.   스레드는 순차적 실행과 프로세스 상태 전이의 병렬성을 접속하기 위해 개발되었다. 다중 프로그래밍 기법에서 여러 개의 프로세스는 하나의 시스템을 공유한다.      단일 프로세스를 다수의 스레드로 생성하여 병행성을 증진시킬 수 있다   실행 환경을 공유시켜 기억 장소의 낭비가 줄어든다   프로세스의 생성이나 문맥 교환 등의 오버헤드를 줄여 운영체제의 성능을 향상   프로세스 내부에 포함되는 스레드는 공통적으로 접근 가능한 기억 장치를 통해 효율적으로 통신   스레드를 사용하면 하드웨어, 운영체제의 성능과 응용프로그램의 처리율을 향상시클 수 있다   하나의 프로세스에 여러 개의 스레드가 존재   스레드는 동일 프로세스 환경에서 서로 독립적인 다중 수행이 가능하다   스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당한다   생성된 프로세스가 자신을 생성한 프로세스의 텍스트와 데이터 영역을 그대로 공유하고 스택만 따로 갖는 새로운 프로세스 모델이다   커널/사용자 수준의 스레드                  사용자 수준       커널 수준                       - 커널 개입이 작다 - 런 타임 시스템이 필요하다 - 속도가 빠르다 - 문맥 교환이 적다 - 독자적 알고리즘이 필요 - 대형 시스템에 적당 - 구현이 어렵다 - 커널을 스스로 호출하지 못한다 - CPU 사용을 해제하지 못하면 시스템이 중단       - 커널 개입이 크다 - 런 타임 시스템이 필요없고 커널이 직접한다 - 속도가 느리다 - 문맥 교환이 많다 - 독자적 알고리즘이 필요 없다 - 대형 시스템에 부적합 - 구현이 쉽다 - 커널을 스스로 호출한다 - CPU 사용을 해제하지 못하면 운영체제가 지원한다          ","categories": ["study"],
        "tags": ["OS"],
        "url": "https://many258.github.io/study/os-computer-system/",
        "teaser": null
      },{
        "title": "[전자계산기] 논리 회로",
        "excerpt":"불 대수  논리 회로를 분석하고 수학적으로 그 연산을 표현하고자 사용하는 대수식으로 논리 대수라고도 한다      논리 변수 사이의 진리표를 대수 형식으로 표시   논리 변수를 조작하여 주어진 회로 기능을 수행하는데 있어 가장 간단한 회로를 결정하고자 사용   불 대수의 모든 변수는 0과 1의 값을 가질 수 있다   논리 회로의 입출력 관계를 대수 형식으로 표시          불 대수의 연산            논리 부정(NOT, ￣ 또는 ＇)       논리곱(AND, · )       논리합(OR, + )                          A + A = A       A · A = A       A · 0 = 0       A + 0 = A                 A + 1 = 1       A · 1 = A       0 + 0 = 0       0 · 0 = 0                 1 + 0 = 1       1 · 0 = 0       1 + 1 = 1       1 · 1 = 1                 A + A·B = A       A·(A + B) = A                           논리 게이트  논리 회로를 구성하는 기본 소자, 2진 정보를 취급하는 기본 논리 회로                     이름       의미                       AND       입력 값이 모두 1일 때만 1 출력                 OR       입력 값이 모두 0일 때만 0 출력                 NOT       입력 값이 0이면 1을 출력하고 1이면 0을 출력                 NAND       입력 값이 모두 1일 때만 0 출력                 NOR       입력 값이 모두 0일 때만 1 출력                 XOR       A, B 입력 값이 서로 다를 때는 1 출력, 같을 때는 0 출력                 XNOR       A, B 입력 값이 서로 같을 때는 1 출력, 같을 때는 1 출력           결선 게이트  필요할 때 게이트의 선을 연결하고, 단절하고 조절함으로써 다양한 기능을 할 수 있도록 만든 게이트를 의미      게이트들의 출력 단자를 논리적으로 직접 연결하여 논리 기능을 발휘할 수 있도록 했다   회로 비용을 절감할 수 있다   하나의 인쇄기판보다 많은 논리 기능을 포함시킬 수 있다   Open Collector TTL(Transistor-Transistor Logic)로 게이트들의 출력 단자를 묶어서 사용한다   불 대수에 의한 최소화           최소항 : 진리표상에서 결과가 1인 부분을 표시할 때 사용하는 방식으로 불식을 형성하는 입력 변수 모두를 포함하는 논리곱(·)으로 나타내는 경우를 의미            최대항 : 진리표상에서 결과가 0인 부분을 표시할 때 사용하는 방식으로 불식을 형성하는 입력 변수 모두를 포함하는 논리합(+)으로 나타내는 경우를 의미                      A   B       F       최소항       수치 표현                       0   0       1       A · B       0                 0   1       0       -       1                 1   0       1       A · B       2                 1   1       1       A · B       3           최소항의 합 표현은 위 표에서와 같이 결과가 1이 되는 부분만을 논리곱으로 표현하여 이 논리곱들을 논리합으로 연결하면 된다      최소항의 합 : F = A · B + A · B + A · B        수치 표현 : F(A, B) = A · B + A · B + A · B = $\\Sigma(0,2,3)$       불 대수식의 최소화  F = A · B + A · B + A · B  = B · (A + A) + A · B = B + A · B  = (B + A) · (B + B)  = B + A                  입력(A, B, C)       출력       최소항       수치 표현                       0 0 0       1       A · B · C       0                 0 0 1       0       -       1                 0 1 0       1       A · B · C       2                 0 1 1       0       -       3                 1 0 0       1       A · B · C       4                 1 0 1       0       -       5                 1 1 0       1       A · B · C       6                 1 1 1       0       -       7              최소항의 합 : Y = A·B·C + A·B·C + A·B·C + A·B·C   수치 표현 : Y(A, B, C) = $\\Sigma(0, 2, 4, 6)$   불 대수식의 최소화  Y = A·B·C + A·B·C + A·B·C + A·B·C  = A·C·(B+B) + A·C·(B+B)  = A·C + A·C  = C   카르노 맵(Karnaugh Map)에 의한 최소화     ","categories": ["study"],
        "tags": ["전자계산기"],
        "url": "https://many258.github.io/study/electronic-calculator-logic-circuit/",
        "teaser": null
      },{
        "title": "[전자계산기] 조합 논리 회로(Combinational Logic Circuit)",
        "excerpt":"조합 논리 회로  논리 게이트의 조합으로 만들어지는 회로로 현재의 입력에 의해서만 출력이 결정되는 회로를 의미   반가산기(Half Adder)      2개의 2진 입력 변수 A와 B를 더한 합 S(Sum)와 자리 올림 수 C(Carry)를 얻는 회로   하나의 AND 게이트와 XOR(eXclusive OR) 게이트를 조합해서 구성                  A       B       S       C                       0       0       0       0                 0       1       1       0                 1       0       1       0                 1       1       0       1              합(Sum) : S = A·B + A·B = A ⊕ B  캐리(Carry) : C = A · B    반감산기(Half Subtracter)      2개의 2진 입력 변수 X에서 Y를 뺀 차 D와 빌려온 수(자리 내림 수) B를 얻는 회로   하나의 NOT 게이트 및 AND 게이트와 XOR 게이트를 조합해서 구성                  X       Y       D       B                       0       0       0       0                 0       1       1       1                 1       0       1       0                 1       1       0       0              차(Difference) : D = X·Y + X·Y  = X ⊕ Y  빌려온 수(자리 내림, Borrow) : B = X · Y    전가산기(Full Adder)      2진수 가산을 완전히 하기 위하여 아래 자리로부터 자리 올림된 수도 고려하여 3개의 2진수를 더할 수 있게 만든 회로   반가산기 2개와 OR 게이트 1개를 연결하여 구성                  A       B       C       S       C0                       0       0       0       0       0                 0       0       1       1       0                 0       1       0       1       0                 0       1       1       0       1                 1       0       0       1       0                 1       0       1       0       1                 1       1       0       0       1                 1       1       1       1       1              합(Sum) : S = A⊕B⊕C  캐리(Carry) : C0 = (A⊕B)·C + A·B = A·B + B·C + A·C    전감산기(Full Subtracter)      2진수 감산을 완전히 하기 위하여 아래 자리로부터 자리 내림수도 고려하여 3개의 2진수를 감산할 수 있게 만든 회로   반감산기 2개와 OR 게이트 1개를 연결하여 구성                  X       Y       B       D       B1                       0       0       0       0       0                 0       0       1       1       1                 0       1       0       1       1                 0       1       1       0       1                 1       0       0       1       0                 1       0       1       0       0                 1       1       0       0       0                 1       1       1       1       1              차(Difference) : D = X⊕Y⊕B  빌려온 수(Borrow) : B1 = (X⊕Y)·B + X·Y    병렬 가산기(Parallel Adder)  여러 비트를 가산하기 위한 회로   반가산기 또는 전가산기를 여러 개 합쳐서 만들어진다     전가산기로 구성하여 N비트 병렬 가산기를 만들 경우  N개의 전가산기 필요   반가산기로 구성하여 N비트 병렬 가산기를 만들 경우  (2N-1)개의 반가산기와 (N-1)개의 OR 게이트 필요      디코더(Decoder)      컴퓨터 내부에서 2진수로 코드화된 데이터를 해독하여 대응되는 한 개의 신호로 바꿔주기 때문에 해독기라고도 한다  N개의 입력으로 최대 2N개의 출력을 얻을 수 있다  AND 게이트로 만들어진다                  A       B       D0       D1       D2       D3                       0       0       1       0       0       0                 0       1       0       1       0       0                 1       0       0       0       1       0                 1       1       0       0       0       1           인코더(Encoder)      입력 정보를 여러 자리의 2진수로 코드화하여 전달하는 회로  해독기와 정반대의 동작을 수행  2N개의 입력을 받아 N개를 출력                  입력       D0       D1       D2                       0       0       0       0                 1       1       1       1                 2       0       1       1                 3       1       0       1                 4       0       1       0                 5       1       0       0                 6       0       0       0                 7       1       1       1           멀티플렉서(Multiplexer)      2N개의 입력선에서 N개의 선택선을 가지고 하나의 출력을 얻도록 구성  여러 개의 입력 회선이 들어가서 하나의 특정 회선을 선택하도록 하므로 선택기라고도 한다  공통적인 버스 라인을 구성하는데 많이 사용                  S0       S1       Y선택 회선                       0       0       I0                 0       1       I1                 1       0       I2                 1       1       I3           디멀티플렉서(Demultiplexer)      하나의 입력 정보를 N개의 선택선을 가지고 2N개의 출력을 얻도록 구성  중앙 처리 장치에서 어떤 내용을 특정 장치로 출력시킬 때 많이 사용                  S0       S1       D0       D1       D2       D3                       0       0       I       0       0       0                 0       1       0       I       0       0                 1       0       0       0       I       0                 1       1       0       0       0       I           비교기(Comparator)  논리적으로 두 수를 비교한다면 ‘같다’, ‘같지 않다’만 판별하면 되므로 두 수 A, B를 XNOR 게이트로 연결하여 1이 얻어지면 ‘같다’고 판별할 수 있다   N비트 논리 비교기를 만들기 위해서는 XNOR 게이트 N개가 필요   3-상태 버퍼(Tri-State Buffer)  3가지 상태 중  1의 상태는 전기적으로 하이 레벨(H)  0의 상태는 로우 레벨(L)  또 다른 상태는 고 임피던스(회로가 끊어진 상태) 상태를 의미한다.   3-상태 버퍼 회로는 인에이블(1) 또는 디스에이블(0) 단자에 의하여 데이터의 전송 방향을 하드웨어적으로 제어하는 데 사용  ","categories": ["study"],
        "tags": ["전자계산기"],
        "url": "https://many258.github.io/study/electronic-calculator-combinational-logic/",
        "teaser": null
      },{
        "title": "[전자계산기] 순서 논리 회로(Sequential Logic Circuit)",
        "excerpt":"순서 논리 회로  기억 능력을 갖추면서 입력과 내부 상태의 조합에 의해 출력이 결정되는 회로   플립플롭이나 레지스터 장치로 구성된다   플립플롭(Flip-Flop)  순서 논리 회로를 구성하는 기본 기억 소자로 1비트를 기억할 수 있는 2진 Cell을 의미   RS 플립플롭      보통 NAND 게이트를 이용해서 구성   SET(S) 단자와 RESET(R) 단자를 갖으며, 모두 1인 경우는 허용되지 않는다   JK 플립플롭      RS 플립플롭에서 S와 R이 모두 1일 때 허용되지 않는 것을 보완해서 이것이 허용되도록 고안된 플립플롭   RS 플립플롭의 내부 상태와 입력 상태를 AND 게이트로 처리하여 입력하는 플립플롭   D 플립플롭      RS나 JK 플립플롭에서 서로 베타적인 경우만 이용되도록 고안된 플립플롭, 1비트 지연 소자로 사용된다  (S가 0이면 R은 1, S가 1이면 R은 0)   T 플립플롭      JK 플립플롭에서 J, K가 같은 값이 입력될 때만 이용할 수 있도록 고안된 플립플롭, 토글(Toggle) 기능을 이용하고자 할 때 사용된다 (J가 0이면 K는 0, J가 1이면 K는 1)   마스터 슬레이브(Master-Slave) 플립플롭      Race 현상을 해결하기 위해 고안된 플립플롭   Race 현상 : 출력이 입력에 피드백되어 플립플롭의 내부 상태가 변화되면 출력 상태가 변할 때 입력도 변하게 되므로 오동작이 발생하게 되는 현상   하나의 플립플롭(주 플립플롭)이 주인 역할을 하고, 다른 하나의 플립플롭(종 플립플롭)이 종속되어 동작하도록 두 개 이상의 플립플롭 회로를 결합한 것   주 플립플롭은 시간 펄스가 상승할 때 동작하고, 종 플립플롭은 시간 펄스가 하강할 때 동작   카운터(Counter)  시간 펄스의 수를 카운트하거나 제어 장치에서 각종 회로의 동작을 제어하는데 사용           리플 카운터(Ripple Counter)  가장 기본이 되는 비동기형(Asynchronous) 카운터. 플립플롭의 수를 n이라 할 때, 2n개까지의 독립된 수 전부를 표현            모드 카운터(MOD Counter)  N개의 서로 다른 출력상태를 갖는 카운터. N개의 서로 다른 출력상태를 나타낸 후 다시 원래의 상태로 복귀해 다시 N개의 출력상태를 반복       레지스터(Register)  연산에 사용될 데이터가 대기하거나 연산된 결과데이터가 임시적으로 대기           시프트 레지스터(Shift Register)  현재 레지스터에 있는 내용을 왼쪽이나 오른쪽의 연결된 플립플롭을 1비트씩 이동시켜 밀어내기와 같은 동작을 수행하는 레지스터            병렬 시프트 레지스터(Parallel Shift Register)  N개의 비트로 구성된 레지스터의 내용을 연결된 다른 레지스터로 한 번에 이동시킬 수 있는 레지스터      ","categories": ["study"],
        "tags": ["전자계산기"],
        "url": "https://many258.github.io/study/electronic-calculator-sequential-logic/",
        "teaser": null
      }]
