<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My LifeChronicle</title>
    <description>Be a Imagineer.</description>
    <link>https://many258.github.io/</link>
    <atom:link href="https://many258.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 13 May 2021 02:13:56 +0900</pubDate>
    <lastBuildDate>Thu, 13 May 2021 02:13:56 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>[전자계산기] 입출력 시스템</title>
        <description>&lt;h2 id=&quot;입출력-시스템&quot;&gt;입출력 시스템&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/input-output-architecture-diagram.png&quot; title=&quot;https://intelligenceofcoa.wordpress.com/2013/12/17/continue-i-o-module/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/input-output-architecture-diagram.png&quot; alt=&quot;&quot; title=&quot;입출력 시스템 다이어그램&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;구성-요소&quot;&gt;구성 요소&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;입출력 제어기(I/O Controller)&lt;/strong&gt;&lt;br /&gt;
입출력 장치의 &lt;strong&gt;공통적인 기능&lt;/strong&gt;을 다루는 제어기.&lt;/p&gt;

    &lt;p&gt;데이터 버퍼링, 제어 신호의 논리적/물리적 변환, 통신 회선 확보, 상태 정보 저장, 주기억 장치 접근, 데이터 교환, 입출력 완료 보고 등의 기능 수행&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;DMA 제어기&lt;/strong&gt;, &lt;strong&gt;채널 제어기&lt;/strong&gt;, &lt;strong&gt;입출력 프로세서&lt;/strong&gt;, 입출력 컴퓨터 등이 여기에 속한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;입출력 버스(I/O Bus)&lt;/strong&gt;
주기억 장치와 입출력 장치 사시에 정보 교환을 위하여 마련되어 있는 통신 회선을 의미&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;주소 버스(Address Bus)&lt;/strong&gt;&lt;br /&gt;
입출력 장치 선택을 위한 정보가 흐르는 단방향 회선&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;데이터 버스(Data Bus)&lt;/strong&gt;&lt;br /&gt;
입출력하기 위한 데이터가 흐르는 회선으로 양방향 회선&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;제어 버스(Control Bus)&lt;/strong&gt;&lt;br /&gt;
입출력 장치에 어떤 동작을 취하기 하기 위해 제어 신호를 전달하는 단방향 회선&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;입출력 인터페이스(I/O Interface)&lt;/strong&gt;  &lt;br /&gt;
입출력 포트라고도 불리며 &lt;strong&gt;입출력 버스와 입출력 장치 사이의 정보를 전송&lt;/strong&gt;하는데 필요한 &lt;strong&gt;회로&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;레지스터, 상태 레지스터, 타이밍 레지스터 등으로 구성되며 변환, 장치 식별, 오류 검사 기능을 수행한다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;고립형 입출력 포트(Isolated I/O Mapped I/O Port)&lt;/strong&gt;&lt;br /&gt;
입출력 포트와 메모리 주소가 &lt;strong&gt;독립적인 상태&lt;/strong&gt;로 운영되는 경우로 마이크로프로세스는 &lt;strong&gt;뚜렷한 입출력 명령&lt;/strong&gt;을 가지며, &lt;strong&gt;각 명령은 인터페이스 레지스터의 주소&lt;/strong&gt;를 가지고 있다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;메모리 맵 입출력 포트(Memory Mapped I/O Port)&lt;/strong&gt;&lt;br /&gt;
입출력 포트를 메모리 주소에 &lt;strong&gt;종속적인 상태로 운영&lt;/strong&gt;하여 &lt;strong&gt;메모리와 입출력 포트의 구별이 없는 형태&lt;/strong&gt;, 이 경우 마이크로프로세서가 인터페이스 레지스터를 &lt;strong&gt;메모리 시스템의 한 부분으로 취급&lt;/strong&gt;한다&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;입출력 장치 제어기(I/O Device Controller)&lt;/strong&gt;&lt;br /&gt;
입출력 커넥터로 연결된 주변 장치를 제어하기 위한 논리 회로&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;입출력 장치(I/O Device)&lt;/strong&gt;&lt;br /&gt;
컴퓨터 시스템이 처리한 결과를 사용자에게 제공하거나 컴퓨터가 필요로 하는 데이터를 사용자가 컴퓨터 시스템에 제공할 때 사용하는 장치를 의미&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;목적&quot;&gt;목적&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;속도 차이 극복&lt;/li&gt;
  &lt;li&gt;전압 레벨 차이 조정&lt;/li&gt;
  &lt;li&gt;전송 사이클 차이 변환&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기능&quot;&gt;기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;입출력 제어 기능&lt;/strong&gt;&lt;br /&gt;
입출력 시스템에 이상이 발생한 경우 이를 사전에 감지하여 수정하고 입출력을 위해 정해진 규정이나 한계로부터 이탈되는 사태나 상황을 사전에 감지하여 &lt;strong&gt;입출력이 바르게 진행&lt;/strong&gt;되도록 하는 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;입출력 버스 기능&lt;/strong&gt;&lt;br /&gt;
주기억 장치와 입출력 장치 사이에 &lt;strong&gt;정보 교환&lt;/strong&gt; 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;인터페이스 기능&lt;/strong&gt;&lt;br /&gt;
주기억 장치와 입출력 장치 간의 &lt;strong&gt;차이점을 극복&lt;/strong&gt;하기 위해 입출력 명령이나 제어 명령을 사용하여 서로 &lt;strong&gt;연결&lt;/strong&gt;되도록 변환하는 기능&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기억-장치와-차이점&quot;&gt;기억 장치와 차이점&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;비교&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;입출력 장치&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;주기억 장치&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;동작 속도&lt;/td&gt;
      &lt;td&gt;기계적인 동작이 필요하므로 속도가 느리다&lt;/td&gt;
      &lt;td&gt;전자적인 주기억 장치는 속도가 빠르다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;정보 단위&lt;/td&gt;
      &lt;td&gt;문자(Character)&lt;/td&gt;
      &lt;td&gt;Word&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;동작의 자율성&lt;/td&gt;
      &lt;td&gt;여러 개를 가지고 있어야 하므로 자율적으로 동작할 수 있어야 한다&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;에러 발생률&lt;/td&gt;
      &lt;td&gt;전송 과정의 여러 원인으로 인해 에러 발생률이 높다&lt;/td&gt;
      &lt;td&gt;전자 회로이므로 거의 에러 발생률이 없다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;입출력-제어-방식&quot;&gt;입출력 제어 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;CPU&lt;/strong&gt; 제어기에 의한 입출력 방식
    &lt;ul&gt;
      &lt;li&gt;CPU와 입출력 장치 사이에 인터페이스가 있는 시스템에 적용&lt;/li&gt;
      &lt;li&gt;CPU가 입출력 제어기 역할을 수행&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;인터페이스에 있는 데이터 레지스터와 CPU에 있는 레지스터 사이에서 데이터 이동이 발생&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;프로그램에 의한&lt;/strong&gt; 입출력 제어 방식(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Polling&lt;/code&gt; 방식)&lt;br /&gt;
CPU와 입출력 장치 사이의 데이터 전달이 프로그램에 의해서 제어되는 방법
        &lt;ul&gt;
          &lt;li&gt;CPU가 &lt;strong&gt;계속적으로 플래그를 검사&lt;/strong&gt;하여 입출력 &lt;strong&gt;전반에 걸쳐 개입&lt;/strong&gt;하기 때문에 &lt;strong&gt;비효율적&lt;/strong&gt;이며 CPU는 다른 연산을 처리하지 못하는 입출력 방법&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;인터럽트에 의한&lt;/strong&gt; 입출력 제어 방식(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Interrupt&lt;/code&gt; 방식)&lt;br /&gt;
CPU가 계속적으로 플래그를 검사하지 않고 입출력이 필요할 때 입출력 장치에서 &lt;strong&gt;CPU에게 인터럽트를 요청&lt;/strong&gt;하면, 그 때 CPU가 하던 &lt;strong&gt;작업을 멈추고 입출력 장치에 데이터를 전송&lt;/strong&gt;하게 하는 방식
        &lt;ul&gt;
          &lt;li&gt;프로그램에 의한 입출력 방식보다 CPU의 이용 &lt;strong&gt;효율이 좋다&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DMA&lt;/code&gt;(Direct Memory Access) 제어기&lt;/strong&gt;에 의한 입출력 방식&lt;br /&gt;
CPU의 입출력 명령에 의해 &lt;strong&gt;CPU의 개입 없이 직접 주기억 장치와 DMA에 사이&lt;/strong&gt;에서 일련의 입출력 동작이 이루어지는 방식
    &lt;ul&gt;
      &lt;li&gt;프로그램이 실행되는 동안 인터럽트의 수를 최소화시켜 준다&lt;/li&gt;
      &lt;li&gt;디스크 동작과 같은 고속 입출력 장치를 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;채널&lt;/strong&gt; 제어기에 의한 입출력 방식&lt;br /&gt;
입출력 &lt;strong&gt;전용 프로세서인 채널&lt;/strong&gt;이 &lt;strong&gt;직접 주기억 장치에 접근&lt;/strong&gt;하여 채널 프로그램의 채널 명령어를 인출하여 채널 명령어 요구 조건에 따라 입출력 명령을 수행하는 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-전송-제어-방식&quot;&gt;데이터 전송 제어 방식&lt;/h2&gt;
&lt;h3 id=&quot;스트로브strobe-제어&quot;&gt;스트로브(Strobe) 제어&lt;/h3&gt;
&lt;p&gt;송신측과 수신측에 &lt;strong&gt;스트로브 신호를 주는 제어선 한 개&lt;/strong&gt;와 &lt;strong&gt;데이터 버스 선 한 개&lt;/strong&gt;로 연결되어 있는 데이터 전송 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스트로브 신호로 데이터가 전송될 시간을 알려주어야 한다&lt;/li&gt;
  &lt;li&gt;데이터를 전송할 때 &lt;strong&gt;실제로 전송하는 것을 알려주기 위해 보내는 신호&lt;/strong&gt;를 &lt;strong&gt;스트로브 신호&lt;/strong&gt;라 한다&lt;/li&gt;
  &lt;li&gt;스트로브 신호를 보내기 위한 회선은 송신 → 수신, 수신 → 송신&lt;/li&gt;
  &lt;li&gt;전송한 데이터를 수신 쪽에서 &lt;strong&gt;확실하게 수신하였는지는 알 수 없다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;병렬-입출력-데이터-전송-방식&quot;&gt;병렬 입출력 데이터 전송 방식&lt;/h3&gt;
&lt;p&gt;송신 및 수신 양쪽에서 상대편에게 제어 신호를 보내는 방법으로 &lt;strong&gt;데이터 버스 외에 양쪽에서 제어 신호를 보내는 별도의 회선 2개&lt;/strong&gt;가 필요하다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제어 라인 중 &lt;strong&gt;하나의 제어 라인&lt;/strong&gt;은 버스 내의 &lt;strong&gt;데이터 방향과 함께 송신부로부터 수신부로 향하고 있는 것&lt;/strong&gt;으로 버스에 데이터가 실려 있음을 수신측에 알려준다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;또 하나의 제어 라인&lt;/strong&gt;은 수신부로부터 송신부로 연결되어 있는 것으로 수신 장치가 &lt;strong&gt;데이터를 받아들일 수 있는지의 여부&lt;/strong&gt;를 송신부에 알려주는 역할을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비동기-데이터-전송-방식&quot;&gt;비동기 데이터 전송 방식&lt;/h3&gt;
&lt;p&gt;송신측과 수신측의 시간적 특성이 현저히 다른 경우에 사용하는 방식이며 전송을 제어하기 위해서는 시작과 끝을 나타내는 &lt;strong&gt;제어 비트(Start Bit, Stop Bit)&lt;/strong&gt;를 첨가해서 사용&lt;/p&gt;

&lt;h3 id=&quot;동기-데이터-전송-방식&quot;&gt;동기 데이터 전송 방식&lt;/h3&gt;
&lt;p&gt;송신측에서 수신측에 정보를 전달할 때 &lt;strong&gt;송신측의 클록 펄스를 함께 보내는 방식&lt;/strong&gt;으로 송/수신 장치가 가까이 있는 경우에 주로 사용&lt;/p&gt;

&lt;h2 id=&quot;입출력-장치&quot;&gt;입출력 장치&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;입력 장치&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;광학 마크 판독기(OMR, Optical Mark Reader)&lt;/li&gt;
      &lt;li&gt;자기 잉크 문자 판독기(MICR, Magnetic Ink Character Reader)&lt;/li&gt;
      &lt;li&gt;광학 문자 판독기(OCR, Optical Character Reader)&lt;/li&gt;
      &lt;li&gt;카드 리더기&lt;/li&gt;
      &lt;li&gt;종이 테이프 판독기&lt;/li&gt;
      &lt;li&gt;음성 입력 장치&lt;/li&gt;
      &lt;li&gt;터치 스크린&lt;/li&gt;
      &lt;li&gt;디지타이저&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;출력 장치&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프린터
        &lt;ul&gt;
          &lt;li&gt;Print Wheel Printer&lt;br /&gt;
&lt;strong&gt;금속 휠 표면&lt;/strong&gt;에 인쇄 문자를 가진 프린팅 기구 구조로 된 프린터&lt;/li&gt;
          &lt;li&gt;Dot Matrix Printer&lt;br /&gt;
프린터 헤드에 &lt;strong&gt;일렬로 배열된 핀&lt;/strong&gt;들이 있고 헤드가 이동하면서 각 위치의 점의 색깔에 핀을 따라 망치로 때려 리본을 통해 종이에 인쇄하는 프린터&lt;/li&gt;
          &lt;li&gt;Chain Printer&lt;br /&gt;
&lt;strong&gt;체인이 돌다가&lt;/strong&gt; 원하는 문자가 프린트 위치에 왔을 때 망치로 때려서 글자가 찍히도록 하는 프린터&lt;/li&gt;
          &lt;li&gt;Bar Printer&lt;br /&gt;
활자가 장치된 &lt;strong&gt;막대가 수평으로 움직&lt;/strong&gt;이면서 인쇄되는 프린터&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;X-Y 플로터&lt;/li&gt;
      &lt;li&gt;CRT(Cathode Ray Tube)&lt;/li&gt;
      &lt;li&gt;COM(Computer Output Microfilm)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;입출력 겸용 장치&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;자기 디스크&lt;/li&gt;
      &lt;li&gt;자기 테이프&lt;/li&gt;
      &lt;li&gt;자기 드럼&lt;/li&gt;
      &lt;li&gt;마이크로필름(Microfilm)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 12 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-input-output-system/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-input-output-system/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] DMA와 채널</title>
        <description>&lt;h2 id=&quot;dmadirect-memory-access&quot;&gt;DMA(Direct Memory Access)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CPU의 개입없이&lt;/strong&gt; 직접 &lt;strong&gt;주기억 장치와 DMA 사이&lt;/strong&gt;에서 일련의 입출력 동작이 이루어지는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU를 경유하지 않는다&lt;/li&gt;
  &lt;li&gt;직접 기억 장치와 입출력 장치 사이에서 전송이 이루어진다&lt;/li&gt;
  &lt;li&gt;하나의 입출력 명령어에 의해 하나의 블록 전체가 전송된다&lt;/li&gt;
  &lt;li&gt;사이클 스틸에 의해 전송이 이루어진다
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;사이클 스틸&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cycle Steal&lt;/code&gt;) : 
CPU가 프로그램을 수행하기 위해 계속해서 &lt;strong&gt;메이저 사이클&lt;/strong&gt;(인출/간접/실행/인터럽트 사이클 &lt;a href=&quot;https://many258.github.io/study/electronic-calculator-instruction-cycle/#%EB%A9%94%EC%9D%B4%EC%A0%80-%EC%82%AC%EC%9D%B4%ED%81%B4%EC%9D%98-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%98%A4%ED%8D%BC%EB%A0%88%EC%9D%B4%EC%85%98&quot; class=&quot;btn btn--info&quot;&gt;포스트 이동하기&lt;/a&gt;)을 반복하고 있는 상태에서 DMA 제어기가 하나의 워드 전송을 위해서 일시적으로 &lt;strong&gt;CPU의 사이클을 훔쳐서 사용&lt;/strong&gt;하는 경우를 의미&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;전송이 끝나면 인터럽트를 발생시켜 CPU에게 알려준다&lt;/li&gt;
  &lt;li&gt;데이터 전송 절차
    &lt;ol&gt;
      &lt;li&gt;버스 사용 요구&lt;/li&gt;
      &lt;li&gt;버스 사용 허가&lt;/li&gt;
      &lt;li&gt;데이터 전송&lt;/li&gt;
      &lt;li&gt;인터럽트&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;구성요소&quot;&gt;구성요소&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;데이터 버퍼 레지스터(DBR, Data Buffer Register)&lt;/strong&gt;&lt;br /&gt;
입출력되는 &lt;strong&gt;하나의 워드를 기억&lt;/strong&gt;시키는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;요청 플립플롭(F Flip-Flop)&lt;/strong&gt;&lt;br /&gt;
데이터의 &lt;strong&gt;이동 방향&lt;/strong&gt;(입력/출력)을 나타내는 플래그&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;상태 레지스터(Status Register)&lt;/strong&gt;&lt;br /&gt;
DMA의 상태를 나타내는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주소 레지스터(Address Register)&lt;/strong&gt;&lt;br /&gt;
입출력시킬 &lt;strong&gt;워드의 주소값&lt;/strong&gt;을 가지고 있는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;단어 계수기(Word Counter)&lt;/strong&gt;&lt;br /&gt;
입출력시킬 &lt;strong&gt;블록 전체의 단어 개수&lt;/strong&gt;를 가지고 있는 계수기&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;DMA 입출력은 &lt;strong&gt;CPU나 채널로부터&lt;/strong&gt; 블록의 첫 번째 워드 주소, 블록의 단어 개수, 입출력 플래그, DMA의 상태 정보, DMA의 시작 명령을 넘겨 받는다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;사이클 스틸&lt;/strong&gt;을 통해서 메모리에서 &lt;strong&gt;단어(Word)를 입출력&lt;/strong&gt;하는데 입출력 할 때마다 &lt;strong&gt;단어 계수기의 값이 하나씩 감소&lt;/strong&gt;한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 단어 계수의 값이 &lt;strong&gt;0이 되는 순간&lt;/strong&gt; 해당 블록의 &lt;strong&gt;입출력이 완료된 것&lt;/strong&gt;으로 이 때 DMA는 &lt;strong&gt;CPU에 인터럽트를 요청&lt;/strong&gt;하여 입출력 완료를 보고한다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;사이클-스틸-vs-인터럽트&quot;&gt;사이클 스틸 VS 인터럽트&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;사이클 스틸&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;인터럽트&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;CPU 상태를 보존할 필요가 없다&lt;/td&gt;
      &lt;td&gt;CPU 상태를 보존해야 한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CPU가 잠시 쉰다&lt;/td&gt;
      &lt;td&gt;인터럽트를 처리한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;아무 사이클&lt;/strong&gt;이나 상관없이 훔치는 것이 가능&lt;/td&gt;
      &lt;td&gt;항상 실행 사이클 이후에만 인터럽트 인지&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;channel&quot;&gt;Channel&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;주기억 장치와 입출력 장치 사이&lt;/strong&gt;에서 입출력을 제어하는 &lt;strong&gt;입출력 전용 프로세서&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;채널 명령어&lt;/strong&gt;를 분석하여 직접 주기억 장치에 접근해서 입출력 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CPU와 동시에 동작이 가능&lt;/strong&gt;하므로 고속으로 입출력 가능한 고속 입출력 제어기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;여러 개의 블록을 전송&lt;/strong&gt;할 수 있다&lt;/li&gt;
  &lt;li&gt;전송 시에는 &lt;strong&gt;DMA를 이용&lt;/strong&gt;할 수도 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;채널의-연결-형태에-따른-구분&quot;&gt;채널의 연결 형태에 따른 구분&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;고정 채널&lt;/strong&gt;&lt;br /&gt;
채널과 I/O 장치들이 &lt;strong&gt;고정된 전송 통로&lt;/strong&gt;를 지닌 형태로 구성은 간단하지만 효율이 낮다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;가변 채널&lt;/strong&gt;&lt;br /&gt;
채널과 I/O 장치들이 &lt;strong&gt;가변적 전송 통로&lt;/strong&gt;를 지닌 형태로 구성은 복잡하지만 효율이 좋다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;입출력-장치의-성질에-따른-채널의-종류&quot;&gt;입출력 장치의 성질에 따른 채널의 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;셀렉터 채널(Selector Channel)&lt;/strong&gt;&lt;br /&gt;
채널 하나를 &lt;strong&gt;하나의 입출력 장치가 독점&lt;/strong&gt;해서 사용하는 방식으로 &lt;strong&gt;고속 전송&lt;/strong&gt;에 적합&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;바이트 멀티플렉서 채널(Byte Multiplexer Channel)&lt;/strong&gt;&lt;br /&gt;
한 개의 채널에 &lt;strong&gt;여러 개의 입출력 장치를 연결&lt;/strong&gt;하여 &lt;strong&gt;시분할 공유 방식&lt;/strong&gt;으로 입출력하는 &lt;strong&gt;저속 입출력&lt;/strong&gt; 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;블록 멀티플렉서 채널(Block Multiplexer Channel)&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;셀렉터 채널과 멀티플렉서 채널 방식을 결합&lt;/strong&gt;한 방식으로 융통성있는 운용을 할 수 있는 방식&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;채널-입출력-방식&quot;&gt;채널 입출력 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;채널 프로그램&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;채널 명령어들이 링크 리스트로 연결&lt;/strong&gt;되어 있는 집합으로 이 프로그램은 채널 제어기에 의해 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;채널 명령어(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CCW&lt;/code&gt;, Channel Command Word)&lt;/strong&gt;&lt;br /&gt;
주기억 장치에 있는 &lt;strong&gt;하나의 블록 입출력 정보&lt;/strong&gt;를 가지고 있는 명령어로 &lt;strong&gt;채널 제어기에 의해 패치&lt;/strong&gt;되어 수행된다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Operation Code&lt;/strong&gt;&lt;br /&gt;
입/출력 여부, 분기, 입출력 장치 제어, 채널 동작에 대한 정보를 나타낸다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;블록 주소&lt;/strong&gt;&lt;br /&gt;
블록의 첫 번째 시작 주소&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;블록의 단어 수&lt;/strong&gt;&lt;br /&gt;
입출력하고자 하는 블록의 워드 개수&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;다음 채널 명령의 주소&lt;/strong&gt;&lt;br /&gt;
채널은 명령어의 실행 순서를 제어하는 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PC&lt;/code&gt;가 없으므로&lt;/strong&gt; 다음에 수행해야 할 명령어의 주소는 채널 명령어 자체에 들어 있어야 한다&lt;/p&gt;

        &lt;p&gt;주기억 장치에 있는 하나의 블록을 &lt;strong&gt;입출력하기 위한 정보&lt;/strong&gt;를 가지고 있는 명령어로 채널 제어기에 의해 패치되어 수행된다&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;채널 주소 단어(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAW&lt;/code&gt;, Channel Address Word)&lt;/strong&gt;&lt;br /&gt;
채널 명령어의 &lt;strong&gt;시작 주소를 기억&lt;/strong&gt;하는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;채널 상태 단어(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CSW&lt;/code&gt;, Channel Status Word)&lt;/strong&gt;&lt;br /&gt;
CPU에서 I/O 명령에 따라 채널에 입출력을 지시할 때 사용할 &lt;strong&gt;채널 정보와 입출력 장치 정보 등&lt;/strong&gt;을 전달하게 되는데, 이 &lt;strong&gt;정보를 기억&lt;/strong&gt;하는 레지스터&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;채널이 주기억 장치에 저장되어 있는 &lt;strong&gt;채널 프로그램에 접근&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;채널 상태 단어가 지시하는 &lt;strong&gt;하나의 채널 명령어를 인출&lt;/strong&gt;해서 채널 명령어에 넣고 &lt;strong&gt;해독&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;해독 결과에 따라 블록을 입출력하고, 채널 명령어 마지막 필드에 있는 &lt;strong&gt;다음 채널 명령어를 채널 상태 단어에 넣고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1~2&lt;/code&gt;번 과정&lt;/strong&gt; 반복적으로 입출력 작업 수행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/channel-architecture.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/channel-architecture.png&quot; alt=&quot;&quot; title=&quot;채널 입출력 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 12 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-dma-channel/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-dma-channel/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 가상 기억 장치 및 인터리빙</title>
        <description>&lt;h2 id=&quot;가상-기억-장치virual-memory&quot;&gt;가상 기억 장치(Virual Memory)&lt;/h2&gt;
&lt;p&gt;기억 용량을 효과적으로 이용하기 위하여 주기억 장치보다 훨씬 큰 보조 기억 공간을 주기억 장치의 연속된 기억 공간으로 사용하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주소 공간의 확대가 목적&lt;/li&gt;
  &lt;li&gt;보조 공간 전체를 주소 공간으로 보고 명령어를 만드는 방식&lt;/li&gt;
  &lt;li&gt;소프트웨어로 실현&lt;/li&gt;
  &lt;li&gt;보조 기억 장치는 직접 접근 장치(DASD)여야 한다(자기 디스크)&lt;/li&gt;
  &lt;li&gt;가상 주소를 실제 주소로 변환하는 과정이 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;사상(Mapping)&lt;/strong&gt;&lt;br /&gt;
가상 기억 장치에 있는 내용을 어떤 일정한 단위로 분류하여 이 단위의 내용이 실기억 장치의 어느 위치에 있는지를 알아내는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;페이징(Paging)&lt;/strong&gt;&lt;br /&gt;
사상 기억 장치에 있는 내용을 어떤 일정한 단위로 분류할 때 분류 단위가 똑같은 크기일 때를 페이징이라 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;세그먼트(Segment)&lt;/strong&gt;&lt;br /&gt;
가상 기억 장치에 있는 내용을 어떤 일정한 단위로 분류할 때 분류 단위가 같지 않은 경우를 세그먼트라 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;페이지 폴트(Page Fault)&lt;/strong&gt;&lt;br /&gt;
주기억 장치에 없는 페이지가 참조될 때 생기는 인터럽트로, 페이지 폴트가 발생하면 CPU가 하던 일을 중단하고 해당 페이지를 주기억 장치로 옮겨 놓은 후 다시 인터럽트 처리를 하게 된다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;스태깅(Staging)&lt;/strong&gt;&lt;br /&gt;
가상 기억 체제에서 페이지 폴트가 발생하면 희생 페이지를 결정해서 보조 기억 장치의 이전 위치에 기억시키고 새로운 페이지를 이전 희생된 페이지가 있던 곳에 위치시키는 과정을 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;스래싱(Thrashing)&lt;/strong&gt;&lt;br /&gt;
보조 기억 장치의 페이지 접근 횟수가 많아 작업 수행 시간보다 페이징 교체 시간이 많아지는 경우&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;관리-기법&quot;&gt;관리 기법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;연속 로딩 기법&lt;/strong&gt;&lt;br /&gt;
프로그램을 &lt;strong&gt;연속된 기억 장소에 저장&lt;/strong&gt;하여 수행하는 기법으로 처음부터 구역을 분할해 두는 &lt;strong&gt;고정 분할&lt;/strong&gt;과 필요에 따라 구역을 정하는 &lt;strong&gt;동적 분할&lt;/strong&gt;이 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;분산 로딩 기법&lt;/strong&gt;&lt;br /&gt;
프로그램을 &lt;strong&gt;적당한 크기로 나누어 필요한 부분만 주기억 장치&lt;/strong&gt;에 저장하여 수행하는 기법으로 주소 공간과 실제 공간을 분리하여 사용한다. 보조 기억 장치의 페이지 접근 횟수가 많아 작업 수행 시간보다 &lt;strong&gt;페이지 교체 시간이 많다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;페이징&lt;/strong&gt;&lt;br /&gt;
프로그램을 비연속적인 기억 공간에 적재하여 수행할 수 있도록 실기억 공간과 가상 기억 공간을 &lt;strong&gt;균등 분할&lt;/strong&gt;하고 매핑 테이블을 이용하여 가상 주소를 실 주소로 변환하는 방법으로 &lt;strong&gt;외부 단편화가 발생하지 않는다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;세그먼트&lt;/strong&gt;&lt;br /&gt;
프로그램을 주프로그램, 부프로그램, 배열, 스택 등 용도가 다른 &lt;strong&gt;여러 크기의 세그먼트&lt;/strong&gt;로 나누어 수행시키는 방법으로 &lt;strong&gt;외부 단편화가 발생할 수 있다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;페이지-교체-알고리즘&quot;&gt;페이지 교체 알고리즘&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://many258.github.io/study/os-memory-strategy/#%EA%B5%90%EC%B2%B4%EC%9E%AC%EB%B0%B0%EC%B9%98-%EC%A0%84%EB%9E%B5replacement-strategy&quot; class=&quot;btn btn--info&quot;&gt;포스트 이동하기&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;tlb&quot;&gt;TLB&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;변환 색인 버퍼(Translation Lookaside Buffer&lt;/strong&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TLB&lt;/code&gt;)는 가상 메모리 주소를 물리적인 주소로 &lt;strong&gt;변환하는 속도를 향상&lt;/strong&gt;시키기 위해 MMU에서 사용하는 고속 &lt;strong&gt;캐시&lt;/strong&gt;로 최근에 일어난 가상 메모리 주소와 물리 주소의 &lt;strong&gt;변환 테이블을 저장&lt;/strong&gt;하기 때문에 일종의 &lt;strong&gt;주소 변환 캐시&lt;/strong&gt;라고 할 수 있다&lt;/p&gt;

&lt;p&gt;TLB는 CPU와 CPU 캐시 사이, CPU 캐시와 메인 메모리 사이 등 여러가지 &lt;strong&gt;다른 레벨의 캐시들 사이에서 주소를 변환하는데 사용&lt;/strong&gt;할 수 있다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/tlb.png&quot; title=&quot;http://thebeardsage.com/virtual-memory-translation-lookaside-buffer-tlb/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/tlb.png&quot; alt=&quot;&quot; title=&quot;변환 색인 버퍼(TLB)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;메모리-인터리빙&quot;&gt;메모리 인터리빙&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/Interleaving.gif&quot; title=&quot;https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%9D%B8%ED%84%B0%EB%A6%AC%EB%B9%99&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/Interleaving.gif&quot; alt=&quot;&quot; title=&quot;메모리 인터리빙&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;메모리 인터리빙 기법은 인접한 메모리 위치를 서로 다른 &lt;strong&gt;메모리 뱅크(Bank)&lt;/strong&gt;에 둠으로써 동시에 여러 곳을 접근할 수 있게 하는 것으로 CPU의 처리 속도에 비해 사이클 타임이 오래 걸리지만 &lt;strong&gt;기억 장치에 접근하는 시간을 효율적&lt;/strong&gt;으로 높일 수 있는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;캐시&lt;/strong&gt; 기억 장치, 고속 &lt;strong&gt;DMA&lt;/strong&gt;(Direct Memory Access) 전송 등에서 주로 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CPU가 시분할하여 여러 모듈을 번갈아가면서 접근&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;중앙 처리 장치의 &lt;strong&gt;쉬는 시간을 줄일 수 있다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;단위 시간 당 수행할 수 있는 &lt;strong&gt;명령어의 수를 증가&lt;/strong&gt;시킬 수 있다&lt;/li&gt;
  &lt;li&gt;이 기억 장치를 구성하는 모듈의 수만큼 단어들에 동시 접근이 가능&lt;/li&gt;
  &lt;li&gt;기억 장치 버스를 시분할하여 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;종류&quot;&gt;종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;상위 인터리빙(High-Order Interleaving)&lt;/strong&gt;&lt;br /&gt;
메모리 주소의 &lt;strong&gt;상위 비트들에 의해 모듈이 선택&lt;/strong&gt;되고, 하위 비트들은 각 모듈 내의 기억 장소의 주소를 나타낸다
    &lt;ul&gt;
      &lt;li&gt;한 모듈에서 에러가 발생해도 해당 모듈만 영향을 받는다&lt;/li&gt;
      &lt;li&gt;동시 접근을 통한 성능 향상의 어려움 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;하위 인터리빙(Low-Order Interleaving)&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;하위 비트들에 의해 모듈이 선택&lt;/strong&gt;되고, 상위 비트들은 각 모듈 내의 주소를 나타낸다
    &lt;ul&gt;
      &lt;li&gt;다수의 모듈이 동시에 동작 가능&lt;/li&gt;
      &lt;li&gt;새로운 메모리 뱅크 추가 시 전체에 영향을 준다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;혼합 인터리빙(High-Low-Order Interleaving)&lt;/strong&gt;&lt;br /&gt;
기억장치 모듈을 뱅크로 &lt;strong&gt;그룹화&lt;/strong&gt;하고 각 그룹 내에서 하위 인터리빙 수행
    &lt;ul&gt;
      &lt;li&gt;상위, 하위 인터리빙의 단점 해결&lt;/li&gt;
      &lt;li&gt;구현이 복잡하고 어려움&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;엑세스-방식&quot;&gt;엑세스 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;C-Access 방식
&lt;a href=&quot;../../assets/images/electronic-calc/memory-interleaving-c-access.png&quot; title=&quot;http://blog.skby.net/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%9D%B8%ED%84%B0%EB%A6%AC%EB%B9%99-memory-interleaving/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/memory-interleaving-c-access.png&quot; alt=&quot;&quot; title=&quot;메모리 인터리빙 C-접근 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;주소들이 프로세서-기억 장치간 &lt;strong&gt;버스를 통해 순차적&lt;/strong&gt;으로 기억 장치 모듈에 도착&lt;/li&gt;
      &lt;li&gt;모듈들에서의 엑세스 동작들이 &lt;strong&gt;시간적으로 중첩&lt;/strong&gt;되지만 실제 엑세스 시간은 약간씩 다르다&lt;/li&gt;
      &lt;li&gt;이 때 주소들이 버스를 통해 각 기억 장치 모듈들로 전송되는 과정에서 버스의 경합으로 일정 시간 간격으로 주소들이 각 모듈에 도착하지 못할 수 있다. 이럴 경우 읽기 동작의 동시성이 줄어들고 결과적으로 데이터 전송도 연속적으로 이루어지지 못하게 된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;S-Access 방식
&lt;a href=&quot;../../assets/images/electronic-calc/memory-interleaving-s-access.png&quot; title=&quot;http://blog.skby.net/%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%9D%B8%ED%84%B0%EB%A6%AC%EB%B9%99-memory-interleaving/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/memory-interleaving-s-access.png&quot; alt=&quot;&quot; title=&quot;메모리 인터리빙 S-접근 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;
    &lt;blockquote&gt;
      &lt;p&gt;액세스 시간 : T = Ta + (M × tb)&lt;br /&gt;
&lt;sub&gt;Ta: 기억 장치 액세스 시간, tb: 버스 클럭의 주기, M: 기억 장치 모듈의 수&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;모든 기억 장치 모듈들에서 읽기 동작들이 동시에 시작되도록 하고, 읽혀진 데이터들을 순차적으로 전송&lt;/li&gt;
      &lt;li&gt;DDR &lt;strong&gt;DRAM&lt;/strong&gt; 등에 적용되고 있으며 연속적인 입력 데이터 흐름이 필요한 &lt;strong&gt;파이프라인&lt;/strong&gt; 컴퓨터에서 주로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 11 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-memory-technology/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-memory-technology/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 캐시 및 연관 기억 장치</title>
        <description>&lt;h2 id=&quot;캐시-기억-장치cache&quot;&gt;캐시 기억 장치(Cache)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CPU와 주기억 장치의 속도 차이를 극복&lt;/strong&gt;하기 위해 CPU와 주기억 장치 사이에 설치한 메모리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU와 비슷한 액세스 속도를 가지고 가격이 비싸다&lt;/li&gt;
  &lt;li&gt;주기억 장치와 CPU 사이에서 일종의 &lt;strong&gt;버퍼 기능을 수행&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;기억 장치의 접근 시간을 줄이므로 컴퓨터의 &lt;strong&gt;처리 속도를 향상&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;CPU에서 실행 중인 프로그램과 데이터를 기억&lt;/li&gt;
  &lt;li&gt;캐시 접근 시 &lt;strong&gt;충돌을 방지&lt;/strong&gt;하기 위해 코드와 데이터를 분리해서 기억시키는 &lt;strong&gt;분리 캐시(Split Cache)를 사용&lt;/strong&gt;한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;적중률ratio&quot;&gt;적중률(Ratio)&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;적중도 : $\frac{적중 횟수}{전체 접근 횟수}$&lt;br /&gt;
&lt;br /&gt;
적중률(히트율) : $\frac{적중 횟수}{전체 접근 횟수} \times 100$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;액세스-시간access-time&quot;&gt;액세스 시간(Access Time)&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;평균 메모리 액세스 시간 = 히트 시간 + 미스도 + 미스 패널티&lt;br /&gt;
&lt;sub&gt;미스 패널티 : 캐시 미스가 발생했을 때 주기억 장치에서 데이터를 가져오기 위해 &lt;strong&gt;추가적으로 필요한 사이클 수&lt;/strong&gt;를 의미&lt;/sub&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;캐시-사상-방법&quot;&gt;캐시 사상 방법&lt;/h3&gt;
&lt;p&gt;주기억 장치의 임의의 블록을 지정된 캐시 블록에 기억시키는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;직접 사상(Direct Mapping)&lt;/strong&gt;&lt;br /&gt;
기억시킬 캐시 블록 결정 함수는 주기억 장치의 블록 번호를 캐시 전체의 블록 수로 나눈 나머지로 결정
    &lt;blockquote&gt;
      &lt;p&gt;캐시 블록 번호 = 주기억 장치 블록 번호 MOD 캐시 전체의 블록 수&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;전체 연합 사상(Fully Associative Mapping)&lt;/strong&gt;&lt;br /&gt;
주기억 장치 임의의 블록 하나를 캐시 전체 블록 중 아무 곳이나 하나를 정해서 기억시키는 방법&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;메모리 워드의 번지와 함께 저장&lt;/strong&gt;하는 방식으로 &lt;strong&gt;캐시 블록 모두 채워진 경우&lt;/strong&gt;라면 보통 &lt;strong&gt;라운드 로빈&lt;/strong&gt; 방식으로 메모리 워드 번지와 데이터를 교체한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;세트 연합 사상(Set Associative Mapping)&lt;/strong&gt;&lt;br /&gt;
직접 사상과 전체 연합 사상 방식의 장점을 취한 방식&lt;/p&gt;

    &lt;p&gt;캐시 블록을 몇 개의 블록으로 이루어진 &lt;strong&gt;세트 단위로 분리&lt;/strong&gt;한 뒤 &lt;strong&gt;세트를 선택&lt;/strong&gt;할 때는 &lt;strong&gt;직접 사상 방식&lt;/strong&gt;을 따르고 세트 내에서 해당 &lt;strong&gt;블록을 지정&lt;/strong&gt;할 때는 &lt;strong&gt;전체 연합 사상&lt;/strong&gt;을 따르는 방식&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;write-through&quot;&gt;Write Through&lt;/h3&gt;
&lt;p&gt;CPU가 데이터를 사용하면 캐시에 저장되게 되는데, &lt;strong&gt;캐시와 주기억 장치를 동시에 갱신&lt;/strong&gt;하는 방법&lt;/p&gt;

&lt;p&gt;캐시와 메모리에 업데이트를 같이 하여 &lt;strong&gt;데이터 일관성을 유지&lt;/strong&gt;할 수 있어 &lt;strong&gt;안정적&lt;/strong&gt;이나 &lt;strong&gt;속도가 느린&lt;/strong&gt; 주기억 장치 또는 보조기억장치에 데이터를 기록할 때 CPU가 대기하는 시간이 필요하기 때문에 &lt;strong&gt;성능이 낮아진다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주로 데이터 로스가 발생하면 안되는 상황&lt;/strong&gt;에서 채택한다&lt;/p&gt;

&lt;h3 id=&quot;write-back&quot;&gt;Write Back&lt;/h3&gt;
&lt;p&gt;캐시의 내용에만 갱신이 일어나다가 해당 블록이 캐시에서 제거될 때 주기억 장치에 해당 블록을 복사해서 갱신하는 방법&lt;/p&gt;

&lt;p&gt;Write Through 방식보다 &lt;strong&gt;속도가 빠르지만&lt;/strong&gt; 캐시에 갱신하고 메모리에는 갱신하지 않기 때문에 캐시와 메모리가 &lt;strong&gt;서로 값이 다른 경우가 발생&lt;/strong&gt;할 수 있다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;빠른 서비스&lt;/strong&gt;를 제공할 때 채택한다&lt;/p&gt;

&lt;h3 id=&quot;참조의-국한성&quot;&gt;참조의 국한성&lt;/h3&gt;
&lt;p&gt;주어진 시간 동안의 메모리 참조는 한정된 영역에서만 이루어지는 경향이 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;시간 구역성(Temporal Locality)&lt;/strong&gt;&lt;br /&gt;
최근에 참조된 기억 장소는 &lt;strong&gt;가까운 장래에도 계속 참조&lt;/strong&gt;될 가능성이 높다&lt;/p&gt;

    &lt;p&gt;&lt;span style=&quot;color:orangered;&quot;&gt;&lt;strong&gt;서브루틴, Spool, 스택, 누산기, 집계&lt;/strong&gt;&lt;/span&gt; 등&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;공간 구역성(Spatial Locality)&lt;/strong&gt;&lt;br /&gt;
하나의 기억 장소가 참조되면 &lt;strong&gt;근처의 기억 장소&lt;/strong&gt;가 참조될 가능성이 높다&lt;/p&gt;

    &lt;p&gt;&lt;span style=&quot;color:orangered;&quot;&gt;&lt;strong&gt;배열, 순차 명령어 실행&lt;/strong&gt;&lt;/span&gt; 등&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;연관-기억-장치associative&quot;&gt;연관 기억 장치(Associative)&lt;/h2&gt;
&lt;p&gt;기억 장치 접근 시 주소에 의해 해당 위치에 접근하는 것이 아니라 찾고자 하는 &lt;strong&gt;내용 일부를 가지고 원하는 내용을 찾아&lt;/strong&gt; 그 위치의 내용 모두를 제공하는 원리의 기억 장치로 내용 지정 메모리(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CAM&lt;/code&gt;, Content Addressable Memory)라고도 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기억된 정보의 내용에 따라 호출하는 기억 장치로 정보 검색에 유용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주소를 필요로 하지 않는다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;병렬 판독 회로&lt;/strong&gt;를 내장하고 있기 때문에 &lt;strong&gt;가격이 비싸다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;작은 용량의 IC 메모리를 사용하며 캐시 메모리나 가상 메모리의 주소 탐색에 많이 이용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;캐시 기억 장치보다 빠르다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;구성-요소&quot;&gt;구성 요소&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;검색 데이터 레지스터(Search Data Register)&lt;/strong&gt;&lt;br /&gt;
찾고자 하는 내용의 일부분을 기억시키는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;마스크 레지스터(Mask Register)&lt;/strong&gt;&lt;br /&gt;
검색 데이터 레지스터에 있는 데이터에서 검색에 필요 없는 부분을 마스크 비트로 세트(Set)시키는 역할을 하는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;일치 레지스터&lt;/strong&gt;&lt;br /&gt;
검색하고자 하는 내용과 일치하는 단어를 포함하고 있는 내용이 있는 경우, 그것을 표시하는데 사용하는 레지스터&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 10 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-cache-associative/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-cache-associative/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 보조 기억 장치</title>
        <description>&lt;h2 id=&quot;보조-기억-장치&quot;&gt;보조 기억 장치&lt;/h2&gt;
&lt;p&gt;데이터나 파일을 보관하는 비휘발성 메모리로 용량이 크고 액세스 속도가 느린 기억 장소&lt;/p&gt;

&lt;p&gt;자기 디스크, 자기 테이프, 자기 드럼, DVD, CD-ROM, 플로피 디스켓 등이 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전원이 차단되어도 기억 내용이 소멸되지 않는다&lt;/li&gt;
  &lt;li&gt;액세스 속도는 느리지만 대용량 장치&lt;/li&gt;
  &lt;li&gt;가격이 저렴하고 많은 자료를 영구적으로 보관할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;자기-디스크magnetic-disk&quot;&gt;자기 디스크(Magnetic Disk)&lt;/h3&gt;
&lt;p&gt;직접 저장 장치(DASD, Direct Access Storage Device)로서 순차 처리와 랜덤 처리를 병행할 수 있는 기록 매체&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;액세스 시간이 빠르다&lt;/li&gt;
  &lt;li&gt;레코드의 추가/삭제/정정하기 쉽다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;등선 속도&lt;/strong&gt;(CLV, Constant Linear Velocity)&lt;br /&gt;
디스크 &lt;strong&gt;전송 속도&lt;/strong&gt;가 처음부터 마지막까지 &lt;strong&gt;일정&lt;/strong&gt;한 방식으로 디스크의 &lt;strong&gt;안쪽&lt;/strong&gt;에 저장할 때는 &lt;strong&gt;회전 속도가 빠르고&lt;/strong&gt; &lt;strong&gt;바깥쪽&lt;/strong&gt;에 저장할 때는 &lt;strong&gt;회전 속도가 느리게&lt;/strong&gt; 되어 소음이 적으나 회전 구동 장치가 복잡&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;등각 속도&lt;/strong&gt;(CAV, Constant Angular Velocity)&lt;br /&gt;
디스크 &lt;strong&gt;회전 속도를 일정&lt;/strong&gt;하게 하여 디스크의 회전각에 따라 데이터를 저장하는 방식으로 디스크 내부 면과 외부 면의 회전 속도 차이로 외부 면의 저장 밀도가 떨어져 공간 낭비를 가져올 수 있으나 접근 속도가 빠른 방식&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;구조&lt;/th&gt;
      &lt;th&gt;내용&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;자기 원판(Magnetic Circle Board)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;자성 재료가 입혀진 원판을 하나의 축으로 연결시켜 놓은 기억 기구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;액세스 암(Access Arm)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;기억 매체 사이를 수평으로 움직이는 기계 장치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;읽기/쓰기 헤드(Read/Write Head)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;액세스 암의 앞에 위치하여 데이터를 기록하고 읽어들이는 장치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;트랙(Track)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;회전축을 중심으로 이루어진 동심원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;섹터(Sector)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;트랙을 일정한 구역으로 나누어 쓰기 쉽게 만들어 놓은 것&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;실린더(Cylinder)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;여러 장의 디스크 팩에서 같은 지름을 갖는 트랙의 집합. 참고로, 실린더의 개수와 트랙의 개수는 같다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;자기 디스크의 접근 시간&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;탐색 시간(Seek Time)&lt;/strong&gt;&lt;br /&gt;
헤드가 데이터를 읽기 위해서 해당 트랙까지 도달하는데 걸리는 시간&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;회전 대기 시간(Rotational Delay Time, Latency Time)&lt;/strong&gt;&lt;br /&gt;
디스크 장치가 회전하여 해당 섹터가 헤드에 도달하는데 걸리는 시간&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;전송 시간(Transfer Time)&lt;/strong&gt;&lt;br /&gt;
데이터가 전달되는데 걸리는 시간&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;접근 시간(Access Time)&lt;/strong&gt;&lt;br /&gt;
읽기 신호나 쓰기 신호를 접하고 나서 데이터가 읽히거나 쓰여지는데 걸리는 시간을 의미
        &lt;blockquote&gt;
          &lt;p&gt;&lt;strong&gt;Seek Time + Rotational Delay Time + Transfer Time&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;Staging&lt;/strong&gt; : 자기테이프나 디스크에 있는 블록들을 주기억 장치에 미리 옮겨 놓는 기능&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;Spooling&lt;/strong&gt; : 처리할 데이터를 디스크나 테이프에 잠시 저장시켰다가 나중에 다른 장치가 이용하게 하는 기능&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디스크의 RAID의 기술 &lt;a href=&quot;https://many258.github.io/study/os-raid/#raid&quot; class=&quot;btn btn--info&quot;&gt;포스트 이동하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;자기-테이프magnetic-tape&quot;&gt;자기 테이프(Magnetic Tape)&lt;/h3&gt;
&lt;p&gt;순차적으로 데이터를 기록하고 읽는 방식으로 가격이 저렴하고 보관에도 어려움이 없을 뿐 아니라 대용량의 기억 장치이기 때문에 대량의 데이터를 보관하는데 많이 사용된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일괄 처리 시 경제적이기 때문에 백업용으로 많이 사용&lt;/li&gt;
  &lt;li&gt;순차 처리만 가능한 SASD(Sequential Access Storage Device)&lt;/li&gt;
  &lt;li&gt;기록 밀도가 좋다&lt;/li&gt;
  &lt;li&gt;디스크에 비해 대량의 자료를 장시간 보관하기 유리&lt;/li&gt;
  &lt;li&gt;블록 단위로 데이터를 전송
    &lt;ul&gt;
      &lt;li&gt;블록 : 테이프에서 입출력하기 위하여 &lt;strong&gt;여러 개의 논리 레코드를 묶어 놓은 개념&lt;/strong&gt;으로 &lt;strong&gt;물리적 레코드&lt;/strong&gt;라고도 한다&lt;/li&gt;
      &lt;li&gt;블록과 블록 사이의 Gap을 IBG(Inter Block Gap)라 한다. IBG에는 아무것도 기억되지 않는다&lt;/li&gt;
      &lt;li&gt;B/F(Blocking Factor) : 하나의 블록에 들어 있는 논리 레코드의 개수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주소 개념이 없고 7트랙(BCD), 8트랙(ASCII), 9트랙(EBCDIC) 용이 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;세로로 하나의 문자를 기록&lt;/strong&gt;하고 &lt;strong&gt;9트랙용이라면 하나의 트랙은 오류 체크를 위한 패리티 비트&lt;/strong&gt; 트랙으로 사용되고 나머지 8개의 트랙에 EBCDIC 코드로 문자 기록을 위한 각 비트가 기록된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;광-디스크od-optical-disk&quot;&gt;광 디스크(OD, Optical Disk)&lt;/h3&gt;
&lt;p&gt;빛의 반사를 이용하여 자료를 읽어내는 저장 매체&lt;/p&gt;

&lt;h4 id=&quot;블루레이-디스크blu-ray&quot;&gt;블루레이 디스크(Blu-ray)&lt;/h4&gt;
&lt;p&gt;고선명(HD) 비디오를 위한 디지털 데이터를 저장할 수 있도록 소니가 주도하는 BDA(블루레이 디스크 협회)에서 정한 광 기록 방식 저장매체&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DVD보다 데이터 전송 &lt;strong&gt;속도가 4~5배 빠른&lt;/strong&gt; 차세대 대용량 &lt;strong&gt;광디스크&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;비디오 포맷은 DVD와 동일한 &lt;strong&gt;MPEG-2 기반 코덱&lt;/strong&gt;이 사용&lt;/li&gt;
  &lt;li&gt;단층 기록면을 가지고 12cm 직경에 &lt;strong&gt;25GB의 데이터를 저장&lt;/strong&gt;할 수 있다&lt;/li&gt;
  &lt;li&gt;기술 규격으로 BD-ROM(읽기 전용), BD-R(기록 가능), BD-RE(재기록 가능)가 있다&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 09 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-sub-storage/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-sub-storage/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 기억 장치</title>
        <description>&lt;h2 id=&quot;기억-장치-분류&quot;&gt;기억 장치 분류&lt;/h2&gt;
&lt;h3 id=&quot;사용-용도에-빠른-분류&quot;&gt;사용 용도에 빠른 분류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주기억 장치
    &lt;ul&gt;
      &lt;li&gt;반도체
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;RAM&lt;/strong&gt;
            &lt;ul&gt;
              &lt;li&gt;SRAM&lt;/li&gt;
              &lt;li&gt;DRAM&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;ROM&lt;/strong&gt;
            &lt;ul&gt;
              &lt;li&gt;MaskROM&lt;/li&gt;
              &lt;li&gt;PROM&lt;/li&gt;
              &lt;li&gt;EPROM&lt;/li&gt;
              &lt;li&gt;EEPROM&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;자기코어&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;보조 기억 장치
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;DASD&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;자기 디스크&lt;/li&gt;
          &lt;li&gt;자기 드럼&lt;/li&gt;
          &lt;li&gt;하드 디스크&lt;/li&gt;
          &lt;li&gt;플로피 디스크&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SASD&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;자기 테이프&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특수 기억 장치
    &lt;ul&gt;
      &lt;li&gt;복수 모듈 기억 장치(&lt;strong&gt;인터리빙&lt;/strong&gt;)&lt;/li&gt;
      &lt;li&gt;연관 기억 장치&lt;/li&gt;
      &lt;li&gt;캐시 기억 장치&lt;/li&gt;
      &lt;li&gt;가상 기억 장치&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;특성에-따른-분류&quot;&gt;특성에 따른 분류&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;전원 공급&lt;/strong&gt; 유무에 따른 내용 &lt;strong&gt;보존&lt;/strong&gt; 여부&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;휘발성 메모리
    &lt;ul&gt;
      &lt;li&gt;RAM 메모리(DRAM, SRAM)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비휘발성 메모리
    &lt;ul&gt;
      &lt;li&gt;ROM, 코어 메모리, 보조 기억 장치&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;읽기 동작 수행 후&lt;/strong&gt;의 자료 &lt;strong&gt;보존&lt;/strong&gt; 여부&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파괴 메모리
    &lt;ul&gt;
      &lt;li&gt;코어 메모리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비파괴 메모리
    &lt;ul&gt;
      &lt;li&gt;반도체 메모리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;접근 방식&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;직접 접근
    &lt;ul&gt;
      &lt;li&gt;자기 디스크, 자기 드럼&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;순차 접근
    &lt;ul&gt;
      &lt;li&gt;자기 테이프&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기억-장치의-기본&quot;&gt;기억 장치의 기본&lt;/h2&gt;
&lt;h3 id=&quot;기억-장치의-용량&quot;&gt;기억 장치의 용량&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;단위&lt;/th&gt;
      &lt;th&gt;용량&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;K(Kilo)&lt;/td&gt;
      &lt;td&gt;1Kbyte = 2&lt;sup&gt;&lt;strong&gt;10&lt;/strong&gt;&lt;/sup&gt;byte = 1024byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M(Mega)&lt;/td&gt;
      &lt;td&gt;1Mbyte = 2&lt;sup&gt;10&lt;/sup&gt;Kbyte = 2&lt;sup&gt;&lt;strong&gt;20&lt;/strong&gt;&lt;/sup&gt;byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;G(Giga)&lt;/td&gt;
      &lt;td&gt;1Gbyte = 2&lt;sup&gt;10&lt;/sup&gt;Mbyte = 2&lt;sup&gt;&lt;strong&gt;30&lt;/strong&gt;&lt;/sup&gt;byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T(Tera)&lt;/td&gt;
      &lt;td&gt;1Tbyte = 2&lt;sup&gt;10&lt;/sup&gt;Gbyte = 2&lt;sup&gt;&lt;strong&gt;40&lt;/strong&gt;&lt;/sup&gt;byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;P(Peta)&lt;/td&gt;
      &lt;td&gt;1Pbyte = 2&lt;sup&gt;10&lt;/sup&gt;Tbyte = 2&lt;sup&gt;&lt;strong&gt;50&lt;/strong&gt;&lt;/sup&gt;byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E(Exa)&lt;/td&gt;
      &lt;td&gt;1Ebyte = 2&lt;sup&gt;10&lt;/sup&gt;Pbyte = 2&lt;sup&gt;&lt;strong&gt;60&lt;/strong&gt;&lt;/sup&gt;byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Z(Zeta)&lt;/td&gt;
      &lt;td&gt;1Zbyte = 2&lt;sup&gt;10&lt;/sup&gt;Ebyte = 2&lt;sup&gt;&lt;strong&gt;70&lt;/strong&gt;&lt;/sup&gt;byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Y(Yotta)&lt;/td&gt;
      &lt;td&gt;1Ybyte = 2&lt;sup&gt;10&lt;/sup&gt;Zbyte = 2&lt;sup&gt;&lt;strong&gt;80&lt;/strong&gt;&lt;/sup&gt;byte&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;주소선이 N개 일 때, 기억 장소의 개수는 2&lt;sup&gt;N&lt;/sup&gt;개&lt;br /&gt;
입출력 데이터 선의 개수가 &lt;strong&gt;N&lt;/strong&gt;개 일 때, 기억 장소의 크기는 &lt;strong&gt;N&lt;/strong&gt;Bit&lt;br /&gt;
&lt;br /&gt;
총 용량 = 기억 장소의 개수 × 기억 장소의 크기&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;시간-관련&quot;&gt;시간 관련&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;접근 시간(Access Time)&lt;/strong&gt;&lt;br /&gt;
정보를 기억장치에 기억시키거나 읽어내는 명령이 있고 난 후부터 실제로 기억 또는 읽기가 시작하는데 소요되는 시간을 의미&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;ROM&lt;/strong&gt;의 접근 시간 : 정보를 기억 장치에 기억시키거나 읽어내는 명령이 있고 난 후부터 실제로 기억 또는 읽기가 완료되는데 쇼요되는 시간&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Disk&lt;/strong&gt;의 접근 시간 : 읽기 신호나 쓰기 신호를 접하고 나서 실제 데이터가 읽혀서 나오거나 저장되는데 걸리는 시간을 의미&lt;/p&gt;
        &lt;blockquote&gt;
          &lt;p&gt;탐색 시간(Seek Time) +&lt;br /&gt;
대기 시간(Rotational Delay Time) +&lt;br /&gt;
전송 시간(Transfer Time)&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;반환 시간(Turnaround Time)&lt;/strong&gt;&lt;br /&gt;
임의의 시스템에 사용자가 수집한 자료를 입력해서 그것이 처리되어 사용자에게 &lt;strong&gt;그 결과가 출력될 때까지&lt;/strong&gt;의 시간을 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;사이클 시간(Cycle Time)&lt;/strong&gt;&lt;br /&gt;
읽기/쓰기 신호를 보내고 나서 &lt;strong&gt;다음 읽기/쓰기 신호를 보낼 때까지&lt;/strong&gt;의 시간을 의미&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DRAM&lt;/code&gt; 메모리는 &lt;strong&gt;재충전&lt;/strong&gt; 시간이 필요하므로 &lt;strong&gt;사이클 시간이 접근 시간보다 크다&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;파괴성 판독&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DRO&lt;/code&gt;, Destructive Read Out) 메모리는 데이터를 읽어내면서 &lt;strong&gt;원래의 데이터를 소거하는 판독 방법&lt;/strong&gt;으로 정보를 보존하려면 &lt;strong&gt;읽어낸 뒤 즉시 재기입&lt;/strong&gt;하여야 하는 메모리를 의미하는 것으로 &lt;strong&gt;사이클 시간이 접근 시간에 비해 크다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;밴드-폭bandwidth&quot;&gt;밴드 폭(Bandwidth)&lt;/h3&gt;
&lt;p&gt;기억 장치에서 자료를 읽거나 기억시킬 때 기억 장치가 &lt;strong&gt;1초 동안에 전달하거나 받아들일 수 있는 비트&lt;/strong&gt; 수&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;주기억 장치 밴드 폭&lt;/strong&gt;은 &lt;strong&gt;주기억 장치&lt;/strong&gt;와 &lt;strong&gt;중앙 처리 장치&lt;/strong&gt; 사이의 &lt;strong&gt;정보 전달 능력의 한계&lt;/strong&gt;를 의미하는 개념&lt;/p&gt;

&lt;h2 id=&quot;계층-메모리&quot;&gt;계층 메모리&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://many258.github.io/study/os-memory/#%EA%B8%B0%EC%96%B5-%EC%9E%A5%EC%B9%98-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0&quot; class=&quot;btn btn--info&quot;&gt;포스트 이동하기&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;목적&quot;&gt;목적&lt;/h3&gt;
&lt;p&gt;계층 메모리를 구성하는 목적은 적&lt;strong&gt;은 비용으로, 큰 메모리를 빠른 접근 시간을 가지고 사용&lt;/strong&gt;하는데 있다.&lt;/p&gt;

&lt;p&gt;즉, 보조 기억 장치의 가격으로 보조 기억 장치만큼의 큰 기억 공간을 캐시 정도의 접근 시간을 가지고 사용하고자 하는데 목적이 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;레지스터&lt;/strong&gt;&lt;br /&gt;
CPU에 있는 플립플롭으로 구성된 기억 장치로 연산을 위한 데이터나 연산 결과 또는 제어 데이터를 &lt;strong&gt;임시적으로 기억&lt;/strong&gt;시키는데 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;캐시&lt;/strong&gt;&lt;br /&gt;
CPU와 주기억 장치의 &lt;strong&gt;속도 차이를 극복&lt;/strong&gt;하기 위해 CPU의 속도와 비슷한 액세스 속도를 가지고 있는 캐시 기억 장치를 CPU와 주기억 장치 사이에 &lt;strong&gt;버퍼 개념&lt;/strong&gt;으로 설치한 것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주기억 장치&lt;/strong&gt;&lt;br /&gt;
CPU가 직접 사용할 수 있는 기억 장소로 수행 중인 프로그램 및 프로그램이 사용할 데이터를 저장하는데 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;보조 기억 장치&lt;/strong&gt;&lt;br /&gt;
나중에 사용할 데이터나 파일을 보관하는 비휘발성 메모리로 용량이 크고 액세스 속도가 느린 기억 장소&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 08 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-memory/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-memory/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 주기억 장치</title>
        <description>&lt;h2 id=&quot;주기억-장치&quot;&gt;주기억 장치&lt;/h2&gt;
&lt;p&gt;CPU가 직접 사용할 수 있는 기억장소로 시스템 프로그램 영역과 사용자 프로그램 영역으로 나누어 사용되는 비교적 빠르고 큰 메모리를 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기억 &lt;strong&gt;장소에 관계없이&lt;/strong&gt; 접근 시간이 일정&lt;/li&gt;
  &lt;li&gt;기억 소자에 대한 선택 기능이 명확&lt;/li&gt;
  &lt;li&gt;주기억 장치의 성능은 기억 용량이 크고 사이클 타임이 빠르며, &lt;strong&gt;밴드 폭이 클수록&lt;/strong&gt; 좋다&lt;/li&gt;
  &lt;li&gt;주기억 장치의 바이트 저장 순서에는 빅-엔디안 방식과 리틀-엔디안 방식이 존재
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;빅 엔디안(Big-Endinan)&lt;/strong&gt;&lt;br /&gt;
큰 쪽(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MSB&lt;/code&gt;)이 먼저 저장되는 방식&lt;/p&gt;

        &lt;p&gt;모토롤라 프로세서, IBM 370, RISC 기반 컴퓨터에서 사용&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;리틀 엔디안(Little-Endian)&lt;/strong&gt;&lt;br /&gt;
작은 쪽(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LSB&lt;/code&gt;)이 먼저 저장되는 방식&lt;/p&gt;

        &lt;p&gt;인텔 프로세서, DEC의 알파 프로세서에서 사용&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;용도&quot;&gt;용도&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;수행 중인 프로그램을 저장하는데 사용&lt;/li&gt;
  &lt;li&gt;수행 중인 프로그램이 사용할 데이터를 저장하는데 사용&lt;/li&gt;
  &lt;li&gt;수행 중인 프로그램이 사용할 임시 기억 장소로 사용&lt;/li&gt;
  &lt;li&gt;보조 기억 장치를 위한 버퍼로도 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;버퍼-메모리buffer-memory&quot;&gt;버퍼 메모리(Buffer Memory)&lt;/h3&gt;
&lt;p&gt;CPU와 주기억 장치 사이에서 데이터를 주기억 장치에서 읽어내거나, 주기억 장치에 저장하기 위해 임시로 자료를 기억시키는 &lt;strong&gt;캐시와 CPU와 입출력 장치 사이의 속도 차이를 줄이기 위해&lt;/strong&gt; 주기억 장치의 일부를 사용하는 입출력 버퍼&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;장치 사이의 속도 차이를 극복하기 위해 임시로 자료를 기억하는 공간&lt;/li&gt;
  &lt;li&gt;한 번 버퍼에 기억시킨 데이터는 여러 번 사용&lt;/li&gt;
  &lt;li&gt;버퍼 공간만큼 한 번에 많은 데이터를 이동시킬 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;반도체-메모리&quot;&gt;반도체 메모리&lt;/h2&gt;
&lt;h3 id=&quot;ramrandom-access-memory&quot;&gt;RAM(Random Access Memory)&lt;/h3&gt;
&lt;p&gt;전원 공급이 되지 않으면 기억된 정보가 사라지는 휘발성 메모리&lt;/p&gt;

&lt;h4 id=&quot;dramdynamic-ram&quot;&gt;DRAM(Dynamic RAM)&lt;/h4&gt;
&lt;p&gt;컴퓨터의 주기억 장치로 사용되는 RAM으로 &lt;strong&gt;콘덴서에 전하를 충전&lt;/strong&gt;하는 형태의 원리를 이용하는 메모리이며 &lt;strong&gt;재충전&lt;/strong&gt;이 필요한 메모리이다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소비 &lt;strong&gt;전력이 낮고&lt;/strong&gt; &lt;strong&gt;집적도가 높다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;속도가 떨어&lt;/strong&gt;지지만 &lt;strong&gt;가격이 저렴&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;집적도&lt;/strong&gt; : 한 개의 반도체 칩에 구성되어 있는 소자의 개수를 의미&lt;/p&gt;

&lt;h4 id=&quot;sramstatic-ram&quot;&gt;SRAM(Static RAM)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;플립플롭 형태로 구성&lt;/strong&gt;되어 액세스 속도가 빠르며 전원이 공급되는 동안은 재충전이 필요 없는 메모리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소비 &lt;strong&gt;전력이 크고&lt;/strong&gt; &lt;strong&gt;집적도가 낮다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;속도가 빠르&lt;/strong&gt;지만 &lt;strong&gt;가격이 비싸다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;주로 &lt;strong&gt;캐시 메모리&lt;/strong&gt;에 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;romread-only-memory&quot;&gt;ROM(Read Only Memory)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;비휘발성 메모리로 읽기만 가능&lt;/strong&gt;하기 때문에 ROM의 &lt;strong&gt;내용을 임의로 변경할 수 없다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;제어용 프로그램(마이크로 프로그램) 또는 모니터 프로그램 등을 고정시켜 사용&lt;/p&gt;

&lt;h4 id=&quot;mask-rom&quot;&gt;Mask ROM&lt;/h4&gt;
&lt;p&gt;제조 과정에서 &lt;strong&gt;Mask를 사용&lt;/strong&gt;하여 논리 회로를 구현시켜 &lt;strong&gt;정보를 저장하는 것으로 변경시킬 수 없다&lt;/strong&gt;. 마스크 제작비가 고가이므로 수요가 많을 경우에 사용&lt;/p&gt;

&lt;h4 id=&quot;prom&quot;&gt;PROM&lt;/h4&gt;
&lt;p&gt;논리 회로 구현을 &lt;strong&gt;한 번에 한해서&lt;/strong&gt; 사용자가 PROM 프로그램 장치를 가지고 &lt;strong&gt;직접 입력&lt;/strong&gt;하여 구현할 수 있는 ROM&lt;/p&gt;

&lt;h4 id=&quot;epromuveprom&quot;&gt;EPROM(UVEPROM)&lt;/h4&gt;
&lt;p&gt;논리 회로의 구현을 사용자가 &lt;strong&gt;여러 번 할 수 있는 ROM&lt;/strong&gt;으로 &lt;strong&gt;자외선을 이용하여 지우고&lt;/strong&gt;, 다시 PROM 프로그램 장치로 입력하여 논리 회로를 구성할 수 있다&lt;/p&gt;

&lt;h4 id=&quot;eeprom&quot;&gt;EEPROM&lt;/h4&gt;
&lt;p&gt;EAPROM이라고도 하며 &lt;strong&gt;사용자가 여러 번 지우고 기입&lt;/strong&gt;할 수 있는 ROM으로 &lt;strong&gt;전기적&lt;/strong&gt;으로 지우고 다시 쓸 수 있는 ROM을 의미&lt;/p&gt;

&lt;h4 id=&quot;flash-memory&quot;&gt;Flash Memory&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;전기적&lt;/strong&gt;으로 데이터를 지우고 다시 기록할 수 있는 &lt;strong&gt;비휘발성&lt;/strong&gt; 컴퓨터 기억 장치로 EEPROM과 다르게 &lt;strong&gt;여러 구역으로 구성된 블록 안에서&lt;/strong&gt; 지우고 쓸 수 있게 구성되어 있으며 EEPROM보다 &lt;strong&gt;비용이 저렴하다&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;NOR형&lt;br /&gt;
비트 혹은 바이트 단위의 읽기 쓰기 가능. 작은 데이터의 수시 인출 및 변경 용도에 적합하다&lt;/p&gt;

    &lt;p&gt;PC-BIOS 저장 장치, 스마트폰 OS 저장 장치&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NAND형&lt;br /&gt;
반도체 셀이 &lt;strong&gt;직렬&lt;/strong&gt;로 배열되어 있는 플래시 종류&lt;br /&gt;
셀을 &lt;strong&gt;수직&lt;/strong&gt;으로 배열하기 때문에 좁은 면적에 많은 셀을 만들 수 있어서 &lt;strong&gt;대용량 저장 장치로 적합&lt;/strong&gt;&lt;br /&gt;
블록 단위로 구성되어 있으며 블록을 &lt;strong&gt;지우기 전에 새로 쓸 수 없다&lt;/strong&gt;. 또한 &lt;strong&gt;블록 단위로만 재기록&lt;/strong&gt;이 가능&lt;br /&gt;
메모리 중에서 가장 &lt;strong&gt;읽기 속도가 느리다&lt;/strong&gt;는 단점이 존재&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;hybrid-drive&quot;&gt;Hybrid Drive&lt;/h4&gt;
&lt;p&gt;저장된 내용이 사라지지 않는 비휘발성 &lt;strong&gt;플래시 메모리를 큰 용량&lt;/strong&gt;으로 구성하여 &lt;strong&gt;하드 디스크와 같이&lt;/strong&gt; 컴퓨터의 &lt;strong&gt;주된 저장 장치 역할&lt;/strong&gt;을 하도록 개발된 메모리&lt;/p&gt;

&lt;h3 id=&quot;ssdsolid-state-drive&quot;&gt;SSD(Solid State Drive)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;반도체를 이용&lt;/strong&gt;하여 &lt;strong&gt;정보를 저장&lt;/strong&gt;하는 장치로 HDD에 비해 속도가 빠르며 지연이나 실패율, 발열, 소음이 적은 장치&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;저장 방식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;SLC(Single Level Cell) : 1 Cell에 1bit 저장&lt;/li&gt;
      &lt;li&gt;MLC(Multiple Level Cell) : 1 Cell에 2bit 저장&lt;/li&gt;
      &lt;li&gt;TLC(Triple Level Cell) : 1 Cell에 3bit 저장&lt;/li&gt;
      &lt;li&gt;QLC(Quad Level Cell) : 1 Cell에 4bit 저장&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;span style=&quot;color: orangered;&quot;&gt;속도&lt;/span&gt; : (&lt;strong&gt;빠름&lt;/strong&gt;) SLC &amp;gt; MLC &amp;gt; TLC &amp;gt; QLC (&lt;strong&gt;느림&lt;/strong&gt;)&lt;br /&gt;
셀당 데이터 &lt;span style=&quot;color: orangered;&quot;&gt;저장 가능 용량&lt;/span&gt; : (&lt;strong&gt;낮다&lt;/strong&gt;) SLC &amp;lt; MLC &amp;lt; TLC &amp;lt; QLC (&lt;strong&gt;높다&lt;/strong&gt;)&lt;br /&gt;
&lt;span style=&quot;color: orangered;&quot;&gt;수명&lt;/span&gt; : (&lt;strong&gt;길다&lt;/strong&gt;) SLC &amp;gt; MLC &amp;gt; TLC &amp;gt; QLC (&lt;strong&gt;짧다&lt;/strong&gt;)&lt;br /&gt;
전기 충격을 QLC가 SLC보다 많이 받기 때문에 수명은 SLC가 가장 길다&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;plaprogrammable-logic-array&quot;&gt;PLA(Programmable Logic Array)&lt;/h3&gt;
&lt;p&gt;ROM이나 PLA이 입력측은 AND Array로 출력측은 OR Array로 구현되어 있지만 PLA가 출력측의 회로를 고정시키고 입력측을 원하는 형태로 설계하여 구현하는 반면 ROM은 입력측을 고정시키고 출력측을 원하는 형태로 설계하여 구현하는 방식&lt;/p&gt;

&lt;h3 id=&quot;palprogrammable-array-logic&quot;&gt;PAL(Programmable Array Logic)&lt;/h3&gt;
&lt;p&gt;PLA와 달리 OR 플레인이 고정된 형태. PAL 디바이스는 AND 게이트만을 프로그래밍을 할 수 있기에 덜 복잡하고 그 만큼 저렴하게 생산이 가능하고 디자인에서의 복잡함도 감소되었다&lt;/p&gt;

&lt;h3 id=&quot;cpldcomplex-programmable-logic-device&quot;&gt;CPLD(Complex Programmable Logic Device)&lt;/h3&gt;
&lt;p&gt;LAB, PLA로 구성되어 규칙적이고 빠른 타이밍이 필요하거나 어드레스 디코더 같은 간단한 로직 구현에 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로직을 저장한 내장 플래시를 가진다&lt;/li&gt;
  &lt;li&gt;Sum of Products와 같은 로직으로 내부 구조가 구성되어 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fpgafield-programmable-gate-array&quot;&gt;FPGA(Field Programmable Gate Array)&lt;/h3&gt;
&lt;p&gt;논리 소자와 메모리가 포함된 반도체 소자로 속도가 느리고 소비전력이 크지만 개발 시간이 짧고 오류 수정이 쉬우며 개발비가 저렴하다는 장점이 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPLD보다 더 많은 게이트를 내장하고 있고 더 복잡한 로직을 프로그래밍 할 수 있다&lt;/li&gt;
  &lt;li&gt;외부에 플래시가 필요&lt;/li&gt;
  &lt;li&gt;Look-up 테이블로 내부 구조가 구성되어 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자기-코어-메모리magnetic-core-memory&quot;&gt;자기 코어 메모리(Magnetic Core Memory)&lt;/h2&gt;
&lt;p&gt;아주 작은 원형 자성 물질인 &lt;strong&gt;코어에 4개의 도선&lt;/strong&gt;이 꿰어져 있으며, 이 도선을 사용해서 자기 코어 메모리에 필요한 정보를 입출력할 수 있다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;X선, Y선&lt;/strong&gt;(Driving Wire-구동선) : 코어를 자화시키기 위해 자화에 필요한 전력의 1/2을 공급하는 도선&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;S선&lt;/strong&gt;(Sense Wire-감지선) : 판독을 위해 구동선에 전력을 가했을 때 자장의 변화를 감지하여 0과 1의 저장 여부를 판단하는 선&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Z선&lt;/strong&gt;(Inhibit Wire-금지선) : 원하지 않는 곳의 자화를 방지하는 선&lt;/p&gt;

&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;전류 일치 기술&lt;/strong&gt;(Coincident-Current Technique)에 의하여 기억 장소를 선별하는 기억 장치&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비휘발성&lt;/strong&gt; 메모리&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;파괴성 판독(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DRO&lt;/code&gt;)&lt;/strong&gt; 메모리이므로 자신의 값을 보존하기 위해 재저장이 필요하다&lt;/p&gt;

    &lt;p class=&quot;notice--info&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;파괴성 판독&lt;/strong&gt; : 데이터를 읽어내면서 원래의 데이터를 소거하는 판독 방법으로 정보를 보존하려면 읽어낸 뒤 즉시 &lt;strong&gt;재기입&lt;/strong&gt;해야 하기 때문에 &lt;strong&gt;사이클 시간&lt;/strong&gt;이 접근 시간에 비해 &lt;strong&gt;크다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;자기 코어의 중심을 통과하는 전선에 흐르는 전류가 오른나사법칙에 따라 1 혹은 0으로 자회되어 기억된다&lt;/li&gt;
  &lt;li&gt;사이클 타임이 기억 장치의 액세스 타임보다 항상 크거나 같은 관계식을 갖는 메모리&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자기 드럼이나 자기 디스크에 비해&lt;/strong&gt; 호출 속도가 매우 &lt;strong&gt;빠르다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 08 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-main-storage/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-main-storage/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 제어</title>
        <description>&lt;h2 id=&quot;제어-장치의-구성&quot;&gt;제어 장치의 구성&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;명령어 해독기(Instruction Decoder)&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;명령 레지스터&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IR&lt;/code&gt;, Instruction Register)에 호출된 &lt;strong&gt;OP-Code를 해독&lt;/strong&gt;하여 그 명령을 수행시키는데 필요한 각종 제어 신호를 만들어 내는 장치&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;순서 제어기(Sequence Controller)&lt;/strong&gt;&lt;br /&gt;
마이크로 명령어의 실행 &lt;strong&gt;순서를 결정&lt;/strong&gt;하는 장치&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제어 주소 레지스터(CAR, Control Address Register)&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;제어 메모리의 주소&lt;/strong&gt;를 기억하는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제어 메모리(Control Memory)&lt;/strong&gt;&lt;br /&gt;
마이크로 명령어들로 이루어진 &lt;strong&gt;마이크로프로그램을 저장하는 내부 기억 장치&lt;/strong&gt;로 액세스 타임이 빠른 ROM으로 만들어진다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제어 버퍼 레지스터(CBR, Control Bufer Register)&lt;/strong&gt;&lt;br /&gt;
제어 메모리로부터 읽혀진 &lt;strong&gt;마이크로 명령어를 일시적으로 기억&lt;/strong&gt;하는 레지스터&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cpu의-제어-데이터&quot;&gt;CPU의 제어 데이터&lt;/h2&gt;
&lt;p&gt;CPU의 제어 장치가 명령어 수행에 필요한 제어 신호를 발생하기 위해 아래와 같은 제어 데이터를 가지고 제어 규칙에 따라 제어 신호를 발생시키게 된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong class=&quot;red&quot;&gt;인출 상태&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;메이저 상태&lt;/strong&gt;를 변화시키는 제어 데이터 : 명령어&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CPU의 제어점&lt;/strong&gt;을 제어하는 제어 데이터 :  명령어&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;명령 수행 순서&lt;/strong&gt;를 결정하는 제어 데이터 : 명령어&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong class=&quot;red&quot;&gt;간접 상태&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;메이저 상태&lt;/strong&gt;를 변화시키는 제어 데이터 : 직/간접 주소를 판별하는 비트&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CPU의 제어점&lt;/strong&gt;을 제어하는 제어 데이터 : 명령어의 &lt;strong&gt;연산자 부분&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;명령 수행 순서&lt;/strong&gt;를 결정하는 제어 데이터 : 기억 장치에서 읽어낸 &lt;strong&gt;실제 데이터의 주소&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong class=&quot;red&quot;&gt;실행 상태&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;메이저 상태&lt;/strong&gt;를 변화시키는 제어 데이터 : &lt;strong&gt;인터럽트&lt;/strong&gt; 요청 신호&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CPU의 제어점&lt;/strong&gt;을 제어하는 제어 데이터 : 명령어의 &lt;strong&gt;연산자 부분&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;명령 수행 순서&lt;/strong&gt;를 결정하는 제어 데이터 : &lt;strong&gt;Program Counter&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong class=&quot;red&quot;&gt;인터럽트 주기&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;메이저 상태&lt;/strong&gt;를 변화시키는 제어 데이터 : 없음&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CPU의 제어점&lt;/strong&gt;을 제어하는 제어 데이터 : 컴퓨터 기종에 따라 다름&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;명령 수행 순서&lt;/strong&gt;를 결정하는 제어 데이터 : 컴퓨터 기종에 따라 다름&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;마이크로-프로그램&quot;&gt;마이크로 프로그램&lt;/h2&gt;
&lt;p&gt;어떤 명령을 수행할 수 있는 &lt;strong&gt;일련의 제어 워드&lt;/strong&gt;가 특수한 기억 장치(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROM&lt;/code&gt;) 속에 &lt;strong&gt;저장&lt;/strong&gt;되어 기계어 명령어들이 적절히 수행되도록 각종 &lt;strong&gt;제어 신호를 발생시키는 프로그램&lt;/strong&gt;을 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU 내의 제어 장치를 설계하는 프로그램&lt;/li&gt;
  &lt;li&gt;마이크로 명령어로 형성되어 있다
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;마이크로 명령어&lt;/strong&gt; : 데이터 경로 제어를 위해 제어 신호 발생에 필요한 정보와 수행 순서를 제어하는 정보로 구성되어 있으며 마이크로 사이클 타임 동안에 수행해야 할 마이크로 액션을 나타낸다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제어 메모리는 보통 빠른 사이클 타임이 요구되므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROM&lt;/code&gt;을 사용하는 것이 일반적&lt;/li&gt;
  &lt;li&gt;하드웨어와 소프트웨어의 중간적인 것으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;펌웨어&lt;/code&gt;라고도 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;제어-메모리에서-번지-결정-방법&quot;&gt;제어 메모리에서 번지 결정 방법&lt;/h2&gt;
&lt;p&gt;제어 메모리에 저장된 마이크로프로그램에서 현재 수행 중인 마이크로 명령어가 끝났을 때 &lt;strong&gt;다음에 수행해야 할 마이크로 명령어의 주소를 결정&lt;/strong&gt;하는 방법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;순차 수행&lt;/strong&gt;&lt;br /&gt;
마이크로프로그램 내에 있는 마이크로 명령어의 순서에 따라 차례대로 수행하는 경우로 &lt;strong&gt;제어 주소 레지스터(CAR)의 내용을 1증가&lt;/strong&gt;하여 결정하는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;무조건 분기&lt;/strong&gt;&lt;br /&gt;
수행 중인 마이크로 명령어 상에 있는 분기 주소에 나타난 다음 마이크로 명령어를 수행하는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;조건 분기&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;상태 비트&lt;/strong&gt;의 내용에 따라 조건부 분기하는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;서브 루틴 Call/Return&lt;/strong&gt;&lt;br /&gt;
마이크로프로그램 내에 있는 독립된 &lt;strong&gt;서브 마이크로프로그램을 호출&lt;/strong&gt;하여 수행하는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;매크로&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;반복되는 부분&lt;/strong&gt;을 매크로로 정의하고 직접 제어 메모리로 &lt;strong&gt;매핑&lt;/strong&gt;하는 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;제어-장치의-구현-방법&quot;&gt;제어 장치의 구현 방법&lt;/h2&gt;
&lt;h3 id=&quot;고정-배선식hard-wired-제어-방식&quot;&gt;고정 배선식(Hard Wired) 제어 방식&lt;/h3&gt;
&lt;p&gt;제어 장치가 순서 회로로 만들어진 것으로 &lt;strong&gt;미리 정해 놓은 제어 신호들이 순서대로 발생&lt;/strong&gt;하도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하드웨어적&lt;/code&gt;으로 구현한 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;마이크로프로그램 제어 방식보다 속도가 &lt;strong&gt;빠르다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;한 번 만들어진 것은 동작 방법이 바뀌었을 때 &lt;strong&gt;변경할 수 없다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;제작이 어렵고&lt;/strong&gt; 집적화가 어려워 &lt;strong&gt;비용이 비싸다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;마이크로프로그램microprogram-제어-방식&quot;&gt;마이크로프로그램(Microprogram) 제어 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;마이크로 명령어로 구성하여 작성하므로 &lt;strong&gt;쉽게 설계를 변경&lt;/strong&gt;할 수 있다&lt;/li&gt;
  &lt;li&gt;마이크로 명령어를 인출하는 별도의 시간때문에 속도가 &lt;strong&gt;느리다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;마이크로프로그램을 저장하기 위한 &lt;strong&gt;제어 메모리가 필요&lt;/strong&gt;하다&lt;/li&gt;
  &lt;li&gt;마이크로프로그램에 대한 &lt;strong&gt;유지보수 및 오류 수정이 용이&lt;/strong&gt;하다&lt;/li&gt;
  &lt;li&gt;명령어 세트가 복잡하고 큰 컴퓨터에서 &lt;strong&gt;비용이 절감&lt;/strong&gt;된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;마이크로-명령어-형식&quot;&gt;마이크로 명령어 형식&lt;/h2&gt;
&lt;h3 id=&quot;수평horizontal-마이크로-명령어&quot;&gt;수평(Horizontal) 마이크로 명령어&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;제어 메모리의 모양이 수평(비트) 방향으로 길고&lt;/strong&gt;, 수직 방향으로 짧은 모양이어서 수평 마이크로 명령어라고 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;마이크로 명령어에 마이크로 액션 수행에 관계되는 제어점을 직접 나타내니 때문에 &lt;strong&gt;직접 마이크로 명령어&lt;/strong&gt;라고도 한다&lt;/li&gt;
  &lt;li&gt;마이크로 명령어의 각 비트는 중앙 처리 장치의 &lt;strong&gt;독립 제어점과 1:1로 연결&lt;/strong&gt;되어 있으므로 디코더가 필요없으나 비트 수가 많이 필요하므로 하나의 &lt;strong&gt;명령어가 길다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디코딩이 필요없&lt;/strong&gt;으므로 수행 속도가 &lt;strong&gt;빠르며&lt;/strong&gt; &lt;strong&gt;병렬 수행&lt;/strong&gt;도 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;수직vertical-마이크로-명령어&quot;&gt;수직(Vertical) 마이크로 명령어&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;제어 메모리의 모양이 수직(단어) 방향으로 길고&lt;/strong&gt;, 수평 방향으로 짧은 모양이어서 수직 마이크로 명령어라고 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;마이크로 명령어에 마이크로 액션 수행에 관계되는 제어점을 직접 나타내는 것이 아니라 &lt;strong&gt;제어점 정보를 몇 개의 그룹으로 분류&lt;/strong&gt;하여 부호화해서 나타내기 때문에 &lt;strong&gt;부호화 마이크로 명령어&lt;/strong&gt;라고도 한다&lt;/li&gt;
  &lt;li&gt;명령어의 길이가 짧은 대신에 수행 속도가 &lt;strong&gt;느리다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;나노-명령어&quot;&gt;나노 명령어&lt;/h3&gt;
&lt;p&gt;나노 메모리에 들어있는 마이크로 명령어를 나노 명령어라고 하며, &lt;strong&gt;작은 용량의 제어 메모리&lt;/strong&gt;와 &lt;strong&gt;큰 용량의 나노 메모리&lt;/strong&gt;를 &lt;strong&gt;계층적&lt;/strong&gt;으로 운영하는 형태&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;마이크로프로그램의 크기가 2048 X 64bit 일 때&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;마이크로 명령어의 수가 128개라면&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;나노 메모리의 크기
    &lt;ul&gt;
      &lt;li&gt;마이크로 명령어의 길이 = 64bit&lt;/li&gt;
      &lt;li&gt;나노 메모리는 64비트짜리 마이크로 명령어 128개를 저장해 놓으면 되므로 &lt;strong&gt;128 X 64bit&lt;/strong&gt; 크기를 가진다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;제어 메모리의 크기
    &lt;ul&gt;
      &lt;li&gt;나노 메모리의 마이크로 명령어 수 = 128개&lt;/li&gt;
      &lt;li&gt;제어 메모리의 워드 크기는 7비트로 설계되어야 한다&lt;/li&gt;
      &lt;li&gt;마이크로프로그램은 2048개의 명령이 필요하다&lt;/li&gt;
      &lt;li&gt;제어 메모리는 7비트짜리 워드 2048개를 저장해 놓으면 되므로 &lt;strong&gt;2048 X 7bit&lt;/strong&gt;가 필요하다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 08 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-control/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-control/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 명령어 사이클</title>
        <description>&lt;h2 id=&quot;명령어의-수행&quot;&gt;명령어의 수행&lt;/h2&gt;
&lt;h3 id=&quot;순서&quot;&gt;순서&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;명령어 인출(Instruction Fetch)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;명령어 해독(Instruction Decoder)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오퍼랜드 인출(Operand Fetch)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;실행(Execute)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인터럽트 조사(Interrupt Search Into)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p class=&quot;notice--warning&quot;&gt;명령어 인출 과정에서 인터럽트가 발생하더라도 &lt;strong&gt;CPU는 인터럽트를 인지하지 못하고&lt;/strong&gt; 하나의 명령어 &lt;strong&gt;실행이 완전히 끝난 상태&lt;/strong&gt;에서 인터럽트의 발생 여부를 조사하여 인터럽트가 발생하였다는 것을 인지하게 되는 것이다&lt;/p&gt;

&lt;h3 id=&quot;수행-시간&quot;&gt;수행 시간&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Memory Read 또는 Write Cycle이 명령어 수행 시간에 지배적인 영향을 준다&lt;/li&gt;
  &lt;li&gt;수행 시간은 명령어 종류에 따라 약간씩 다르다&lt;/li&gt;
  &lt;li&gt;명령어 수행 시간은 여러 개의 Machine Cycle로 구성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;성능&quot;&gt;성능&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;$명령어의 성능 = \frac{인스트럭션 수행 시간}{인스터럭션 패치 시간 + 인스트럭션 준비 시간}$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p class=&quot;notice--success&quot;&gt;&lt;strong&gt;속도 단위&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;as&lt;/strong&gt;(아토초) : 10&lt;sup&gt;&lt;strong&gt;-18&lt;/strong&gt;&lt;/sup&gt; = 1/10&lt;sup&gt;&lt;strong&gt;18&lt;/strong&gt;&lt;/sup&gt;&lt;br /&gt;
&lt;strong&gt;fs&lt;/strong&gt;(펨토초) : 10&lt;sup&gt;&lt;strong&gt;-15&lt;/strong&gt;&lt;/sup&gt; = 1/10&lt;sup&gt;&lt;strong&gt;15&lt;/strong&gt;&lt;/sup&gt;&lt;br /&gt;
&lt;strong&gt;㎰&lt;/strong&gt;(피코초) : 10&lt;sup&gt;&lt;strong&gt;-12&lt;/strong&gt;&lt;/sup&gt; = 1/10&lt;sup&gt;&lt;strong&gt;12&lt;/strong&gt;&lt;/sup&gt;&lt;br /&gt;
&lt;strong&gt;㎱&lt;/strong&gt;(나노초) : 10&lt;sup&gt;&lt;strong&gt;-9&lt;/strong&gt;&lt;/sup&gt; = 1/10&lt;sup&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/sup&gt;&lt;br /&gt;
&lt;strong&gt;㎲&lt;/strong&gt;(마이크로초) : 10&lt;sup&gt;&lt;strong&gt;-6&lt;/strong&gt;&lt;/sup&gt; = 1/10&lt;sup&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/sup&gt;&lt;br /&gt;
&lt;strong&gt;㎳&lt;/strong&gt;(밀리초) : 10&lt;sup&gt;&lt;strong&gt;-3&lt;/strong&gt;&lt;/sup&gt; = 1/10&lt;sup&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;strong&gt;진동수 단위&lt;/strong&gt;(Hz)&lt;br /&gt;
KHz : 1초에 10&lt;sup&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/sup&gt;번 진동&lt;br /&gt;
MHz : 1초에 10&lt;sup&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/sup&gt;번 진동&lt;br /&gt;
GHz : 1초에 10&lt;sup&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/sup&gt;번 진동&lt;br /&gt;
THz : 1초에 10&lt;sup&gt;&lt;strong&gt;12&lt;/strong&gt;&lt;/sup&gt;번 진동&lt;/p&gt;

&lt;h2 id=&quot;마이크로-오퍼레이션&quot;&gt;마이크로 오퍼레이션&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;CPU에서 발생시키는 &lt;strong&gt;하나의 클록 펄스 동안 실행되는 기본 동작&lt;/strong&gt;을 의미&lt;/li&gt;
  &lt;li&gt;CPU에 있는 레지스터와 플래그의 &lt;strong&gt;상태 변환을 일으키게 하는 동작&lt;/strong&gt;을 의미&lt;/li&gt;
  &lt;li&gt;CPU에서 발생시키는 &lt;strong&gt;제어 신호에 따라&lt;/strong&gt; 마이크로 오퍼레이션이 &lt;strong&gt;순서적&lt;/strong&gt;으로 일어난다&lt;/li&gt;
  &lt;li&gt;명령어의 수행은 마이크로 오퍼레이션의 수행으로 이루어진다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;일반-형식&quot;&gt;일반 형식&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;단항&lt;/strong&gt; 마이크로 오퍼레이션&lt;br /&gt;
Rd &lt;strong&gt;←&lt;/strong&gt; F(R1)&lt;br /&gt;
&lt;br /&gt;
&lt;strong&gt;이항&lt;/strong&gt; 마이크로 오퍼레이션&lt;br /&gt;
Rd &lt;strong&gt;←&lt;/strong&gt; F(R1, R2)&lt;br /&gt;
&lt;sub&gt;Rd: 결과가 들어갈 레지스터&lt;br /&gt;
F: 처리기&lt;br /&gt;
R1, R2: 연산 대상체가 들어 있는 레지스터&lt;/sub&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;주요-동작&quot;&gt;주요 동작&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;MAR ← MBR(AD) : 기억 레지스터에 번지부 전송&lt;/li&gt;
  &lt;li&gt;IR ← MBR(OP) : 명령 레지스터에 명령 코드 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A ← CONSTANT : 레지스터 A에 상수 전송&lt;/li&gt;
  &lt;li&gt;A ← A + B : A와 B를 합하여 A에 기억&lt;/li&gt;
  &lt;li&gt;A ← A - B : A에서 B를 뺄셈하여 A에 기억&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A ← A｀: A 내용의 1의 보수&lt;/li&gt;
  &lt;li&gt;A ← A｀+ 1 : A 내용의 2의 보수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;F ← A ∧ B : A와 B의 논리곱&lt;/li&gt;
  &lt;li&gt;F ← A XOR B : A와 B의 베타적 논리합&lt;/li&gt;
  &lt;li&gt;F ← A ∨ B : A와 B의 논리합&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;마이크로-사이클-시간&quot;&gt;마이크로 사이클 시간&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;마이크로 사이클&lt;/strong&gt;은 &lt;strong&gt;하나의 오퍼레이션을 수행하는 과정&lt;/strong&gt;을 의미하며&lt;/p&gt;

&lt;p&gt;마이크로 사이클을 실행하는 시간을 마이크로 사이클 타임 또는 CPU Clock Time이라 한다&lt;/p&gt;

&lt;h3 id=&quot;동기-고정식synchronous-fixed&quot;&gt;동기 고정식(Synchronous Fixed)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여러 개의 마이크로 오퍼레이션 동작 중에서 &lt;strong&gt;마이크로 사이클 타임이 가장 긴 것을 선택&lt;/strong&gt;하여 CPU의 클록 주기로 사용하는 방식&lt;/li&gt;
  &lt;li&gt;CPU의 시간 이용이 &lt;strong&gt;비효율적&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;모든 마이크로 오퍼레이션 &lt;strong&gt;수행 시간이 유사&lt;/strong&gt;한 경우 사용&lt;/li&gt;
  &lt;li&gt;제어 장치의 &lt;strong&gt;구현이 간단&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;동기-가변식synchronous-variable&quot;&gt;동기 가변식(Synchronous Variable)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;마이크로 오퍼레이션 동작들을 마이크로 사이클 타임에 따라 &lt;strong&gt;몇 개의 군으로 분류&lt;/strong&gt;하여 &lt;strong&gt;군별로 CPU의 클록 주기를 따로따로 부여&lt;/strong&gt;하는 방식&lt;/li&gt;
  &lt;li&gt;마이크로 오퍼레이션 &lt;strong&gt;수행 시간의 차이가 현저할 때&lt;/strong&gt; 사용&lt;/li&gt;
  &lt;li&gt;클록 주기 시간은 &lt;strong&gt;정수배&lt;/strong&gt;가 될 수 있도록 해야 각 집합 간 서로 다른 사이클 타임의 동기를 맞추기 쉽고 제어 장치 설계가 쉬워진다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비동기식asynchronous&quot;&gt;비동기식(Asynchronous)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;모든 마이크로 오퍼레이션에 대해 &lt;strong&gt;서로 다른 마이크로 사이클 시간&lt;/strong&gt;을 부여하는 방식&lt;/li&gt;
  &lt;li&gt;하나의 오퍼레이션 동작이 끝나면 &lt;strong&gt;끝난 사실을 제어 장치에 알려 다음 오퍼레이션이 수행&lt;/strong&gt;되도록 하여야 하므로 &lt;strong&gt;제어 장치가 복잡&lt;/strong&gt;하게 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;메이저-상태major-state&quot;&gt;메이저 상태(Major State)&lt;/h2&gt;
&lt;p&gt;기억 장치의 주기 시간을 단위로 하여 해당 주기 동안에 &lt;strong&gt;기억 장치로 접근할 때 무엇을 위해서 접근하는지를 표시&lt;/strong&gt;하는 &lt;strong&gt;주 상태&lt;/strong&gt;와 시간에 관한 정보를 나타내는 시간 상태가 있다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;메이저 상태&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Major State&lt;/code&gt;)는 CPU가 무엇을 하고 있는가를 나타내는 상태로 Machine Cycle이라고도 한다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;시간 상태&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Timing State&lt;/code&gt;)는 메이저 상태에서 &lt;strong&gt;마이크로 오퍼레이션이 수행되는 시간을 나타내는 것&lt;/strong&gt;으로 &lt;strong&gt;타이밍 상태 계수기&lt;/strong&gt;를 이용하여 나타내며 하나의 마이크로 오퍼레이션이 수행될 때마다 &lt;strong&gt;하나씩 증가&lt;/strong&gt;시켜 나타낸다&lt;/p&gt;

&lt;h3 id=&quot;종류&quot;&gt;종류&lt;/h3&gt;
&lt;p&gt;메이저 상태는 주기억 장치에 무엇을 위해 접근하는지에 따라 인출, 간접, 실행, 인터럽트 4가지 상태가 존재하며, 이 상태는 F,R 플래그의 상태를 가지고 파악한다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;상태&lt;/th&gt;
      &lt;th&gt;F&lt;/th&gt;
      &lt;th&gt;R&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;인출&lt;/strong&gt; 주기&lt;br /&gt;(Fetch Cycle)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;간접&lt;/strong&gt; 주기&lt;br /&gt;(Indirect)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;실행&lt;/strong&gt; 주기&lt;br /&gt;(Execute)&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;인터럽트&lt;/strong&gt; 주기&lt;br /&gt;(Interrupt)&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;관계&quot;&gt;관계&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/instruction-cycle.png&quot; title=&quot;https://quickcse.wordpress.com/2018/09/10/micro-operations/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/instruction-cycle.png&quot; alt=&quot;&quot; title=&quot;메이저 사이클의 관계&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;인출 주기가 완료되면 해독 결과에 따라 &lt;strong&gt;직접 주소이면 바로 실행 주기로 진행&lt;/strong&gt;하고, &lt;strong&gt;간접 주소이면 간접 주기를 거쳐서&lt;/strong&gt; 실행 주기로 진행된다&lt;/p&gt;

&lt;p&gt;실행 주기에서는 인터럽트 발생 여부에 따라 &lt;strong&gt;인터럽트가 발생&lt;/strong&gt;했으면 &lt;strong&gt;인터럽트 주기&lt;/strong&gt;로 진행하고 그렇지 않으면 &lt;strong&gt;인출 주기로 진행&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;인터럽트 주기에서는 &lt;strong&gt;항상 인출 주기&lt;/strong&gt;로 진행&lt;/p&gt;

&lt;h2 id=&quot;메이저-사이클의-마이크로-오퍼레이션&quot;&gt;메이저 사이클의 마이크로 오퍼레이션&lt;/h2&gt;
&lt;h3 id=&quot;인출-주기fetch-cycle&quot;&gt;인출 주기(Fetch Cycle)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;명령어를 &lt;strong&gt;기억 장치에서 CPU로 읽어&lt;/strong&gt;오는 주기&lt;/li&gt;
  &lt;li&gt;명령어를 &lt;strong&gt;해독&lt;/strong&gt;하는 주기&lt;/li&gt;
  &lt;li&gt;명령어의 &lt;strong&gt;종류가 판단&lt;/strong&gt;되는 주기&lt;/li&gt;
  &lt;li&gt;PC가 하나 증가되어 다음 명령어를 지시하는 주기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-fetch-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-fetch-cycle.png&quot; alt=&quot;&quot; title=&quot;인출 주기 마이크로 오퍼레이션&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;간접-주기indirect-cycle&quot;&gt;간접 주기(Indirect Cycle)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;유효주소를 얻기 위하여 기억 장치에 한 번 더 접근하는 주기&lt;/li&gt;
  &lt;li&gt;오퍼랜드에 표현된 주소가 간접 주소인 경우에 수행되는 주기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-indirect-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-indirect-cycle.png&quot; alt=&quot;&quot; title=&quot;간접 주기 마이크로 오퍼레이션&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;실행-주기execute-cycle&quot;&gt;실행 주기(Execute Cycle)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;기억 장치로부터 실제 데이터를 읽어다가 연산 동작을 수행시키는 주기&lt;/li&gt;
  &lt;li&gt;다양한 형태의 명령어가 분기 처리되는 주기&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;add-마이크로-동작&quot;&gt;ADD 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ACC&lt;/strong&gt;에 있는 내용과 &lt;strong&gt;메모리&lt;/strong&gt;에 있는 &lt;strong&gt;내용을 더해서&lt;/strong&gt; 결과를 ACC에 넣어놓는 연산&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-add-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-add-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(ADD 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;and-마이크로-동작&quot;&gt;AND 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ACC&lt;/strong&gt;에 있는 내용과 &lt;strong&gt;메모리&lt;/strong&gt;에 있는 내용을 &lt;strong&gt;논리곱&lt;/strong&gt;(AND)하여 결과를 ACC에 넣어놓는 연산&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-and-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-and-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(AND 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;loadlda-마이크로-동작&quot;&gt;LOAD(LDA) 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ACC를 0으로 초기화&lt;/strong&gt;하고 이 초기화된 누산기와 메모리에 있는 내용을 더해서 결과를 ACC에 넣어놓게 되면 &lt;strong&gt;메모리에 있는 내용을 누산기로 이동시킨 효과&lt;/strong&gt;를 보게 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-load-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-load-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(LOAD 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;storesta-마이크로-동작&quot;&gt;STORE(STA) 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ACC에 있는 내용을 지정된 &lt;strong&gt;메모리에 저장&lt;/strong&gt;시키는 연산&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-store-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-store-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(STORE 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;bunjump-마이크로-동작&quot;&gt;BUN(JUMP) 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램의 수행 제어 순서를 &lt;strong&gt;지정된 유효 번지로 분기&lt;/strong&gt;시키는 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-jump-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-jump-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(JUMP 마이크로 오퍼레이션&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;bsabranch-and-save-return-address-마이크로-동작&quot;&gt;BSA(Branch and Save Return Address) 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;복귀 주소를 저장하고 &lt;strong&gt;서브 프로그램으로 분기&lt;/strong&gt;하기 위한 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-bsa-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-bsa-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(BSA 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;iszincrement-and-skip-if-zero-마이크로-동작&quot;&gt;ISZ(Increment and Skip if Zero) 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램의 수행 순서를 조건에 따라 결정하는 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-isz-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-isz-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(ISZ 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;인터럽트-주기interrupt-cycle&quot;&gt;인터럽트 주기(Interrupt Cycle)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여러 가지 원인에 의해서 정상적으로 수행 과정을 계속할 수 없어 먼저 응급 조치를 취한 후에 계속 수행할 수 있도록 &lt;strong&gt;CPU의 현 상태를 보관하기 위해 기억 장치에 접근&lt;/strong&gt;하는 주기&lt;/li&gt;
  &lt;li&gt;명령어 수행 과정에서 인터럽트가 발생하더라도 반드시 해당 명령어가 완료된 상태에서 인터럽트를 처리하게 된다. 따라서 &lt;strong&gt;인터럽트 처리가 완료된 상태에서는 반드시 인출 주기로 진행&lt;/strong&gt;한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pc값을-메모리의-0번지에-저장할-때&quot;&gt;PC값을 메모리의 0번지에 저장할 때&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-interrupt-cycle-store-memory.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-interrupt-cycle-store-memory.png&quot; alt=&quot;&quot; title=&quot;인터럽트 주기(PC값을 메모리의 0번지에 저장할 때 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;pc값을-스택에-저장할-때&quot;&gt;PC값을 스택에 저장할 때&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-interrupt-cycle-store-stack.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-interrupt-cycle-store-stack.png&quot; alt=&quot;&quot; title=&quot;인터럽트 주기(PC값을 스택에 저장할 때 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-instruction-cycle/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-instruction-cycle/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 레지스터(Register)</title>
        <description>&lt;h2 id=&quot;레지스터register&quot;&gt;레지스터(Register)&lt;/h2&gt;
&lt;p&gt;주기억 장치보다 &lt;strong&gt;작은 개수의 주소 비트&lt;/strong&gt;를 가지고 기억된 정보를 신속하게 접근할 수 있는 기억 장소로 중앙 처리 장치 안에 &lt;strong&gt;임시 기억 장치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;중앙 처리 장치의 주소 선은 주소 레지스터(AR)와 연결되어 있고 데이터 선은 데이터 레지스터(DR)와 연결되어 있다. 따라서 &lt;strong&gt;메모리의 용량은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AR&lt;/code&gt;&lt;/strong&gt;과 관계가 있고 &lt;strong&gt;한 번에 엑세스되는 워드 크기는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DR&lt;/code&gt;&lt;/strong&gt;과 관계가 있다&lt;/p&gt;

&lt;h3 id=&quot;특수-전담-레지스터&quot;&gt;특수 전담 레지스터&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로그램 카운터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PC&lt;/code&gt;, Program Counter)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;로케이션 카운터(LC, Location Counter)라고도 한다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;다음 명령어의 주소 값을 기억&lt;/strong&gt;하고 있는 레지스터&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;명령어의 수행 순서&lt;/strong&gt;를 나타내는 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모리 번지 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAR&lt;/code&gt;, Memory Address Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;메모리에 접근하고자 할 때 &lt;strong&gt;접근하고자 하는 곳의 주소 값&lt;/strong&gt;을 기억하고 있는 레지스터&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;기억 장치의 용량&lt;/strong&gt;과 관계가 있는 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;기억 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MBR&lt;/code&gt;, Memory Buffer Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;주기억 장치에서 정보를 읽을 때 &lt;strong&gt;읽은 정보를 기억시키거나 주기억 장치에 정보를 기억&lt;/strong&gt;시키는 레지스터&lt;/li&gt;
      &lt;li&gt;기억 장치의 &lt;strong&gt;WORD 크기&lt;/strong&gt;와 관계가 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;명령 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IR&lt;/code&gt;, Instruction Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;현재 수행하고 있는 명령어를 기억&lt;/strong&gt;하는 레지스터&lt;/li&gt;
      &lt;li&gt;명령 레지스터에 있는 정보는 &lt;strong&gt;연산에 사용되지 않고&lt;/strong&gt; 명령 수행을 제어하기 위해 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-레지스터dr-data-register&quot;&gt;데이터 레지스터(DR, Data Register)&lt;/h3&gt;
&lt;p&gt;명령어 수행 시 수행에 &lt;strong&gt;필요한 데이터를 기억&lt;/strong&gt;시키는 레지스터로 &lt;strong&gt;기억 장치의 워드 크기&lt;/strong&gt;와 관계가 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;누산기(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACC&lt;/code&gt;, Accumulator)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산기능 수행 시 중심이 되는 데이터 레지스터로서 연산 장치에 연결되어 있다&lt;/li&gt;
      &lt;li&gt;연산시 연산에 사용되는 &lt;strong&gt;데이터 및 연산 결과를 임시적&lt;/strong&gt;으로 기억하는 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;기억 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MBR&lt;/code&gt;, Memory Buffer Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;주기억 장치에서 읽은 정보&lt;/strong&gt;나 저장시킬 정보를 임시적으로 기억시키는 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;범용 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GPR&lt;/code&gt;, General Purpose Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;함수 연산 기능을 수행하는 명령어&lt;/strong&gt;에서 사용할 수 있도록 설계된 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;주소-레지스터ar-address-register&quot;&gt;주소 레지스터(AR, Address Register)&lt;/h3&gt;
&lt;p&gt;주기억 장치에 접근하기 위한 주소의 일부 또는 전부를 기억시키는 레지스터로 기억 장치 용량과 관계가 있는 레지스터&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로그램 카운트(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PC&lt;/code&gt;, Program Counter)&lt;/strong&gt;
다음 명령어의 주소 값을 기억하고 있는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;메모리 번지 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAR&lt;/code&gt;, Memory Address Register)&lt;/strong&gt;
메모리에 접근하고자 할 때 접근하고자 하는 곳의 주소 값을 기억하고 있는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인덱스 레지스터(Index Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;주소 변환 및 계산에 필요한 수&lt;/strong&gt;를 기억&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;주소 수정에 필요한 주소값&lt;/strong&gt;을 기억&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;배열의 시작 주소&lt;/strong&gt;와 같은 &lt;strong&gt;반복 계수를 기억&lt;/strong&gt;시키는 용도로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;베이스 레지스터(Base Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;하나의 서브 프로그램 루틴 또는 데이터의 블록에 대하여 &lt;strong&gt;기준이 되는 주소를 기억&lt;/strong&gt;시키는 레지스터&lt;/li&gt;
      &lt;li&gt;프로그램을 &lt;strong&gt;재배치하는 경우 상대적인 변위 값&lt;/strong&gt;을 기억시키는데 사용&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;명령이 시작되는 최초의 번지&lt;/strong&gt;를 기억&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;상태-레지스터status-register&quot;&gt;상태 레지스터(Status Register)&lt;/h3&gt;
&lt;p&gt;프로그램 제어를 위한 상태 정보를 기억시키는데 필요한 레지스터를 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;플래그 레지스터(Flag Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;= &lt;strong&gt;프로그램 상태 워드 레지스터&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PSWR&lt;/code&gt;, Program Status Word Register)&lt;/li&gt;
      &lt;li&gt;프로그램의 수행이 진행되고 있을 때 매 &lt;strong&gt;순간마다 프로그램의 수행 상태를 포함&lt;/strong&gt;하는 &lt;strong&gt;중앙 처리 장치의 상태&lt;/strong&gt;를 나타내는 레지스터&lt;/li&gt;
      &lt;li&gt;명령의 실행 중에 어떤 상황(부호 체크, 오버플로 여부, 캐리 발생 여부 등) &lt;strong&gt;발생에 대한 사항들을 각각 1비트로 세트&lt;/strong&gt;시키는 레지스터를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;프로그램 상태 워드(PSW)&lt;/strong&gt;는 컴퓨터 &lt;strong&gt;시스템 내부에서 순간순간의 시스템 상태를 기록&lt;/strong&gt;하고 있는 특별한 워드로서 이 레지스터에 기억되어 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메이저 상태 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MSR&lt;/code&gt;, Major State Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU가 어떤 수행을 하고 있는지를 나타내는 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 06 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-register/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-register/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
  </channel>
</rss>
