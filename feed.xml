<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://many258.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://many258.github.io/" rel="alternate" type="text/html" /><updated>2021-03-25T02:24:25+09:00</updated><id>https://many258.github.io/feed.xml</id><title type="html">My LifeChronicle</title><subtitle>Be a Imagineer.</subtitle><author><name>SG Yoo.</name></author><entry><title type="html">[소프트웨어공학] 소프트웨어 검사</title><link href="https://many258.github.io/study/software-engineering-testing/" rel="alternate" type="text/html" title="[소프트웨어공학] 소프트웨어 검사" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-09T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-testing%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-testing/">&lt;h1 id=&quot;검사-관련-용어정의&quot;&gt;검사 관련 용어정의&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;검사&lt;/strong&gt;(Testing)&lt;br /&gt;
오류를 찾는 작업&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;검증&lt;/strong&gt;(Verification)&lt;br /&gt;
개발된 소프트웨어와 사용자의 요구분석 명세서와의 차이를 확인하는 작업&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디버깅&lt;/strong&gt;(Debugging)&lt;br /&gt;
검사로 찾아낸 오류를 수정하는 작업&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;검토 회의&lt;/strong&gt;(Walk-through)&lt;br /&gt;
소프트웨어 생명주기의 단계마다 산출된 명세서를 가지고 다음 단계로 넘어가기 전에 오류를 찾아내는 작업&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;정형 기술 검토&lt;/strong&gt;(FTR)&lt;br /&gt;
소프트웨어에 관련된 여러 사람이 모여 회의하는 정형화된 오류 검토 회의&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;검사방법&quot;&gt;검사방법&lt;/h1&gt;
&lt;h2 id=&quot;화이트-박스-검사&quot;&gt;화이트 박스 검사&lt;/h2&gt;
&lt;p&gt;상자 안을 들여다 볼 수 있다는 뜻으로 &lt;strong&gt;원시 프로그램을 직접 보면서&lt;/strong&gt; 프로그램 상 허용되는 논리적인 모든 경로를 직접 검사하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 모듈의 논리적 구조를 체계적으로 점검하는 구조 검사&lt;/li&gt;
  &lt;li&gt;원시 코드의 모든 문장을 &lt;strong&gt;한 번 이상 수행함&lt;/strong&gt;으로써 진행되는 구조 검사&lt;/li&gt;
  &lt;li&gt;검사 대상의 가능한 경로를 어느 정도 통과하는 지의 적용 범위성을 측정 기준으로 한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램의 제어 구조에 따라 &lt;strong&gt;선택, 반복 등의 부분들을 수행&lt;/strong&gt;함으로써 논리적인 경로를 검사&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;기초 경로 검사&lt;/strong&gt;(Basic Path Testing)&lt;br /&gt;
모든 논리적인 경로를 복잡도로 계산하여 구한 후 경로를 수행할 수 있는 검사 경우를 직접 입력하여 오류를 검출하는 방법
        &lt;blockquote&gt;
          &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오일러의 공식&lt;/code&gt; : V - E + R = 2&lt;br /&gt;
&lt;sub&gt;V: 노드의 수, E: 간선의 수, R:영역의 수&lt;/sub&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;루프 검사&lt;/strong&gt;(Loop Testing)&lt;br /&gt;
반복문 관련 오류 검출&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;데이터 흐름 검사&lt;/strong&gt;(Data Flow Testing)&lt;br /&gt;
제어 흐름 그래프에 데이터 사용 현황(정의, 소멸, 사용)을 테스트&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;조건 검사&lt;/strong&gt;(Condition Testing)&lt;br /&gt;
조건문 관련 오류 검출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;찾을 수 있는 오류
    &lt;ul&gt;
      &lt;li&gt;자세하고 세부적 오류 검출 가능&lt;/li&gt;
      &lt;li&gt;반복문, 참거짓을 판단할 수 있는 논리 구조 상의 오류 검출 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;블랙-박스-검사&quot;&gt;블랙 박스 검사&lt;/h2&gt;
&lt;p&gt;상자 안을 볼 수 없다는 뜻으로 원시 프로그램은 보지 않고 프로그램만 실행시켜 데이터 입력에 대한 결과만을 보고 오류를 판단하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;균등 분할&lt;/strong&gt;(Equivalence Partitioning)&lt;br /&gt;
입력 자료에 초점을 맞춰 검사 사례를 만드는 방법.&lt;br /&gt;
타당한 자료와 타당하지 않은 자료의 개수를 균등하게 하여 정함&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;한계값 분석&lt;/strong&gt;(Boundary Value Analysis)&lt;br /&gt;
입력조건의 중간값에서 보다 &lt;strong&gt;경계값에서 에러가 발생될 확률이 높다&lt;/strong&gt;는 점을 이용하여 이를 실행하는 테스크 케이스를 만드는 방법&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;원인-결과 그래프&lt;/strong&gt;(Cause-Effect Graphing)&lt;br /&gt;
입력 데이터 간의 관계가 출력에 미치는 영향을 그래프로 표현하여 오류 검출&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;오류 예측&lt;/strong&gt;(Error Guessing)&lt;br /&gt;
각 시험기법들이 놓치기 쉬운 오류들을 감각 및 경험으로 찾아보는 것&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;비교 검사&lt;/strong&gt;(Comparison Testing)&lt;br /&gt;
여러 버전의 프로그램에 동일한 검사 자료를 제공하여 동일한 결과가 출력되는 지 비교 및 확인하는 검사&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;페어 와이즈 조합 테스트&lt;/strong&gt;&lt;br /&gt;
모든 가능한 입력 값들의 조합들을 테스트하는 대신에 모든 Pair의 조합을 테스트하는 방법&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;상태 전이 검사&lt;/strong&gt;&lt;br /&gt;
시스템의 상태가 변화함에 따른 검사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비정상적인 자료를 입력해도 오류 처리를 수행하지 않은 경우의 오류 검출 가능&lt;/li&gt;
  &lt;li&gt;정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우의 오류를 검출 가능&lt;/li&gt;
  &lt;li&gt;성능 오류, 자료 구조 상의 오류, 인터페이스, 시작과 종결 상의 오류를 찾을 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;검사-순서&quot;&gt;검사 순서&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;단위(코드) 검사&lt;/li&gt;
  &lt;li&gt;통합(설계) 검사&lt;/li&gt;
  &lt;li&gt;검증(요구사항) 검사&lt;/li&gt;
  &lt;li&gt;시스템 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;단위-검사&quot;&gt;단위 검사&lt;/h2&gt;
&lt;p&gt;원시 프로그램의 모듈을 대상으로 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;화이트 검사&lt;/code&gt;를 실시&lt;/strong&gt;하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인터페이스 검사&lt;/li&gt;
  &lt;li&gt;자료 구조 검사&lt;/li&gt;
  &lt;li&gt;경로 검사&lt;/li&gt;
  &lt;li&gt;오류 처리 검사&lt;/li&gt;
  &lt;li&gt;한계값 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;통합-검사&quot;&gt;통합 검사&lt;/h2&gt;
&lt;p&gt;단위 검사를 성공적으로 실시한 후에 단위별로 &lt;strong&gt;결합하면서 오류를 검출&lt;/strong&gt;하는 방법&lt;/p&gt;

&lt;h3 id=&quot;하향식top-down-통합-검사&quot;&gt;하향식(Top-Down) 통합 검사&lt;/h3&gt;
&lt;p&gt;상위 모듈에서 하위 모듈로 결합하면서 오류를 찾는 방법으로 가짜 모듈(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stub&lt;/code&gt;)이 필요하다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;전체 프로그램을 매번 실행하고 종속적인 모듈은 &lt;strong&gt;가짜 모듈(Stub)로 대치&lt;/strong&gt;한다&lt;/li&gt;
  &lt;li&gt;통합 방법에 따라 가짜 모듈을 &lt;strong&gt;실제 모듈로 대치&lt;/strong&gt;한다&lt;/li&gt;
  &lt;li&gt;각 모듈이 &lt;strong&gt;통합되면 검사&lt;/strong&gt;를 실시&lt;/li&gt;
  &lt;li&gt;통합될 때마다 &lt;strong&gt;회귀 검사&lt;/strong&gt;를 실시&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 전체를 실행하면서 검사 가능&lt;/li&gt;
  &lt;li&gt;중요 모듈을 우선 검사할 때에는 부적합&lt;/li&gt;
  &lt;li&gt;독립적인 구조로 검사할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;상향식bottom-up-통합-검사&quot;&gt;상향식(Bottom-Up) 통합 검사&lt;/h3&gt;
&lt;p&gt;최하위의 모듈부터 상위로 진행하면서 통합하는 방식으로 가짜 모듈은 필요없지만 통합 시에 통합된 클러스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cluster&lt;/code&gt;)를 실행할 수 있는 시험 가동기(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Driver&lt;/code&gt;)가 필요하다&lt;/p&gt;

&lt;p&gt;&lt;sub&gt;
클러스터 : 여러 개의 모듈을 하나로 묶어 놓은 단위&lt;br /&gt;
드라이버 : 임시로 실행시켜 검사해 보기 위한 임시 프로그램 모듈
&lt;/sub&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;낮은 수준의 모듈들을 클러스터로 &lt;strong&gt;결합&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;검사 사례 입/출력을 조정하기 위해 &lt;strong&gt;드라이버&lt;/strong&gt; 작성&lt;/li&gt;
  &lt;li&gt;클러스터 &lt;strong&gt;검사&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;드라이버 제거하고 클러스터를 &lt;strong&gt;상위&lt;/strong&gt;로 결합&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;중요 모듈을 우선 검사할 때 유리&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;혼합식mixed-통합-검사&quot;&gt;혼합식(Mixed) 통합 검사&lt;/h3&gt;
&lt;p&gt;하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 검사하는 방법. &lt;strong&gt;샌드위치식 통합 방식&lt;/strong&gt;이라고도 한다.&lt;/p&gt;

&lt;h2 id=&quot;검증-검사&quot;&gt;검증 검사&lt;/h2&gt;
&lt;p&gt;소프트웨어가 사용자의 &lt;strong&gt;요구사항을 충족시키는가&lt;/strong&gt;에 중점을 두고 검사하는 방법. 요구사항 명세서를 토대로 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블랙 박스 테스트&lt;/code&gt;를 사용&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;형상 검사&lt;/strong&gt; : 소프트웨어 구성요소, 목록, 유지보수를 지원하기 위해 필요한 사항 표현 검사&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;알파 검사&lt;/strong&gt; : 개발자의 장소에서 사용자가 개발자 앞에서 실행하는 검사&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;베타 검사&lt;/strong&gt; : 다수의 사용자를 제한되지 않은 환경에서 프로그램을 사용하게 하고 오류가 발견되면 개발자에게 통보하는 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시스템-검사&quot;&gt;시스템 검사&lt;/h2&gt;
&lt;p&gt;개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 검사&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;확인 검사 : 이해관계가 있는 모든 사람이 참석하여 오류 검출하는 방법&lt;/li&gt;
  &lt;li&gt;보안 검사&lt;/li&gt;
  &lt;li&gt;무결성 검사&lt;/li&gt;
  &lt;li&gt;스트레스 검사&lt;/li&gt;
  &lt;li&gt;부피 검사&lt;/li&gt;
  &lt;li&gt;메모리 검사&lt;/li&gt;
  &lt;li&gt;성능 검사&lt;/li&gt;
  &lt;li&gt;호환성 검사&lt;/li&gt;
  &lt;li&gt;신뢰성 검사&lt;/li&gt;
  &lt;li&gt;회복 검사&lt;/li&gt;
  &lt;li&gt;사용 용이성 검사&lt;/li&gt;
  &lt;li&gt;유지보수 용이성 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정형-기술-검토ftr--formal-technical-review&quot;&gt;정형 기술 검토(FTR : Formal Technical Review)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;목적
    &lt;ul&gt;
      &lt;li&gt;소프트웨어가 요구사항에 일치되는 정도를 확인&lt;/li&gt;
      &lt;li&gt;소프트웨어가 &lt;strong&gt;표준화되었는지 검토&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;정형화된 소프트웨어가 개발되도록 지원&lt;/li&gt;
      &lt;li&gt;프로젝트 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;검토 지침
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;제품 검토의 집중성&lt;/strong&gt; : 수정이 아닌 제품의 검토에 집중&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;사전 준비성&lt;/strong&gt; : 검토를 위한 자료를 사전에 배포하여 검토&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;의제의 제한성&lt;/strong&gt; : 의견을 제한하되 충분히 받아들인다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;안건 고수성&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;논쟁 반박의 제한성&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;문제 공개성&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;참가 인원의 제한성&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;문서성&lt;/strong&gt; : 발견된 오류는 문서화한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;오류-증폭-모형&quot;&gt;오류 증폭 모형&lt;/h2&gt;
&lt;p&gt;소프트웨어 개발 생명주기 중 검사 단계에서 오류를 찾는 것보다 &lt;strong&gt;생명주기의 단계마다 확인하고 검사&lt;/strong&gt;하면 많은 양의 오류 검출 및 수정이 가능하다.&lt;/p&gt;

&lt;p&gt;이러한 방법을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;검토 회의&lt;/code&gt;(Walk-through)라고 하며 검토 회의를 할 경우에 예측할 수 있는 &lt;strong&gt;오류 감소 비율을 이론적으로 정립한 것&lt;/strong&gt;을 &lt;strong&gt;오류 증폭 모델&lt;/strong&gt;이라 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(전달된 오류수 + 오류 증폭수 + 생성된 오류수) X (100% - 오류 제거 비율)&lt;br /&gt;
오류 증폭수 = (이전 단계에서 전달된 오류수 - 전달된 오류 수) X 오류 증폭 비율&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">검사 관련 용어정의 검사(Testing) 오류를 찾는 작업 검증(Verification) 개발된 소프트웨어와 사용자의 요구분석 명세서와의 차이를 확인하는 작업 디버깅(Debugging) 검사로 찾아낸 오류를 수정하는 작업 검토 회의(Walk-through) 소프트웨어 생명주기의 단계마다 산출된 명세서를 가지고 다음 단계로 넘어가기 전에 오류를 찾아내는 작업 정형 기술 검토(FTR) 소프트웨어에 관련된 여러 사람이 모여 회의하는 정형화된 오류 검토 회의</summary></entry><entry><title type="html">[소프트웨어공학] 비용 산정 방법론</title><link href="https://many258.github.io/study/software-engineering-cost-model/" rel="alternate" type="text/html" title="[소프트웨어공학] 비용 산정 방법론" /><published>2021-03-24T00:00:00+09:00</published><updated>2021-03-24T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-cost-model%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-cost-model/">&lt;h1 id=&quot;소프트웨어-개발비용-산정기법&quot;&gt;소프트웨어 개발비용 산정기법&lt;/h1&gt;

&lt;h2 id=&quot;상향식&quot;&gt;상향식&lt;/h2&gt;
&lt;p&gt;단계별로 측정한 결과들을 모아서 총비용을 측정하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LOC 기법 (원시 코드 라인 수 : Line Of Code)&lt;br /&gt;
프로젝트의 각 기능별 라인 수를 측정(&lt;strong&gt;비관치, 기대치, 낙관치&lt;/strong&gt;)하여 비용을 산정하는 방법
    &lt;ul&gt;
      &lt;li&gt;비관치 : 기능을 코딩할 때, 가장 많이 측정된 라인 수&lt;/li&gt;
      &lt;li&gt;기대치 : 기능을 코딩할 때, 제시한 측정된 라인 수의 평균&lt;/li&gt;
      &lt;li&gt;낙관치 : 기능을 코딩할 때, 가장 적게 측정된 라인 수&lt;/li&gt;
      &lt;li&gt;예측치 : $\frac{(비관치 + 4 \cdot 기대치 + 낙관치)}{6}$&lt;/li&gt;
      &lt;li&gt;평방 편차 : $({\frac{(비관치-낙관치)}6})^2$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개발 단계별 인월 수 방법&lt;br /&gt;
LOC 기법을 보완하기 위한 방법으로, 각 기능을 구현시키는데 필요한 노력을 생명주기의 각 단계별로 산정&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;수학적-산정-기법&quot;&gt;수학적 산정 기법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Walston Felix 모형&lt;/strong&gt;&lt;br /&gt;
60여 개 개발 업체의 다양한 규모의 프로젝트 비용 측정 자료를 모아 통계적으로 분석한 &lt;strong&gt;공식&lt;/strong&gt;으로 개발 비용을 측정하는 방법&lt;br /&gt;
인월 수를 계산하는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KDSI&lt;/code&gt;(원시코드에서 주석라인, 라이브러리 루틴, 공백을 제외한 실제 수행 코드 라인 수)를 사용한다
    &lt;ul&gt;
      &lt;li&gt;COCOMO 비용 산정 공식의 모체이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;COCOMO&lt;/strong&gt;(COnstructive COst MOdel)&lt;br /&gt;
Boehm이 제시한 원시 프로그램의 규모에 의한 비용 예측 모형
변화 모형과 규모 유형이 존재한다
    &lt;ul&gt;
      &lt;li&gt;변화 모형
        &lt;ul&gt;
          &lt;li&gt;Basic : S/W 크기 + 개발 유형&lt;/li&gt;
          &lt;li&gt;Intermediate : Basic Model + 가중치&lt;/li&gt;
          &lt;li&gt;Detailed : Intermediate Model + 시스템 세분화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;규모 모형
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;Organic&lt;/strong&gt;(유기형)
            &lt;blockquote&gt;
              &lt;p&gt;인월(MM) = $2.4 \times [KDSI]^{1.05}$&lt;br /&gt;
개발기간(TDEV) = $2.5 \times [KDSI]^{0.38}$&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Semi-detached&lt;/strong&gt;(준 분리형)
            &lt;blockquote&gt;
              &lt;p&gt;인월(MM) = $3.0 \times [KDSI]^{1.12}$&lt;br /&gt;
개발기간(TDEV) = $2.5 \times [KDSI]^{0.35}$&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Embedded&lt;/strong&gt;(내재형)
            &lt;blockquote&gt;
              &lt;p&gt;인월(MM) = $3.6 \times [KDSI]^{1.20}$&lt;br /&gt;
개발기간(TDEV) = $2.5 \times [KDSI]^{0.32}$&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PUTNAM&lt;/strong&gt;&lt;br /&gt;
시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 한다&lt;br /&gt;
개발 기간이 연장될수록 프로젝트 적용 인원의 노력이 감소하므로 &lt;strong&gt;대형 프로젝트&lt;/strong&gt;의 노력 분포 산정으로 적당&lt;br /&gt;
Putnam 모형을 기초로 해서 만든 자동화 추정 도구는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SLIM&lt;/code&gt;이다&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;MM = $\frac{DSI^3}{[개발 기술 지수]^3 \times [개발 기간]^4\frac{3}{4}}$&lt;br /&gt;
LOC =  $[개발 기술 지수] \times[총인월]^{\frac{1}{3}} \times [개발 기간]^{\frac{3}{4}}$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Albrecht&lt;/strong&gt; 모형(&lt;strong&gt;기능점수, FP&lt;/strong&gt;)&lt;br /&gt;
프로젝트를 기능 별로 &lt;strong&gt;분해&lt;/strong&gt;하고 경험을 바탕으로 단순/보통/복잡한 정도에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가중치&lt;/code&gt;를 부여&lt;br /&gt;
요인별 가중치를 합산하여 총 기능점수 산출&lt;br /&gt;
총 기능점수와 영향도를 이용하여 실질 기능 점수를 구한 후 최종 비용 산정&lt;br /&gt;
FP 모형을 기초로 하여 개발된 자동화 도구는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESTIMACS&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;실질 기능 점수(FP) = $총기능점수 \times [0.65+ (0.1 \times 총영향도)]$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;하향식&quot;&gt;하향식&lt;/h2&gt;
&lt;p&gt;프로젝트의 총비용을 측정한 후 단계별로 비용을 세분화하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전문가 감정 기법
    &lt;ul&gt;
      &lt;li&gt;조직 내 경험이 많은 두명 이상의 전문가에게 비용산정 의뢰&lt;/li&gt;
      &lt;li&gt;의뢰자로부터 신뢰를 얻을 수 있다&lt;/li&gt;
      &lt;li&gt;새로운 프로젝트와 유사한 프로젝트에 대한 경험이 없을 수 있고 개인직이고 주관적일 가능성이 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;델파이 기법
    &lt;ul&gt;
      &lt;li&gt;많은 전문가의 의견을 종합 후 산정하는 방법으로 전문가 감정 기법의 단점을 보완&lt;/li&gt;
      &lt;li&gt;전문가들의 의견을 중재하는 중재자가 반드시 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">소프트웨어 개발비용 산정기법</summary></entry><entry><title type="html">[소프트웨어공학] 객체지향 개발 방법론</title><link href="https://many258.github.io/study/software-engineering-object-oriented/" rel="alternate" type="text/html" title="[소프트웨어공학] 객체지향 개발 방법론" /><published>2021-03-24T00:00:00+09:00</published><updated>2021-03-24T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-object-oriented%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-object-oriented/">&lt;h1 id=&quot;객체지향-개발-방법론&quot;&gt;객체지향 개발 방법론&lt;/h1&gt;
&lt;h2 id=&quot;객체지향-방법론의-정의&quot;&gt;객체지향 방법론의 정의&lt;/h2&gt;
&lt;p&gt;현실 세계의 개체(Entity)를 속성(Attribute)과 메소드(Method)가 결합된 형태의 객체(Object)로 표현하는 개념으로 객체간의 메시지 통신을 통해 시스템을 구현하는 개발 방법&lt;/p&gt;

&lt;h2 id=&quot;객체지향-기술의-장점&quot;&gt;객체지향 기술의 장점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;규모가 큰 대형 프로젝트에 적합&lt;/li&gt;
  &lt;li&gt;소프트웨어의 재사용률/확장성/유지보수 향상&lt;/li&gt;
  &lt;li&gt;신속하게 개발이 가능&lt;/li&gt;
  &lt;li&gt;사용자 타입 중심&lt;/li&gt;
  &lt;li&gt;대화식 프로그램 개발에 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체지향-기술의-단점&quot;&gt;객체지향 기술의 단점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;설계의 어려움&lt;/li&gt;
  &lt;li&gt;규모가 크기 때문에 실행속도 저하&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구성요소&quot;&gt;구성요소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;클래스&lt;/strong&gt;(Class)&lt;br /&gt;
같은 종류(또는 문제 해결을 위한)의 집단에 속한 속성(attribute)과 행위(behavior)를 정의한 것&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;객체&lt;/strong&gt;(Object)&lt;br /&gt;
자신 고유의 데이터(attribute)를 가지며 클래스에서 정의한 행위(behavior)를 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인스턴스&lt;/strong&gt;(Instance)&lt;br /&gt;
어떤 클래스에 속하는 구체적인 객체를 의미하며 클래스로 정의된 객체의 요소로 객체의 복사본이라 할 수 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;어트리뷰트&lt;/strong&gt;(Attribute)&lt;br /&gt;
객체 안에 존재하는 절대적 자료형.&lt;br /&gt;
객체에 존재하는 함수들이 동작하게 될 경우 같은 객체에 존재하는 어트리뷰트 값을 변경한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메서드&lt;/strong&gt;(Method)&lt;br /&gt;
객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메시지&lt;/strong&gt;(Message)&lt;br /&gt;
Sender와 Receiver객체들간의 상호작용의 수단으로 다른 객체에 특정 작업을 요청하는 신호&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주요-특징&quot;&gt;주요 특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;캡슐화&lt;/strong&gt;(Encapsulation)&lt;br /&gt;
연관된 속성(데이터)과 메소드(연산)을 하나로 묶어서 객체로 구성&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;추상화&lt;/strong&gt;(Abstraction)&lt;br /&gt;
하위 객체의 공통된 특성을 묘사하기 위한 객체를 추상적인 객체. 이러한 추상적인 객체는 문제 대상의 공통 특성을 추출하여 객체를 정의하기에 유용하고 편리함을 제공한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다형성&lt;/strong&gt;(Polymorphism)&lt;br /&gt;
같은 상위 객체에서 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;정보은닉&lt;/strong&gt;(Information Hiding)&lt;br /&gt;
캡슐화된 객체 내부에 자료 구조나 함수의 기능을 외부의 영향을 받거나 주지 않도록 설계하는 방법&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상속성&lt;/strong&gt;(Inheritance)&lt;br /&gt;
상위클래스가 갖는 속성과 연산을 그대로 물려받는 것을 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체지향-개발-순서&quot;&gt;객체지향 개발 순서&lt;/h2&gt;
&lt;p&gt;전통적인 구조적 개발 순서 구분처럼 단계가 분명하게 구분되지는 않는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;계획&lt;/li&gt;
  &lt;li&gt;분석(OOA)
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;객체&lt;/code&gt; 모델링&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동적&lt;/code&gt; 모델링&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기능&lt;/code&gt; 모델링&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;설계(OOD)
    &lt;ul&gt;
      &lt;li&gt;객체 설계&lt;/li&gt;
      &lt;li&gt;시스템 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구현(OOP)&lt;/li&gt;
  &lt;li&gt;테스트 및 검증
    &lt;ul&gt;
      &lt;li&gt;단위 테스트&lt;/li&gt;
      &lt;li&gt;통합 테스트&lt;/li&gt;
      &lt;li&gt;검증과 시스템 테스팅&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;객체지향-분석ooa--object-oriented-analysis&quot;&gt;객체지향 분석(OOA : Object Oriented Analysis)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;특징&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;문제 영역의 분석 대상을 &lt;strong&gt;형식적인 전략&lt;/strong&gt;으로 기술하는 단계&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;E-R 다이어그램&lt;/strong&gt;은 객체지향 분석의 표기법으로 적합&lt;/li&gt;
      &lt;li&gt;클래스, 객체, 속성, 연산들을 표현해서 문제를 &lt;strong&gt;모형화&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해내는 기법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체지향 분석의 순서(OMT : Object Modeling Technique, 람바우 방법)
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;객체 모델링&lt;/strong&gt;(Object Modeling)&lt;br /&gt;
객체를 찾아내고 객체의 속성, 연산을 식별하는 단계&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;동적 모델링&lt;/strong&gt;(Dynamic Modeling)&lt;br /&gt;
객체 모형들의 행위/상태/조건을 파악하는 단계&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;기능 모델링&lt;/strong&gt;(Functional Modeling)
        &lt;ul&gt;
          &lt;li&gt;입출력 결정&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자료 흐름도&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;객체들의 제어 흐름, 상호 반응 연산 순서를 나타내주는 과정&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;기능의 내용을 상세히 기술&lt;/li&gt;
          &lt;li&gt;제약사항을 결정하고 최소화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;객체지향-설계ood--object-oriented-design&quot;&gt;객체지향 설계(OOD : Object Oriented Design)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;특징&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;문제 영역의 분석 모형을 구체적인 절차로 표현&lt;/li&gt;
      &lt;li&gt;사용자 중심, 대화식 프로그램의 개발에 적합&lt;/li&gt;
      &lt;li&gt;시스템을 구성하는 클래스와 속성, 연산을 인식하여 클래스를 객체로, 속성을 자료 구조로, 연산을 알고리즘으로 표현하는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체지향 설계의 순서
    &lt;ul&gt;
      &lt;li&gt;문제의 정의&lt;/li&gt;
      &lt;li&gt;요구 명세화&lt;/li&gt;
      &lt;li&gt;객체 연산자 정의(객체 설계)&lt;br /&gt;
객체 분석에서 정의된 요구 명세서를 기반으로 객체 연산자를 정의하여 설계&lt;/li&gt;
      &lt;li&gt;객체 인터페이스 결정(시스템 설계)&lt;br /&gt;
객체 설계 단계에서 정의된 객체 간의 인터페이스를 정하여 전체적인 시스템을 설계&lt;br /&gt;
데이터, 자원 관리 방법을 결정&lt;br /&gt;
객체는 순차적으로 또는 동시적으로 제어할지를 결정&lt;/li&gt;
      &lt;li&gt;객체 구현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체지향 설계의 계층
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Responsibilities&lt;/strong&gt; Layer&lt;br /&gt;
속성과 연산들에 대한 메타 데이터와 알고리즘을 표현&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Message&lt;/strong&gt; Layer&lt;br /&gt;
객체와 객체 간의 인터페이스를 표현&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Class &amp;amp; Object&lt;/strong&gt; Layer&lt;br /&gt;
전체 객체를 구체적으로 표현&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Subsystem&lt;/strong&gt; Layer&lt;br /&gt;
요구사항을 지원하는 기술적인 기반 구조를 구현&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;객체지향-테스트&quot;&gt;객체지향 테스트&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;쓰레드 기반 테스트(Thread-Based Testing)&lt;br /&gt;
시스템에 대한 하나의 입력이나 이벤트에 응답하는데 요구되는 클래스들의 집합을 통합(구조적 검사 기법의 &lt;strong&gt;하향식 통합 검사&lt;/strong&gt; 방법과 유사)&lt;/li&gt;
  &lt;li&gt;사용-기반 테스트(Use-Based Testing)&lt;br /&gt;
상위 클래스와 관계를 갖지 않는 수준에서 클래스들을 독립적으로 검사한 후 상위 클래스와 결합(구조적 검사 기법의 &lt;strong&gt;상향식 통합 방법&lt;/strong&gt;과 유사)&lt;/li&gt;
  &lt;li&gt;검증과 시스템 테스트&lt;br /&gt;
사용자의 요구가 객체에 정확히 반영되었는지, 성능이나 인터페이스상 오류는 없는지 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체지향-분석-방법론의-종류&quot;&gt;객체지향 분석 방법론의 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;람바우(Rumbaugh) Method&lt;/strong&gt;&lt;br /&gt;
객체 모형, 동적 모형, 기능 모형으로 분리하여 접근하는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;E-R 다이어그램&lt;/strong&gt;&lt;br /&gt;
데이터 구조들과 그들 간의 관계를 표현하고 객체 모형을 만드는 방법론&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Booch Method&lt;/strong&gt;&lt;br /&gt;
미시적 개발 프로세스, 거시적 개발 프로세스로 접근하는 방법.&lt;br /&gt;
각 작업에 대한 다이어그램, 클래스 계층 정의, 클래스들의 클러스터링 작업 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Coad &amp;amp; Yourdon Method&lt;/strong&gt;&lt;br /&gt;
E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성되는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jacobson Method&lt;/strong&gt;&lt;br /&gt;
사용자가 제품 또는 시스템과 어떻게 상호 작용하는지를 서술한 시나리오로 접근&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Wirfs-Brocks Method&lt;/strong&gt;&lt;br /&gt;
분석과 설계 프로세스 간에 뚜렷한 구분이 없고, 고객 명세의 평가로 시작하여 설계로 끝나는 연속적인 프로세스로 접근한 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><category term="(구)정보처리기사" /><summary type="html">객체지향 개발 방법론 객체지향 방법론의 정의 현실 세계의 개체(Entity)를 속성(Attribute)과 메소드(Method)가 결합된 형태의 객체(Object)로 표현하는 개념으로 객체간의 메시지 통신을 통해 시스템을 구현하는 개발 방법</summary></entry><entry><title type="html">[소프트웨어공학] 소프트웨어 설계</title><link href="https://many258.github.io/study/software-engineering-sw-design/" rel="alternate" type="text/html" title="[소프트웨어공학] 소프트웨어 설계" /><published>2021-03-23T00:00:00+09:00</published><updated>2021-03-23T23:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-sw-design%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-sw-design/">&lt;h1 id=&quot;설계의-기본-개념&quot;&gt;설계의 기본 개념&lt;/h1&gt;
&lt;h2 id=&quot;소프트웨어-설계-절차&quot;&gt;소프트웨어 설계 절차&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DFD, DD 분석&lt;/li&gt;
  &lt;li&gt;외부 설계&lt;br /&gt;
파일 설계, 입출력 설계 등 S/W의 내적인 기능보다는 외부적은 특성을 설계&lt;/li&gt;
  &lt;li&gt;내부 설계(기본설계)&lt;br /&gt;
S/W의 내부 설계이며 주로 모듈의 기능을 정의하거나 모듈 간의 관계를 정의하는 설계&lt;/li&gt;
  &lt;li&gt;내부 설계(상세설계)&lt;br /&gt;
모듈 내부의 알고리즘을 정의&lt;/li&gt;
  &lt;li&gt;설계 명세서&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;설계-모형&quot;&gt;설계 모형&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;문서량 기준
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;데이터(Data) 설계&lt;br /&gt;
요구분석의 자료 사전(DD, 메타 데이터)을 분석&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;구조(Architectural) 설계&lt;br /&gt;
구조도 작성(외부 설계)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;관계(Interface) 설계&lt;br /&gt;
모듈 간의 관계를 표현(기본 설계)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;절차(Procedure) 설계&lt;br /&gt;
PDL로 알고리즘을 작성(상세 설계)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;노력 기준
    &lt;ul&gt;
      &lt;li&gt;절차 설계&lt;/li&gt;
      &lt;li&gt;관계 설계&lt;/li&gt;
      &lt;li&gt;구조 설계&lt;/li&gt;
      &lt;li&gt;데이터 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;설계의-종류&quot;&gt;설계의 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;상위 설계(High-Level Design) : 아키텍처/예비 설계, 하위 설계를 위한 바탕
    &lt;ul&gt;
      &lt;li&gt;구조 설계&lt;/li&gt;
      &lt;li&gt;DB 설계&lt;/li&gt;
      &lt;li&gt;인터페이스 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하위 설계(Low-Level Design) : 시스템 수준에서의 소프트웨어 구성 컴포넌트 간의 관계
    &lt;ul&gt;
      &lt;li&gt;컴포넌트 설계&lt;/li&gt;
      &lt;li&gt;자료구조 설계&lt;/li&gt;
      &lt;li&gt;알고리즘 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구조적-설계의-원칙&quot;&gt;구조적 설계의 원칙&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;모듈화(Modularization)&lt;/strong&gt;&lt;br /&gt;
단일 기능을 갖출 수 있도록 부분적으로 묶어서 처리하는 기술&lt;br /&gt;
단위 프로그램, 함수, 서브 프로그램을 작성하기 위한 설계 기법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;추상화(Abstraction)&lt;/strong&gt;&lt;br /&gt;
세부적은 설계를 배제하고 전체 흐름과 구조를 알아볼 수 있도록 개관적인 설계부터 점차 세부적으로 진행하는 설계 기법
    &lt;ul&gt;
      &lt;li&gt;기능 추상화 : 수행의 흐름만을 정의&lt;/li&gt;
      &lt;li&gt;제어 추상화 : 선택, 반복, 분기 등의 설계를 추상화&lt;/li&gt;
      &lt;li&gt;자료 추상화 : 변수 및 레코드 등을 추상화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구조화(Structured)&lt;/strong&gt;&lt;br /&gt;
모듈을 수행하기 위한 위치나 시기를 전체 구조에 적절하게 배치시키는 설계 기법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;정보 은닉(Information Hiding)&lt;/strong&gt;&lt;br /&gt;
모듈 간의 관계성을 최소화시키는 설계 기법.(S/W 변경 용이)&lt;br /&gt;
설계상의 결정 사항들이 각 모듈 안에 숨겨져 있어 다른 모듈이 접근하거나 변경을 못한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;분할과 정복&lt;/strong&gt;&lt;br /&gt;
Bottom-Up 방식으로 작은 시스템을 개발하고, 이를 합쳐 큰 시스템을 만든다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단계적 분해&lt;/strong&gt;&lt;br /&gt;
하향식 설계에서 사용. 문제를 상위 수준에서 점증적으로 더 구체적인 하위 수준으로 분할하는 기법
    &lt;ul&gt;
      &lt;li&gt;문제를 하위 수준의 독립된 단위로 나눈다&lt;/li&gt;
      &lt;li&gt;구분된 문제의 자세한 내용은 가능한 뒤로 미룬다&lt;/li&gt;
      &lt;li&gt;점증적으로 구체화 작업을 계속한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;좋은-설계&quot;&gt;좋은 설계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;요구사항을 모두 표현(완전성)&lt;/li&gt;
  &lt;li&gt;유지보수하기 쉽고(변경이 용이) 가독성이 좋고 객관성 있게 작성&lt;/li&gt;
  &lt;li&gt;구현 관점에서 데이터/기능/행위 영역을 설명하는 완전한 그림을 제공&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모듈적이어야 하며, 두 모듈 간의 상호 의존도는 약하게 해야 한다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모듈화&quot;&gt;모듈화&lt;/h1&gt;
&lt;h2 id=&quot;모듈의-특징&quot;&gt;모듈의 특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;구현, 컴파일, 설계는 독립적으로 수행, 실행은 종속적으로 수행&lt;/li&gt;
  &lt;li&gt;다른 모듈을 호출할 수도, 호출당할 수 있다&lt;/li&gt;
  &lt;li&gt;모듈 호출 시 매개변수를 전달하거나 전달받을 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;모듈화의-장점&quot;&gt;모듈화의 장점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;단위 프로그램을 독립적으로 설계할 수 있기 때문에 설계가 용이&lt;/li&gt;
  &lt;li&gt;모듈만을 구분하면 되므로 프로그램의 복잡도를 감소&lt;/li&gt;
  &lt;li&gt;다른 모듈에 영향을 주지 않을 수 있으므로 수정이 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;공유도--제어도&quot;&gt;공유도 / 제어도&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;공유도(Fan-in)
얼마나 많은 모듈이 주어진 모듈을 호출하는가를 나타내는 척도.&lt;/li&gt;
  &lt;li&gt;제어도(Fan-out)
주어진 모듈이 호출하는 모듈의 개수&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모듈의-응집력cohesion&quot;&gt;모듈의 응집력(Cohesion)&lt;/h1&gt;
&lt;p&gt;모듈 안의 요소들이 서로 관련되어 있는 정도로 강할수록 좋은 설계(좋은 설계 순서)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;기능적(Functional)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부가 하나의 단일 기능으로 존재하는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;순차적(Sequential)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 이전의 명령어로부터 나온 출력 결과를 그 다음 명령어의 입력자료로 사용하는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;교환적(Communication)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 작업 대상이 같은 기능끼리 존재하는 경우나 동일한 입력과 출력을 사용하는 작업들이 모인 경우&lt;br /&gt;
예시) 하나의 파일을 대상으로 갱신 작업을 하는 루틴끼리 묶인 루틴&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;절차적(Procedural)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 수행 시기에 순위가 있는 기능끼리 존재하는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;시간적(Temporal)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 시간상으로 수행 시기가 같은 기능끼리 존재&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;논리적(Logical)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 같은 범주에 속하는 기능끼리 묶은 모듈.&lt;br /&gt;
유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 하나의 모듈로 형성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;우연적(Coincidental)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 뚜렷한 관계없이 묶인 경우&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모듈의-결합도coupling&quot;&gt;모듈의 결합도(Coupling)&lt;/h1&gt;
&lt;p&gt;두 모듈 간의 관계성(상호 의존성)의 척도로, 약할수록 좋은 설계(좋은 설계 순서)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;자료(Data)&lt;/strong&gt; 결합도&lt;br /&gt;
두 모듈 간의 인터페이스가 자료 요소만으로 구성된 결합도&lt;br /&gt;
Call By Value 기법으로 결합된 모듈&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구조(Stamp)&lt;/strong&gt; 결합도&lt;br /&gt;
두 모듈 간의 인터페이스로 배열이나 레코드같은 자료 구조가 전달&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제어(Control)&lt;/strong&gt; 결합도&lt;br /&gt;
호출 모듈에서 전달된 자료에 의해서 운용되는 피 호출 모듈의 관계(종속적인 관계)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;외부(Extern)&lt;/strong&gt; 결합도&lt;br /&gt;
외부 변수에 의해 영향을 받는 두 모듈이 결합된 관계. 전역 변수 관련&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;공통(Common)&lt;/strong&gt; 결합도&lt;br /&gt;
공유되는 공통 데이터 영역을 여러 모듈이 사용하는 모듈 관계.&lt;br /&gt;
Call By Referrence, 메모리 번지의 공유&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;내용(Content)&lt;/strong&gt; 결합도&lt;br /&gt;
모듈이 다른 모듈 내부 기능 및 그 내부 자료를 참조하는 형태의 결합&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;구조적-설계-표기법&quot;&gt;구조적 설계 표기법&lt;/h1&gt;
&lt;h2 id=&quot;n-snassi-schneiderman-chart&quot;&gt;N-S(Nassi-Schneiderman) Chart&lt;/h2&gt;
&lt;p&gt;IBM사에 의해 개발되었으며 입출력 자료와 소프트웨어 모듈들 사이의 관계를 표현하는 뛰어난 능력을 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;고려사항
    &lt;ul&gt;
      &lt;li&gt;도표는 항상 직사각형&lt;/li&gt;
      &lt;li&gt;도표의 제어 흐름은 맨 위에서 시작&lt;/li&gt;
      &lt;li&gt;제어 흐름은 위에서 아래로 흐른다(하향식)&lt;/li&gt;
      &lt;li&gt;수평으로 그어진 줄은 모두 평행이 되어야 한다&lt;/li&gt;
      &lt;li&gt;사각형 안의 내용이 수행된 후에는 아래 방향으로 빠져나온다&lt;/li&gt;
      &lt;li&gt;사각형에 빈 공간이 있을 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/sw-engineering/n-s-chart.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;논리적 기술에 중점을 둔 도형을 이용한 표현 방법&lt;/li&gt;
      &lt;li&gt;연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현&lt;/li&gt;
      &lt;li&gt;임의의 제어 이동이 어렵다&lt;/li&gt;
      &lt;li&gt;상자 도표라고도 하며 프로그램으로 구현이 쉽다&lt;/li&gt;
      &lt;li&gt;조건이 복합된 곳의 처리를 시각적으로 명확히 식별하는데 적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hipohierarchy-plus-input-process-output&quot;&gt;HIPO(Hierarchy plus Input Process Output)&lt;/h2&gt;
&lt;p&gt;IBM에서 개발한 방법으로 프로그램을 기능 위주로 문서화하는 하향식 설계 기법.&lt;/p&gt;

&lt;p&gt;입력/처리/출력으로 구성되어 시각적으로 알아보기 쉽게 표현할 수 있으며 구조화된 방법으로 구현될 수 있도록 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;도식 목차(가시적 도표, Visual Table of Contents)&lt;br /&gt;
전체적인 흐름과 구조를 나타내는 도표&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;총괄 도표(총체적 도표, Overview Diagram)&lt;br /&gt;
입력/처리/출력 등의 기능을 명확히 표현한 도표(&lt;strong&gt;사용자관점&lt;/strong&gt;)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;상세 도표(세부적 도표, Detail Diagram)&lt;br /&gt;
총괄 도표의 일부 기능을 구체적으로 표현한 모듈 도표(&lt;strong&gt;개발자관점&lt;/strong&gt;)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;분석 및 설계 도구로 사용&lt;/li&gt;
      &lt;li&gt;하향식(Top-Down) 개발에 적당&lt;/li&gt;
      &lt;li&gt;수정 및 유지보수가 용이&lt;/li&gt;
      &lt;li&gt;소규모 프로젝트에 적합&lt;/li&gt;
      &lt;li&gt;기능과 자료의 관계를 동시에 표현할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;설계-방법론&quot;&gt;설계 방법론&lt;/h1&gt;
&lt;h2 id=&quot;구조적-설계-방법론&quot;&gt;구조적 설계 방법론&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기본구조
    &lt;ul&gt;
      &lt;li&gt;순차(Sequence) 구조&lt;/li&gt;
      &lt;li&gt;선택(Condition) 구조&lt;/li&gt;
      &lt;li&gt;반복(Repetition) 구조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;단일 입출력으로 처리&lt;/li&gt;
      &lt;li&gt;실행 효율성을 중시할 때 한정된 범위 내에서 GOTO문을 사용&lt;/li&gt;
      &lt;li&gt;프로그램의 이해가 쉽고 유지보수와 검증이 용이&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자료-흐름-중심-설계-방법론&quot;&gt;자료 흐름 중심 설계 방법론&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;자료 흐름 설계 과정
    &lt;ul&gt;
      &lt;li&gt;정보 &lt;strong&gt;흐름의 유형&lt;/strong&gt;을 설정&lt;/li&gt;
      &lt;li&gt;흐름의 &lt;strong&gt;경계&lt;/strong&gt;(Flow Boundaries)를 표시&lt;/li&gt;
      &lt;li&gt;자료 흐름도를 프로그램 구조로 &lt;strong&gt;사상&lt;/strong&gt; → &lt;strong&gt;변환 사상&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;제어 계층을 분해&lt;/strong&gt;시켜서 정의&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;경험적 방법&lt;/strong&gt;을 구체화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;변환 사상(Transform Mapping)&lt;/strong&gt;&lt;br /&gt;
변환 흐름에 특성을 갖는 &lt;strong&gt;DFD(Data Flow Diagram)&lt;/strong&gt; 을 전체 혹은 일부를 분할해서 &lt;strong&gt;구조도&lt;/strong&gt;로 변화하는 작업&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자료-구조-중심-설계-방법론&quot;&gt;자료 구조 중심 설계 방법론&lt;/h2&gt;
&lt;p&gt;입출력 자료의 구조 파악으로 소프트웨어 구조를 추출&lt;/p&gt;

&lt;h3 id=&quot;dssd-방법론-warnier-orr-기법&quot;&gt;DSSD 방법론 (Warnier-Orr 기법)&lt;/h3&gt;
&lt;p&gt;Warnier가 개발한 LCP(Logical of Program)를 Orr와 공동으로 개발한 자료 구조 지향 설계 방법으로 출력 자료를 중심으로 입력 자료를 설계하고 제어 구조도 설계하는 방법&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;출력 자료 정의 : 출력할 자료를 파악하여 배열&lt;/li&gt;
  &lt;li&gt;논리적 레코드 정의 : 출력할 레코드의 구조를 정의&lt;/li&gt;
  &lt;li&gt;사건 분석 : 출력할 레코드 항목을 기준으로 입력 항목을 정의&lt;/li&gt;
  &lt;li&gt;물리적 레코드 정의 : 입력할 레코드의 구조를 정의&lt;/li&gt;
  &lt;li&gt;논리적 절차 정의 : 입력/처리/출력 모듈로 구분하여 Warnier-Orr 도표를 그림&lt;/li&gt;
  &lt;li&gt;물리적 절차 정의 : 명시된 도표를 보고 알고리즘 기술&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;jsd-방법론-jackson-기법&quot;&gt;JSD 방법론 (Jackson 기법)&lt;/h3&gt;
&lt;p&gt;프로그램의 입력과 출력 자료의 구조를 대응시켜서 설계하는 자료 구조 지향 설계 방법론으로 자료 구조를 정의하면서 제어 구조를 유도하는 방식&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;자료 구조 정의&lt;br /&gt;
입출력 구조를 정의하여 일치되지 않는 부분을 처리 루틴으로 모듈화하고 일치하는 부분은 입력과 출력 루틴으로 모듈화&lt;/li&gt;
  &lt;li&gt;구조도 작성&lt;br /&gt;
입력/처리/출력으로 분류하여 잭슨 표기법으로 구조도를 세분화하여 작성&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;연산 목록 작성&lt;br /&gt;
  구조도를 보고 필요한 제어 구조 명시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;구조문 작성&lt;br /&gt;
  명시된 제어 구조를 보고 알고리즘 기술&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;소프트웨어-설계-solid-원칙&quot;&gt;소프트웨어 설계 SOLID 원칙&lt;/h1&gt;
&lt;h2 id=&quot;single-responsibility-priciple단일-책임-원칙--srp&quot;&gt;Single Responsibility Priciple(단일 책임 원칙 : SRP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;소프트웨어의 설계 부품은 반드시 한 개의 책임을 가져야 한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;책임 대신 기능이라 해석해도 무방하다.&lt;/p&gt;

&lt;h2 id=&quot;open-closed-principle개방-폐쇠-원칙--ocp&quot;&gt;Open-Closed Principle(개방 폐쇠 원칙 : OCP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;한 번 설계가 되고 단위 테스트가 완료된 객체는 향후 외부에 변경 사항이 발생하더라도 객체 자체는 변경되지 않아야 한다는 것을 의미&lt;/p&gt;

&lt;h2 id=&quot;liskov-substitution-principle리스코프-치환-원칙--lsp&quot;&gt;Liskov Substitution Principle(리스코프 치환 원칙 : LSP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;자식 클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MIT 컴퓨터 사이언스 교수인 리스코프가 제안한 설계 원칙으로 상속관계에 있는 두 객체에 있어서 부모 클래스의 인스턴스가 사용된 자리에 자식 클래스의 인스턴스를 넣어도 &lt;strong&gt;코드의 맥락이 변하지 않아야&lt;/strong&gt; 한다는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;자식 클래스가 부모 클래스를 대체하기 위해서는 부모의 기능에 대해 오버라이드되지 않도록 하면 된다. 즉, 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않과 &lt;strong&gt;확장만 수행&lt;/strong&gt;하도록 해야 LSP를 만족하게 된다.&lt;/p&gt;

&lt;p&gt;LSP의 만족 여부는 [자식 클래스 &lt;strong&gt;is a kind of&lt;/strong&gt; 부모 클래스]의 참/거짓으로 간단히 파악이 가능&lt;/p&gt;

&lt;h2 id=&quot;interface-segregation-principle인터페이스-분리-원칙--isp&quot;&gt;Interface Segregation Principle(인터페이스 분리 원칙 : ISP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;객체 자신이 사용하지 않을 인터페이스는 구현하면 안된다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 자신이 &lt;strong&gt;사용하지 않는 기능에는 영향을 받지 말아야 한다&lt;/strong&gt;는 것을 의미한다&lt;/p&gt;

&lt;p&gt;가능한 경우라면, 범용 인터페이스를 구현하는 것보다 객체에 &lt;strong&gt;특화된 인터페이스를 분리&lt;/strong&gt;해내어 구현한다.&lt;/p&gt;

&lt;h2 id=&quot;dependency-inversion-principle의존-역전-원칙--dip&quot;&gt;Dependency Inversion Principle(의존 역전 원칙 : DIP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;의존 관계를 맺을 때, 변화하기 쉬운 것(구체화)보다 변화하기 어려운 것(추상화)에 의존해야 한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;구체적인 클래스보다 &lt;strong&gt;추상성이 높은 인터페이스나 추상클래스와 관계&lt;/strong&gt;를 맺는다는 것을 의미. 일반적으로 Interface를 활용 시 이 원칙을 준수할 수 있다.&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">설계의 기본 개념 소프트웨어 설계 절차 DFD, DD 분석 외부 설계 파일 설계, 입출력 설계 등 S/W의 내적인 기능보다는 외부적은 특성을 설계 내부 설계(기본설계) S/W의 내부 설계이며 주로 모듈의 기능을 정의하거나 모듈 간의 관계를 정의하는 설계 내부 설계(상세설계) 모듈 내부의 알고리즘을 정의 설계 명세서 설계 모형 문서량 기준 데이터(Data) 설계 요구분석의 자료 사전(DD, 메타 데이터)을 분석</summary></entry><entry><title type="html">[프로그래밍] 함수형 프로그래밍</title><link href="https://many258.github.io/study/functional-programming/" rel="alternate" type="text/html" title="[프로그래밍] 함수형 프로그래밍" /><published>2021-03-22T00:00:00+09:00</published><updated>2021-03-23T22:37:34+09:00</updated><id>https://many258.github.io/study/%7Bfunctional-programming%7D</id><content type="html" xml:base="https://many258.github.io/study/functional-programming/">&lt;h1 id=&quot;함수형-프로그래밍&quot;&gt;함수형 프로그래밍&lt;/h1&gt;
&lt;p&gt;함수의 동작에 의한 변수의 부수적인 값 변경을 원천 배제함으로써 오류를 방지하는 패러다임&lt;/p&gt;

&lt;p&gt;함수 내부에 상태가 존재하지 않으며, 함수의 출력 값은 항상 함수의 입력 값의 영향만 받는다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;높은 표현력을 통해 불필요한 코드를 줄일 수 있다.&lt;/li&gt;
  &lt;li&gt;함수형 프로그래밍의 언어군은 프로그래밍 언어론의 최신 연구 결과를 반영하고 있다&lt;/li&gt;
  &lt;li&gt;불변성(Immutability)으로 인해 다양한 최적화 및 검증이 용이&lt;/li&gt;
  &lt;li&gt;이전에 계산한 함수의 값을 캐싱해 두었다가 필요할 때 다시 사용하는 메모이제이션이 가능&lt;/li&gt;
  &lt;li&gt;함수형 프로그래밍 언어에서는 변경 가능한 상태를 원천적으로 배제하기 때문에 멀티프로세서, 멀티스레드 환경에서 동작하는 동시성 프로그램을 개발할 때 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대표 함수형 프로그래밍 언어 : &lt;strong&gt;Scala, LISP, Haskell, F#, Erlang&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;일급-객체&quot;&gt;일급 객체&lt;/h2&gt;
&lt;p&gt;다음 조건을 만족하면 일급 객체라고 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;변수나 데이터에 할당할 수 있어야 한다&lt;/li&gt;
  &lt;li&gt;객체의 인자로 넘길 수 있어야 한다&lt;/li&gt;
  &lt;li&gt;객체의 리턴값으로 리턴할 수 있어야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, 객체처럼 동작할 수 있는 함수를 지칭한다&lt;/p&gt;

&lt;h2 id=&quot;순수-함수&quot;&gt;순수 함수&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;항상 같은 인풋에는 항상 같은 아웃풋(멱등성, 참조 투명성)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;외부의 인자를 변화시키지 않고 최대한 지역변수만을 사용해서 구현되는 함수&lt;/p&gt;

&lt;h2 id=&quot;고차-함수--고계-함수&quot;&gt;고차 함수 = 고계 함수&lt;/h2&gt;
&lt;p&gt;함수를 값이라 생각하고 &lt;strong&gt;함수를 인자값&lt;/strong&gt;으로 넣어주는 형태&lt;/p&gt;

&lt;p&gt;인자로 다른 함수를 받아 결과값을 내보내는 함수를 의미&lt;/p&gt;

&lt;h2 id=&quot;커링&quot;&gt;커링&lt;/h2&gt;
&lt;p&gt;여러 인자를 받는 함수에 &lt;strong&gt;일부 인자만&lt;/strong&gt; 넣어서 나머지 인자를 받는 다른 함수를 만들어낼 수 있는 함수형 프로그래밍 기법을 의미&lt;/p&gt;

&lt;h2 id=&quot;함수-합성&quot;&gt;함수 합성&lt;/h2&gt;
&lt;p&gt;함수형 프로그래밍을 위한 라이브러리들에는 컬렉션 내 요소들을 다양하게, 연속적으로 처리할 수 있는 많은 도구&lt;/p&gt;

&lt;p&gt;새로운 함수를 생성하거나 어떤 계산을 수행하기 위해 &lt;strong&gt;둘 이상의 함수를 결합&lt;/strong&gt;하는 프로세스이다&lt;/p&gt;

&lt;h2 id=&quot;재귀와-꼬리-재귀-최적화&quot;&gt;재귀와 꼬리 재귀 최적화&lt;/h2&gt;

&lt;h2 id=&quot;모나드monad&quot;&gt;모나드(Monad)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;모나드는 값을 캡슐화하고, 추가 기능을 더해 새로운 타입을 생성하는 구조체&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;모나드는 하나의 타입이며 인자를 Type 타입으로 받아 값을 캡슐화하여 값을 가공할 수 있는 추가기능 오퍼레이터를 사용할 수 있는 Functor를 사용하여 최종적으로 이러한 프로세스를 구현하는 구조를 새롭게 생성하는 특징을 가지고 있다.&lt;/p&gt;

&lt;p&gt;다음 세 가지를 충족하면 모나드라 할 수 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;타입을 인자로 받는 타입&lt;/li&gt;
  &lt;li&gt;unit(return) 오퍼레이터가 있어야 한다&lt;/li&gt;
  &lt;li&gt;bind 오퍼레이터가 있어야 한다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;모나드가 필요한 이유 ? &lt;br /&gt;
비동기 연산 처리, NULL 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Map&lt;/strong&gt;&lt;br /&gt;
컬렉션의 원소를 순회하는 방법의 의미보다&lt;br /&gt;
&lt;strong&gt;T 타입의 Functor를 R 타입의 Functor로 바꾸는 기능&lt;/strong&gt;이라고 생각하는 중요!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;flatMap&lt;/strong&gt;&lt;br /&gt;
위 맵의 역할을 하지만 캡슐화가 된 자료구조를 Serialize했다고 생각하면 편하다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.function.Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;함수를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;인자를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;받는&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;메소드만&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;가진다&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;인자&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;가짐&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;전달인자인&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;함수&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f는&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;값을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;받아&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;값을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환하는&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;함수&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor는&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map함수를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;거쳐&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;타입의&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;map메소드로 값을 변경하는 것 뿐인데 왜 Functor를 사용할까?&lt;br /&gt;
=&amp;gt; Functor를 이용하면 &lt;strong&gt;일반적으로 모델링할 수 없는 상황을 모델링 할 수 있다&lt;/strong&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;타입안정성을 유지하면서 NULL을 인코딩하는 방법&lt;/li&gt;
  &lt;li&gt;아직 값을 가지고 있지 않아도 동일하게 map 메소드를 적용할 수 있음
(문법적으로나 의미적으로 완전 동일)&lt;/li&gt;
  &lt;li&gt;비동기 로직을 동기 로직을 구현하는 것과 동일한 형태로 구현하면서도, 함수의 합성 및 완전한 Non-Blocking Pipeline을 구현 가능&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;Functor의 문제점&lt;br /&gt;
=&amp;gt; Functor가 Functor안에 감싸져 있으면, 함수의 합성과 체이닝을 저해하므로 제 기능을 하지 못하게 될 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Monad = Functor + flatMap&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Monad&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Functor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;{&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;flatMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;지연-연산lazy-evaluation&quot;&gt;지연 연산(Lazy Evaluation)&lt;/h2&gt;
&lt;p&gt;어떤 값이 실제로 쓰이기 전까지 그 값의 계산을 최대한 연기하는 것을 의미.&lt;/p&gt;

&lt;p&gt;값을 미리 계산하여 저장하지 않기때문에 공간을 절약할 수 있고 값이 꼭 필요할 때만 계산하기 때문에 프로그램 성능에도 긍정적인 영향을 준다.&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="Programming" /><summary type="html">함수형 프로그래밍 함수의 동작에 의한 변수의 부수적인 값 변경을 원천 배제함으로써 오류를 방지하는 패러다임</summary></entry><entry><title type="html">[데이터보안] 재해복구시스템(DRS:Disater Recovery System)</title><link href="https://many258.github.io/study/disaster-recovery-system/" rel="alternate" type="text/html" title="[데이터보안] 재해복구시스템(DRS:Disater Recovery System)" /><published>2021-03-22T00:00:00+09:00</published><updated>2021-03-22T20:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdisaster-recovery-system%7D</id><content type="html" xml:base="https://many258.github.io/study/disaster-recovery-system/">&lt;h1 id=&quot;재해복구시스템drs--disaster-recovery-system&quot;&gt;재해복구시스템(DRS : Disaster Recovery System)&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/DRS/disaster-recovery-system-intro.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;천재지변이나 해킹 등 각종 재난/재해로 인해 IT 인프라에 장애가 발생하여 제 기능을 수행하지 못하게 되었을 경우, 서비스 연속성을 보장하기 위해 이를 대체하거나 복구하여 제 기능을 수행할 수 있도록 하는 시스템&lt;/p&gt;

&lt;p&gt;재해복구 대책에 대한 법적인 규제 추세(금융감독원 권고안 발표)이다&lt;/p&gt;

&lt;h2 id=&quot;구성-요소&quot;&gt;구성 요소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;BIA(Business Impact Analysis)&lt;br /&gt;
재해가 비지니스에 영향을 미치는 정도를 분석하는 작업&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DOMAIN&lt;br /&gt;
영향도 별 그룹화(복구 우선순위 별 그룹화)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RTO(Recovery Time Object)&lt;br /&gt;
재해 상황에서 서비스가 복구되어야 할 최대 시간&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RPO(Recovery Point Objective)&lt;br /&gt;
재해 상황에서 수용할 수 있는 최대 허용 데이터 손실&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DR 센터 선정&lt;br /&gt;
주 센터와 복구 센터 위치 선정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;백업 방안&lt;br /&gt;
Hot Standby, DB Shadowing, 원격 백업, OS 백업, 단순백업&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;운영 방안&lt;br /&gt;
조직체계, 평상시/재해시 운영절차, 모의 훈련 절차&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기술적-요소&quot;&gt;기술적 요소&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/images/security/DRS/disaster-recovery-system.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;HA&lt;/strong&gt;(&lt;strong&gt;고가용성&lt;/strong&gt; : High Availability)&lt;br /&gt;
서버와 네트워크 등의 정보 시스템이 지속적으로 정상 운영이 가능한 성질&lt;br /&gt;
2개의 서버 중 1대의 서버에서 장애가 발생하면 다른 서버가 대처&lt;br /&gt;
레이드(RAID) 방식과 샌(SAN) 방식을 주로 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;결함 허용&lt;/strong&gt;(FT)&lt;br /&gt;
시스템을 구성하는 푸품의 일부에서 결함(Fault) 또는 고장(Failure)이 발생하여도 정상적 혹은 부분적으로 기능을 수행할 수 있는 시스템&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SAN&lt;/strong&gt;(Storage Area Network)&lt;br /&gt;
대량의 데이터를 집중시켜 보관하고 이를 구성하는 장비들을 이용, 공유하여 사용할 수 있도록 하는 기술.&lt;br /&gt;
다만, 별도의 Fibre Channel 네트워크를 구성해야 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IP-SAN&lt;/strong&gt;&lt;br /&gt;
기존의 TCP/IP 망을 그대로 이용하여 별도의 Fibre Channel 네트워크를 구성해야하는 기존 SAN의 단점을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보완&lt;/code&gt;, 속도는 크게 떨어지지 않는 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fibre Channel&lt;/strong&gt;(파이버 채널 : FC)&lt;br /&gt;
주로 스토리지 네트워킹에 쓰이는 기가 비트 속도의 네트워크 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;WDM&lt;/strong&gt;(파장 분할 다중화 :Wavelength Division Multiplexing)&lt;br /&gt;
한 가닥의 광섬유에 여러 채널을 통해 파장을 동시에 전송하는 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DWDM&lt;/strong&gt;(Dense WDM)&lt;br /&gt;
일정 파장 대역에 걸쳐  수십, 수백개의 파장의 광 신호를 동시에 변조시켜서 하나의 광섬유를 통해 전송하는 WDM의 발전된 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CWDM&lt;/strong&gt;(Coarse WDM)&lt;br /&gt;
DWDM과 유사하나, 파장 간격이 보다 넓고(~10nm 이상) 광증폭기를 잘 사용하지 않는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단거리&lt;/code&gt; 전송에 주로 사용&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;재해복구-구축-절차&quot;&gt;재해복구 구축 절차&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;업무 영향 분석&lt;br /&gt;
&lt;strong&gt;BIA, DOMAIN, RTO, RPO&lt;/strong&gt; 등의 적용과정&lt;br /&gt;
재해로 인한 핵심 프로그램 들의 가동 중단 시 파급영향 분석 및 그에 따른 복구 우선순위를 설정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;재해복구 전략 수립&lt;br /&gt;
대상 별 복구 전략, 복구 솔루션 선전 및 재해복구센터 선정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;시스템 구축 및 복구 계획 수립&lt;br /&gt;
재해복구 시스템 구축 및 업무와 전산시스템의 복구를 위한 상세 계획 수립&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;운영 및 모의 훈련&lt;br /&gt;
수립된 계획의 주기적 테스트를 통한 미비점 파악 및 보완&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;계획-수립-시-고려사항&quot;&gt;계획 수립 시 고려사항&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RSO&lt;/strong&gt;(복구 목표 대상/범위 : Recovery Scope Objective)&lt;br /&gt;
정보의 중요성과 복구 우선순위 지정의 기본 지표가 된다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RTO&lt;/strong&gt;(복구 목표 시간 : Recovery Time Objective)&lt;br /&gt;
시스템 복구까지 허용할 수 있는 최대 시간&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RPO&lt;/strong&gt;(복구 목표 지점 : Recovery Point Objective)&lt;br /&gt;
목표 복구 시점, 데이터 손실을 시간으로 환산한 개념&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RCO&lt;/strong&gt;(통신 복구 목표 : Recovery Communications Objective)&lt;br /&gt;
네트워크 복구 수준&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BCO&lt;/strong&gt;(목표 백업 센터 : Backup Center Objective)&lt;br /&gt;
백업 센터 구축 및 관리 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구축-형태&quot;&gt;구축 형태&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;독자구축&lt;/strong&gt;&lt;br /&gt;
단일 기관 전용의 DRS를 독자적으로 구축&lt;br /&gt;
보안 유지 및 복구의 신뢰성이 가장 높음&lt;br /&gt;
구축 및 유지비용이 가장 많이 소요&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;공동구축&lt;/strong&gt;&lt;br /&gt;
두 개 이상의 기관이 DRS를 공동으로 구축 및 이용&lt;br /&gt;
비교적 적은 구축 및 유지비용&lt;br /&gt;
보안 및 운용 측면에서 고려할 사항이 많고, 광역재해 발생 시 공동이용기관간의 동시 재해복구 불가&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;상호구축&lt;/strong&gt;&lt;br /&gt;
단일 기관의 여러 개 사이트 또는 두 개 이상 기관의 사이트 상호간 DRS의 역할을 수행&lt;br /&gt;
가장 적은 구축 및 유지 비용&lt;br /&gt;
상호 기관 작업에 종속&lt;br /&gt;
서로 다른 기관간의 보안성 및 재해복구에 대한 신뢰성이 낮음&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;외부위탁&lt;/strong&gt;&lt;br /&gt;
재해 복구 전문 서비스 업체에 위탁하여 운영&lt;br /&gt;
전문기술 지원 가능&lt;br /&gt;
정보 유출, 보안 및 신뢰성 문제&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시스템-구성요소-별-복제방식&quot;&gt;시스템 구성요소 별 복제방식&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;H/W (Disk) 복제&lt;/strong&gt;&lt;br /&gt;
디스크 간 복제&lt;br /&gt;
안정성/고성능, 높은비용&lt;br /&gt;
Shadow Copy, True Copy&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;S/W (OS) 복제&lt;/strong&gt;&lt;br /&gt;
OS 수준 솔루션&lt;br /&gt;
안정성/효율성, 비교적 낮은 비용&lt;br /&gt;
Shareplex, Oracle Golden Gate&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;S/W (DBMS) 복제&lt;/strong&gt;&lt;br /&gt;
DBMS 기능 기용&lt;br /&gt;
안정성/효율성, 비교적 낮은 비용&lt;br /&gt;
Orcle RAC&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-동기화-기법&quot;&gt;데이터 동기화 기법&lt;/h2&gt;
&lt;h3 id=&quot;스토리지-데이터-복제-방식&quot;&gt;스토리지 데이터 복제 방식&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Active-Active 스토리지 방식&lt;/strong&gt;&lt;br /&gt;
동기방식으로 스토리지 1, 2가 하나의 저장공간으로 ㄷ오작하며 웹서버1(Active), 웹서버2(Active)가 각각 로컬 스토리지에 Write/Read가 가능&lt;/p&gt;

&lt;p&gt;구성 시 CWDM/DWDM으로 구현, 지연시간에 따라 센터간 50KM이내 권장&lt;/p&gt;

&lt;h3 id=&quot;스토리지-데이터-동기-복제-기법&quot;&gt;스토리지 데이터 동기 복제 기법&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;실시간 동기 방식&lt;/strong&gt;(Synchronous Data Replication)&lt;br /&gt;
서버가 로컬 스토리지에 저장 시 원격 스토리지에도 저장 후 응답을 받고 나서 서버에게 최종 응답을 전달 - Zero RPO, 거리 제약(50Km ~ 300Km)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동기 복제&lt;/code&gt; : SCSI(FC)는 한 번 동작이 메시지를 2차례를 주고 받는다.
즉, 50KM 거리에서 SCSI 한 번 동작 시 1ms 지연 발생&lt;/p&gt;

&lt;h3 id=&quot;스토리지-데이터-비동기-복제-기법&quot;&gt;스토리지 데이터 비동기 복제 기법&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;비동기 방식&lt;/strong&gt;(Asynchronous Data Replication)&lt;br /&gt;
서버가 로컬 스토리지에 저장 이후 리모트 스토리지에 저장 - 거리 제약 없음&lt;/p&gt;

&lt;h2 id=&quot;수준별-유형&quot;&gt;수준별 유형&lt;/h2&gt;
&lt;h3 id=&quot;미러사이트mirror-site&quot;&gt;미러사이트(Mirror Site)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주 센터와 동일한 수준의 정보기술자원을 원격지에 구축, Active Active 상태로 실시간 동시 서비스 제공&lt;/li&gt;
  &lt;li&gt;복구소요시간(RTO) : 즉시&lt;/li&gt;
  &lt;li&gt;데이터 최신성, 높은 안정성, 신속한 업무 재개&lt;/li&gt;
  &lt;li&gt;높은 초기투자비용, 높은 유지보수 비용, 데이터 업데이트가 많은 경우 과부하 야기&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;핫사이트hot-site&quot;&gt;핫사이트(Hot Site)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;주센터와 동일한 수준의 정보기술자원을 원격지에 구축 후 Active Stanby 상태로 유지&lt;/li&gt;
  &lt;li&gt;재해 발생 시 Active 상태로 전환&lt;/li&gt;
  &lt;li&gt;데이터는 동기적 또는 비동기적 방식으로 실시간 미러링을 통하여 최신상태 유지&lt;/li&gt;
  &lt;li&gt;복구소요시간(RTO) : 수 시간 이내&lt;/li&gt;
  &lt;li&gt;데이터 최신성, 높은 안정성, 신속한 업무 재개, 데이터 업데이트가 많은 경우 적합&lt;/li&gt;
  &lt;li&gt;높은 초기투자비용, 높은 유지보수비용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;웜사이트warm-site&quot;&gt;웜사이트(Warm Site)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;중요성이 높은 정보기술자원만 부분적으로 재해복수센터에 보유&lt;/li&gt;
  &lt;li&gt;데이터는 주기적으로 백업&lt;/li&gt;
  &lt;li&gt;복구소요시간(RTO) : 일 단위 ~ 주 단위&lt;/li&gt;
  &lt;li&gt;구축 및 유지비용이 핫사이트에 비해 저렴&lt;/li&gt;
  &lt;li&gt;데이터 손실 다소 발생, 초기복구수준이 부분적, 복구소요시간이 길다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;콜드사이트cold-site&quot;&gt;콜드사이트(Cold Site)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터만 원격지에 보관하고 이의 서비스를 위한 정보자원은 확보하지 않거나 장소 등 최소한으로 확보&lt;/li&gt;
  &lt;li&gt;재해 발생 시 데이터를 근간으로 필요한 정보자원을 조달하여 정보시스템의 복구 개시&lt;/li&gt;
  &lt;li&gt;데이터는 주기적으로 원격지에 백업&lt;/li&gt;
  &lt;li&gt;복구소요시간(RTO) : 주 단위 ~ 달 단위&lt;/li&gt;
  &lt;li&gt;구축 및 유지비용이 가장 저렴&lt;/li&gt;
  &lt;li&gt;데이터 손실 발생, 복구에 매우 긴 시간 소요, 복구 신뢰성이 낮다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;drs-도입-효과&quot;&gt;DRS 도입 효과&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;재무적 관점&lt;/strong&gt;&lt;br /&gt;
ROI, TCO&lt;br /&gt;
서비스 연속성을 통한 투자 대비 효과&lt;br /&gt;
비용 증가 대비 가시성 효과 증대&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;고객 관점&lt;/strong&gt;&lt;br /&gt;
위험 대비 체계적 고품질 서비스&lt;br /&gt;
서비스 안정화로 고객 만족&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로세스 관점&lt;/strong&gt;&lt;br /&gt;
서비스 안정성 기반 생산성 증대&lt;br /&gt;
체계적 관리로 업무 효율성 향상&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;bcpbusiness-continuous-planning과의-비교&quot;&gt;BCP(Business Continuous Planning)과의 비교&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;구분&lt;/th&gt;
      &lt;th&gt;DRS&lt;/th&gt;
      &lt;th&gt;BCP&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;적용시점&lt;/td&gt;
      &lt;td&gt;재해 사후&lt;/td&gt;
      &lt;td&gt;재해 사전/후(평시, 비상시 연속)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;목적&lt;/td&gt;
      &lt;td&gt;정보시스템 인프라와 사업 운영에 필수적인 정보자산의 복구를 촉직하기 위한 상세한 절차를 제공&lt;/td&gt;
      &lt;td&gt;심각한 중단 상황에서 복구가 진행되는 동안에 필수적인 사업을 유지하기 위한 절차를 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;범위&lt;/td&gt;
      &lt;td&gt;IT서비스 중심. BIA에 따른 RTO, RPO를 고려한 서버, 스토리지, 네트워크 구축&lt;/td&gt;
      &lt;td&gt;실제의 업무 프로세스와 업무 프로세스를 지원하기 위한 IT 영역에 집중&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;실행 주체&lt;/td&gt;
      &lt;td&gt;정보시스템 부서가 절차중심으로 수행&lt;/td&gt;
      &lt;td&gt;각 비지니스 부서가 계획중심으로 수행&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;대상&lt;/td&gt;
      &lt;td&gt;IT운영팀을 중심으로 운영시설을 사업단위 중심으로 수행&lt;/td&gt;
      &lt;td&gt;업무는 물론 사람, 물리적 사무공간, 중요 문서등을 포함하여 사전에 준비하기 어려운 수많은 항목이 대상&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;구축 결과물&lt;/td&gt;
      &lt;td&gt;DRP(Disaster Recovery Plan)과 사전 계획 문서&lt;/td&gt;
      &lt;td&gt;재해복구계획, 업무복구계획, 대체프로세스계획, 업무비상계획&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;레퍼런스&quot;&gt;레퍼런스&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.skby.net/drs-disaster-recovery-system/&quot;&gt;도리의 디지털 라이프&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.naver.com/seilius/130189038043&quot;&gt;바보상자의 개발 블로그&lt;/a&gt;&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="데이터 보안" /><summary type="html">재해복구시스템(DRS : Disaster Recovery System)</summary></entry><entry><title type="html">[알고리즘/데이터보안] 블록체인(Block-Chain)</title><link href="https://many258.github.io/study/block-chain/" rel="alternate" type="text/html" title="[알고리즘/데이터보안] 블록체인(Block-Chain)" /><published>2021-03-21T00:00:00+09:00</published><updated>2021-03-22T15:37:34+09:00</updated><id>https://many258.github.io/study/%7Bblock-chain%7D</id><content type="html" xml:base="https://many258.github.io/study/block-chain/">&lt;h1 id=&quot;블록-체인&quot;&gt;블록 체인&lt;/h1&gt;
&lt;p&gt;관리 대상 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블록&lt;/code&gt;이라고 하는 소규모 데이터들이 P2P방식을 기반으로 모여 이룬 체인 연결고리 분산 데이터 저장 환경&lt;/p&gt;

&lt;p&gt;즉, 네트워크에 중앙 서버가 아닌 참여하는 모든 사용자가 모든 거래 내역 등을 공동으로 기록, 관리하여 데이터를 분산, 저장하는 기술을 의미&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/block-chain.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;
&lt;p&gt;편집이 불가능하고 추가 작업(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APPEND&lt;/code&gt;)만 가능한 데이터베이스&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;탈중앙화&lt;/code&gt;(Decentralization) 데이터베이스의 복제본을 모두가 소유하고 있기 때문에 개인의 위조를 방지할 수 있다&lt;/p&gt;

&lt;h2 id=&quot;블록의-구성&quot;&gt;블록의 구성&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/block-chain-element.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; width=&quot;120%&quot; height=&quot;120%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;블록 헤더&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;블록의 정체성
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;비전&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;이전블록의 해시&lt;/strong&gt; : 현재 블록이 이전 블록과 연결되어 있음을 의미&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;타임스탬프&lt;/strong&gt; : 채굴 경쟁과 직접적 연관이 있는 부분&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;난이도 목표&lt;/strong&gt; : 채굴 경쟁과 직접적 연관이 있는 부분&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;논스&lt;/strong&gt;: 채굴 경쟁과 직접적 연관이 있는 부분&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;머클루트&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;거래 카운터&lt;/strong&gt; : 거래의 개수&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;거래&lt;/strong&gt; : 블록에 기록된 거래 내역&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해시&quot;&gt;해시&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/hash-algorithm.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;단방향 암호화, 결정론적&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;임의의 길이를 갖는 문자열을 입력받아 &lt;strong&gt;고정된 길이&lt;/strong&gt;의 해시 값을 출력하는 함수를 해시 함수라 하는데 이 함수로 인해서 출력된 값을 해쉬 값이라 부른다. 이 때 해쉬 값으로부터 기존 메시지를 역산할 수는 없는 성질을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단방향성&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;또한, 메시지가 다르면 비슷하다 할지라도 해시값도 다르다는 특징이 있는데 해당 특징으로 인해 해시 함수를 무결성을 확인하기 위한 방안으로 사용하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결정론적&lt;/code&gt;이다라는 의미는 해시 알고리즘은 특정 입력 대해 항상 같은 해시 값을 반환한다는 것을 뜻한다.&lt;/p&gt;

&lt;p&gt;일반적인 해싱 알고리즘은 MD4, MD5, SHA, RIPEMD, WHIRLPOOL, TIGER가 있다.&lt;/p&gt;

&lt;p&gt;이전 블록 해쉬 + 데이터 =&amp;gt; 자기 자신만의 블록 해쉬 값
이렇게 해쉬 값을 가지고 블록을 연결시킨다는 의미에서 체인이라는 단어를 사용하는 것이다.&lt;/p&gt;

&lt;p&gt;데이터가 조금이라도 변경된다면 해쉬값도 변경되고 그 이후 블록에도 영향을 미치기 때문에 올바른 체인을 생성할 수 없게 된다.&lt;/p&gt;

&lt;p&gt;블록체인을 사용하는 모든 사용자들이 같은 체인을 가지고 있으며, 각자의 체인을 비교함으로서 같은 체인인지 검증이 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;머클-루트merkle-root&quot;&gt;머클 루트(Merkle Root)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/merkle-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이진트리라는 이름으로도 알려져 있으며,&lt;/p&gt;

&lt;p&gt;두 개씩 거래를 묶은 다음 해싱 알고리즘을 통해 해시 값으로 나타내고 또 그렇게 묶은 값들을 다시 두 개씩 묶어서 다시 해싱하여 수 백개의 거래 값들을 가장 꼭대기에 위치한 하나의 데이터로 만들어준다.&lt;/p&gt;

&lt;p&gt;이렇게 이진트리 방식으로 구성하게되면 거래량이 기하급수적으로 늘어나도 특정 거래를 찾는 경로는 단순하다는 이점이 있다. 그렇기에 거래 내역을 위조하려는 시도가 있어도 머클트리의 경로를 따라가면 해시값이 다른 것이 나오게 되어 거래의 위변조도 쉽고 빠르게 알 수 있게 되고 이를 방지할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;종류&quot;&gt;종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;퍼블릭 블록체인&lt;/strong&gt;(Public BlockChain)&lt;br /&gt;
개방형 블록체인으로 누구나 트랜잭션을 생성할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프라이빗 블록체인&lt;/strong&gt;(Private BlockChain)&lt;br /&gt;
폐쇠형 블록체인으로 주로 기업에서 사용하기에 엔터프라이즈 블록체인(Enterprise BlockChain)이라고도 한다.서비스 제공자의 승인을 받아야만 참여가 가능한 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;콘소시엄 블록체인&lt;/strong&gt;(Consortium BloackChain)&lt;br /&gt;
프라이빗 블록체인을 확장한 방식으로 여러 기업또는 기관이 공동으로 참여한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;작업증명pow--proof-of-work&quot;&gt;작업증명(PoW : Proof of Work)&lt;/h2&gt;
&lt;p&gt;모든 블록(노드)가 포함된 거래 내역이 악의적인 공격자에 의해 변조되지 않은 올바른 블록체인을 공유하는 있다는 것을 입증하기 위해 P2P 네트워크, 공개키-개인키 암호, 공유된 데이터베이스에 정보를 저장하고 검증하는 방법을 관리하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;합의 알고리즘&lt;/code&gt;(Consensus Mechanism)이라는 것을 활용하는데 여러 종류 중에서도 비트코인의 경우 PoW(작업증명 : Proof of Work)라는 합의 알고리즘을 사용한다.&lt;/p&gt;

&lt;p&gt;블록체인은 이와 같은 요소 기술들을 결합해 네트워크 상에서 투명성을 확보하며 데이터의 위조/변조 방지 및 보안성을 강화한 기술이다&lt;/p&gt;

&lt;h2 id=&quot;마이닝mining&quot;&gt;마이닝(Mining)&lt;/h2&gt;
&lt;p&gt;PoW란 컴퓨팅 파워를 이용해 블록의 해쉬 값을 추적하여 블록체인 네트워크에 새로운 블록을 추가하는 방식의 알고리즘이다&lt;/p&gt;

&lt;p&gt;위 과정이 채굴(Mining)에 해당한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/dodge-mining.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비트코인의 경우 
채굴자가 네트워크에 새로운 블록들을 추가할 때 마다 받을 수 있으며
새로운 블록들을 추가하기 위해서는 네트워크의 질문에 원하는 답을 찾아서 논스 값을 변경해야 한다.&lt;/p&gt;

&lt;p&gt;논스(Nonce)는 채굴자가 변경할 수 있는 유일한 값이며 Nonce 값을 변경할 때 마다 해쉬 값이 달라지는데, 채굴자는 그중에서도 현재 난이도에 맞춰서 네트워크가 던지는 질문에 적절한 값을 가지는 해쉬를 만들어내야 한다.&lt;/p&gt;

&lt;h2 id=&quot;활용&quot;&gt;활용&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;암호화폐 거래&lt;/li&gt;
  &lt;li&gt;ICO(Initial Coin Offering)&lt;/li&gt;
  &lt;li&gt;NFT(Non-Fungible Token)&lt;/li&gt;
  &lt;li&gt;DEX(Decebtrakuzed Exchange)&lt;/li&gt;
  &lt;li&gt;스마트 컨트랙트(Smart Contract)
    &lt;blockquote&gt;
      &lt;p&gt;사전에 정해진 임의의 규칙에 따라 디지털 자산을 자동적으로 이전하는 시스템 - Vitalik Buter&lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;블록체인이 지니고 있는 탈중앙화를 기반으로 금융거래, 부동산 계약, 공증 등 다양한 형태의 계약을 체결하고 이행하는 것. (블록체인 2.0)&lt;/li&gt;
      &lt;li&gt;다른사람들과의 교류와 코드로 소통이 가능하며 또한 공유 네트워크에 업로드할 수 있다&lt;/li&gt;
      &lt;li&gt;수정은 불가하나 공유/검증/실행은 가능하다&lt;/li&gt;
      &lt;li&gt;원하는 소스를 다 활용할 수 없음(블록체인 네트워크 위에서만 실행 가능)&lt;/li&gt;
      &lt;li&gt;신뢰 기반이 아닌 특수한 네트워크, 환경을 요구&lt;/li&gt;
      &lt;li&gt;스마트 컨트랙 지원 암호화폐&lt;br /&gt;
이더리움, Kusama, Polkadot, Cardano, Cosmos&lt;/li&gt;
      &lt;li&gt;개발자들은 이더리움 상에서 스마트 컨트랙트를 활용하여 암호화폐 지갑, 금융 애플리케이션, 마켓, 게임과 같이 새로운 종류의 탈중앙화된 애플리케이션(DApps)을 개발할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;단점&quot;&gt;단점&lt;/h2&gt;
&lt;p&gt;블록체인 네트워크는 그 특성상 노드의 신뢰를 기반으로 하기 때문에, 신뢰가 무너지는 순간 블록체인 역시 급격하게 무너질 수 있다는 치명적인 맹점이 있다.&lt;/p&gt;

&lt;p&gt;또한 참여하는 노드 수(분산되어 데이터를 저장되는 주체의 수)가 매우 적을 경우에 외부 공격자와 침입에 취약하다&lt;/p&gt;

&lt;p&gt;탈중앙화, 보안성, 확장성의 문제로 이 세 가지 문제 중 어떠한 두 가지는 만족시킬 수 있지만, 남은 한 가지는 만족시킬 수 없는 트릴레마의 문제가 있으며 이 문제를 보완하기 위해 사이드체인, 샤딩, 인터체인, 라이트닝 네트워크, 플라즈마 기술이 있다.&lt;/p&gt;

&lt;h1 id=&quot;레퍼런스&quot;&gt;레퍼런스&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.banksalad.com/contents/%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%98%EB%8A%94-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC-Merkle-Trees-%EB%9E%80-ilULl&quot;&gt;블록체인-개념-완벽-정리(뱅크샐러드)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://brownbears.tistory.com/372&quot;&gt;머클트리란? - 불곰님 티스토리 블로그&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kiri.or.kr/pdf/%EC%97%B0%EA%B5%AC%EC%9E%90%EB%A3%8C/%EC%97%B0%EA%B5%AC%EB%B3%B4%EA%B3%A0%EC%84%9C/nre2018-24_02.pdf&quot;&gt;블록체인의 이해&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Ca7Meu4z-F4&quot;&gt;노마드 코더 유튜브&lt;/a&gt;&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="Algorithm" /><category term="데이터 보안" /><summary type="html">블록 체인 관리 대상 데이터를 블록이라고 하는 소규모 데이터들이 P2P방식을 기반으로 모여 이룬 체인 연결고리 분산 데이터 저장 환경</summary></entry><entry><title type="html">[배민커넥트] 도보로 시작하기 및 주의사항과 소소한팁</title><link href="https://many258.github.io/life/baemin-connect/" rel="alternate" type="text/html" title="[배민커넥트] 도보로 시작하기 및 주의사항과 소소한팁" /><published>2021-03-20T00:00:00+09:00</published><updated>2021-03-20T20:37:34+09:00</updated><id>https://many258.github.io/life/%7Bbaemin-connect%7D</id><content type="html" xml:base="https://many258.github.io/life/baemin-connect/">&lt;h1 id=&quot;개요&quot;&gt;개요&lt;/h1&gt;
&lt;p&gt;몸이 굳어있던 추운 계절이 지나고 나들이나 운동을 하기 좋은 계절이 오고 있습니다.&lt;br /&gt;
하지만 코로나의 영향으로 아직까지는 헬스장을 가는게 꺼려지는 것은 제 주관적이지만 솔직히 말해서 사실입니다.&lt;/p&gt;

&lt;p&gt;이 때, 배민커넥트를 시작하기에 최적의 시기라고 생각합니다.&lt;/p&gt;

&lt;p&gt;필자는 걷는 것을 좋아해서 작년 여름에 주변 지인의 추천으로 배민 커넥트에 입문하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/life/baemin-connect_feature.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간단히 말해, 내가 원하는 시간에 운동과 동시에 부수입을 얻을 수 있다는 것이 배민커넥트의 최대 장점이라 할 수 있겠습니다&lt;/p&gt;

&lt;p&gt;마지막 이유로 현재 진행중인 친구초대 이벤트를 후술하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;도보로-시작하기&quot;&gt;도보로 시작하기&lt;/h1&gt;

&lt;p&gt;다른 수단들과 비교하여 별다른 준비 없이 핸드폰, 보온가방, 튼튼한 두 다리만 있다면 가능하지만, 만약 ‘나는 수입이 목적이에요~’라는 사람이 있다면 권유는 드리지 않습니다.&lt;/p&gt;

&lt;p&gt;커넥트의 장점은 내가 &lt;strong&gt;원하는 시간&lt;/strong&gt;에 할 수 있다는 것이지, 수입을 목적으로 하기엔 어려운 면이 있습니다. 아무래도 당일 &lt;strong&gt;주문의 양&lt;/strong&gt;에 따라 그 날 수입이 들쑥날쑥하고 한 건당 &lt;strong&gt;시간 소요가 크기 때문에&lt;/strong&gt; 안타깝게도 어떤 날은 최저시급으로 계산한 것 보다 적게 지급받을 수도 있습니다.&lt;/p&gt;

&lt;p&gt;가방과 보조장비들은 우아한스토어에서 구매(가방만 구매시 26,400원)를 하시거나 중고 마켓을 이용하는 것도 방법 중 하나입니다.&lt;/p&gt;

&lt;p&gt;또한 매주 배송할 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;20시간&lt;/code&gt;으로 제한되어 있으며 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수요일&lt;/code&gt;에 초기화되며 가장 중요한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정산&lt;/code&gt;은 별다른 공지가 없으면 매주 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;금요일&lt;/code&gt;에 진행됩니다. 정산의 경우 한 건 이상을 배달을 수행하였다면, 약 3천원 정도의 &lt;strong&gt;산재보험료&lt;/strong&gt;가 부과된다는 점 알고 계시기 바랍니다.&lt;/p&gt;

&lt;p&gt;마지막으로 산업안전보건법에 따라 &lt;strong&gt;PC&lt;/strong&gt;에서 &lt;strong&gt;2시간&lt;/strong&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안전보건교육&lt;/code&gt; 이수 후에 첫 배달을 시작할 수 있습니다.&lt;/p&gt;

&lt;p&gt;무엇보다도 뚜벅이 커넥터일지라도 &lt;strong&gt;안전&lt;/strong&gt;이 &lt;strong&gt;최우선&lt;/strong&gt;으로 중요합니다!&lt;/p&gt;

&lt;h2 id=&quot;배송-과정&quot;&gt;배송 과정&lt;/h2&gt;
&lt;p&gt;처음 시도하는 입장에서 까다로울 것 같지만 한 두번 해보게 되면 전혀 어렵지않습니다.&lt;/p&gt;

&lt;p&gt;주문을 받는 시스템으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;일반 배차&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AI배차&lt;/code&gt;가 있으며&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일반 배차&lt;/strong&gt;의 경우 실시간으로 주문(콜)이 올라오며 커넥터가 이 콜을 직접 선택하는 방식이고&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AI배차&lt;/strong&gt;의 경우 AI가 경로를 파악하며 고객에게 예정 시간에 배달이 가능한지 등을 종합적으로 고려해서 특정 배달 주문을 수행하기에 가장 적합한 위치의 커넥터에게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선적&lt;/code&gt;으로 콜을 보내는 방식입니다. 이 때, 약 30초간 선택할 수 있는 시간이 주어지고 시간이 초과될 때까지 결정을 못했다면 다른 커넥터/라이더에게 주문이 넘어갑니다.&lt;/p&gt;

&lt;p&gt;필자는 다른 커넥터/라이더들과 경쟁으로 인해 빨리빨리 콜을 잡아햐하는 일반배차보다 품목을 세부적으로 꼼꼼히 확인할 수 있는 &lt;strong&gt;AI배차&lt;/strong&gt;를 더 추천하는 바입니다.&lt;/p&gt;

&lt;p&gt;실제 배송 과정은 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;신규배달&lt;/code&gt; 알림이 도착한다(AI배차로 선택한 경우)&lt;/li&gt;
  &lt;li&gt;알림을 눌러 배송가능한 품목들인지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;확인&lt;/code&gt;을 한다&lt;/li&gt;
  &lt;li&gt;가능할 것 같다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;승낙&lt;/code&gt;을 누르고 다음 단계로, 어려울 것 같다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;거절&lt;/code&gt;을 누르고 1단계로 다시 돌아가 알림올 때까지 기다린다.&lt;/li&gt;
  &lt;li&gt;매장까지 이동하고 매장에 도착했다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;매장도착&lt;/code&gt; 버튼을 누른다&lt;/li&gt;
  &lt;li&gt;음식/물품이 완료될 때 까지 기다리고 주문번호 확인 후 받았으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;픽업완료&lt;/code&gt;를 누른다&lt;/li&gt;
  &lt;li&gt;고객에게 이동한 후 음식/물품을 건내주고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전달완료&lt;/code&gt;를 누른다&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;embed-responsive embed-responsive-16by9&quot;&gt;
  &lt;iframe class=&quot;embed-responsive-item&quot; width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/r3PXvZ6CxUI&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;

&lt;p class=&quot;align-center&quot;&gt;&lt;br /&gt;&lt;br /&gt;
자세한 사항은 &lt;a href=&quot;http://www.baeminriders.kr/connect/&quot;&gt;배민커넥트 홈페이지&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;주의-사항&quot;&gt;주의 사항&lt;/h2&gt;
&lt;h3 id=&quot;핸드폰은-생명이나-다름-없다&quot;&gt;핸드폰은 생명이나 다름 없다&lt;/h3&gt;
&lt;p&gt;핸드폰이 방전되었다면 사실상 할 수 있는 것이 없습니다.&lt;/p&gt;

&lt;p&gt;가능하다면 필히 &lt;strong&gt;보조배터리&lt;/strong&gt;를 소지하고 다니고 만약 고장이 난 경우,
주변 사람들의 도움을 받아 배달의 민족 고객센터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1600-9880&lt;/code&gt;으로 
연락 후 조치를 취하는 것이 가장 현명한 방법이라 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;모든-항목을-꼼꼼히-검토한다-욕심은-금물&quot;&gt;모든 항목을 꼼꼼히 검토한다. 욕심은 금물&lt;/h3&gt;
&lt;p&gt;배송 중에는 단지 힘들다고 또는 거리가 멀다고 중간에 그만두거나 배송 &lt;strong&gt;취소하기가 상당히 어렵습니다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;그래서, 항!상! 품목을 확인하고 내가 배송을 갈 수 있는 것인지 아닌지 판단하고 행동하는 것이 중요합니다. 자유에는 책임이 따른다는 명언이 생각나네요&lt;/p&gt;

&lt;p&gt;또한 &lt;strong&gt;고객요청사항&lt;/strong&gt; 중에 특히나 벨을 울리지 말아달라는 요청도 많으니 이 점 확실하게 유의해주셔야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;면국물-요리는-자신이-있을-때-잡자&quot;&gt;면/국물 요리는 자신이 있을 때 잡자&lt;/h3&gt;
&lt;p&gt;면/국물 요리는 특히 시간이 생명이라는 거 잘 알고 계실거라 생각됩니다.&lt;/p&gt;

&lt;p&gt;도보커넥터들은 보통 다른 운송수단보다 상대적으로 시간이 더 소요되기 때문에 보온/보냉가방을 사용하고 있고 거리가 가까운 경우가 아니라면 다른 커넥터/라이더 분께 양보해드리는 게 더 좋을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;현금카드-결제는-미리-확인하자&quot;&gt;현금/카드 결제는 미리 확인하자&lt;/h3&gt;
&lt;p&gt;비마트의 경우에는 무조건 선결제로 이뤄지지만 일반 매장일 경우 현금이나 카드로 결제를 신청하는 분들이 꽤 있으십니다.&lt;/p&gt;

&lt;p&gt;그러므로, 배송수락 전 잔돈이 있는지 확인하는 것을 습관화합시다.&lt;/p&gt;

&lt;h3 id=&quot;손님에게-직접-건네주지-않는-한-사진을-꼭-찍어두자&quot;&gt;손님에게 직접 건네주지 않는 한 사진을 꼭 찍어두자&lt;/h3&gt;
&lt;p&gt;코로나로 인해 직접 대면하여 음식/물건을 전달하는 것보다 ‘집 앞에 놓아주세요’라고 요청하는 고객님들이 부쩍 늘었습니다.&lt;/p&gt;

&lt;p&gt;어플 기능 중에 고객에게 사진 전송하는 기능이 있는데 실제로 고객님이 사용하는 어플에 푸쉬알림으로 전해지게 됩니다.
혹여나 음식이나 물건을 전달받았음에도 불구하고 받지 못했다고 클레임을 진행하는 고객이 있을 수도 있으니(한번도 만나보지 못했지만..) 배송업무를 끝내고 증거(?)로 남겨두는 목적입니다.&lt;/p&gt;

&lt;h2 id=&quot;미세한-팁들&quot;&gt;미세한 팁들&lt;/h2&gt;
&lt;h3 id=&quot;거점을-정하자&quot;&gt;거점을 정하자&lt;/h3&gt;
&lt;p&gt;배민커넥트 카카오톡 플러스친구에서는 주마다 어느 지역에 배달이 많았는지 분포도로 알려주고 있습니다.&lt;/p&gt;

&lt;p&gt;이를 참고하여 어느 지점을 타겟팅을 할 것인지 &lt;strong&gt;개방화장실&lt;/strong&gt;의 위치정도는 미리 파악해두는 것이 도움이 될 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;점심시간과-저녁시간이-피크타임&quot;&gt;점심시간과 저녁시간이 피크타임&lt;/h3&gt;
&lt;p&gt;가능하면 시간대를 12시 ~ 2시, 6시 ~ 8시로 움직이는 것을 추천합니다.&lt;/p&gt;

&lt;p&gt;이 때가 가장 주문이 많은 편이며 각종 프로모션으로 배송비도 또한 많이 오르는 편입니다.&lt;/p&gt;

&lt;h3 id=&quot;휴식할-곳을-미리-파악하자&quot;&gt;휴식할 곳을 미리 파악하자&lt;/h3&gt;
&lt;p&gt;뚜벅이 커넥터들은 항상 다리가 아픕니다.&lt;/p&gt;

&lt;p&gt;배송이 끝난 후 남는 시간에 미리미리 휴식할 장소(특히 공원 벤치)을 찾아 체력을 비축해두는 것을 추천합니다.&lt;/p&gt;

&lt;h3 id=&quot;만보기-어플을-이용하자&quot;&gt;만보기 어플을 이용하자&lt;/h3&gt;
&lt;p&gt;우리의 목표는 운동과 부수입이라는 두 마리 토끼를 잡는 것입니다.&lt;/p&gt;

&lt;p&gt;이 만보기나 헬스케어 어플은 운동을 시각화해줌으로써 목표를 달성하면 하루의 보람을 느끼게 해주기도 하고 다음 날에도 계속 커넥트를 할 수 있게 끔 추진력과 원동력을 만들어 주기에 많은 도움을 줍니다.&lt;/p&gt;

&lt;h3 id=&quot;웨어러블-장비를-마련하자&quot;&gt;웨어러블 장비를 마련하자&lt;/h3&gt;
&lt;p&gt;이건 진짜 알려주기 싫을 정도로 꿀정보라고 할 수 있는데 필자는 현재 미밴드를 착용하면서 커넥트를 하고 있습니다.&lt;/p&gt;

&lt;p&gt;미밴드 뿐만 아니라 다른 스마트워치에도 대부분 존재하는 기능 중에 따로 지정한 어플에서 푸쉬알림이 오면 진동으로 알려주는 시스템이 있는데, 이 때, 핸드폰을 굳이 보고있지 않아도 알림이 오면 손목에서 진동으로 자칫 못보고 넘어갈 수 있는 알림을 알려주니까 확인하기 편해서 강력히 추천드립니다.&lt;/p&gt;

&lt;h1 id=&quot;마치며&quot;&gt;마치며..&lt;/h1&gt;
&lt;p&gt;앞서 말씀드린 것처럼 배민에서는 친구초대 이벤트를 현재 진행중입니다.&lt;/p&gt;

&lt;p&gt;기존 이벤트의 경우 추천인 코드를 입력한 사람이 배송임무를 진행할 경우, 추천받은 사람과 추천한 사람 모두 1만원을 제공하였으나 금일부로(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3월20일&lt;/code&gt;) 2만원으로 인상되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/life/baemin-connect.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에 한시적으로 진행하므로 이 기회에 지인과 함께 하시거나 저의 추천인코드(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BC642005&lt;/code&gt;)와 한 번 도전해보시는 것도 좋은 선택이라 생각됩니다.&lt;/p&gt;

&lt;p&gt;포스팅을 하는 지금 당장 생각나는 내용들은 이것으로 마무리하겠습니다.&lt;br /&gt;
블로그를 운영하지 얼마 지나지 않았고 글을 쓰는 재주도 없는 터라 많은 도움이 되셨는지는 모르겠습니다.&lt;/p&gt;

&lt;p&gt;그 밖에도 궁금하신 내용이나 질문들은 제가 경험한 선에서 답해드릴 수 있으니 좌측이나 우측에 있는 &lt;strong&gt;카카오톡 오픈톡방&lt;/strong&gt; 링크로 문의부탁드리겠습니다.&lt;/p&gt;

&lt;p&gt;감사합니다 XD&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="life" /><category term="배민커넥트" /><summary type="html">개요 몸이 굳어있던 추운 계절이 지나고 나들이나 운동을 하기 좋은 계절이 오고 있습니다. 하지만 코로나의 영향으로 아직까지는 헬스장을 가는게 꺼려지는 것은 제 주관적이지만 솔직히 말해서 사실입니다.</summary></entry><entry><title type="html">[알고리즘] 최소신장트리(MST)와 그래프의 순회(Graph Traversal)</title><link href="https://many258.github.io/study/algorithm-MST-graph-traversal/" rel="alternate" type="text/html" title="[알고리즘] 최소신장트리(MST)와 그래프의 순회(Graph Traversal)" /><published>2021-03-19T00:00:00+09:00</published><updated>2021-03-19T22:37:34+09:00</updated><id>https://many258.github.io/study/%7Balgorithm-MST-graph-traversal%7D</id><content type="html" xml:base="https://many258.github.io/study/algorithm-MST-graph-traversal/">&lt;h1 id=&quot;신장-트리spanning-tree&quot;&gt;신장 트리(Spanning Tree)&lt;/h1&gt;
&lt;p&gt;그래프 내의 모든 정점을 포함하는 트리&lt;br /&gt;
최소 연결 부분 그래프.&lt;/p&gt;

&lt;p&gt;N개의 정점을 가지는 그래프의 최소 간선의 수는 N-1개이며, N-1개의 간선으로 연결되어 있으면 필연적으로 트리 형태가 이루어지고 이것이 바로 Spanning Tree라 할 수 있다.&lt;/p&gt;

&lt;p&gt;하나의 그래프에는 많은 신장 트리가 존재할 수 있으며, 트리의 특수한 형태이므로 모든 정점들이 연결되어 있어야 하고 사이클을 &lt;strong&gt;포함해서는 안된다&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;최소-신장트리mst--minimum-spanning-tree&quot;&gt;최소 신장트리(MST : Minimum Spanning Tree)&lt;/h2&gt;
&lt;p&gt;가능한 신장트리에서 간선의 가중치 합이 최소인 신장트리를 의미&lt;/p&gt;

&lt;p&gt;최소 비용 신장 트리를 구하는 방법들은 모두 &lt;strong&gt;탐욕 알고리즘&lt;/strong&gt;(Greedy Algorithm)으로 구현&lt;/p&gt;

&lt;p&gt;** 탐욕 알고리즘 : 각 단계에서 최선의 선택이 최종 단계에서도 최선의 결과를 나타낼 것이라고 생각하는 알고리즘&lt;/p&gt;

&lt;h2 id=&quot;크루스칼-알고리즘kruskals-algorithm&quot;&gt;크루스칼 알고리즘(Kruskal’s Algorithm)&lt;/h2&gt;
&lt;p&gt;간선 위주의 알고리즘.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;모든 간선들의 가중치를 오름차순으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정렬&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;가중치가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소&lt;/code&gt;인 간선을 선택&lt;/li&gt;
  &lt;li&gt;위에서 선택한 간선이 연결하려는 2개의 노드가 서로 연결되지 않은 상태라면, 2개의 노드를 서로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연결&lt;/code&gt;(이 때, &lt;strong&gt;사이클이 발생하지 않도록 주의&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;최소신장트리가 만들어지기 전까지 2~3 과정 반복 수행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그래프 내 간선의 개수가 적은 &lt;strong&gt;희소 그래프&lt;/strong&gt;의 경우 크루스칼 알고리즘에 적합하다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/algorithm/graph/KruskalAlg.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프림-알고리즘prims-algorithm&quot;&gt;프림 알고리즘(Prim’s Algorithm)&lt;/h2&gt;
&lt;p&gt;정점 위주의 알고리즘&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;임의의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정점&lt;/code&gt;을 선택&lt;/li&gt;
  &lt;li&gt;정점에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인접&lt;/code&gt;한 간선 중 가중치가 최소인 간선으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연결&lt;/code&gt;된 정점을 선택&lt;/li&gt;
  &lt;li&gt;위 정점에서 다시 최소 간선으로 연결된 정점을 선택&lt;/li&gt;
  &lt;li&gt;최소신장트리가 만들어지기 전까지 2-3 과정 반복 수행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그래프 내 간선의 개수가 많은 &lt;strong&gt;밀집 그래프&lt;/strong&gt;의 경우 프림 알고리즘이 적합하다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/algorithm/graph/PrimAlg.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;그래프의-순회graph-traversal&quot;&gt;그래프의 순회(Graph Traversal)&lt;/h1&gt;
&lt;p&gt;하나의 정점에서 시작하여 그래프에 있는 모든 정점을 한번씩 방문하는 것을 그래프 순회 또는 탐색이라 한다&lt;/p&gt;

&lt;h2 id=&quot;dfs깊이-우선-탐색--depth-first-search&quot;&gt;&lt;strong&gt;DFS&lt;/strong&gt;(깊이 우선 탐색 : Depth-First Search)&lt;/h2&gt;
&lt;p&gt;아직 방문하지 않은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자식&lt;/code&gt; 노드를 우선적으로 탐색&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;정점 i를 방문한다.&lt;/li&gt;
  &lt;li&gt;정점 i에 인접한 정점 중에서 아직 방문하지 않은 정점이 있으면 이 정점을 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STACK&lt;/code&gt;에 저장한다&lt;/li&gt;
  &lt;li&gt;스택에서 정점을 삭제하여 새로운 i를 설정하고 다시 1단계부터 수행&lt;/li&gt;
  &lt;li&gt;스택이 공백이 되면 연산을 종료&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/algorithm/graph/DFS.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;특징&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;현 경로상의 노드만을 기억하면 되므로 저장 공간의 수요가 비교적 적지만, 한 경로가 무한히 깊을 경우 &lt;strong&gt;오버플로우&lt;/strong&gt;가 발생할 수 있다.&lt;br /&gt;
이를 방지하기 위해, 깊이에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제한&lt;/code&gt;을 두고 구현이 필요하다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;목표에 &lt;strong&gt;도달하지 못할 가능성이 존재&lt;/strong&gt;하며, 도달할지라도 해당 경로가 &lt;strong&gt;최단 경로라고 보장할 수 없다&lt;/strong&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bfs너비-우선-탐색--breadth-first-search&quot;&gt;&lt;strong&gt;BFS&lt;/strong&gt;(너비 우선 탐색 : Breadth-First Search)&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;형제&lt;/code&gt; 노드를 우선적으로 탐색하는 기법&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;임의의 시작 노드를 정해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QUEUE&lt;/code&gt;에 넣는다&lt;/li&gt;
  &lt;li&gt;Dequeue연산을 통해 큐에서 노드를 가져와 현재 노드로 정한다&lt;/li&gt;
  &lt;li&gt;현재 노드의 인접 노드 목록을 순회하면서 방문하지 않은 노드가 있는지 확인한다&lt;/li&gt;
  &lt;li&gt;방문하지 않은 노드가 있다면 그 노드를 큐에 넣고 방문한다.&lt;/li&gt;
  &lt;li&gt;큐가 공백이 될 때까지 2~4과정을 반복 수행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/algorithm/graph/BFS.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;특징&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;큐에 다음에 탐색할 정점들을 저장해야 하므로 &lt;strong&gt;저장공간이 많이 필요&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;단순 검색속도가 DFS보다 빠르다&lt;/li&gt;
      &lt;li&gt;최단 경로를 보장함과 동시에 &lt;strong&gt;반드시 찾을 수 있다&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="Algorithm" /><category term="컴퓨터일반" /><category term="Programming" /><summary type="html">신장 트리(Spanning Tree) 그래프 내의 모든 정점을 포함하는 트리 최소 연결 부분 그래프.</summary></entry><entry><title type="html">[자료구조] 트리의 종류 및 특징</title><link href="https://many258.github.io/study/data-structure-tree-type/" rel="alternate" type="text/html" title="[자료구조] 트리의 종류 및 특징" /><published>2021-03-19T00:00:00+09:00</published><updated>2021-03-19T20:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdata-structure-tree-type%7D</id><content type="html" xml:base="https://many258.github.io/study/data-structure-tree-type/">&lt;h1 id=&quot;트리의-종류&quot;&gt;트리의 종류&lt;/h1&gt;
&lt;h2 id=&quot;이진-트리binary-tree&quot;&gt;이진 트리(Binary Tree)&lt;/h2&gt;
&lt;p&gt;기본적으로 자식노드를 최대 2개 가지는 트리를 의미&lt;/p&gt;

&lt;h3 id=&quot;완전-이진-트리complete-binary-tree&quot;&gt;완전 이진 트리(Complete Binary Tree)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;왼쪽&lt;/code&gt; 자식노드부터 채워지며 마지막 레벨을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제외&lt;/code&gt;하고는 모든 자식노드가 채워져있는 트리&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/complete-binary-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;힙heap&quot;&gt;힙(Heap)&lt;/h4&gt;
&lt;p&gt;부모 자식 노드 간의 대소 관계는 정의되어 있으나 형제간의 대소관계는 정의되어 있지 않은 완전 이진트리 자료구조를 의미&lt;/p&gt;

&lt;p&gt;힙에는 두가지 종류가 있으며, 부모노드의 키값이 자식노드의 키값보다 항상 큰 힙을 ‘최대 힙’, 부모노드의 키값이 자식노드의 키값보다 항상 작은 힙을 ‘최소 힙’이라고 명명한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/heap.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;포화-이진-트리perfect-binary-tree&quot;&gt;포화 이진 트리(Perfect Binary Tree)&lt;/h3&gt;
&lt;p&gt;모든 노드가 0 or 2개의 자식노드를 가지며 모든 리프노드가 똑같은 레벨에 있는 경우의 트리&lt;/p&gt;

&lt;p&gt;레벨의 수를 N이라 가정할 때, 2&lt;sup&gt;n&lt;/sup&gt;-1 개의 노드를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/perfect-binary-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;정-이진-트리full-binary-tree&quot;&gt;정 이진 트리(Full Binary Tree)&lt;/h3&gt;
&lt;p&gt;모든 노드가 0 or 2개의 자식노드를 가지는 트리를 의미&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/full-binary-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;편향-이진-트리skewed-binary-tree&quot;&gt;편향 이진 트리(Skewed Binary Tree)&lt;/h3&gt;
&lt;p&gt;노드들이 전부 한 방향으로 편향된 트리를 의미&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/skewed-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;이진-탐색-트리bst--binary-search-tree&quot;&gt;이진 탐색 트리(BST : Binary Search Tree)&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이진트리&lt;/code&gt;의 구조와 자료의 검색/삭제/삽입에 효율적이게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정렬&lt;/code&gt;의 개념이 추가된 형태&lt;/p&gt;

&lt;p&gt;기본적인 특징은 이진 트리와 같지만 하나 다른 점은 자기 왼쪽에는 자신보다 값이 작은 노드가, 오른쪽에는 자신보다 값이 큰 노드가 존재해야 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;중회 순회(Inorder) 시 순차적으로 데이터가 정렬된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자가-균형-이진-탐색-트리self-balancing-binary-search-tree&quot;&gt;자가 균형 이진 탐색 트리(Self-Balancing Binary Search Tree)&lt;/h2&gt;
&lt;p&gt;이진 탐색트리는 저장과 검색에 평균 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logN&lt;/code&gt;시간이 소요되지만 편향으로 구성되어있거나 균형이 무너지면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;에 근접한 시간이 소요될 수 있다.&lt;/p&gt;

&lt;p&gt;그래서, 고안해낸 것이 균형잡힌 이진탐색트리이다. 대표적으로 AVL트리와 레드블랙트리가 있으며 최악의 경우에도 이진트리의 균형이 잘 맞도록 유지한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AVL트리는 더욱 엄격한 균형을 이루고 있기 때문에 Red-Black 트리보다 더 빠른 검색을 제공&lt;/li&gt;
  &lt;li&gt;Red-Black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어지지 않기 때문에 AVL트리보다 빠르게 삽입/제거 작업을 수행&lt;/li&gt;
  &lt;li&gt;AVL트리는 각 노드에 대해 BF를 저장하므로 노드 당 int 저장이 필요
Red-Black 트리는 노드당 1bit의 정보만 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;avl-트리&quot;&gt;AVL 트리&lt;/h3&gt;
&lt;p&gt;스스로 균형을 잡는 이진 탐색 트리&lt;/p&gt;

&lt;p&gt;검색/삽입/삭제 평균과 최악의 경우 O(log N)의 시간복잡도를 가지며,&lt;br /&gt;
노드가 삽입 또는 삭제될 때 회전을 통해 트리를 재구성하여 높이 균형 성질을 유지시킨다&lt;/p&gt;

&lt;p&gt;균형인수(BF : Balance Factor)를 구성하며 왼쪽과 오른쪽 서브트리의 높이 차를 나타낸다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BF = hL - hR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;값이 -1, 0, 1일 때만 균형있는 트리라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/AVL_Tree.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;레드블랙-트리rb-tree--red-black-tree&quot;&gt;레드블랙 트리(RB Tree : Red-Black Tree)&lt;/h3&gt;
&lt;p&gt;레드-블랙 트리는 자료의 삽입과 삭제, 검색에서 최악의 경우에도 일정한 실행 시간을 보장한다.&lt;br /&gt;
이는 실시간 처리와 같은 실행 시간이 중요한 경우에 유용하며 일정한 실행 시간을 보장하는 다른 자료구조(대표적으로 STL의 Map)를 만드는 데에도 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/red-black-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RB Tree는 다음과 같은 특성을 가진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;각 모든 노드는 레드 or 블랙 색상을 갖는다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Root Property&lt;br /&gt;
트리의 루트는 항상 블랙이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;External Property&lt;br /&gt;
모든 리프 노드(NIL)들은 블랙이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Internal Property&lt;br /&gt;
노드가 레드이면 그 노드의 자식은 반드시 블랙이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Depth Property&lt;br /&gt;
특정 노드에서 아래에 있는 모든 NULL 노드까지의 경로에서 만나는 블랙 색상의 노드의 수가 동일하다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;다원-탐색-트리-mst--m-way-search-tree&quot;&gt;다원 탐색 트리 (MST : M-way Search Tree)&lt;/h2&gt;
&lt;p&gt;균형을 유지한다는 점에서 균형 이진 트리와 유사하지만 트리의 각 &lt;strong&gt;노드가 여러 개의 자료&lt;/strong&gt;를 가질 수 있고, &lt;strong&gt;하위 트리의 수&lt;/strong&gt;를 임의로 설정 가능하다는 차이점이 존재한다.&lt;/p&gt;

&lt;p&gt;MST는 한개의 노드에 여러개의 키가 있을 수 있다. 자식 노드에도 여러 개의 키가 들어갈 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;각 노드는 0에서 최대 M개의 서브 트리를 가진다&lt;/li&gt;
      &lt;li&gt;K개의 서브 트리를 가지는 노드는 (K-1)개의 자료를 가진다(단, K&amp;lt;=M)&lt;/li&gt;
      &lt;li&gt;각 노드 안에서 자료들은 검색 키에 의해 정렬&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;b-트리b-tree&quot;&gt;B-트리(B Tree)&lt;/h3&gt;
&lt;p&gt;M원 탐색 트리의 차수가 많아져서 트리의 높이도 증가하면 점점 비효율적으로 변하게 된다. 그래서 B-트리를 고안해 규칙이 있는 MST를 구상했다.&lt;/p&gt;

&lt;p&gt;대량의 데이터를 처리해야 하는 검색 구조 주로 데이터베이스, 파일시스템에서 인덱스 저장 방법으로 사용하는 자료구조이다.&lt;/p&gt;

&lt;p&gt;노드 내 데이터 수가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;개라면 자식 노드의 수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(N+1)&lt;/code&gt;이며, 노드의 데이터는 항상 정렬된 상태여야 한다.&lt;/p&gt;

&lt;p&gt;노드 내 최대 데이터 수에 따라 2차 B-Tree(2개), 3차 B-Tree(3개), …라 명명&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/b-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;특징&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;루트 노드의 자식 수는 2 이상이어야 한다&lt;/li&gt;
      &lt;li&gt;모든 단말노드는 같은 레벨을 가진다&lt;/li&gt;
      &lt;li&gt;Internal 노드는 ⌈M/2⌉이상 M이하의 자식을 갖는다.&lt;/li&gt;
      &lt;li&gt;각 노드의 원소 수는 최소[M/2-1]개 이상 최대[M-1]개를 가진다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;b트리b-plus-tree&quot;&gt;B+트리(B Plus Tree)&lt;/h3&gt;
&lt;p&gt;B-트리는 특성상 순회 작업이 상당히 난감하다. B+ 트리는 색인구조에서 순차접근에 대한 문제의 해결책으로 제시되었다.&lt;/p&gt;

&lt;p&gt;B트리의 특징을 가지고 있지만 모든 키 값들이 Leaf 노드에 정렬되어 있는 트리 구조.&lt;/p&gt;

&lt;p&gt;Leaf 노드들은 연결 리스트 형태로 서로 연결되어 있고 이를 순차집합(sequence set)이라고 하며 오름차순으로 정렬이 되어 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;B+ 트리의 비단말 노드(not leaf)들은 데이터의 빠른 접근을 위한 인덱스 역할 수행(Index Set)&lt;/li&gt;
  &lt;li&gt;오직 리프노드에만 데이터 저장 가능하고 리프 노드에 모든 데이터가 있기 때문에 키 중복이 있다&lt;/li&gt;
  &lt;li&gt;리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용 가능&lt;/li&gt;
  &lt;li&gt;하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.&lt;/li&gt;
  &lt;li&gt;B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/B-plus-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;b트리b-star-tree&quot;&gt;B*트리(B Star Tree)&lt;/h3&gt;
&lt;p&gt;삽입 또는 삭제 작업 수행 시 발생하는 노드 분리를 줄이기 위해 노드의 약 2/3 이상이 채워지는 B트리.&lt;/p&gt;

&lt;p&gt;노드가 꽉 차면 분리하지 않고 키와 포인터를 재배치하여 다른 형제 노드로 옮김&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리프를 제외한 모든 노드는 m개의 서브트리 이상을 가질 수 없다&lt;/li&gt;
  &lt;li&gt;루트와 리프를 제외한 모든 노드는 적어도 [(2m-2)/3]+1개의 서브트리를 갖는다&lt;/li&gt;
  &lt;li&gt;루트는 리프가 아닌 이상 최소 2개, 적어도 2[(2m-2)/3]+1개의 서브트리를 갖는다.&lt;/li&gt;
  &lt;li&gt;모든 단말노드는 같은 레벨을 가진다&lt;/li&gt;
  &lt;li&gt;각 리프노드는 최소[(2m-2)/3]개, 최대 m-1개의 키 값을 갖는다&lt;/li&gt;
  &lt;li&gt;노드에 저장되는 자료가 넘치는 경우(Overflow), 일단 형제 노드들로 재분배하는 과정 수행. 모든 형제 노드들이 가득 찬 경우에만 B-트리의 분할 연산을 수행(보조 연산 최소화)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;트라이trie&quot;&gt;트라이(Trie)&lt;/h2&gt;
&lt;p&gt;문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조
주로 검색어 자동완성, 사전찾기, 문자열 검사에서 사용&lt;/p&gt;

&lt;p&gt;원하는 원소를 찾을 때, 원소의 길이가 L일 경우 O(L)의 시간복잡도를 가진다.&lt;/p&gt;

&lt;p&gt;빠르게 탐색이 가능하다는 장점이 있으나 각 노드에서 자식들에 대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;포인터&lt;/code&gt;들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;배열&lt;/code&gt;로 모두 저장하고 있다는 점에서 저장공간의 크기(공간복잡도)가 크다는 단점을 지니고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/trie.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="자료구조" /><category term="컴퓨터일반" /><category term="Programming" /><summary type="html">트리의 종류 이진 트리(Binary Tree) 기본적으로 자식노드를 최대 2개 가지는 트리를 의미</summary></entry></feed>