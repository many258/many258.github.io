<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My LifeChronicle</title>
    <description>Be a Imagineer.</description>
    <link>https://many258.github.io/</link>
    <atom:link href="https://many258.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 26 May 2021 01:08:17 +0900</pubDate>
    <lastBuildDate>Wed, 26 May 2021 01:08:17 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>[정보보안기사/네트워크] 스니핑(Sniffing)</title>
        <description>&lt;h2 id=&quot;스니핑sniffing&quot;&gt;스니핑(Sniffing)&lt;/h2&gt;
&lt;p&gt;네트워크로 전송되는 &lt;strong&gt;패킷을 훔쳐보는 도구&lt;/strong&gt;이다. 스니핑은 네트워크 관리자가 네트워크 장애를 식별하고 조치하기 위해서 사용되던 도구로 네트워크에 참여하는 송신자와 수신자 사이에 정상적으로 패킷이 전송되었는지 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;유선 및 무선 데이터 통신의 내용을 몰래 도청하는 행위 및 소프트웨어로 수동적(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Passive&lt;/code&gt;)인 공격 형태이다. 수동적(소극적)인 공격은 복제해도 알 수 없고 탐지가 어렵지만 &lt;strong&gt;예방은 가능하다&lt;/strong&gt;는 특징을 가지고 있다.&lt;/p&gt;

&lt;p&gt;하지만, 스니핑은 공격도구로도 사용할 수 있는데 송신자와 수신자의 패킷을 훔쳐보아서 송신자와 수신자의 &lt;strong&gt;IP 주소, 포트 번호 및 송수신되는 메시지까지 확인&lt;/strong&gt;이 가능하다.&lt;/p&gt;

&lt;p&gt;스니핑 도구를 실행시키면 기본적으로 &lt;strong&gt;정규모드&lt;/strong&gt;(Normal Mode)로 실행된다. Normal Node는 &lt;strong&gt;자신의 컴퓨터에 전송되는 패킷&lt;/strong&gt;만 수신받고 자신과 관련없는 패킷은 삭제한다. &lt;strong&gt;네트워크에 흘러다니는 모든 패킷을 모니터링&lt;/strong&gt;할 때는 &lt;strong&gt;무차별모드&lt;/strong&gt;(Promiscuours Mode)로 설정하고 스니핑을 실행해야 한다.&lt;/p&gt;

&lt;p&gt;스니핑을 할 수 있는 도구 중 하나가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tcpdump&lt;/code&gt; 프로그램이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;tcpdump Option&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-c&lt;/td&gt;
      &lt;td&gt;Count 수 만큼 패킷을 받는다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-e&lt;/td&gt;
      &lt;td&gt;MAC 주소 형태로 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-F&lt;/td&gt;
      &lt;td&gt;File에 Expression을 입력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-i&lt;/td&gt;
      &lt;td&gt;특정 인터페이스를 지정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-q&lt;/td&gt;
      &lt;td&gt;간결하게 표시&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-w&lt;/td&gt;
      &lt;td&gt;패킷을 파일로 저장한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r&lt;/td&gt;
      &lt;td&gt;저장한 파일을 읽는다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-t&lt;/td&gt;
      &lt;td&gt;Timestamp&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-v&lt;/td&gt;
      &lt;td&gt;자세히 표시&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;session-hijacking&quot;&gt;Session Hijacking&lt;/h2&gt;
&lt;p&gt;세션 하이재킹은 &lt;strong&gt;세션 값을 훔쳐가는 것을 의미&lt;/strong&gt;한다. 로그인 사용자에게 웹 서버가 세션 값이라는 문자열을 생성해서 전송해준다. 세션 값이라는 문자열만 획득하면, 로그인 과정없이 홈페이지에 접근할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이미 인증을 받아 세션을 생성, 유지하고 있는 연결을 빼앗는 공격을 총칭(스니핑 기술의 일종)한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인증을 위한 모든 검증을 우회&lt;/strong&gt; : TCP를 이용해서 통신하고 있을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RST&lt;/code&gt; 패킷을 보내 일시적으로 TCP 세션을 끊고 &lt;strong&gt;시퀀스 넘버를 새로 생성하여 세션을 빼앗고 인증을 회피&lt;/strong&gt;한다&lt;/li&gt;
  &lt;li&gt;세션은 &lt;strong&gt;스니핑 추측(Brute-Force Guessing)&lt;/strong&gt;을 통해 도용하거나 가로채어 자신이 원하는 데이터를 보낼 수 있는 공격 방법이다.&lt;/li&gt;
  &lt;li&gt;원인 : 암호화되지 않은 프로토콜에서 정보를 평문으로 전송, 길이가 짧은 Session ID, 세션 타임아웃 부재&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;세션 하이재킹을 하기 위해서는 &lt;strong&gt;공격자 웹 서버에 세션 문자열을 기록하는 악성코드&lt;/strong&gt;를 만들어야 한다. 그리고 피해자는 정상적으로 사용하는 홈페이지에 로그인한다. 공격자는 만든 악성코드를 호출할 수 있도록 XSS를 사용한다.&lt;/p&gt;

&lt;p&gt;공격자는 웹프록시를 사용해서 피해자의 세션 값으로 변경하고 홈페이지에 접근하면 로그인 없이 접근할 수 있다. 사용자가 &lt;strong&gt;로그아웃을 하면 해당 세션 값은 초기화되기 때문에 로그인 순간에 사용&lt;/strong&gt;해야 한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;세션 하이재킹 도구&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;내용&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Hunt&lt;/td&gt;
      &lt;td&gt;네트워크상의 감시, 가로채기 등을 할 수 있는 도구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Arpspoof&lt;/td&gt;
      &lt;td&gt;공격자의 주소로 속이는 행위를 하는 도구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IP Watcher&lt;/td&gt;
      &lt;td&gt;네트워크상의 연결, 감시 및 세션을 가로채기 위한 다양한 기능을 제공하는 상용 프로그램&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ferret&lt;/td&gt;
      &lt;td&gt;세션 정보를 가로채는 도구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Hamster&lt;/td&gt;
      &lt;td&gt;Proxy 서버 상태로 만들어주는 도구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Paros&lt;/td&gt;
      &lt;td&gt;웹 Proxy 서버로서 사용할 수 있는 도구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Cain &amp;amp; Abel&lt;/td&gt;
      &lt;td&gt;스푸핑과 스캐닝 등 다양한 기능이 있는 도구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WireShark&lt;/td&gt;
      &lt;td&gt;네트워크 패킷 분석 도구이며 다양한 패킷 정보를 볼 수 있는 도구&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Wed, 26 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-network-sniffing/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-network-sniffing/</guid>
        
        <category>정보보안기사</category>
        
        <category>Network</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/네트워크] 스캐닝(Scanning)</title>
        <description>&lt;h2 id=&quot;포트-스캐닝port-scanning&quot;&gt;포트 스캐닝(Port Scanning)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;서버에 열려있는 포트를 확인하기 위한 방법&lt;/strong&gt;으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NMAP&lt;/code&gt; 이라는 도구를 사용해서 스캐닝을 수행한다. 포트 스캐닝을 사용하면 서버에 열려있는 포트를 확인하고 해당 포트의 취약점을 이용하여 공격할 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;NMAP Port Scan&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;TCP connect() Scan&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-Way Handshaking&lt;/code&gt;를 수립하고 Target System에서 쉽게 탐지가 가능하다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TCP SYN Scan&lt;/td&gt;
      &lt;td&gt;SYN 패킷을 대상 포트로 발송하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN/ACK&lt;/code&gt; 패킷을 수신 받으면 &lt;strong&gt;Open&lt;/strong&gt; 상태이다&lt;br /&gt;SYN 패킷을 대상 포트로 발송하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RST/ACK&lt;/code&gt;을 수신받으면 &lt;strong&gt;Close&lt;/strong&gt; 상태이다&lt;br /&gt;&lt;strong&gt;Half Open&lt;/strong&gt; 혹은 &lt;strong&gt;Stealth Scanning&lt;/strong&gt;이라고 한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TCP FIN Scan&lt;/td&gt;
      &lt;td&gt;대상 포트로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 패킷을 전송하고 닫혀있는 포트는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RST&lt;/code&gt;를 전송한다&lt;br /&gt;포트가 개방되어 있으면 패킷을 무시한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TCP Null&lt;/td&gt;
      &lt;td&gt;모든 플래그를 지운다&lt;br /&gt;대상 포트가 닫혀있으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RST&lt;/code&gt;를 돌려보내고 개방 상태이면 패킷을 무시한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TCP X-MAS Tree Scan&lt;/td&gt;
      &lt;td&gt;대상 포트로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;URG&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PSH&lt;/code&gt; 패킷을 전송한다&lt;br /&gt;대상 시스템에서 &lt;strong&gt;포트가 닫혀있으면&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RST&lt;/code&gt;를 되돌려 보낸다&lt;br /&gt;포트가 &lt;strong&gt;개방되어 있으면 패킷을 무시&lt;/strong&gt;한다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;nmap-옵션&quot;&gt;NMAP 옵션&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;.SCAN Type&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
      &lt;th&gt;.Port Option&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-sS&lt;/td&gt;
      &lt;td&gt;TCP SYN Scan&lt;/td&gt;
      &lt;td&gt;-p #&lt;/td&gt;
      &lt;td&gt;특정 포트번호만 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sT&lt;/td&gt;
      &lt;td&gt;TCP Connection Scan&lt;/td&gt;
      &lt;td&gt;-p ssh&lt;/td&gt;
      &lt;td&gt;특정 이름의 포트만 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sU&lt;/td&gt;
      &lt;td&gt;UDP Scan&lt;/td&gt;
      &lt;td&gt;-p 1,2,3&lt;/td&gt;
      &lt;td&gt;여러 개의 특정 포트만 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sF&lt;/td&gt;
      &lt;td&gt;TCP FIN Scan&lt;/td&gt;
      &lt;td&gt;-p 1-1023&lt;/td&gt;
      &lt;td&gt;특정 범위의 포트만 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sX&lt;/td&gt;
      &lt;td&gt;TCP Xmas Scan&lt;/td&gt;
      &lt;td&gt;-p -1023&lt;/td&gt;
      &lt;td&gt;처음부터 특정 범위의 포트만 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sN&lt;/td&gt;
      &lt;td&gt;TCP NULL Scan&lt;/td&gt;
      &lt;td&gt;-p 49152-&lt;/td&gt;
      &lt;td&gt;특정 포트부터 끝까지 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sA&lt;/td&gt;
      &lt;td&gt;TCP ACK Scan&lt;/td&gt;
      &lt;td&gt;-p-&lt;/td&gt;
      &lt;td&gt;0번을 제외한 모든 포트 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sW&lt;/td&gt;
      &lt;td&gt;TCP Windows Scan&lt;/td&gt;
      &lt;td&gt;-pT:1,2,U:1,2&lt;/td&gt;
      &lt;td&gt;T는 TCP포트, U는 UDP 포트를 의미&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sM&lt;/td&gt;
      &lt;td&gt;TCP Maimon Scan&lt;/td&gt;
      &lt;td&gt;-p http&lt;/td&gt;
      &lt;td&gt;http라는 이름을 가진 모든 포트를 스캔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sI&lt;/td&gt;
      &lt;td&gt;TCP IDLE Scan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sO&lt;/td&gt;
      &lt;td&gt;IP Protocol Scan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-b&lt;/td&gt;
      &lt;td&gt;FTP Bounce Scan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;namp-포트-스캐닝&quot;&gt;NAMP 포트 스캐닝&lt;/h3&gt;
&lt;h4 id=&quot;udp-scan&quot;&gt;UDP SCAN&lt;/h4&gt;
&lt;p&gt;공격자는 UDP Packet을 전송해서 스캐닝하는 것으로 UDP의 특성상 신뢰성이 떨어진다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/network/udp-scan.png&quot;&gt;&lt;img src=&quot;../../assets/images/security/network/udp-scan.png&quot; alt=&quot;&quot; title=&quot;UDP SCAN&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;tcp-open-scan&quot;&gt;TCP Open SCAN&lt;/h4&gt;
&lt;p&gt;공격자는 TCP의 3-Way Handshaking 과정을 진행해서 개방된 포트를 확인한다. 서버에 로그가 기록되고 스캔 속도가 느리다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/network/tcp-open-scan.png&quot;&gt;&lt;img src=&quot;../../assets/images/security/network/tcp-open-scan.png&quot; alt=&quot;&quot; title=&quot;TCP Open SCAN&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;stealth-scan&quot;&gt;Stealth SCAN&lt;/h4&gt;
&lt;p&gt;스캔하는 대상에 로그를 남기지 않는 스캐닝 기법으로 TCP Half Open Scan, FIN Scan, Xmas Scan, Null Scan 방법이 있다. 공격 대상을 속이고 자신의 위치 또한 숨기는 스캔이다.&lt;/p&gt;

&lt;h5 id=&quot;tcp-half-open-scan&quot;&gt;TCP Half Open SCAN&lt;/h5&gt;
&lt;p&gt;TCP 연결 시에 SYN 패킷만 전송하고 응답 정보로 포트 개방을 확인한다. 완전한 세션을 성립하지 않고 포트의 활성화를 확인하므로 로그가 남지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/network/tcp-half-open-scan.png&quot;&gt;&lt;img src=&quot;../../assets/images/security/network/tcp-half-open-scan.png&quot; alt=&quot;&quot; title=&quot;TCP Half Open SCAN&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;fin-scan&quot;&gt;FIN SCAN&lt;/h5&gt;
&lt;p&gt;TCP에서 FIN은 &lt;strong&gt;연결 종료&lt;/strong&gt;를 의미하며 공격자는 &lt;strong&gt;FIN을 전송&lt;/strong&gt;하여 포트를 스캔한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/network/fin-scan.png&quot;&gt;&lt;img src=&quot;../../assets/images/security/network/fin-scan.png&quot; alt=&quot;&quot; title=&quot;FIN SCAN&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;x-mas-scan&quot;&gt;X-MAS SCAN&lt;/h5&gt;
&lt;p&gt;공격자는 &lt;strong&gt;TCP FIN, PSH, URG&lt;/strong&gt; Packet을 전송하여 포트 개방을 확인한다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/network/x-mas-scan.png&quot;&gt;&lt;img src=&quot;../../assets/images/security/network/x-mas-scan.png&quot; alt=&quot;&quot; title=&quot;X-MAS SCAN&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;null-scan&quot;&gt;NULL SCAN&lt;/h5&gt;
&lt;p&gt;공격자는 TCP &lt;strong&gt;NULL 패킷&lt;/strong&gt;을 전송하여 포트 개방을 확인한다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/network/null-scan.png&quot;&gt;&lt;img src=&quot;../../assets/images/security/network/null-scan.png&quot; alt=&quot;&quot; title=&quot;NULL SCAN&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;tcp-fragmentation&quot;&gt;TCP Fragmentation&lt;/h4&gt;
&lt;p&gt;20Byte의 &lt;strong&gt;헤더를 2개로 분할&lt;/strong&gt;하여 보안장비의 탐지를 우회하는 방법. 첫 번째 패킷은 &lt;strong&gt;IP 주소 정보&lt;/strong&gt;가 있고 두 번째 패킷은 &lt;strong&gt;Port 정보만&lt;/strong&gt; 있게 한다.&lt;/p&gt;

</description>
        <pubDate>Tue, 25 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-network-scanning/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-network-scanning/</guid>
        
        <category>정보보안기사</category>
        
        <category>Network</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/네트워크] 분산 서비스 거부 공격(DDos)</title>
        <description>&lt;h2 id=&quot;서비스-거부-공격dos-denial-of-service&quot;&gt;서비스 거부 공격(DoS, Denial of Service)&lt;/h2&gt;
&lt;p&gt;컴퓨터의 자원을 고갈시키기 위한 공격으로 특정 서비스를 계속적으로 호출하여 CPU, Memory, Network 등의 자원을 고갈시킨다.&lt;/p&gt;

&lt;p&gt;DoS 공격은 &lt;strong&gt;소프트웨어 취약점&lt;/strong&gt;을 이용하는 공격과 IP Header를 변조하여 공격하는 &lt;strong&gt;로직 공격&lt;/strong&gt;(Logic Attack), 무작위로 패킷을 발생시키는 &lt;strong&gt;플러딩 공격&lt;/strong&gt;(Flooding Attack)으로 구분된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;도구&lt;/th&gt;
      &lt;th&gt;Trinoo&lt;/th&gt;
      &lt;th&gt;TFN&lt;/th&gt;
      &lt;th&gt;Stacheldraht&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;공격방법&lt;/td&gt;
      &lt;td&gt;UDP Flood&lt;/td&gt;
      &lt;td&gt;UDP, ICMP, SYN Flood, Smurf&lt;/td&gt;
      &lt;td&gt;UDP, ICMP, SYN Flood, Smurf&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;암호 기능&lt;/td&gt;
      &lt;td&gt;없음&lt;/td&gt;
      &lt;td&gt;없음&lt;/td&gt;
      &lt;td&gt;가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Attacker-Master&lt;/td&gt;
      &lt;td&gt;27665/tcp&lt;/td&gt;
      &lt;td&gt;Telnet 등 방법&lt;/td&gt;
      &lt;td&gt;1660/tcp(암호화)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Master-Agent&lt;/td&gt;
      &lt;td&gt;27444/udp&lt;/td&gt;
      &lt;td&gt;ICMP echo Reply&lt;/td&gt;
      &lt;td&gt;ICMP echo Reply, 65000/tcp&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Agent-Master&lt;/td&gt;
      &lt;td&gt;323335/udp&lt;/td&gt;
      &lt;td&gt;ICMP echo Reply&lt;/td&gt;
      &lt;td&gt;ICMP echo Reply&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;분산-서비스-거부-공격ddos&quot;&gt;분산 서비스 거부 공격(DDoS)&lt;/h2&gt;
&lt;h3 id=&quot;tcp-syn-flooding&quot;&gt;TCP SYN Flooding&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP&lt;/code&gt; 패킷의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt; 비트를 이용한 공격 방법으로 너무 많은 연결 요청을 전송해서 대상 시스템이 범람(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flooding&lt;/code&gt;)하게 만들어 대상 시스템의 서비스를 중단시키는 공격&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;TCP 연결 요청. TCP SYN packet 전송 (Host A[Hacker] =&amp;gt; Host B[Victim])&lt;/li&gt;
  &lt;li&gt;Host C에게 응답. TCP SYN/ACK packet 전송&lt;/li&gt;
  &lt;li&gt;Host B는 Host C의 응답 대기 TCP ACK packet 대기&lt;/li&gt;
  &lt;li&gt;TCP 연결 대기 큐가 Overflow될 때까지 Host B에게 계속 연결 요청&lt;/li&gt;
  &lt;li&gt;Host C로부터 ACK 없음, 대기 큐는 Overflow&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;TCP 초기 연결 과정(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-Way Handshaking&lt;/code&gt;)&lt;/strong&gt; 이용, &lt;strong&gt;SYN 패킷을 요청&lt;/strong&gt;하여 서버가 ACK 및 SYN 패킷을 보내게 한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;전송하는 주소가 무의미한 주소이며 서버는 대기 상태이고 대량의 요청 패킷 전송으로 서버의 대기 큐가 가득차서 DoS 상태가 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;대응 방법
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;방화벽에서 대응&lt;/strong&gt;&lt;br /&gt;
IP 당 SYN 요청에 대한 PPS(Packet Per Second) 임계치를 단계적으로 조정&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;First SYN Drop(Spoofed) 설정&lt;/strong&gt;&lt;br /&gt;
SYN 패킷을 보낸 클라이언트의 존재 여부를 파악하여 차단하는 방법&lt;br /&gt;
클라이언트에서 전송된 첫 번째 SYN을 DROP하여 재요청 여부 확인 후 Spoofing 여부를 판단한다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;TCP 세션 연결 차단&lt;/strong&gt;&lt;br /&gt;
트래픽 유형별 임계치를 조정하여 TCP 세션 연결에 대한 차단&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Back Queue 증가&lt;/strong&gt;&lt;br /&gt;
임시적 방법으로 서버의 Queue 사이즈를 증가시킴
        &lt;blockquote&gt;
          &lt;p&gt;sysctl -w net.ipv4.tcp_max_syn_backlog = 1024&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;(라우터) &lt;strong&gt;Watch Mode&lt;/strong&gt;&lt;br /&gt;
SYN 패킷을 통과시키고 &lt;strong&gt;일정 시간 동안 연결이 이루어지지 않으면 라우터가 SUN 패킷을 차단&lt;/strong&gt;한다&lt;/li&gt;
      &lt;li&gt;(라우터) &lt;strong&gt;Intercept Mode&lt;/strong&gt;&lt;br /&gt;
라우터에 유입되는 SYN 패킷 요청을 &lt;strong&gt;서버로 전송하지 않고, 라우터에서 가로채어&lt;/strong&gt; SYN 패킷을 요청한 클라이언트와 서버를 대신 연결한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;DRDoS&lt;/strong&gt;&lt;br /&gt;
별도의 Agent를 설치하지 않고 TCP Half Open의 취약점을 이용하는 공격 기법&lt;br /&gt;&lt;br /&gt;
공격대상 IP로 출발지 IP를 변조하여 SYN 패킷 전송, 서버는 변조된 공격대상 IP로 SYN-ACK 패킷 전송&lt;/p&gt;

&lt;h3 id=&quot;icmp-flooding&quot;&gt;ICMP Flooding&lt;/h3&gt;
&lt;p&gt;IP 특징(Broadcast 주소 방식)과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ICMP&lt;/code&gt; 패킷을 이용한 공격 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;통신을 위해서 &lt;strong&gt;서비스 및 포트가 필요없는&lt;/strong&gt; 유일한 프로토콜이다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Smurfing Attack&lt;/strong&gt;이라고도 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다수의 호스트가 존재하는 서브 네트워크에 ICMP echo 패킷을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Broadcast&lt;/code&gt;로 전송한다. 이에 대한 다량의 응답 패킷이 공격대상 서버로 집중되게 하여 마비시키는 공격이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ICMP 공격에 사용되는 메시지&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Source Quench(Type-4)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사용 중 전송자에게 패킷 전송 속도를 줄여 줄 것을 요구하는 메시지로 전송 속도 지연 발생&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Time to live exceeded in Transit(Type-11, Code-0)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;시간초과로 패킷이 폐기되었기 때문에 재전송한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Destination unreachable(Type-3, Code-0,1,2,3)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ICMP 트래픽 처리에 자원을 사용하게 되므로 시스템이 조금씩 느려지는 현상 발생&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응 방법
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;ACL(Access Control List)을 이용한 차단&lt;/strong&gt;&lt;br /&gt;
웹 서버 혹은 운영 장비에 대한 접근 제어 목록을 차단&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Inbound 패킷 임계치 설정&lt;/strong&gt;&lt;br /&gt;
운영 장비로 유입되는 Inbound 패킷을 기준으로 PPS 수치를 유입되는 수치보다 낮게 설정. 임계치 이상의 ICMP 및 UDP 차단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tear-drop--ip-fragmetation-ping-of-death&quot;&gt;Tear Drop : IP Fragmetation (Ping of Death)&lt;/h3&gt;
&lt;p&gt;네트워크 패킷은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTU&lt;/code&gt;(Maximum Transmission Unit)보다 큰 패킷이 오면 분할하고 분할(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fragmentation&lt;/code&gt;)된 정보를 Flag와 Offset이 가지고 있다. 이 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Offset을&lt;/code&gt; 임의로 조작하여 다시 조립될 수 없도록 하는 공격&lt;/p&gt;

&lt;p&gt;Fragment를 조작하여 패킷 필터링 장비나 IDS를 우회하여 서비스 거부를 유발시킨다&lt;/p&gt;

&lt;h4 id=&quot;공격-종류&quot;&gt;공격 종류&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Tiny Fragment&lt;/strong&gt;&lt;br /&gt;
최초의 &lt;strong&gt;Fragment를 아주 작게 만들어서&lt;/strong&gt; 네트워크 침입탐지 시스템이나 패킷 필터링 장비를 우회하는 공격&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fragment Overlap&lt;/strong&gt;&lt;br /&gt;
Tiny Fragment 공격 기법에 비해 정교하며, IDS의 &lt;strong&gt;Fragment 처리 방법과 패킷 필터링의 재조합과 Overwrite 처리를 이용&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IP Fragmentation을 이용한 DoS&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Ping of Death&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ping&lt;/code&gt;을 이용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ICMP&lt;/code&gt; 패킷을 &lt;strong&gt;규정된 길이 이상으로 큰&lt;/strong&gt; IP 패킷을 전송, 수신받은 OS에서 처리하지 못함으로써 시스템을 마비시키는 공격&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Tear Drop&lt;/strong&gt;&lt;br /&gt;
Fragment 재조합 과정의 취약점을 이용한 공격으로 목표시스템 정지나 재부팅을 유발하는 공격. &lt;strong&gt;TCP Header&lt;/strong&gt; 부분의 &lt;strong&gt;Offset Field&lt;/strong&gt; 값이 중첩되는 데이터 패킷을 대상 시스템에 전송
        &lt;ul&gt;
          &lt;li&gt;offset field : 특정 데이터 패킷이 운반 중인 데이터나 데이터 범위 내에서 운반할 byte를 지정한다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;land-attack&quot;&gt;Land Attack&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IP Header를 변조&lt;/strong&gt;하여 인위적으로 &lt;strong&gt;송신자 IP주소 및 Port주소를 수신자의 IP 주소와 Port주소로 설정&lt;/strong&gt;하여 트래픽을 전송하는 공격 기법.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;송신자와 수신자의 IP주소와 Port주소가 동일&lt;/strong&gt;하기 때문에 네트워크 장비에 부하를 유발한다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RAW Socket&lt;/strong&gt;에서 &lt;strong&gt;s_addr&lt;/strong&gt;은 송신자의 IP이고 &lt;strong&gt;daddr&lt;/strong&gt;은 수신자의 IP주소이다. 즉, s_addr과 daddr을 동일한 IP주소로 설정하고 송신하면 Land Attack을 구현할 수 있다.&lt;/p&gt;

&lt;p&gt;송신자와 수신자의 IP주소가 동일한 패킷을 삭제함으로써 대응이 가능하다&lt;/p&gt;

&lt;h3 id=&quot;http-get-flooding&quot;&gt;HTTP Get Flooding&lt;/h3&gt;
&lt;p&gt;정상적인 TCP 연결 이후에 정상적으로 보이는 HTTP Transaction 과정을 수행하는 방식으로 DoS/DDoS 공격 방법.&lt;/p&gt;

&lt;p&gt;HTTP Get을 지속적으로 요청하여 HTTP 연결 및 HTTP 처리 로직까지 과부하를 유발한다. TCP의 3-Way Handshaking 이후 공격을 수행하기 때문에 IP를 변조하지 않는다.&lt;/p&gt;

&lt;p&gt;HTTP Get Flooding은 아주 간단한 공격으로 다수의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP Request&lt;/code&gt;를 계속적으로 호출하게 만드는 방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응 방법
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;선별적 IP 차단&lt;/strong&gt;&lt;br /&gt;
TCP 연결요청 임계치 값과 HTTP Get의 임계치 값을 모니터링한 후 비정상적인 트래픽은 차단한다.&lt;/p&gt;

        &lt;p&gt;연결기반 공격이므로 IP를 변조할 수 없는 특성을 이용한 방법이다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;컨텐츠 요청횟수에 의한 임계치 설정&lt;br /&gt;
특정 컨텐츠를 다량으로 요청하는 것이므로 IP마다 컨텐츠 요청 횟수의 임계치를 설정&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;시간대별 웹 페이지 URL 접속 임계치 설정 차단&lt;br /&gt;
시간대별 임계치를 설정하여 임의의 시간 안에 설정한 임계치 이상의 요청이 들어온 경우 해당 IP를 탐지하여 방화벽 차단 목록에 등록한다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Web Scraping&lt;/strong&gt; 기법을 이용한 차단&lt;br /&gt;
L7 스위치를 운영하는 경우 웹 스크랩핑 기능을 사용하여 &lt;strong&gt;요청 패킷에 대한 쿠키 값이나 자바 스크립트를 보내어&lt;/strong&gt; 클라이언트로부터 원하는 값에 &lt;strong&gt;재요청 패킷이 없는 경우&lt;/strong&gt; 해당 패킷을 차단한다&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cache-control-attack&quot;&gt;Cache Control Attack&lt;/h3&gt;
&lt;p&gt;HTTP RFC 2616에 규정되어 있는 Cache-Control Header 옵션 값을 사용한다. 이 옵션은 자주 변경되는 데이터에 대해서 새롭게 HTTP 요청과 응답을 요구하는 옵션으로 &lt;strong&gt;no-cache가 설정되면 항상 최신의 페이지를 요청하여 부하를 발생&lt;/strong&gt;시킨다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응 방법
    &lt;ul&gt;
      &lt;li&gt;HTTP GET Attack과 마찬가지로 임계치 기반 대응을 실시&lt;/li&gt;
      &lt;li&gt;단, Cache-Control 사용여부에 따른 임계치를 설정하는 것이 더 효과적&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;slow-http-getpost-attack&quot;&gt;Slow HTTP Get/Post Attack&lt;/h3&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;Slow HTTP GET Flooding&lt;/strong&gt;&lt;br /&gt;
HTTP GET Flooding과 달리 HTTP Header를 변조해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Slow HTTP Get 방식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;TCP 및 UDP 기반 공격 : 변조 IP가 아닌 정상 IP 기반 공격이며, 탐지가 어렵다&lt;/li&gt;
      &lt;li&gt;소량의 트래픽을 사용한 공격 : 소량의 트래픽과 세션 연결을 통해서 공격한다&lt;/li&gt;
      &lt;li&gt;애플리케이션 대상 : 서비스의 취약점을 이용한 공격이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Slow HTTP Post 방식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;HTTP의 Post 지시자를 이용하여 서버에게 전달할 대량의 데이터를 장시간에 걸쳐 분할 전송한다&lt;/li&gt;
      &lt;li&gt;Post 데이터가 모두 수신되지 않으면 연결을 장시간 유지하게 된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Slow HTTP Read DoS&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;공격자가 웹 서버와 TCP 연결 시 TCP 윈도우 크기 및 데이터 처리율을 감소시킨 후 HTTP 데이터를 송신하여 웹 서버가 정상적으로 응답하지 못하도록 하는 DoS/DDoS 기법&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;TCP 윈도우 크기 및 데이터 처리율을 감소&lt;/strong&gt;시키면 서버는 정상상태로 회복할 때까지 &lt;strong&gt;대기 상태&lt;/strong&gt;에 빠지게 되어 &lt;strong&gt;부하를 유발&lt;/strong&gt;한다&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;공격자는 자신의 TCP 윈도우 크기를 0바이트로 만든 후 서버로 전달&lt;/li&gt;
      &lt;li&gt;서버는 윈도우 크기가 0바이트인 것을 확인하고 데이터를 전송하지 않고 Pending 상태로 빠지게 된다&lt;/li&gt;
      &lt;li&gt;공격자는 윈도우 크기를 점검하는 Probe 패킷을 ACK로 전송하면 서버는 대기 상태로 빠지게 된다&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Slow HTTP Header DoS(Slowloris)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;HTTP Header를 비정상적으로 조작&lt;/strong&gt;해서 웹 서버가 헤더 정보를 구분할 수 없도록 하는 방법. 웹 서버에 &lt;strong&gt;HTTP Header 정보가 모두 전달되지 않은 것으로 판단&lt;/strong&gt;하여 &lt;strong&gt;연결을 장시간 유지&lt;/strong&gt;한다&lt;/li&gt;
      &lt;li&gt;웹 서버는 클라이언트로부터 요청이 끝나지 않은 것으로 판단되기 때문에 &lt;strong&gt;웹 로그에 기록하지 않는다&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;HTTP Header와 Body는 개행문자(\r\n\r\n)로 구분되는데 Slow HTTP Header DoS는 \r\n만 전송하여 불완전한 Header를 전송한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응 방법
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;접속 임계치 설정&lt;br /&gt;
특정 발신지에서 IP로 연결할 수 있는 최대값 설정&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;방화벽 설정 도구인 &lt;strong&gt;iptables로&lt;/strong&gt; 차단
        &lt;blockquote&gt;
          &lt;p&gt;iptables -A INPUT -p tcp -dport 80 -m connlimit-above 30 -j DROP&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;p&gt;30개 이상의 Concurrent Connection에 대한 차단&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Connection Timeout&lt;/strong&gt;과 &lt;strong&gt;Keepalibetime&lt;/strong&gt; 설정&lt;br /&gt;
Connection Timeout 설정으로 클라이언트와 서버 간에 데이터 전송이 없을 경우 연결 종료&lt;br /&gt;
웹 서버의 keepalivetime을 설정하여 차단&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;RequestReadTimeout&lt;/strong&gt; 설정으로 차단&lt;br /&gt;
Apache 2.2.15 버전이후에서 사용&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;RequestReadTimeout header=5 body=8 설정&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;p&gt;Slow Attack를 차단하기 위해서 5초 내에 연결이 안되면 연결 종료, POST 요청 이후 8초 내에 데이터가 오지 않으면 연결 종료&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;POST 메시지의 크기(POST_MAX_SIZE)를 제한한다&lt;/li&gt;
      &lt;li&gt;최저 데이터 전송 속도를 제한한다&lt;/li&gt;
      &lt;li&gt;TCP 상태를 모니터링한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hash-dos&quot;&gt;Hash DoS&lt;/h3&gt;
&lt;p&gt;클라이언트에서 전달되는 각종 파라미터 값을 관리하는 해시테이블의 &lt;strong&gt;인덱스 정보가 중복되도록 유도&lt;/strong&gt;하여 사전에 저장된 정보 조회 시 &lt;strong&gt;많은 CPU 자원을 소모&lt;/strong&gt;하도록 하는 공격&lt;/p&gt;

&lt;p&gt;HTTP Request 요청 시 Get, Post 방식으로 전송되는 변수를 Hash 구조로 관리한다. 많은 수의 매개변수를 전달하면 매개변수를 저장하는 해시테이블에서 &lt;strong&gt;해시 충돌이 발생&lt;/strong&gt;하여 해시테이블에 접근하는 시간이 증가한다.&lt;/p&gt;

&lt;p&gt;해시 충돌(Hash Collision) : 서로 다른 키 값이 같은 인덱스 값으로 매핑되는 현상&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응 방안
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;HTTP &lt;strong&gt;Post 파라미터 수 제한&lt;/strong&gt;&lt;br /&gt;
TOMCAT, PHP, Ruby 등의 최신 버전은 파라미터의 수를 제한할 수 있다. 즉, 개수 제한을 적용시킨다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Post 메시지 크기 제한&lt;/strong&gt;&lt;br /&gt;
POST 메시지의 사이즈를 제안하는 서비스 설정&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;PHP에서 Hash DoS 차단&lt;/strong&gt;&lt;br /&gt;
php.ini파일에서 max_input_var로 최대 HTTP POST Parameter 개수 설정&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hulk-dos&quot;&gt;Hulk DoS&lt;/h3&gt;
&lt;p&gt;웹 서버의 가용량을 모두 사용하여 정상적인 서비스가 불가능하도록 하는 Get Flooding 공격 유형&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;공격 대상 URL을 지속적으로 변경&lt;/strong&gt;하여 DDoS 차단정책을 우회하는 특징을 가진다. 특정 URL이 계속 변경되면 임계치 설정 기반 방어가 불가능해진다. 즉, 임계치는 고정된 URL에만 설정이 가능한 특성을 우회한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응 방안
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;접속 임계치 설정&lt;/strong&gt;을 통한 차단&lt;br /&gt;
발신 IP에서 연결할 수 있는 동시 접속 수에 대한 최댓값을 설정하여 한 개의 IP에서 대량의 연결 시도를 차단
        &lt;blockquote&gt;
          &lt;p&gt;iptables -A INPUT -p tcp -dport 80 -m connlimit-above 30 -j DROP&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;p&gt;30개 이상의 Concurrent Connection에 대한 차단&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;HTTP Request HOST 필드 값&lt;/strong&gt;에 대한 임계치 설정을 통한 차단&lt;br /&gt;
Hulk DoS는 URL을 계속 변경하기 때문에 URL이 아닌 HTTP Request에 포함된 &lt;strong&gt;HOST 필드 값&lt;/strong&gt;을 카운트하여 임계치 이상인 경우 차단한다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;302-Redirect&lt;/strong&gt;를 이용한 차단&lt;br /&gt;
대부분의 &lt;strong&gt;DDoS 공격 툴은 302-Redirect 요청&lt;/strong&gt;에 대해 반응하지 않는 것이 특징이므로, URL 중에서 공격 당하기 쉬운 웹 사이트에 대한 Redirect 처리를 통해서 자동화된 DDoS 공격 툴을 이용한 공격을 사전에 차단한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-network-ddos/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-network-ddos/</guid>
        
        <category>정보보안기사</category>
        
        <category>Network</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/윈도우] 바이러스와 악성코드</title>
        <description>&lt;h2 id=&quot;바이러스&quot;&gt;바이러스&lt;/h2&gt;
&lt;p&gt;컴퓨터 바이러스는 컴퓨터 프로그램의 한 종류로 사용자 몰래 은닉하여 정상적인 프로그램이나 사용자의 데이터를 파괴하는 악성 프로그램이다. 컴퓨터 바이러스와 악성코드는 혼동하여 많이 사용되지만, 가장 근본적인 차이점은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자기복제 여부&lt;/code&gt;이다. 즉, &lt;strong&gt;컴퓨터 바이러스는 자기 스스로를 복제하여 증식하는 자기복제 특성&lt;/strong&gt;을 가지고 있다&lt;/p&gt;

&lt;h3 id=&quot;제1세대-원시형-바이러스primitive-virus&quot;&gt;제1세대, 원시형 바이러스(Primitive Virus)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;일반적으로 아마추어 프로그래머에 의해서 개발된 바이러스&lt;/li&gt;
  &lt;li&gt;단순하여 분석이 쉽고 코드의 변형이 없이 고정된 크기를 가지고 있다&lt;/li&gt;
  &lt;li&gt;일반적으로 &lt;strong&gt;주기억 장치에 상주해서 부트 영역이나 파일을 감염&lt;/strong&gt;시키는 특성이 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;돌(Stoned) 바이러스, 예루살렘 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제2세대-암호화-바이러스encryption-virus&quot;&gt;제2세대, 암호화 바이러스(Encryption Virus)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터 프로그램의 일부 또는 전체를 &lt;strong&gt;암호화&lt;/strong&gt; 시켜서 백신으로 바이러스 감염 여부를 확인할 수 없게한다.&lt;/li&gt;
  &lt;li&gt;암호화 방식이 일정해서 복호화 방식도 일정하다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;폭포(Cascade) 바이러스, 느림보(Slow) 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제3세대-은페형-바이러스stealth-virus&quot;&gt;제3세대, 은페형 바이러스(Stealth Virus)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;자기 스스로 은폐할 수 있는 바이러스&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;다른 실행 파일에 &lt;strong&gt;기생하여 그 실행 파일의 크기를 증가&lt;/strong&gt;시킨다&lt;/li&gt;
  &lt;li&gt;파일 크기가 변경되기 때문에 백신이 발견하기 쉽다.&lt;/li&gt;
  &lt;li&gt;(단, 백신이 감염 여부를 진단할 때 이전 상태를 보여주어서 감염 여부를 확인하기 어렵게 한다)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;맥가이버(MacGyver) 바이러스, 브레인(Brain) 바이러스, 512 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제4세대-갑옷형-바이러스armor-virus&quot;&gt;제4세대, 갑옷형 바이러스(Armor Virus)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;다양한 암호화 기법을 사용&lt;/strong&gt;해서 은폐하는 기법을 사용하기 때문에 어떤 백신도 진단하기 어렵다.&lt;/li&gt;
  &lt;li&gt;바이러스가 프로그램을 변형하기 위해서 100만개가 넘는 방법을 사용한다&lt;/li&gt;
  &lt;li&gt;전문 프로그래머에 의해서 개발되었다&lt;/li&gt;
  &lt;li&gt;진단이나 치료가 불가능하지는 않다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다형성(Polymorphic) 바이러스, 자체 변형(Self-encryption) 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제5세대-매크로-바이러스&quot;&gt;제5세대, 매크로 바이러스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;엑셀이나 워드처럼 매크로 명령을 사용하는 프로그램을 감염시키는 바이러스&lt;/li&gt;
  &lt;li&gt;전문 프로그래머가 아니어도 누구나 쉽게 만들 수 있고 배포가 가능하다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;운영체제와 관계없이&lt;/strong&gt; 응용 프로그램에서 동작하는 바이러스&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Melisa, Laroux, Limda 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;부트-바이러스&quot;&gt;부트 바이러스&lt;/h3&gt;
&lt;p&gt;컴퓨터 전원을 켜면 디스크에 저장되어 있는 운영체제를 메모리로 로드한다. 이러한 과정을 부팅이라고 하며 부트 정보를 가지고 있는 디스크 영역을 부트섹터라고 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;부트 바이러스는 &lt;strong&gt;부트섹터에 영향&lt;/strong&gt;을 주는 컴퓨터 바이러스&lt;/li&gt;
  &lt;li&gt;부트섹터에 바이러스가 감염되면 컴퓨터가 &lt;strong&gt;부팅되지 않거나 부팅 시간이 오래 걸리게&lt;/strong&gt; 된다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;브레인 바이러스, 미켈란젤로(Michelangelo) 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파일-바이러스&quot;&gt;파일 바이러스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용자가 사용하는 일반 파일에 감염되는 바이러스&lt;/li&gt;
  &lt;li&gt;윈도우의 실행 파일인 &lt;strong&gt;COM 혹은 EXE 파일을 감염&lt;/strong&gt;시킨다&lt;/li&gt;
  &lt;li&gt;파일 바이러스는 기생형, 겹쳐쓰기형, 산란형, 연결형 바이러스로 분류된다
    &lt;ul&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;기생형&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;원래의 프로그램은 파괴하지 않고 바이러스가 프로그램의 앞 혹은 뒤에 붙어 &lt;strong&gt;기생&lt;/strong&gt;한다&lt;/li&gt;
          &lt;li&gt;바이러스 감염 여부 확인이 어렵다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;겹쳐쓰기형&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;파일의 앞부분을 겹쳐쓴다&lt;/li&gt;
          &lt;li&gt;원래의 프로그램이 파괴되므로 &lt;strong&gt;원래 프로그램은 복구가 안된다&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;산란형&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;EXE를 감염시키지 않고 &lt;strong&gt;같은 이름으로 COM 파일을 만든다&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;같은 디렉터리에 같은 이름의 EXE와 COM이 있는 경우 사용자가 파일이름을 입력하면 COM이 먼저 실행된다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;연결형&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;프로그램을 &lt;strong&gt;감염시키지 않는다&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;디렉터리 영역에 저장된 프로그램의 시작위치를 바이러스 위치로 변경한다&lt;/li&gt;
          &lt;li&gt;프로그램을 실행하면 &lt;strong&gt;원래 프로그램이 아닌 바이러스가 실행&lt;/strong&gt;된다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;부트-및-파일-바이러스&quot;&gt;부트 및 파일 바이러스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;부트섹터와 파일영역 모두를 감염시키는 바이러스&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;게킬라, 나타스, 침입자 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;윈도우-dde-취약점을-이용한-공격&quot;&gt;윈도우 DDE 취약점을 이용한 공격&lt;/h2&gt;
&lt;p&gt;윈도우 DDE 취약점은 DDE의 정상적인 기능을 악용한 것으로 MS Word의 경우 문서를 열 때 자동 연결 업데이트를 해제하면 방어할 수 있다&lt;/p&gt;

&lt;h3 id=&quot;윈도우-ddedynamic-data-exchange&quot;&gt;윈도우 DDE(Dynamic Data Exchange)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DDE는 &lt;strong&gt;윈도우에서 애플리케이션 간에 데이터를 전송하기 위한 프로토콜&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;윈도우 어플리케이션 간에 &lt;strong&gt;공유 메모리&lt;/strong&gt;를 사용해서 데이터를 공유한다&lt;/li&gt;
  &lt;li&gt;DDE는 윈도우 및 &lt;strong&gt;다른 운영체제 간에 데이터를 공유&lt;/strong&gt;할 수 있도록 허용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shellcode&quot;&gt;Shellcode&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;Shellcode&lt;/span&gt;는 &lt;strong&gt;작은 크기의 코드로 소프트웨어 취약점을 이용하는 짧은 기계어 코드&lt;/strong&gt;이다. 일반적으로 명령 셀을 실행시켜서 피해자의 컴퓨터를 공격자가 통제한다. Shellcode는 &lt;strong&gt;어셈블리어로 작성&lt;/strong&gt;되고 기계어로 번역되어 사용된다.&lt;/p&gt;

&lt;h2 id=&quot;heap-spray&quot;&gt;Heap Spray&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;Heap Spray&lt;/span&gt;는 짧은 기계어 코드인 Shell Code를 Heap 영역에 뿌리는 것으로 &lt;strong&gt;Heap 영역에 임의적으로 Shell Code를 삽입하여 실행시키는 공격 기법&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;생성된 Shell Code는 Visual Studio를 복사한 후 전역변수를 선언해서 대입해야 한다. 그리고 Visual Studio에서 DEP(Data Execution Prevention)을 해제하여 컴파일하면 바로 실행할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;aslraddress-space-layout-randomizaion&quot;&gt;ASLR(Address Space Layout Randomizaion)&lt;/h2&gt;
&lt;p&gt;실행 파일이 메모리에 로드될 때 기본주소는 항상 동일한 주소를 갖는다. 하지만 이렇게 동일한 메모리 주소를 가지면 공격자에게 매우 취약한 문제점이 발생한다. 즉, 주소가 동일하기 때문에 해당 주소에 악성 코드를 적재하기가 쉬워진다.&lt;/p&gt;

&lt;p&gt;프로세스가 실행될 때 메모리에 적재되는 &lt;strong&gt;기본주소가 항상 동일하면 공격자는 해당 주소를 하드코딩해서 자신의 Shellcode를 임의로 적재하여 악성코드를 실행&lt;/strong&gt;하게 할 수 있다. 이러한 문제점으로 인해서 &lt;strong&gt;윈도우 Vista 부터는 메모리의 주소를 항상 동적으로 할당&lt;/strong&gt;하게 했다. 즉, 기본주소가 동적으로 할당되는 것이다. 마찬가지로 리눅스에서도 기본주소를 동적으로 사용할 수 있는 시스템 변수가 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ASLR을 해제(고정 주소)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;sysctl -w kernel.randomize_va_space = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;ASLR을 설정(동적 주소)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;sysctl -w kernel.randomize_va_space = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;버퍼-오버플로우buffer-overflow&quot;&gt;버퍼 오버플로우(Buffer Overflow)&lt;/h2&gt;
&lt;p&gt;버퍼 오버플로우는 &lt;strong&gt;프로세스가 사용 가능한 메모리 공간을 초과해서 발생되는 공격으로 보안 취약점&lt;/strong&gt;이다. C나 C++를 사용해서 프로그램을 개발할 때 &lt;strong&gt;메모리 공간에 제한을 두지 않는 API를 사용해서 발생&lt;/strong&gt;하는 공격이다.&lt;/p&gt;

&lt;p&gt;버퍼 오버플로우 공격을 알기 위해서는 먼저 실행 중인 프로세스가 사용하는 메모리 공간의 구조를 알아야 한다. 프로세스가 사용하는 메모리 공간은 &lt;strong&gt;Stack, Heap, Text, Data&lt;/strong&gt; 로 나누어져 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Stack&lt;/strong&gt;&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램 함수 내에서 사용하는 &lt;strong&gt;지역변수&lt;/strong&gt;가 저장된다&lt;/li&gt;
      &lt;li&gt;함수를 호출하는 경우 되돌아오는 주소인 &lt;strong&gt;복귀주소&lt;/strong&gt;를 가지고 있다&lt;/li&gt;
      &lt;li&gt;함수의 인자 값을 가지고 있다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;스택 버퍼 오버플로우 공격&lt;/strong&gt; : 스택에 저장되어 있는 복귀주소가 지역변수에 의해서 침범당하는 공격&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Heap&lt;/strong&gt;&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램 실행 중 &lt;strong&gt;메모리를 동적으로 할당&lt;/strong&gt;하는 경우 힙 영역에 할당된다&lt;/li&gt;
      &lt;li&gt;동적 메모리 할당 함수를 사용해서 메모리를 할당하면 힙 영역에 할당된다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;힙 버퍼 오버플로우 공격&lt;/strong&gt; : 힙 영역은 하위주소에서 상위주소로 메모리를 할당한다. 그러므로 경계 값을 검사하지 않고 메모리를 사용하면 경계를 초과하는 취약점이 발생한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Text&lt;/strong&gt;&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;읽기만 가능한 메모리 영역&lt;/li&gt;
      &lt;li&gt;프로그램의 &lt;strong&gt;코드가 저장&lt;/strong&gt;된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;선언된 &lt;strong&gt;전역변수&lt;/strong&gt;, &lt;strong&gt;정적변수&lt;/strong&gt;가 저장된다&lt;/li&gt;
      &lt;li&gt;데이터 영역에 변수가 선언되면 자동으로 초기화된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;버퍼 오버플로우에 취약한 C언어 함수들은 다음과 같다. 이들 함수의 공통점은 &lt;strong&gt;길이제한을 두는 기능이 없다&lt;/strong&gt;는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;strcpy(char* dest, const char* src)&lt;/li&gt;
  &lt;li&gt;strcat(char* dest, const char* src)&lt;/li&gt;
  &lt;li&gt;getwd(char* buf)&lt;/li&gt;
  &lt;li&gt;gets(char* s)&lt;/li&gt;
  &lt;li&gt;fscanf(FILE* stream, const char* format, …)&lt;/li&gt;
  &lt;li&gt;scanf(const char* format, …)&lt;/li&gt;
  &lt;li&gt;sprintf(char* str, const char* format, …)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;버퍼 오버플로우를 방지하기 위해서 사용을 권고하는 C언어 함수는 다음과 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;strncat()&lt;/li&gt;
  &lt;li&gt;strncpy()&lt;/li&gt;
  &lt;li&gt;fgets()&lt;/li&gt;
  &lt;li&gt;fscanf()&lt;/li&gt;
  &lt;li&gt;vfscanf()&lt;/li&gt;
  &lt;li&gt;snprintf()&lt;/li&gt;
  &lt;li&gt;vsnprint()&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;버퍼 오버런(Buffer Overrun)&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
메모리 공간에 할당된 공간보다 더 큰 데이터를 입력하면 프로그램의 오류를 유발할 수 있다. 즉, &lt;strong&gt;공격자는 프로그램의 오류를 유발하여 시스템을 장악하거나 Shellcode를 복사하여 악성코드를 실행&lt;/strong&gt;한다.&lt;/p&gt;

&lt;h2 id=&quot;경쟁조건race-condition&quot;&gt;경쟁조건(Race Condition)&lt;/h2&gt;
&lt;p&gt;경쟁조건이란 다중 프로세스 환경에서 두 개 이상의 프로세스가 동시에 수행될 때 발생되는 비정상적인 상태를 의미한다. 즉, &lt;strong&gt;임의의 공유자원을 여러 개의 프로세스가 경쟁하기 때문에 발생&lt;/strong&gt;한다.&lt;/p&gt;

&lt;h2 id=&quot;aptadvanced-persistent-threat-공격&quot;&gt;APT(Advanced Persistent Threat) 공격&lt;/h2&gt;
&lt;p&gt;특정 기법 및 조직을 대상으로 &lt;strong&gt;다양한 공격 기법을 사용하여 지속적으로 공격을 수행하는 행위&lt;/strong&gt;를 APT 공격이라 한다.&lt;/p&gt;

&lt;p&gt;APT는 사회관계망 서비스(SNS)를 사용하여 정보수집, 악성 코드 배포를 수행하고 공격 표적을 선정하여 지속적으로 공격을 수행하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Zero Day Attack&lt;/strong&gt;&lt;/span&gt;은 &lt;strong&gt;소프트웨어 패치 전에 취약점을 이용한 공격&lt;/strong&gt;이고 &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;MAIL APT&lt;/strong&gt;&lt;/span&gt;는 &lt;strong&gt;악성 코드를 메일에 첨부하여 발송하고 이를 통해 정보를 획득하는 공격&lt;/strong&gt;이다. &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;백도어 APT&lt;/strong&gt;&lt;/span&gt;는 &lt;strong&gt;표적에 침투 후 백도어를 설치하여 재침입 시에 유입경로를 열어두는 것&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APT 공격 단계&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;침투(Incursion)&lt;/strong&gt; : Email, USB, 웹사이트를 통한 악성코드 등&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;탐색(Discovery)&lt;/strong&gt; : Network 정보, 시스템 정보, 계정 정보 및 DB/시스템 구조에 대한 정보&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수집/공격(Capture/Attack)&lt;/strong&gt; : 목표로 한 데이터 수집 혹은 시스템 공격&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유출(Exfiltration)&lt;/strong&gt; : 분석 및 추가 공격 혹은 금전적 이익을 취하기 위해 정보 유출&lt;/li&gt;
&lt;/ol&gt;

&lt;p class=&quot;notice--success&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;바이너리 디핑(Binary Diffing)&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
APT 공격이 아닌 &lt;strong&gt;Zero Attack 취약점을 찾을 수 있는 기법&lt;/strong&gt;이다. &lt;strong&gt;리버스 엔지니어링 분야&lt;/strong&gt;에서 활용되는 분야로 &lt;strong&gt;디핑 기술을 이용하여 스크립트된 바이너리 함수 정보를 획득&lt;/strong&gt;한다. 즉, 자동으로 Malware을 탐지하고 오픈소스 라이선스 준수여부를 확인할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 22 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-window-virus/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-window-virus/</guid>
        
        <category>정보보안기사</category>
        
        <category>Windows</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/윈도우] 레지스트리 /이벤트</title>
        <description>&lt;h2 id=&quot;레지스트리registry&quot;&gt;레지스트리(Registry)&lt;/h2&gt;
&lt;p&gt;윈도우 레지스트리는 마이크로소프트 윈도우 운영체제에서 운영체제 및 응용 프로그램 등에 필요한 &lt;strong&gt;정보를 저장하고 관리하기 위한 계층형 데이터베이스&lt;/strong&gt;이다. 레지스트리는 윈도우 부팅 시 로그인, 서비스 실행, 응용 프로그램 실행, 사용자의 행위에 관한 모든 활동에 참여하고 그 &lt;strong&gt;정보를 기록 및 관리&lt;/strong&gt;하는 것으로 윈도우 Me, XP, 2003, 7, 8, 10 모두 사용된다.&lt;/p&gt;

&lt;p&gt;윈도우 레지스트리 정보를 확인하는 방법은 regedit.exe 라는 레지스트리 관리 프로그램을 실행하면 된다.&lt;/p&gt;

&lt;p&gt;윈도우 레지스트리는 &lt;strong&gt;계층형 데이터베이스로 Key, Value, Data Type, Data&lt;/strong&gt;로 이루어져 있다. 키는 상위 레벨에서 하위 레벨 구조로 정의되어 있으며 레지스트리가 어떤 정보를 가지고 있는지 나타낸다.&lt;/p&gt;

&lt;p&gt;해당 키에는 Value와 Data Type, Data로 되어 있어서 Key에 대한 Value와 Value의 데이터 형태가 문자 혹은 숫자인지 등의 데이터 타입이 정의되고 마지막에는 해당 Value가 가지고 있는 데이터를 나타낸다.&lt;/p&gt;

&lt;p&gt;윈도우 레지스트리 키 중에서 가장 상위 레벨에 있는 레지스트리 키를 &lt;strong&gt;루트 키(Root Key)&lt;/strong&gt;라고 하는데 하위에 있는 레지스트리들에 어떤 정보가 있는지 알려주는 것으로 &lt;strong&gt;레지스트리 정보를 일정한 기준으로 분류&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;루트키 역할&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;HKEY_CLASSES_ROOT&lt;/strong&gt; : 파일의 각 &lt;strong&gt;확장자&lt;/strong&gt;에 대한 정보와 파일과 &lt;strong&gt;프로그램 간의 연결&lt;/strong&gt;에 대한 정보&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HKEY_LOCAL_MACHINE&lt;/strong&gt; : 설치된 &lt;strong&gt;하드웨어와 소프트웨어 설치&lt;/strong&gt; 드라이버 설정에 대한 정보&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HKEY_USERS&lt;/strong&gt; : 사용자에 대한 정보&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HKEY_CURRENT_CONFIG&lt;/strong&gt; : &lt;strong&gt;디스플레이 설정&lt;/strong&gt;과 &lt;strong&gt;프린트 설정&lt;/strong&gt;에 관한 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;주요 레지스트리 키&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;윈도우 버전 정보&lt;/strong&gt;&lt;br /&gt;
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컴퓨터 이름&lt;/strong&gt;
HKLM\SYSTEM\ControlSet00X\Control\ComputerName&lt;br /&gt;
\ActiveComputerName&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시작 프로그램 관련&lt;/strong&gt;
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows&lt;br /&gt;
\CurrentVersion\&lt;strong&gt;Run&lt;/strong&gt;,&lt;strong&gt;RunOnce&lt;/strong&gt;,&lt;strong&gt;RunServices&lt;/strong&gt;,&lt;strong&gt;RunServicesOnce&lt;/strong&gt;&lt;br /&gt;
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows&lt;br /&gt;
\CurrentVersion\&lt;strong&gt;Run&lt;/strong&gt;,&lt;strong&gt;RunOnce&lt;/strong&gt;,&lt;strong&gt;RunServices&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최근에 실행한 명령어 확인&lt;/strong&gt;&lt;br /&gt;
HKU\{USER}\SOFTWARE\Microsoft\Windows\CurrentVersion&lt;br /&gt;
\Explorer\RunMRU&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;하이브hive&quot;&gt;하이브(Hive)&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;하이브 파일&lt;/span&gt;은 &lt;strong&gt;레지스트 정보를 가지고 있는 물리적인 파일을 의미&lt;/strong&gt;한다. 윈도우 레지스트 프로그램(regedit.exe)은 하이브 파일을 읽어서 보여주거나 변경하는 것으로 &lt;strong&gt;레지스트와 관련된 모든 정보는 하이브 파일에 저장&lt;/strong&gt;되어 있다.&lt;/p&gt;

&lt;p&gt;하이브 파일은 일반적인 에디터로 변경하는 것은 불가능하고 &lt;strong&gt;커널에 의해&lt;/strong&gt;서 관리되며 &lt;strong&gt;SAM, SECURITY, SYSTEM, SOFTWARE, Default, NTUSER.DAT 등에 존재&lt;/strong&gt;한다. 이러한 하이브 파일의 목록을 하이브 셋이라고 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SYSTEM&lt;/strong&gt; : &lt;strong&gt;시스템 부팅&lt;/strong&gt;에 필요한 시스템 전역 구성정보를 가지고 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SOFTWARE&lt;/strong&gt; : 시스템 부팅에 필요없는 시스템 전역 구성정보로 소프트웨어 정보를 가지고 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SECURITY&lt;/strong&gt; : 시스템 보안정책과 권한 할당 정보로 &lt;strong&gt;시스템 계정만 접근&lt;/strong&gt;이 가능하다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SAM&lt;/strong&gt; : &lt;strong&gt;로컬 계정 정보와 그룹정보&lt;/strong&gt;로 &lt;strong&gt;시스템 계정만 접근&lt;/strong&gt; 가능&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HARDWARE&lt;/strong&gt; : 시스템 하드웨어 디스크립션과 모든 하드웨어의 장치 드라이버 매핑 정보를 가지고 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;COMPONENTS&lt;/strong&gt; : 설치된 컴포넌트와 관련된 정보 관리&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BCD00000000&lt;/strong&gt; : 부팅 환경 데이터를 관리하는 것은 과거 &lt;strong&gt;윈도우 XP의 Boot.ini가 없어지고 대체&lt;/strong&gt;되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;윈도우에서 하이브 파일은 &lt;strong&gt;C:\windows\system32\config&lt;/strong&gt; 디렉터리에 존재한다. 해당 디렉터리에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RegBack&lt;/code&gt;이라는 디렉터리가 존재하는데 이는 &lt;strong&gt;하이브 파일에 대한 백업&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h2 id=&quot;윈도우-이벤트-로그&quot;&gt;윈도우 이벤트 로그&lt;/h2&gt;
&lt;p&gt;윈도우 이벤트 로그는 &lt;strong&gt;윈도우 시스템을 사용하는 동안 발생되는 모든 내용을 발생시간 순으로 기록&lt;/strong&gt;하는 &lt;strong&gt;로그파일&lt;/strong&gt;이다. 이벤트 로그는 이벤트 뷰어라는 관리도구를 사용하여 확인할 수 있으며 이벤트 로그를 기록하고 있는 로그파일은 확장자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.evt&lt;/code&gt; 라는 이름으로 기록되어 있다.&lt;/p&gt;

&lt;p&gt;이벤트 로그는 윈도우에서 발생되는 로그파일을 계속해서 기록하여 모든 로그를 보유하고 있는 것이 아니라 &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;일정한 크기가 되면 덮어쓰는 형태&lt;/strong&gt;&lt;/span&gt;로 기록된다. 이벤트 뷰어 프로그램에서 이벤트 로그파일의 크기를 변경할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;윈도우-로그-종류&quot;&gt;윈도우 로그 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;응용 프로그램 로그&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램 개발자에 의해서 이벤트를 정의하고 분류하여 응용 프로그램에 기록할 이벤트들이 수록된 자료&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;보안 로그&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;관리자에 의해서 보안 로그에 기록된 이벤트 유형을 지정하고, 보안 로그에 기록됨&lt;/li&gt;
      &lt;li&gt;로그온 횟수, 로그인 오류 정보, 파일 생성 및 다른 개체 만들기, 파일 열기 및 삭제 등의 리소스 사용관련 이벤트 기록&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시스템 로그&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;윈도우 시스템에서 사전에 정한 윈도우 시스템 구성요소에서 기록한 이벤트 자료&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;수집된 이벤트 로그는 파일변환을 통해서 엑셀 혹은 SQLite DB에 업로드하거나 Logparse 도구를 사용해서 분석한다.&lt;/p&gt;

&lt;h2 id=&quot;웹-아티펙트-분석&quot;&gt;웹 아티펙트 분석&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;웹 아티펙트 분석&lt;/span&gt;은 사용자가 웹 사이트를 이용한 흔적을 분석하는 것이다. 웹은 웹브라우저와 웹 서버 간의 양방향 통신으로 이루어지고, &lt;strong&gt;웹에서 할당한 모든 기록을 가지고 와서 분석&lt;/strong&gt;하는 것을 웹 아티펙트 분석이라고 한다.&lt;/p&gt;

&lt;p&gt;웹 아티팩트 분석 대상으로는 웹 브라우저 &lt;span style=&quot;color:orangered&quot;&gt;캐시&lt;/span&gt;가 있는데 웹 브라우저 캐시는 캐시 데이터와 캐시 인덱스 정보로 이루어져 있다. &lt;strong&gt;캐시 데이터&lt;/strong&gt;는 &lt;strong&gt;다운로드 받은 이미지 텍스트 파일, 아이콘 등&lt;/strong&gt;을 가지고 있고 &lt;strong&gt;캐시 인덱스&lt;/strong&gt;는 &lt;strong&gt;다운로드 URL, 다운로드 시간, 데이터 크기 등&lt;/strong&gt;의 정보를 가지고 있다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;히스토리 분석&lt;/span&gt;은 사용자가 방문한 웹 사이트 접속 정보를 저장하는 것으로 월별, 일별 방문 기록을 가지고 있다. &lt;strong&gt;히스토리 정보&lt;/strong&gt;는 &lt;strong&gt;방문 사이트 URL, 방문 시간, 방문 횟수, 사이트 제목 등&lt;/strong&gt;을 가지고 있다.&lt;/p&gt;

&lt;p&gt;웹 브라우저 &lt;span style=&quot;color:orangered&quot;&gt;쿠키&lt;/span&gt;는 &lt;strong&gt;웹 사이트 방문 시 자동으로 사용자 PC에 저장되는 작은 저장 공간&lt;/strong&gt;으로 &lt;strong&gt;자동 로그인 기능, 자주 조회되는 물건 등의 값&lt;/strong&gt;이 있다. 또한 &lt;strong&gt;호스트 정보, 경로, 수정시간, 만료시간&lt;/strong&gt; 등의 값도 있다.&lt;/p&gt;

&lt;p&gt;인터넷 익스플로러에 대한 아티팩트 수집 데이터 위치&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;index.dat&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Win XP, 7&lt;/code&gt;)
    &lt;ul&gt;
      &lt;li&gt;캐시, 히스토리, 쿠키 등의 정보가 &lt;strong&gt;각각 나누어져 별도&lt;/strong&gt;의 index.dat 파일로 구성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;WebCacheV01.dat / WebCacheV24.dat&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Win 10&lt;/code&gt;)
    &lt;ul&gt;
      &lt;li&gt;웹 아티팩트 &lt;strong&gt;파일이 통합&lt;/strong&gt;되어서 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 22 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-window-registry-event/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-window-registry-event/</guid>
        
        <category>정보보안기사</category>
        
        <category>Windows</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/윈도우] 윈도우 시스템</title>
        <description>&lt;h2 id=&quot;윈도우-시스템&quot;&gt;윈도우 시스템&lt;/h2&gt;
&lt;p&gt;윈도우 운영체제는 과거 단일 사용자 운영체제인 DOS로부터 시작되어 &lt;strong&gt;GUI(Graph User Interface) 환경 및 다중 사용자, 다중 프로세스 구조를 지원&lt;/strong&gt;하는 운영체제이다. 윈도우는 손쉬운 사용자 인터페이스로 개인용 PC에서 많이 사용된다.&lt;/p&gt;

&lt;p&gt;윈도우 운영체제는 다양한 하드웨어를 자동으로 인식하여 사용할 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Plug &amp;amp; Play&lt;/code&gt; 기능을 지원한다. Plug &amp;amp; Plag 란 &lt;strong&gt;하드웨어를 표준화된 인터페이스를 통해서 개발하면 윈도우의 HAL(Hardware Abstraction Layer) 계층이 하드웨어를 인식&lt;/strong&gt;하는 기능이다. 이러한 하드웨어는 윈도우의 운영체제에 해당되는 &lt;strong&gt;Micro Kernel&lt;/strong&gt;이 관리하게 된다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;구성 내용&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;세부 내용&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;HAL&lt;br /&gt;(Hardware Abstraction Layer)&lt;/td&gt;
      &lt;td&gt;새로운 하드웨어가 개발되어 시스템에 장착되어도 드라이버 개발자가 HAL 표준을 준수하면, 파드웨어와 시스템 간 원할한 통신이 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Micro Kernel&lt;/td&gt;
      &lt;td&gt;Manager에게 작업을 분담시키고 하드웨어를 제어&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IO Manager&lt;/td&gt;
      &lt;td&gt;시스템 입출력을 제어, 장치 드라이버 사이에서 메시지 전달, 응용 프로그램이 하드웨어와 통신할 수 있는 통로를 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Object Manager&lt;/td&gt;
      &lt;td&gt;파일, 포트, 프로세스, 스레드와 같은 각 객체에 대한 정보를 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Security Reference Manager&lt;/td&gt;
      &lt;td&gt;데이터 및 시스템 자원의 제어를 허가 및 거부함으로써 강제적으로 시스템의 보안설정을 책임&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Process Manager&lt;/td&gt;
      &lt;td&gt;프로세스 및 스레드를 생성하고 요청에 따른 작업을 처리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Local Procedure Cell&lt;/td&gt;
      &lt;td&gt;프로세스는 서로의 메모리 공간을 침범하지 못하기 때문에 프로세스 간에 통신이 필요한 경우 이를 처리하는 장치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Virtual Memory Manager&lt;/td&gt;
      &lt;td&gt;응용 프로그램의 요청에 따라 RAM 메모리를 할당, 가상 메모리의 Paging을 제어&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Win 32/64 Sub System&lt;/td&gt;
      &lt;td&gt;윈도우의 기본 서버 시스템, 32비트 및 64비트 응용 프로그램이 동작할 수 있도록 지원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POSIX&lt;/td&gt;
      &lt;td&gt;유닉스 운영체계에 기반을 두고 있는 일련의 표준 운영체제 인터페이스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Security Sub System&lt;/td&gt;
      &lt;td&gt;사용자가 로그인할 때 데이터를 보호하고 운영체제가 이를 제어할 수 있도록 만든 서브 시스템&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;윈도우 파일 시스템의 경우 FAT(File Allocation Table)와 NTFS(NT File System)를 지원한다. FAT은 과거 DOS를 기반으로 하는 파일 시스템으로 작은 파일 시스템에 사용되고 NTFS는 대용량 파일과 긴 파일명, 압축, 저널링 정보를 통한 오류 처리 등을 지원&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;FAT(File Allocation Table)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;FAT16&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;DOS와 윈도우 95의 첫 버전으로 최대 디스크 지원 용량이 2GB&lt;/li&gt;
          &lt;li&gt;NTFS, FAT로 변경 및 변환 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;FAT32&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;2G 이상의 파티션 지원 및 대용량 디스크 지원 기능&lt;/li&gt;
          &lt;li&gt;NTFS로 변환 가능, FAT로 변경 변환은 불가&lt;/li&gt;
          &lt;li&gt;사용되는 운영체제 - 윈도우 95 OSR2, 윈도우 98, 윈도우 2000, 윈도우 XP&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NTFS(NT File System)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;기존 FAT 파일 시스템을 개선하고 윈도우 서버용으로 사용하기 위해서 개발된 파일 시스템&lt;/li&gt;
      &lt;li&gt;파일 암호화 및 파일 레벨 보안 지원&lt;/li&gt;
      &lt;li&gt;디스크 압축 및 파티션 단위로 쿼터&lt;/li&gt;
      &lt;li&gt;FAT16이나 FAT32로 변환 불가&lt;/li&gt;
      &lt;li&gt;사용되는 운영체제 - 윈도우 NT, 윈도우 2000, 윈도우 XP&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;USN 저널&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Update Sequence Number Journal&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;저널링 기능을 제공&lt;/strong&gt;하는 것으로 파일 시스템이 &lt;strong&gt;변경될 때 그 내용을 기록하여 복구&lt;/strong&gt;할 수 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ADS&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Alternate Data Stream&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;MAC 파일 시스템과 호환성&lt;/strong&gt;을 위해서 만든 공간으로 다중 데이터 스트림을 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Sparse 파일&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;파일 데이터가 대부분 0일 경우에 실제 데이터 기록 없이 정보를 기록하는 기능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;파일 압축&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;LZ77의 변형된 데이터 압축 알고리즘 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;VSS&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Volume Shadow Copy Service&lt;/li&gt;
          &lt;li&gt;덮어써진 파일과 디렉터리 백업을 유지하여 복구 기능을 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;EFS&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Encryting File System&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;대칭키 기법&lt;/strong&gt;으로 파일 데이터를 &lt;strong&gt;암호화&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Quotas&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;사용자별 디스크 사용 용량을 제한 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Unicode&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;다국어 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;동적 Bad 클러스터 할당&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Bad Sector가 발생한 클러스터를 자동으로 재할당&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;대용량 지원&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;2TB&lt;/strong&gt;가 넘는 대용량 볼륨 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ntfs-파일-시스템-구성&quot;&gt;NTFS 파일 시스템 구성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;VBR(Volume Boot Record)&lt;/strong&gt;&lt;br /&gt;
NTFS 파일 시스템의 제일 처음에 있는 것으로 &lt;strong&gt;부트섹터, 부트코드, NTLDR&lt;/strong&gt; 위치 등의 정보를 가지고 있다. VBR의 부트섹터는 섹터 0번에 존재한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MFT(Master File Table)&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;NTFS의 메타정보, 파일 및 디렉터리 등의 정보를 관리&lt;/strong&gt;하는 파일로 파일 위치, 속성, 시간정보, 파일명, 크기 등의 정보를 가지고 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Data Area&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;윈도우-인증-시스템&quot;&gt;윈도우 인증 시스템&lt;/h3&gt;
&lt;p&gt;winlogon은 내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;megina.dll&lt;/code&gt;이라는 GINA 프로그램을 구동시키며 검증을 위해서 아이디를 LSA에 전달한다. NTLM 값과 SAM에 저장된 NTLM 값을 비교하여 같으면 SRM에게 권한을 부여한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/windows/windows-authority.png&quot; title=&quot;https://m.blog.naver.com/PostView.naver?blogId=darkness76&amp;amp;logNo=60201244303&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F&quot;&gt;&lt;img src=&quot;../../assets/images/security/windows/windows-authority.png&quot; alt=&quot;&quot; title=&quot;윈도우 인증 프로세스&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/windows/windows-authority-role.png&quot; title=&quot;https://m.blog.naver.com/PostView.naver?blogId=darkness76&amp;amp;logNo=60201244303&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F&quot;&gt;&lt;img src=&quot;../../assets/images/security/windows/windows-authority-role.png&quot; alt=&quot;&quot; title=&quot;윈도우 인증 프로세스 역할&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;인증 프로세스 구성요소&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Winlogon&lt;/strong&gt;&lt;br /&gt;
윈도우 로그인 프로세스. 윈도우 시작 시 자동으로 초기화되어 실행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GINA(msgina.dll)&lt;/strong&gt;&lt;br /&gt;
Winlogon은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msgina.dll&lt;/code&gt;을 로딩하여 사용자가 입력한 &lt;strong&gt;계정과 암호를 LSA에게 전달&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LSA(Local Security Authority, lsass.exe에서 관리)&lt;/strong&gt;&lt;br /&gt;
모든 계정의 &lt;strong&gt;로그인에 대한 검증&lt;/strong&gt;&lt;br /&gt;
시스템 자원 및 파일 등에 대한 &lt;strong&gt;접근 권한을 검사&lt;/strong&gt;&lt;br /&gt;
계정과 암호를 검증하기 위해서 NTLM(암호화) 모듈을 로딩하고 계정을 검증&lt;br /&gt;
SRM이 작성한 감사로그를 기록&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SAM(Security Account Manager)&lt;/strong&gt;&lt;br /&gt;
사용자 계정 정보(해시 값)에 저장&lt;br /&gt;
사용자의 로그인 입력 정보와 SAM 데이터베이스 &lt;strong&gt;정보를 비교하여 인증 여부를 결정&lt;/strong&gt;하도록 해준다.&lt;/p&gt;

    &lt;p&gt;리눅스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/shadow&lt;/code&gt; 파일과 같은 역할을 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SRM(Security Reference Monitor)&lt;/strong&gt;&lt;br /&gt;
SAM이 사용자의 계정과 패스워드가 일치하는 지를 확인하여 SRM에게 알려주면 SRM은 사용자에게 고유의 SID를 부여하고 SID에 권한 부여&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;윈도우-실행-프로세스&quot;&gt;윈도우 실행 프로세스&lt;/h3&gt;
&lt;p&gt;윈도우 운영체제 관련 프로세스는 wininit.exe, services.exe, lsm.exe, winlogon.exe 등이 있으며 &lt;strong&gt;C:\windows\system32&lt;/strong&gt; 폴더에 위치한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;프로세스&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;wininit.exe&lt;/td&gt;
      &lt;td&gt;윈도우 시작 프로그램&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;services.exe&lt;/td&gt;
      &lt;td&gt;윈도우 서비스 관리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lsm.exe&lt;/td&gt;
      &lt;td&gt;Local Session Manager&lt;br /&gt;&lt;br /&gt;시스템 관리 작업, 주요 함수 실행, 호스트 컴퓨터와 서버의 연결을 관리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lsass.exe&lt;/td&gt;
      &lt;td&gt;Local Security Authority Subsystem Service&lt;br /&gt;&lt;br /&gt;사용자 로그인 검사, 비밀번호 변경 관리, 액세스 토큰 생성&lt;br /&gt;Windows Security Log를 작성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;svchost.exe&lt;/td&gt;
      &lt;td&gt;서비스를 관리하기 위한 프로세스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;conhost.exe&lt;/td&gt;
      &lt;td&gt;키보드, 마우스 입력 허용, 문자 출력, 콘솔 API 등 셀의 기본 기능 수행&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;윈도우-계정&quot;&gt;윈도우 계정&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Users&lt;/strong&gt; : 기본적인 권한은 가지고 있지 않지만 Domain Users 글로벌 그룹이 구성원으로 포함되어 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Account Operators&lt;/strong&gt; : 서버 관리자를 사용하여 컴퓨터를 도메인 추가 가능하며, 사용자 계정, 그룹의 생성 및 삭제, 수정할 수 있는 권한을 가지고 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Printer Operators&lt;/strong&gt; : 도메인 컨트롤러에 있는 프린터를 생성 및 관리&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Server Operators&lt;/strong&gt; : 도메인 컨트롤러에 있는 자원을 공유하거나 폴더를 백업하고 복구&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;유니버설 그룹&lt;/strong&gt;은 &lt;strong&gt;복수의 도메인 환경에서 상호 관련되어 있는 자원에 대한 허가를 부여할 때 주로 사용&lt;/strong&gt;한다. 도메인 내의 로컬 그룹과 유니버설 그룹의 구성원이 될 수 있다. 성능 저하를 초래할 수 있으므로 꼭 필요할 때에만 사용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;유니버설 그룹 계정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Administrators&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 컴퓨터의 모든 관리 권한과 사용 권한을 보유&lt;/li&gt;
      &lt;li&gt;기본적으로 Administrator가 사용자 계정과 Domain Admins를 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Users&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;기본적인 권한은 갖지 않음&lt;/li&gt;
      &lt;li&gt;컴퓨터에서 생성되는 로컬 사용자 계정 포함&lt;/li&gt;
      &lt;li&gt;Domain Users 글로벌 그룹이 구성원으로 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Guest&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;관리자에 의해 허락된 자원과 권한만을 사용하여 네트워크 자원에 접근 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Backup Operators&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Windows 백업을 이용하여 모든 도메인의 컨트롤러에 있는 파일과 폴더를 백업하고 복구할 수 있는 권한이 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Power Users&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;컴퓨터에서 로컬 사용자 &lt;strong&gt;계정을 생성하고 수정&lt;/strong&gt;할 수 있는 권한을 갖고 있으며 &lt;strong&gt;자원을 공유하거나 멈출 수 있다&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;시스템에 대한 전체 권한은 없지만 &lt;strong&gt;시스템을 관리할 수 있는 권한&lt;/strong&gt;이 부여된 그룹&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;공유-파일&quot;&gt;공유 파일&lt;/h3&gt;
&lt;p&gt;윈도우의 공유 폴더 기능은 자신의 컴퓨터에 잇는 폴더를 다른 컴퓨터와 공유할 수 있는 기능으로 자료를 같이 공유하면서 업무를 처리할 때 아주 유용한 기능이다. 하지만, 정보보안에서는 공유 폴더를 통해서 악성코드를 유포하거나 시스템 정보를 획득할 수 있기 때문에 삭제를 권고한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공유 폴더 목록 확인 : &lt;strong&gt;net share&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;IPC$&lt;/strong&gt; : 네트워크 프로그램 간에 통신을 위해서 파이프를 사용하고 네트워크 &lt;strong&gt;서버 원격관리를 위해서 사용&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공유 폴더 삭제 : &lt;strong&gt;/delete&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 21 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-window-system/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-window-system/</guid>
        
        <category>정보보안기사</category>
        
        <category>Windows</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/리눅스] 로그 파일 및 주요 명령어</title>
        <description>&lt;h2 id=&quot;로그-파일&quot;&gt;로그 파일&lt;/h2&gt;
&lt;p&gt;사용자가 네트워크를 경유해서 리눅스 운영체제에 접속하고 로그인 후 어떤 명령 등을 실행하면 리눅스 운영체제는 &lt;strong&gt;사용자의 터미널 정보, 실행한 명령어, 로그인과 로그아웃 정보 등을 모두 로그파일에 기록&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;로그파일은 공격자가 임의적으로 시스템에 접근하여 어떤 작업을 수행했는지 알 수 있는 것으로 침해사고 발생 시 누가 무엇을 수행했는지 증명하는 책임추적성 역할을 수행한다.&lt;/p&gt;

&lt;p&gt;로그 파일이라는 것은 &lt;strong&gt;파일에 불과하기 때문에 어떤 로그 파일도 공격자에 의해서 조작될 수 있으므로&lt;/strong&gt; 하나의 로그 파일을 보고 침해 사고를 분석하는 것이 아니라 여러 개의 로그 파일을 종합적으로 분석해서 판단해야 한다.&lt;/p&gt;

&lt;p&gt;리눅스의 로그파일은 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/log&lt;/code&gt; 라는 디렉터리에 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;현재-로그인-사용자-확인&quot;&gt;현재 로그인 사용자 확인&lt;/h3&gt;
&lt;p&gt;리눅스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w&lt;/code&gt; 혹은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;who&lt;/code&gt; 명령을 실행하면 현재 로그인 한 사용자 정보를 확인할 수 있다. 즉, 리눅스에서 &lt;strong&gt;로그인 사용자 ID, 사용 터미널, 로그인 시간 등을 확인&lt;/strong&gt;할 수 있다.&lt;/p&gt;

&lt;p&gt;현재 로그인한 사용자 정보는 로그인을 수행할 때 &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;utmp&lt;/strong&gt;&lt;/span&gt; 라는 파일에 로그인 정보가 기록된다. utmp 파일은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/run/utmp&lt;/code&gt;에 존재한다.&lt;/p&gt;

&lt;p&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;who&lt;/code&gt; 명령은 &lt;strong&gt;utmp 파일을 읽어서 터미널에 출력&lt;/strong&gt;해주는 역할을 수행하는 것이고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utmp&lt;/code&gt; 파일은 &lt;strong&gt;현재 로그인 한 사용자의 정보&lt;/strong&gt;를 가지고 있는 것이다.&lt;/p&gt;

&lt;p&gt;utmp 파일에 대한 정보는 &lt;strong&gt;stat 명령을 실행&lt;/strong&gt;해서 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;사용자의-로그인-및-로그아웃-정보-확인&quot;&gt;사용자의 로그인 및 로그아웃 정보 확인&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;wtmp&lt;/strong&gt;&lt;/span&gt; 로그 파일은 &lt;strong&gt;사용자의 로그인과 로그아웃 정보를 가지고 있는 로그 파일&lt;/strong&gt;로 접속 정보를 &lt;strong&gt;계속 기록&lt;/strong&gt;하는 파일이다. wtmp 파일은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/log&lt;/code&gt; 디렉터리에 존재하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last&lt;/code&gt; 명령을 사용하여 wtmp 파일을 읽을 수 있다.&lt;/p&gt;

&lt;p&gt;또한 wtmp 파일은 로그인과 로그아웃 정보 이외에도 시스템 관련 정보를 포함하고 있기 때문에 침해사고 분석 시 중요한 로그파일 중 하나이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 로그인 및 로그아웃 정보&lt;/li&gt;
  &lt;li&gt;시스템 관련 정보&lt;/li&gt;
  &lt;li&gt;시스템 종료 및 부팅 정보&lt;/li&gt;
  &lt;li&gt;재부팅 정보&lt;/li&gt;
  &lt;li&gt;telnet 및 ftp 등을 통한 로그인 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;로그인-실패-정보-확인&quot;&gt;로그인 실패 정보 확인&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;btmp&lt;/strong&gt;&lt;/span&gt; 로그 파일은 리눅스 &lt;strong&gt;로그인 시 실패한 정보를 가지고 있는 로그 파일&lt;/strong&gt;이다. 해당 로그 파일은 바이너리로 되어 있기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lastb&lt;/code&gt; 명령어를 실행하여 확인해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;syslog-사용하기&quot;&gt;syslog 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;syslog&lt;/strong&gt;&lt;/span&gt;는 리눅스 &lt;strong&gt;운영체제에 대한 로그를 기록하는 데몬 프로세스&lt;/strong&gt;로 syslogd라는 프로그램에 의해서 로그를 기록한다. syslogd 프로세스가 실행되면 syslogd의 설정 파일인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/syslogd.conf&lt;/code&gt; 파일을 읽어서 로그를 기록할 수준을 결정한다.&lt;/p&gt;

&lt;p&gt;즉, 로그를 기록하는 수준이라는 것은 위험성에 따라 분류하여 어디까지 로그파일을 기록할 것인지를 결정하는 것이다.&lt;/p&gt;

&lt;p&gt;syslogd 프로세스에 의해서 &lt;strong&gt;기록되는 로그파일은 /var/log&lt;/strong&gt; 디렉터리에 존재하며 &lt;strong&gt;syslogd.conf 파일&lt;/strong&gt;은 syslogd 데몬 프로세스가 어떤 로그를 기록하고 각각의 로그파일은 어느 디렉터리에 기록할 것인지를 정의하는 &lt;strong&gt;설정파일&lt;/strong&gt;이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;syslog 주체별 분류(Facility)&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;종류&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;내용&lt;/strong&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;kern&lt;/td&gt;
          &lt;td&gt;kernel에서 요청하는 경우 로그를 기록&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;mail&lt;/td&gt;
          &lt;td&gt;mail subsystem 요청하는 경우 로그를 기록&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;lpr&lt;/td&gt;
          &lt;td&gt;Pringing subsystem에서 요청하는 경우 로그를 기록&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;daemon&lt;/td&gt;
          &lt;td&gt;System server processes에서 요청하는 경우 로그를 기록&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;auth&lt;/td&gt;
          &lt;td&gt;Login authentication system에서 요청하는 경우 로그를 기록&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;시스템 위험성에 따른 syslog 유형&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;위험성 강도 순서&lt;/strong&gt; : emerg &amp;gt; alert &amp;gt; crit &amp;gt; err &amp;gt; warn &amp;gt; notice &amp;gt; info &amp;gt; debug&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;위험강도&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;내용&lt;/strong&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;emerg&lt;/td&gt;
          &lt;td&gt;가장 위험성이 높고 긴급하며 심각한 상황을 모든 사용자에게 경보하는 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;alert&lt;/td&gt;
          &lt;td&gt;변조된 시스템 데이터베이스 등과 같이 곧바로 정정해야만 하는 것으로 즉시 주의를 요하는 심각한 에러가 발생한 경우의 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;crit&lt;/td&gt;
          &lt;td&gt;H/W나 디바이스와 관련하여 심각한 오류 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;err&lt;/td&gt;
          &lt;td&gt;일상적으로 발생할 수 있는 에러 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;warn&lt;/td&gt;
          &lt;td&gt;시스템 수행 시 주의사항 및 경고 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;notice&lt;/td&gt;
          &lt;td&gt;에러 상태는 아니나, 특수한 방법으로 수행해야 할 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;info&lt;/td&gt;
          &lt;td&gt;도움말 등의 정보가 있는 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;debug&lt;/td&gt;
          &lt;td&gt;오류를 검출하거나 해결 시 도움이 될 만한 외부 정보들을 표시하는 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;none&lt;/td&gt;
          &lt;td&gt;로깅 주체에서 무시하는 정보 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;mark&lt;/td&gt;
          &lt;td&gt;메시지 생성 시간을 결정하는 메시지(기본값 = 15분)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주요-명령어&quot;&gt;주요 명령어&lt;/h2&gt;
&lt;h3 id=&quot;작업-스케줄-관리&quot;&gt;작업 스케줄 관리&lt;/h3&gt;
&lt;h4 id=&quot;cron&quot;&gt;cron&lt;/h4&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;cron&lt;/strong&gt;&lt;/span&gt;은 &lt;strong&gt;일정한 날짜와 시간에 지정된 작업을 실행하는 프로세스로 반복적인 작업을 수행&lt;/strong&gt;할 때 사용한다. cron 프로세스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/crontab&lt;/code&gt; 파일에 설정된 것을 읽어서 작업을 수행한다.&lt;/p&gt;

&lt;p&gt;정보보안에서 cron이 중요한 이유는 두 가지가 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;보안 취약점 검사를 수행할 때 매일 반복적으로 점검이 가능하다&lt;/li&gt;
  &lt;li&gt;공격자가 악성코드를 실행하는 명령을 crontab에 설정해서 반복적으로 악성코드를 실행할 수 있다&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;crontab 파일구조&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;분(m)&lt;/strong&gt; : 0 ~ 59&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;시(h)&lt;/strong&gt; : 0 ~ 23&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;일(dom)&lt;/strong&gt; : 1 ~ 31&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;월(mon)&lt;/strong&gt; : 1 ~ 12&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;요일(dow)&lt;/strong&gt; : 일요일(0) ~ 토요일(6)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;사용자(user)&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;실행명령(command)&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;crontab 옵션&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-l&lt;/td&gt;
      &lt;td&gt;현재 로그인 된 계정에 잡혀있는 작업 스케쥴 확인&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-e&lt;/td&gt;
      &lt;td&gt;현재 로그인 중인 계정에 작업을 등록&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r&lt;/td&gt;
      &lt;td&gt;현재 crontab에 등록된 작업을 삭제&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u [유저명]&lt;/td&gt;
      &lt;td&gt;작업을 실행시킬 유저명 설정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;at&quot;&gt;at&lt;/h4&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;at&lt;/strong&gt;&lt;/span&gt;은 cron과 다르게 예약한 명령어를 정해진 시간에 한 번만 실행할 때 사용하는 명령어이다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;at 옵션&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-l&lt;/td&gt;
      &lt;td&gt;현재 실행 대기 중인 명령의 목록을 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r&lt;/td&gt;
      &lt;td&gt;실행 대기 중인 명령에서 해당 작업번호를 삭제&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-f&lt;/td&gt;
      &lt;td&gt;표준 입력 대신 실행할 명령을 파일로 저장&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;악성코드-탐지&quot;&gt;악성코드 탐지&lt;/h3&gt;
&lt;h4 id=&quot;리다이렉션redirection&quot;&gt;리다이렉션(Redirection)&lt;/h4&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;리다이렉션&lt;/strong&gt;&lt;/span&gt;은 &lt;strong&gt;표준 스트림으로 사용자가 지정한 곳을 변경&lt;/strong&gt;할 수 있는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어 명령어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 파일로 입력하면 &lt;strong&gt;명령어의 결과가 파일에 저장&lt;/strong&gt;된다. 즉 ps &amp;gt; A.txt 를 실행하면 ps 정보로 출력되는 프로세스 정보가 A.txt 라는 파일에 기록된다. 만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt; 로 입력한다면 &lt;strong&gt;파일에 추가&lt;/strong&gt;하라는 의미이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;종류&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;=1&amp;gt;와 같은 것으로 1의 의미는 표준출력. 출력 방향 전환으로 파일이 존재하면 덮어쓴다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;=1»와 같은 의미로 표준출력에 추가한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;lt;&lt;/td&gt;
      &lt;td&gt;출력 방향 전환으로 파일이 존재하면 덮어쓴다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;«&lt;/td&gt;
      &lt;td&gt;표준 출력에 추가한다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;파이프pipe&quot;&gt;파이프(Pipe)&lt;/h4&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;파이프&lt;/strong&gt;&lt;/span&gt;는 어떤 명령어의 실행 결과를 다른 명령어의 입력으로 전달하는 것으로 명령어 1 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; 명령어 2 형태로 사용한다&lt;/p&gt;

&lt;h3 id=&quot;find-명령어&quot;&gt;find 명령어&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;find&lt;/strong&gt;&lt;/span&gt; 명령은 특정 파일명이나 특정 권한이 부여된 파일을 찾을 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;파일명&lt;/strong&gt;으로 파일을 검색한다. 알려진 공격 파일을 찾을 수도 있으며 특히, Web Shell 중에서 알려진 파일 등을 확인할 수 있다
    &lt;blockquote&gt;
      &lt;p&gt;EX1) find . -name “[A-Z]&lt;em&gt;” : 현재 디렉터리에서 파일명의 첫 글자가 영문자 대문자인 것을 검색&lt;br /&gt;
EX2) find . -name “&lt;/em&gt; *” -exec rm -f {}\; : 현재 디렉터리에서 파일 이름에 공백이 들어간 모든 문자를 삭제&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;특정 권한이 부여된 파일을 검색&lt;/strong&gt;하여 파일에 특수 권한이 부여되어 있거나, 실행권한을 가지고 있는 파일을 찾을 수 있다
    &lt;ul&gt;
      &lt;li&gt;권한을 가질 파일을 찾을 때는 가장 먼저 setuid, setgid 등의 &lt;strong&gt;특수 권한이 부여된 것을 찾아야&lt;/strong&gt; 한다. setuid(4000), setgid(2000), sticky bit(1000)의 권한이 부여되었으며 만약, setuid와 setgid 모두가 부여된 것을 찾기 위해서는 6000(4000+2000)으로 검색하면 된다.
        &lt;blockquote&gt;
          &lt;p&gt;EX) find / &lt;strong&gt;-perm&lt;/strong&gt; +6000&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특정 &lt;strong&gt;시간 이후에 변경된 파일을 찾아서&lt;/strong&gt; 침입 이후에 변경된 파일 리스트를 확인할 수 있다
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;-atime&lt;/strong&gt; : Access Time으로 파일을 열거나 접근한 시간을 기준으로 검색&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;-mtime&lt;/strong&gt; : Modify Time으로 파일이 변경된 시간으로 검색&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;-ctime&lt;/strong&gt; : Change Time으로 파일 속성이 변경된 시간을 기준으로 검색
        &lt;blockquote&gt;
          &lt;p&gt;EX1) find / -mtime +5 : 최근 5일 동안 변경되지 않은 파일 검색&lt;br /&gt;
EX2) find / -mtime -1 : 24시간 동안 변경된 파일 검색&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;특정 사용자가 소유자인 파일 검색&lt;/strong&gt;. 파일의 &lt;strong&gt;소유자를 기준으로 파일&lt;/strong&gt;을 찾기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 옵션을 사용하면 된다. &lt;strong&gt;소유자가 없는 파일&lt;/strong&gt;을 찾을 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nouser&lt;/code&gt; 옵션을 이용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파일-무결성integrity-검사&quot;&gt;파일 무결성(Integrity) 검사&lt;/h3&gt;
&lt;p&gt;단순하게 시간을 기준으로 파일이 변경되었는지 확인하기는 어렵다. 파일 시간은 얼마든지 변조가 가능하기 때문에 시간만으로 파일 변경 여부를 확인할 수 없다.&lt;/p&gt;

&lt;p&gt;파일의 무결성 검사를 위해서는 &lt;strong&gt;초기 상태의 파일 정보에 대해서 해시 값을 저장&lt;/strong&gt;하고 원하는 시점에 초기의 해시 값과 &lt;strong&gt;비교해서 변경 여부를 확인&lt;/strong&gt;한다. 해시 값을 사용해서 파일의 무결성을 검사하는 도구로는 &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;tripwire&lt;/strong&gt;&lt;/span&gt;가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;tripwire –&lt;strong&gt;init&lt;/strong&gt; : 해시 값을 저장한 데이터베이스 초기화&lt;/li&gt;
  &lt;li&gt;tripwire –&lt;strong&gt;check&lt;/strong&gt; : 무결성 검사를 실행&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 21 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-linux-log/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-linux-log/</guid>
        
        <category>정보보안기사</category>
        
        <category>Linux</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/리눅스] 방화벽</title>
        <description>&lt;h2 id=&quot;방화벽&quot;&gt;방화벽&lt;/h2&gt;
&lt;h3 id=&quot;iptables&quot;&gt;iptables&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;iptables&lt;/span&gt;는 리눅스에서 &lt;strong&gt;방화벽 정책을 수립할 수 있는 도구&lt;/strong&gt;로 iptables를 사용하는 경우 다음과 같은 방화벽 정책을 수립해서 패킷 필터링을 할 수 있다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 것을 허용한 후에 일부 패킷을 제한한다&lt;/li&gt;
  &lt;li&gt;모든 것을 거부한 후에 일부 패킷을 허용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;iptables의 체인은 외부에서 리눅스 시스템으로 유입되는 패킷과 리눅스 내부에서 외부로 전송되는 패킷에 대해서 접근 제어를 생성할 수 있다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;iptables 체인 종류&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;INPUT&lt;/strong&gt; : 리눅스로 들어오는 패킷(입력 패킷)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FORWARD&lt;/strong&gt; : INPUT과 OUTPUT 역할, 라우터에 방화벽을 적용할 때 사용한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OUTPUT&lt;/strong&gt; : 외부로 나가는 패킷(출력 패킷)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;iptables 사용법&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;iptables [-t table] command [match] [target\jump]&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;A&lt;/strong&gt;(–append) : 규칙을 추가&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;D&lt;/strong&gt;(–delete) : 규칙을 삭제&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;N&lt;/strong&gt;(–new-chain) : 새로운 체인 생성&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;X&lt;/strong&gt;(–delete-chain) : 체인 제거&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;P&lt;/strong&gt;(–policy) : 체인 기본정책 변경&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;L&lt;/strong&gt;(–list) : 체인의 규칙 상태 보기&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;F&lt;/strong&gt;(–flush) : 체인 내의 모든 규칙 제거(&lt;strong&gt;방화벽 초기화&lt;/strong&gt;)&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Z&lt;/strong&gt;(–zero) : 체인 내의 모든 규칙의 패킷과 바이트의 카운트를 0으로 초기화&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;R&lt;/strong&gt;(–replace) : 새로운 규칙으로 대체&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;I&lt;/strong&gt;(–insert) : 체인의 가장 처음에 규칙을 추가&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;E&lt;/strong&gt;(–rename-chain) : 체인의 이름을 변경&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;iptables에 등록된 정보는 &lt;strong&gt;INPUT, FORWARD, OUTPUT 체인 별&lt;/strong&gt;로 확인할 수 있는데 이 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iptables -L&lt;/code&gt;을 사용하면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용 예제
    &lt;ul&gt;
      &lt;li&gt;loopback 패킷 차단
        &lt;blockquote&gt;
          &lt;p&gt;iptables -A OUTPUT -o lo -j DROP&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;등록된 체인 삭제
        &lt;blockquote&gt;
          &lt;p&gt;iptables -F OUTPUT&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ifconfig&quot;&gt;ifconfig&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;ifconfig&lt;/span&gt; 명령어는 &lt;strong&gt;네트워크 인터페이스 정보를 확인하거나 네트워크 인터페이스를 시작, 종료&lt;/strong&gt;할 수 있다. 리눅스에서 ifconfig 명령어를 입력하면 네트워크 인터페이스를 확인할 수 있는데, 일반적으로 &lt;strong&gt;eth0, lo&lt;/strong&gt; 두 개의 인터페이스가 확인된다. 여기서 &lt;strong&gt;lo 인터페이스는 Loopback 주소&lt;/strong&gt;로 자기 자신의 주소로 사용되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt;의 주소가 할당되어 있다&lt;/p&gt;

</description>
        <pubDate>Fri, 21 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-linux-firewall/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-linux-firewall/</guid>
        
        <category>정보보안기사</category>
        
        <category>Linux</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[에픽게임즈/Epic Games] 시작되는 2021 에픽스토어 메가세일과 무료 배포 게임(5/21)</title>
        <description>&lt;p&gt;생각보다는 일찍 이번 상반기에도 에픽에서 메가 세일을 진행하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/hobby/games/epic-mega-sale.png&quot;&gt;&lt;img src=&quot;../../assets/images/hobby/games/epic-mega-sale.png&quot; alt=&quot;&quot; title=&quot;에픽 메가 세일&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;메가 세일 기간은 글을 작성하는 오늘(&lt;strong&gt;5/21&lt;/strong&gt;)일자부터 &lt;strong&gt;6/17&lt;/strong&gt;(목요일)까지 입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/hobby/games/epic-mega-sale-coupon.png&quot;&gt;&lt;img src=&quot;../../assets/images/hobby/games/epic-mega-sale-coupon.png&quot; alt=&quot;&quot; title=&quot;크레딧 지급&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11,000&lt;/code&gt;원의 상당한 쿠폰을 같이 배포하는데 신작, 별도 할인과 구분없이 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;15,000&lt;/code&gt;원 이상의 게임을 구매할 때 사용&lt;/strong&gt;할 수 있으며 구매 즉시 해당 상품권을 다시 자동으로 회수하여 사용할 수 있습니다(이론 상 무한정!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;몇 달 전에는 GTA5를 비롯하여 명작게임들을 무료로 배포한 전적이 있죠.&lt;/p&gt;

&lt;p&gt;지금까지 그래왔듯이 &lt;strong&gt;금요일 매주 미스터리 게임이 무료&lt;/strong&gt;로 제공됩니다.&lt;/p&gt;

&lt;p&gt;기존과 다른점이 있다면 저번 겨울때처럼 미리 공개를 하지 않는다는 거네요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;5/21일자의 무료 게임은 [&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NBA 2K21&lt;/code&gt;&lt;/strong&gt;] 이며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5/28&lt;/code&gt;(다음주 금요일) 자정전까지 무료로 받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;스포츠 게임을 그리 좋아하지 않는 저로서는 아마 하지는 않을 것 같지만 무료로 배포하는 거니까 일단 라이브러리에 담아 놓았습니다.&lt;/p&gt;

&lt;p&gt;다음 주에는 어떤 게임을 배포할 지 매우 궁금하네요 :)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/hobby/games/05-21-epic-free-game.png&quot;&gt;&lt;img src=&quot;../../assets/images/hobby/games/05-21-epic-free-game.png&quot; alt=&quot;&quot; title=&quot;2021/05/21 에픽 무료 배포 게임 - NBA2K21&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;다음 주에도 무료 배포 게임과 함께 포스팅하겠습니다&lt;/p&gt;

&lt;p&gt;모두 라이브러리 채워놓을 준비합시다!&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;이 글은 순전히 정보 전달 목적으로 작성되었으며 일절 비용을 받지 않았습니다.&lt;/p&gt;
</description>
        <pubDate>Fri, 21 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/hobby/games-epic-free-week-0521/</link>
        <guid isPermaLink="true">https://many258.github.io/hobby/games-epic-free-week-0521/</guid>
        
        <category>Games</category>
        
        
        <category>hobby</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/리눅스] 리눅스 부팅(Booting)</title>
        <description>&lt;h2 id=&quot;boot-master&quot;&gt;Boot Master&lt;/h2&gt;
&lt;p&gt;컴퓨터 시스템에 전원이 들어왔을 때 가장 처음 하는 것은 &lt;strong&gt;보조 기억 장치에 있는 운영체제의 커널을 주기억 장치에 적재&lt;/strong&gt;하는 작업이다. 이렇게 보조 기억 장치에 있는 커널을 주기억 장치에 올리는 것은 &lt;strong&gt;로더&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Loader&lt;/code&gt;)라는 프로그램이 수행한다&lt;/p&gt;

&lt;p&gt;리눅스에서 이러한 로더의 역할을 수행하는 것이 &lt;span style=&quot;color:orangered&quot;&gt;LILO(LInux LOader)&lt;/span&gt;이다. 즉, LILO는 리눅스의 부트로더이다. LILO는 실행 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/lilo.conf&lt;/code&gt; 라는 파일을 읽어 들여서 실행된다&lt;/p&gt;

&lt;p&gt;최근에는 리눅스 부팅에 LILO보다는 &lt;span style=&quot;color:orangered&quot;&gt;GRUB&lt;/span&gt; 이라는 부트로드를 사용한다. GRUB은 로더의 역할을 수행하는 것으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/boot/grub/grub.conf&lt;/code&gt; 설정파일을 읽어서 가동된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GRUB&lt;/code&gt;의 특징&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;부트정보를 사용자가 임의로 변경할 수 있음&lt;/li&gt;
      &lt;li&gt;여러 운영체제를 사용할 수 있는 멀티부팅 지원&lt;/li&gt;
      &lt;li&gt;커널 경로 및 파일명만 알고 있다면 부팅이 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;/boot/grub/grub.conf 설정 값&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;default=0&lt;/td&gt;
      &lt;td&gt;부트 순서를 지정하는 번호로 멀티부트의 경우 운영체제 레이블 번호를 선택&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;timeout=0&lt;/td&gt;
      &lt;td&gt;지정된 시간이 경과되면 default로 지정된 운영체제로 부팅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;splashimg=(hd0,0)&lt;br /&gt;/grub/splash.xpm.gz&lt;/td&gt;
      &lt;td&gt;부팅 이미지를 지정하는 부분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hiddenmenu&lt;/td&gt;
      &lt;td&gt;부트로더를 보여주지 않음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;title Fedora&lt;/td&gt;
      &lt;td&gt;부팅되는 부트 엔트리를 의미&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;부팅-순서&quot;&gt;부팅 순서&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;리눅스의 서버 전원을 켜면 &lt;strong&gt;ROM BIOS를 읽고 디스크의 MBR(Master Boot Record)에 있는 부트로더가 실행&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;부트로더는 보조 기억 장치에 저장되어 있는 &lt;strong&gt;리눅스 커널을 찾고 실행&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;리눅스 커널은 하드웨어를 확인하고 &lt;strong&gt;root의 읽기 전용&lt;/strong&gt;으로 마운트를 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디스크 검사&lt;/strong&gt;하고 &lt;strong&gt;root의 쓰기 전용&lt;/strong&gt;으로 다시 마운트 수행&lt;/li&gt;
  &lt;li&gt;리눅스 커널은 &lt;strong&gt;init 프로세스를 실행하고 PID 1번&lt;/strong&gt;을 할당&lt;/li&gt;
  &lt;li&gt;init 프로세스는 자신의 설정파일인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/initab&lt;/code&gt; 파일을 읽어서 디바이스 및 프로세스를 활성화&lt;/li&gt;
  &lt;li&gt;init 프로세스의 작업 수행은 리눅스의 &lt;strong&gt;Run 레벨에 따라 다르게 부팅&lt;/strong&gt;된다&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;run-level&quot;&gt;Run Level&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;0&lt;/strong&gt; : &lt;strong&gt;PROM&lt;/strong&gt; 감사 단계&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;1&lt;/strong&gt; : 관리상태의 단계. 사용자 로그인의 접근이 불가능한 단일 사용자 단계로 여러 개의 파일 시스템이 로드되어 있음. &lt;strong&gt;암호를 변경할 때 사용&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;2&lt;/strong&gt; : &lt;strong&gt;공유된 자원을 갖지 않은 다중 사용자&lt;/strong&gt; 단계&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;3&lt;/strong&gt; : 기본 실행 단계로 &lt;strong&gt;공유 자원을 가진 다중 사용자 단계&lt;/strong&gt;, 텍스트 유저 모드&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;4&lt;/strong&gt; : &lt;strong&gt;현재 사용되지 않음&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;5&lt;/strong&gt; : Level3 으로 기동 후에 그래픽 모드인 &lt;strong&gt;X-Windows 실행&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;6&lt;/strong&gt; : &lt;strong&gt;재부팅 단계&lt;/strong&gt;로 실행단계 3의 상태로 재부팅&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;디렉터리-구조&quot;&gt;디렉터리 구조&lt;/h2&gt;
&lt;p&gt;디렉터리는 운영체제의 파일 관리 구조로 사용자는 디렉터리를 만들어서 파일을 저장하고 사용할 수 있다. 디렉터리는 리눅스를 설치하면 기본적으로 생성되는 것이 있으며 해당 디렉터리는 그 용도가 정해져 있다&lt;/p&gt;

&lt;p&gt;리눅스 디렉터리는 &lt;strong&gt;계층형 파일 시스템&lt;/strong&gt;으로 이루어져 있으며 사용자별로 자신의 디렉터리를 생성하여 사용할 수 있다. 특히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bin&lt;/code&gt;은 &lt;strong&gt;기본적인 실행파일&lt;/strong&gt;을 가지고 있고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot&lt;/code&gt;는 &lt;strong&gt;리눅스 부트 프로그램인 LILO 파일&lt;/strong&gt;을 가지고 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;etc&lt;/code&gt; 디렉터리는 환경설정에 관련된 파일&lt;/strong&gt;을 가지고 있어서 사용자 패스워드 정보를 가지고 있는 &lt;strong&gt;passwd 파일, shadow 파일&lt;/strong&gt;과 프로토콜 및 서비스 정보를 보유를 &lt;strong&gt;protocol, services 파일&lt;/strong&gt; 등을 가지고 있다&lt;/p&gt;

&lt;p&gt;리눅스는 다중 사용자를 제공하고 있으므로 각 사용자별로 디렉터리를 생성한다. &lt;strong&gt;사용자 디렉터리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;home&lt;/code&gt; 디렉터리 하위&lt;/strong&gt;에 생성된다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;디렉터리 구조&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;/&lt;/td&gt;
      &lt;td&gt;루트 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/bin&lt;/td&gt;
      &lt;td&gt;기본적인 실행 명령&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/boot&lt;/td&gt;
      &lt;td&gt;LILO 등 부팅에 관련된 파일&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev&lt;/td&gt;
      &lt;td&gt;장치 파일 모음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/fd&lt;/td&gt;
      &lt;td&gt;플로디 디스크&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/hda&lt;/td&gt;
      &lt;td&gt;마스트 IDE 하드 디스크&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/sda&lt;/td&gt;
      &lt;td&gt;SCSI 및 SATA 하드 디스크&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/cdrom&lt;/td&gt;
      &lt;td&gt;CD ROM 드라이버&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/mouse&lt;/td&gt;
      &lt;td&gt;마우스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/hdb&lt;/td&gt;
      &lt;td&gt;슬레이브 IDE 하드 디스크&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/hd&lt;/td&gt;
      &lt;td&gt;하드 디스크&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/etc&lt;/td&gt;
      &lt;td&gt;시스템 설정 파일&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/home&lt;/td&gt;
      &lt;td&gt;사용자 홈 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/lib&lt;/td&gt;
      &lt;td&gt;C 라이브러리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/mnt&lt;/td&gt;
      &lt;td&gt;임시 마운트용 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc&lt;/td&gt;
      &lt;td&gt;시스템 정보를 가진 가상 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/buddyinfo&lt;/td&gt;
      &lt;td&gt;버디 할당자 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/cmdline&lt;/td&gt;
      &lt;td&gt;시스템 부팅 중 커널에 제출된 명령 내용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/cpuinfo&lt;/td&gt;
      &lt;td&gt;시스템 CPU 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/devices&lt;/td&gt;
      &lt;td&gt;디바이스들의 목록&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/diskstats&lt;/td&gt;
      &lt;td&gt;디스크의 상태 및 파티션 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/dma&lt;/td&gt;
      &lt;td&gt;DMA 채널&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/filesystems&lt;/td&gt;
      &lt;td&gt;파일 시스템의 목록&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/interrupts&lt;/td&gt;
      &lt;td&gt;인터럽트에 대한 통계&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/iomem&lt;/td&gt;
      &lt;td&gt;할당된 메모리 영역&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/ioport&lt;/td&gt;
      &lt;td&gt;입출력 포트 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/kallsyms&lt;/td&gt;
      &lt;td&gt;심볼들의 목록&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/loadavg&lt;/td&gt;
      &lt;td&gt;CPU 부하와 관련된 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/locks&lt;/td&gt;
      &lt;td&gt;잠금 파일&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/mdstat&lt;/td&gt;
      &lt;td&gt;RAID 시스템의 정보를 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/meminfo&lt;/td&gt;
      &lt;td&gt;시스템 메모리 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/modules&lt;/td&gt;
      &lt;td&gt;사용중인 모듈들&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/partitions&lt;/td&gt;
      &lt;td&gt;파티션 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/slabinfo&lt;/td&gt;
      &lt;td&gt;슬랩 할당기 통계 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/swaps&lt;/td&gt;
      &lt;td&gt;스왑 파티션에 대한 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/uptime&lt;/td&gt;
      &lt;td&gt;시스템이 부팅된 이후의 시간&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/root&lt;/td&gt;
      &lt;td&gt;루트 사용자의 홈 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/sbin&lt;/td&gt;
      &lt;td&gt;시스템 관리용 실행 파일&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/tmp&lt;/td&gt;
      &lt;td&gt;임시파일 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/usr&lt;/td&gt;
      &lt;td&gt;애플리케이션이 설치되는 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/var&lt;/td&gt;
      &lt;td&gt;시스템에서 운영되는 임시파일 및 로그파일&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Thu, 20 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-linux-boot/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-linux-boot/</guid>
        
        <category>정보보안기사</category>
        
        <category>Linux</category>
        
        
        <category>study</category>
        
      </item>
    
  </channel>
</rss>
