<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My LifeChronicle</title>
    <description>Be a Imagineer.</description>
    <link>https://many258.github.io/</link>
    <atom:link href="https://many258.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 07 May 2021 02:06:24 +0900</pubDate>
    <lastBuildDate>Fri, 07 May 2021 02:06:24 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>[전자계산기] 명령어 사이클</title>
        <description>&lt;h2 id=&quot;명령어의-수행&quot;&gt;명령어의 수행&lt;/h2&gt;
&lt;h3 id=&quot;순서&quot;&gt;순서&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;명령어 인출(Instruction Fetch)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;명령어 해독(Instruction Decoder)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오퍼랜드 인출(Operand Fetch)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;실행(Execute)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인터럽트 조사(Interrupt Search Into)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p class=&quot;notice--warning&quot;&gt;명령어 인출 과정에서 인터럽트가 발생하더라도 &lt;strong&gt;CPU는 인터럽트를 인지하지 못하고&lt;/strong&gt; 하나의 명령어 &lt;strong&gt;실행이 완전히 끝난 상태&lt;/strong&gt;에서 인터럽트의 발생 여부를 조사하여 인터럽트가 발생하였다는 것을 인지하게 되는 것이다&lt;/p&gt;

&lt;h3 id=&quot;수행-시간&quot;&gt;수행 시간&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Memory Read 또는 Write Cycle이 명령어 수행 시간에 지배적인 영향을 준다&lt;/li&gt;
  &lt;li&gt;수행 시간은 명령어 종류에 따라 약간씩 다르다&lt;/li&gt;
  &lt;li&gt;명령어 수행 시간은 여러 개의 Machine Cycle로 구성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;성능&quot;&gt;성능&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;$명령어의 성능 = \frac{인스트럭션 수행 시간}{인스터럭션 패치 시간 + 인스트럭션 준비 시간}$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p class=&quot;notice--success&quot;&gt;&lt;strong&gt;속도 단위&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;as&lt;/strong&gt;(아토초) : 10&lt;sup&gt;&lt;strong&gt;-18&lt;/strong&gt;&lt;/sup&gt; = 1/10&lt;sup&gt;&lt;strong&gt;18&lt;/strong&gt;&lt;/sup&gt;&lt;br /&gt;
&lt;strong&gt;fs&lt;/strong&gt;(펨토초) : 10&lt;sup&gt;&lt;strong&gt;-15&lt;/strong&gt;&lt;/sup&gt; = 1/10&lt;sup&gt;&lt;strong&gt;15&lt;/strong&gt;&lt;/sup&gt;&lt;br /&gt;
&lt;strong&gt;㎰&lt;/strong&gt;(피코초) : 10&lt;sup&gt;&lt;strong&gt;-12&lt;/strong&gt;&lt;/sup&gt; = 1/10&lt;sup&gt;&lt;strong&gt;12&lt;/strong&gt;&lt;/sup&gt;&lt;br /&gt;
&lt;strong&gt;㎱&lt;/strong&gt;(나노초) : 10&lt;sup&gt;&lt;strong&gt;-9&lt;/strong&gt;&lt;/sup&gt; = 1/10&lt;sup&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/sup&gt;&lt;br /&gt;
&lt;strong&gt;㎲&lt;/strong&gt;(마이크로초) : 10&lt;sup&gt;&lt;strong&gt;-6&lt;/strong&gt;&lt;/sup&gt; = 1/10&lt;sup&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/sup&gt;&lt;br /&gt;
&lt;strong&gt;㎳&lt;/strong&gt;(밀리초) : 10&lt;sup&gt;&lt;strong&gt;-3&lt;/strong&gt;&lt;/sup&gt; = 1/10&lt;sup&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;strong&gt;진동수 단위&lt;/strong&gt;(Hz)&lt;br /&gt;
KHz : 1초에 10&lt;sup&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/sup&gt;번 진동&lt;br /&gt;
MHz : 1초에 10&lt;sup&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/sup&gt;번 진동&lt;br /&gt;
GHz : 1초에 10&lt;sup&gt;&lt;strong&gt;9&lt;/strong&gt;&lt;/sup&gt;번 진동&lt;br /&gt;
THz : 1초에 10&lt;sup&gt;&lt;strong&gt;12&lt;/strong&gt;&lt;/sup&gt;번 진동&lt;/p&gt;

&lt;h2 id=&quot;마이크로-오퍼레이션&quot;&gt;마이크로 오퍼레이션&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;CPU에서 발생시키는 &lt;strong&gt;하나의 클록 펄스 동안 실행되는 기본 동작&lt;/strong&gt;을 의미&lt;/li&gt;
  &lt;li&gt;CPU에 있는 레지스터와 플래그의 &lt;strong&gt;상태 변환을 일으키게 하는 동작&lt;/strong&gt;을 의미&lt;/li&gt;
  &lt;li&gt;CPU에서 발생시키는 &lt;strong&gt;제어 신호에 따라&lt;/strong&gt; 마이크로 오퍼레이션이 &lt;strong&gt;순서적&lt;/strong&gt;으로 일어난다&lt;/li&gt;
  &lt;li&gt;명령어의 수행은 마이크로 오퍼레이션의 수행으로 이루어진다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;일반-형식&quot;&gt;일반 형식&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;단항&lt;/strong&gt; 마이크로 오퍼레이션&lt;br /&gt;
Rd &lt;strong&gt;←&lt;/strong&gt; F(R1)&lt;br /&gt;
&lt;br /&gt;
&lt;strong&gt;이항&lt;/strong&gt; 마이크로 오퍼레이션&lt;br /&gt;
Rd &lt;strong&gt;←&lt;/strong&gt; F(R1, R2)&lt;br /&gt;
&lt;sub&gt;Rd: 결과가 들어갈 레지스터&lt;br /&gt;
F: 처리기&lt;br /&gt;
R1, R2: 연산 대상체가 들어 있는 레지스터&lt;/sub&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;주요-동작&quot;&gt;주요 동작&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;MAR ← MBR(AD) : 기억 레지스터에 번지부 전송&lt;/li&gt;
  &lt;li&gt;IR ← MBR(OP) : 명령 레지스터에 명령 코드 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A ← CONSTANT : 레지스터 A에 상수 전송&lt;/li&gt;
  &lt;li&gt;A ← A + B : A와 B를 합하여 A에 기억&lt;/li&gt;
  &lt;li&gt;A ← A - B : A에서 B를 뺄셈하여 A에 기억&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A ← A｀: A 내용의 1의 보수&lt;/li&gt;
  &lt;li&gt;A ← A｀+ 1 : A 내용의 2의 보수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;F ← A ∧ B : A와 B의 논리곱&lt;/li&gt;
  &lt;li&gt;F ← A XOR B : A와 B의 베타적 논리합&lt;/li&gt;
  &lt;li&gt;F ← A ∨ B : A와 B의 논리합&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;마이크로-사이클-시간&quot;&gt;마이크로 사이클 시간&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;마이크로 사이클&lt;/strong&gt;은 &lt;strong&gt;하나의 오퍼레이션을 수행하는 과정&lt;/strong&gt;을 의미하며&lt;/p&gt;

&lt;p&gt;마이크로 사이클을 실행하는 시간을 마이크로 사이클 타임 또는 CPU Clock Time이라 한다&lt;/p&gt;

&lt;h3 id=&quot;동기-고정식synchronous-fixed&quot;&gt;동기 고정식(Synchronous Fixed)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여러 개의 마이크로 오퍼레이션 동작 중에서 &lt;strong&gt;마이크로 사이클 타임이 가장 긴 것을 선택&lt;/strong&gt;하여 CPU의 클록 주기로 사용하는 방식&lt;/li&gt;
  &lt;li&gt;CPU의 시간 이용이 &lt;strong&gt;비효율적&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;모든 마이크로 오퍼레이션 &lt;strong&gt;수행 시간이 유사&lt;/strong&gt;한 경우 사용&lt;/li&gt;
  &lt;li&gt;제어 장치의 &lt;strong&gt;구현이 간단&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;동기-가변식synchronous-variable&quot;&gt;동기 가변식(Synchronous Variable)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;마이크로 오퍼레이션 동작들을 마이크로 사이클 타임에 따라 &lt;strong&gt;몇 개의 군으로 분류&lt;/strong&gt;하여 &lt;strong&gt;군별로 CPU의 클록 주기를 따로따로 부여&lt;/strong&gt;하는 방식&lt;/li&gt;
  &lt;li&gt;마이크로 오퍼레이션 &lt;strong&gt;수행 시간의 차이가 현저할 때&lt;/strong&gt; 사용&lt;/li&gt;
  &lt;li&gt;클록 주기 시간은 &lt;strong&gt;정수배&lt;/strong&gt;가 될 수 있도록 해야 각 집합 간 서로 다른 사이클 타임의 동기를 맞추기 쉽고 제어 장치 설계가 쉬워진다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비동기식asynchronous&quot;&gt;비동기식(Asynchronous)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;모든 마이크로 오퍼레이션에 대해 &lt;strong&gt;서로 다른 마이크로 사이클 시간&lt;/strong&gt;을 부여하는 방식&lt;/li&gt;
  &lt;li&gt;하나의 오퍼레이션 동작이 끝나면 &lt;strong&gt;끝난 사실을 제어 장치에 알려 다음 오퍼레이션이 수행&lt;/strong&gt;되도록 하여야 하므로 &lt;strong&gt;제어 장치가 복잡&lt;/strong&gt;하게 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;메이저-상태major-state&quot;&gt;메이저 상태(Major State)&lt;/h2&gt;
&lt;p&gt;기억 장치의 주기 시간을 단위로 하여 해당 주기 동안에 &lt;strong&gt;기억 장치로 접근할 때 무엇을 위해서 접근하는지를 표시&lt;/strong&gt;하는 &lt;strong&gt;주 상태&lt;/strong&gt;와 시간에 관한 정보를 나타내는 시간 상태가 있다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;메이저 상태&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Major State&lt;/code&gt;)는 CPU가 무엇을 하고 있는가를 나타내는 상태로 Machine Cycle이라고도 한다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;시간 상태&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Timing State&lt;/code&gt;)는 메이저 상태에서 &lt;strong&gt;마이크로 오퍼레이션이 수행되는 시간을 나타내는 것&lt;/strong&gt;으로 &lt;strong&gt;타이밍 상태 계수기&lt;/strong&gt;를 이용하여 나타내며 하나의 마이크로 오퍼레이션이 수행될 때마다 &lt;strong&gt;하나씩 증가&lt;/strong&gt;시켜 나타낸다&lt;/p&gt;

&lt;h3 id=&quot;종류&quot;&gt;종류&lt;/h3&gt;
&lt;p&gt;메이저 상태는 주기억 장치에 무엇을 위해 접근하는지에 따라 인출, 간접, 실행, 인터럽트 4가지 상태가 존재하며, 이 상태는 F,R 플래그의 상태를 가지고 파악한다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;상태&lt;/th&gt;
      &lt;th&gt;F&lt;/th&gt;
      &lt;th&gt;R&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;인출&lt;/strong&gt; 주기&lt;br /&gt;(Fetch Cycle)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;간접&lt;/strong&gt; 주기&lt;br /&gt;(Indirect)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;실행&lt;/strong&gt; 주기&lt;br /&gt;(Execute)&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;인터럽트&lt;/strong&gt; 주기&lt;br /&gt;(Interrupt)&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;관계&quot;&gt;관계&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/instruction-cycle.png&quot; title=&quot;https://quickcse.wordpress.com/2018/09/10/micro-operations/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/instruction-cycle.png&quot; alt=&quot;&quot; title=&quot;메이저 사이클의 관계&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;인출 주기가 완료되면 해독 결과에 따라 &lt;strong&gt;직접 주소이면 바로 실행 주기로 진행&lt;/strong&gt;하고, &lt;strong&gt;간접 주소이면 간접 주기를 거쳐서&lt;/strong&gt; 실행 주기로 진행된다&lt;/p&gt;

&lt;p&gt;실행 주기에서는 인터럽트 발생 여부에 따라 &lt;strong&gt;인터럽트가 발생&lt;/strong&gt;했으면 &lt;strong&gt;인터럽트 주기&lt;/strong&gt;로 진행하고 그렇지 않으면 &lt;strong&gt;인출 주기로 진행&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;인터럽트 주기에서는 &lt;strong&gt;항상 인출 주기&lt;/strong&gt;로 진행&lt;/p&gt;

&lt;h2 id=&quot;메이저-사이클의-마이크로-오퍼레이션&quot;&gt;메이저 사이클의 마이크로 오퍼레이션&lt;/h2&gt;
&lt;h3 id=&quot;인출-주기fetch-cycle&quot;&gt;인출 주기(Fetch Cycle)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;명령어를 &lt;strong&gt;기억 장치에서 CPU로 읽어&lt;/strong&gt;오는 주기&lt;/li&gt;
  &lt;li&gt;명령어를 &lt;strong&gt;해독&lt;/strong&gt;하는 주기&lt;/li&gt;
  &lt;li&gt;명령어의 &lt;strong&gt;종류가 판단&lt;/strong&gt;되는 주기&lt;/li&gt;
  &lt;li&gt;PC가 하나 증가되어 다음 명령어를 지시하는 주기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-fetch-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-fetch-cycle.png&quot; alt=&quot;&quot; title=&quot;인출 주기 마이크로 오퍼레이션&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;간접-주기indirect-cycle&quot;&gt;간접 주기(Indirect Cycle)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;유효주소를 얻기 위하여 기억 장치에 한 번 더 접근하는 주기&lt;/li&gt;
  &lt;li&gt;오퍼랜드에 표현된 주소가 간접 주소인 경우에 수행되는 주기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-indirect-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-indirect-cycle.png&quot; alt=&quot;&quot; title=&quot;간접 주기 마이크로 오퍼레이션&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;실행-주기execute-cycle&quot;&gt;실행 주기(Execute Cycle)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;기억 장치로부터 실제 데이터를 읽어다가 연산 동작을 수행시키는 주기&lt;/li&gt;
  &lt;li&gt;다양한 형태의 명령어가 분기 처리되는 주기&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;add-마이크로-동작&quot;&gt;ADD 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ACC&lt;/strong&gt;에 있는 내용과 &lt;strong&gt;메모리&lt;/strong&gt;에 있는 &lt;strong&gt;내용을 더해서&lt;/strong&gt; 결과를 ACC에 넣어놓는 연산&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-add-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-add-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(ADD 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;and-마이크로-동작&quot;&gt;AND 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ACC&lt;/strong&gt;에 있는 내용과 &lt;strong&gt;메모리&lt;/strong&gt;에 있는 내용을 &lt;strong&gt;논리곱&lt;/strong&gt;(AND)하여 결과를 ACC에 넣어놓는 연산&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-and-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-and-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(AND 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;loadlda-마이크로-동작&quot;&gt;LOAD(LDA) 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ACC를 0으로 초기화&lt;/strong&gt;하고 이 초기화된 누산기와 메모리에 있는 내용을 더해서 결과를 ACC에 넣어놓게 되면 &lt;strong&gt;메모리에 있는 내용을 누산기로 이동시킨 효과&lt;/strong&gt;를 보게 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-load-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-load-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(LOAD 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;storesta-마이크로-동작&quot;&gt;STORE(STA) 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ACC에 있는 내용을 지정된 &lt;strong&gt;메모리에 저장&lt;/strong&gt;시키는 연산&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-store-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-store-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(STORE 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;bunjump-마이크로-동작&quot;&gt;BUN(JUMP) 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램의 수행 제어 순서를 &lt;strong&gt;지정된 유효 번지로 분기&lt;/strong&gt;시키는 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-jump-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-jump-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(JUMP 마이크로 오퍼레이션&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;bsabranch-and-save-return-address-마이크로-동작&quot;&gt;BSA(Branch and Save Return Address) 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;복귀 주소를 저장하고 &lt;strong&gt;서브 프로그램으로 분기&lt;/strong&gt;하기 위한 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-bsa-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-bsa-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(BSA 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;iszincrement-and-skip-if-zero-마이크로-동작&quot;&gt;ISZ(Increment and Skip if Zero) 마이크로 동작&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램의 수행 순서를 조건에 따라 결정하는 명령어&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-execute-isz-cycle.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-execute-isz-cycle.png&quot; alt=&quot;&quot; title=&quot;실행 주기(ISZ 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;인터럽트-주기interrupt-cycle&quot;&gt;인터럽트 주기(Interrupt Cycle)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;여러 가지 원인에 의해서 정상적으로 수행 과정을 계속할 수 없어 먼저 응급 조치를 취한 후에 계속 수행할 수 있도록 &lt;strong&gt;CPU의 현 상태를 보관하기 위해 기억 장치에 접근&lt;/strong&gt;하는 주기&lt;/li&gt;
  &lt;li&gt;명령어 수행 과정에서 인터럽트가 발생하더라도 반드시 해당 명령어가 완료된 상태에서 인터럽트를 처리하게 된다. 따라서 &lt;strong&gt;인터럽트 처리가 완료된 상태에서는 반드시 인출 주기로 진행&lt;/strong&gt;한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;pc값을-메모리의-0번지에-저장할-때&quot;&gt;PC값을 메모리의 0번지에 저장할 때&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-interrupt-cycle-store-memory.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-interrupt-cycle-store-memory.png&quot; alt=&quot;&quot; title=&quot;인터럽트 주기(PC값을 메모리의 0번지에 저장할 때 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;pc값을-스택에-저장할-때&quot;&gt;PC값을 스택에 저장할 때&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/micro-operation-interrupt-cycle-store-stack.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/micro-operation-interrupt-cycle-store-stack.png&quot; alt=&quot;&quot; title=&quot;인터럽트 주기(PC값을 스택에 저장할 때 마이크로 오퍼레이션)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-instruction-cycle/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-instruction-cycle/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 레지스터(Register)</title>
        <description>&lt;h2 id=&quot;레지스터register&quot;&gt;레지스터(Register)&lt;/h2&gt;
&lt;p&gt;주기억 장치보다 &lt;strong&gt;작은 개수의 주소 비트&lt;/strong&gt;를 가지고 기억된 정보를 신속하게 접근할 수 있는 기억 장소로 중앙 처리 장치 안에 &lt;strong&gt;임시 기억 장치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;중앙 처리 장치의 주소 선은 주소 레지스터(AR)와 연결되어 있고 데이터 선은 데이터 레지스터(DR)와 연결되어 있다. 따라서 &lt;strong&gt;메모리의 용량은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AR&lt;/code&gt;&lt;/strong&gt;과 관계가 있고 &lt;strong&gt;한 번에 엑세스되는 워드 크기는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DR&lt;/code&gt;&lt;/strong&gt;과 관계가 있다&lt;/p&gt;

&lt;h3 id=&quot;특수-전담-레지스터&quot;&gt;특수 전담 레지스터&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로그램 카운터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PC&lt;/code&gt;, Program Counter)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;로케이션 카운터(LC, Location Counter)라고도 한다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;다음 명령어의 주소 값을 기억&lt;/strong&gt;하고 있는 레지스터&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;명령어의 수행 순서&lt;/strong&gt;를 나타내는 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모리 번지 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAR&lt;/code&gt;, Memory Address Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;메모리에 접근하고자 할 때 &lt;strong&gt;접근하고자 하는 곳의 주소 값&lt;/strong&gt;을 기억하고 있는 레지스터&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;기억 장치의 용량&lt;/strong&gt;과 관계가 있는 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;기억 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MBR&lt;/code&gt;, Memory Buffer Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;주기억 장치에서 정보를 읽을 때 &lt;strong&gt;읽은 정보를 기억시키거나 주기억 장치에 정보를 기억&lt;/strong&gt;시키는 레지스터&lt;/li&gt;
      &lt;li&gt;기억 장치의 &lt;strong&gt;WORD 크기&lt;/strong&gt;와 관계가 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;명령 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IR&lt;/code&gt;, Instruction Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;현재 수행하고 있는 명령어를 기억&lt;/strong&gt;하는 레지스터&lt;/li&gt;
      &lt;li&gt;명령 레지스터에 있는 정보는 &lt;strong&gt;연산에 사용되지 않고&lt;/strong&gt; 명령 수행을 제어하기 위해 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-레지스터dr-data-register&quot;&gt;데이터 레지스터(DR, Data Register)&lt;/h3&gt;
&lt;p&gt;명령어 수행 시 수행에 &lt;strong&gt;필요한 데이터를 기억&lt;/strong&gt;시키는 레지스터로 &lt;strong&gt;기억 장치의 워드 크기&lt;/strong&gt;와 관계가 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;누산기(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACC&lt;/code&gt;, Accumulator)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산기능 수행 시 중심이 되는 데이터 레지스터로서 연산 장치에 연결되어 있다&lt;/li&gt;
      &lt;li&gt;연산시 연산에 사용되는 &lt;strong&gt;데이터 및 연산 결과를 임시적&lt;/strong&gt;으로 기억하는 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;기억 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MBR&lt;/code&gt;, Memory Buffer Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;주기억 장치에서 읽은 정보&lt;/strong&gt;나 저장시킬 정보를 임시적으로 기억시키는 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;범용 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GPR&lt;/code&gt;, General Purpose Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;함수 연산 기능을 수행하는 명령어&lt;/strong&gt;에서 사용할 수 있도록 설계된 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;주소-레지스터ar-address-register&quot;&gt;주소 레지스터(AR, Address Register)&lt;/h3&gt;
&lt;p&gt;주기억 장치에 접근하기 위한 주소의 일부 또는 전부를 기억시키는 레지스터로 기억 장치 용량과 관계가 있는 레지스터&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로그램 카운트(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PC&lt;/code&gt;, Program Counter)&lt;/strong&gt;
다음 명령어의 주소 값을 기억하고 있는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;메모리 번지 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAR&lt;/code&gt;, Memory Address Register)&lt;/strong&gt;
메모리에 접근하고자 할 때 접근하고자 하는 곳의 주소 값을 기억하고 있는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인덱스 레지스터(Index Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;주소 변환 및 계산에 필요한 수&lt;/strong&gt;를 기억&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;주소 수정에 필요한 주소값&lt;/strong&gt;을 기억&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;배열의 시작 주소&lt;/strong&gt;와 같은 &lt;strong&gt;반복 계수를 기억&lt;/strong&gt;시키는 용도로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;베이스 레지스터(Base Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;하나의 서브 프로그램 루틴 또는 데이터의 블록에 대하여 &lt;strong&gt;기준이 되는 주소를 기억&lt;/strong&gt;시키는 레지스터&lt;/li&gt;
      &lt;li&gt;프로그램을 &lt;strong&gt;재배치하는 경우 상대적인 변위 값&lt;/strong&gt;을 기억시키는데 사용&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;명령이 시작되는 최초의 번지&lt;/strong&gt;를 기억&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;상태-레지스터status-register&quot;&gt;상태 레지스터(Status Register)&lt;/h3&gt;
&lt;p&gt;프로그램 제어를 위한 상태 정보를 기억시키는데 필요한 레지스터를 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;플래그 레지스터(Flag Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;= &lt;strong&gt;프로그램 상태 워드 레지스터&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PSWR&lt;/code&gt;, Program Status Word Register)&lt;/li&gt;
      &lt;li&gt;프로그램의 수행이 진행되고 있을 때 매 &lt;strong&gt;순간마다 프로그램의 수행 상태를 포함&lt;/strong&gt;하는 &lt;strong&gt;중앙 처리 장치의 상태&lt;/strong&gt;를 나타내는 레지스터&lt;/li&gt;
      &lt;li&gt;명령의 실행 중에 어떤 상황(부호 체크, 오버플로 여부, 캐리 발생 여부 등) &lt;strong&gt;발생에 대한 사항들을 각각 1비트로 세트&lt;/strong&gt;시키는 레지스터를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;프로그램 상태 워드(PSW)&lt;/strong&gt;는 컴퓨터 &lt;strong&gt;시스템 내부에서 순간순간의 시스템 상태를 기록&lt;/strong&gt;하고 있는 특별한 워드로서 이 레지스터에 기억되어 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메이저 상태 레지스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MSR&lt;/code&gt;, Major State Register)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU가 어떤 수행을 하고 있는지를 나타내는 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 06 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-register/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-register/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 프로세서(Processor)</title>
        <description>&lt;h2 id=&quot;프로세서의-종류&quot;&gt;프로세서의 종류&lt;/h2&gt;
&lt;h3 id=&quot;cisccomplex-instruction-set-computer&quot;&gt;CISC(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Complex&lt;/code&gt; Instruction Set Computer)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;초창기 대부분의 컴퓨터 구조&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;마이크로프로그램 제어&lt;/strong&gt; 방식을 사용&lt;/li&gt;
  &lt;li&gt;명령어의 크기는 &lt;strong&gt;16~64비트&lt;/strong&gt;, &lt;strong&gt;명령어의 개수&lt;/strong&gt;는 120~305개 정도로 &lt;strong&gt;많은&lt;/strong&gt; 편이다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모리 참조 연산&lt;/strong&gt;을 많이 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;riscreduced-instruction-set-computer&quot;&gt;RISC(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reduced&lt;/code&gt; Instruction Set Computer)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;하드 와이어드 제어&lt;/strong&gt; 방식을 채택&lt;/li&gt;
  &lt;li&gt;중요 명령어들만 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ROM&lt;/code&gt;에 저장&lt;/strong&gt;시켜 처리하고 나머지 명령어들은 &lt;strong&gt;사용 시에 소프트웨어적&lt;/strong&gt;으로 처리&lt;/li&gt;
  &lt;li&gt;명령어의 길이는 &lt;strong&gt;32비트로 고정 크기&lt;/strong&gt;이고 &lt;strong&gt;명령어의 개수&lt;/strong&gt;도 100개 미만으로 &lt;strong&gt;적다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;레지스터 참조&lt;/strong&gt; 연산을 많이 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;수퍼-스칼라-risc&quot;&gt;수퍼 스칼라 RISC&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;파이프라인 병렬 처리가 가능&lt;/strong&gt;하게 한 구조&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RISC&lt;/code&gt;구조의 확장형&lt;/strong&gt;으로 명령어의 효율적인 처리를 위해 고안된 구조&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vliwvery-long-instruction-word&quot;&gt;VLIW(Very Long Instruction Word)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;수평 마이크로 명령 형식&lt;/strong&gt;을 사용하므로 &lt;strong&gt;명령어의 해독이 필요&lt;/strong&gt;없으며, 비트 하나가 &lt;strong&gt;하나의 명령&lt;/strong&gt;을 의미&lt;/li&gt;
  &lt;li&gt;하나의 &lt;strong&gt;명령어의 길이가&lt;/strong&gt; 수백 비트(128~512Bit)로 &lt;strong&gt;크다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;마이크로프로세서의-구성-방법&quot;&gt;마이크로프로세서의 구성 방법&lt;/h2&gt;
&lt;h3 id=&quot;비트-슬라이스-마이크로프로세서bit-sliced-microprocessor&quot;&gt;비트 슬라이스 마이크로프로세서(Bit Sliced Microprocessor)&lt;/h3&gt;
&lt;p&gt;Processor Unit, Micro-Program Sequencer, Control Memory 등을 &lt;strong&gt;각각 다른 IC에&lt;/strong&gt; 설계한 마이크로프로세서.&lt;/p&gt;

&lt;p&gt;이는 주어진 특성에 맞게 동적으로 &lt;strong&gt;재구성이 가능&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;단일-칩-마이크로-프로세서one-chip-microprocessor&quot;&gt;단일 칩 마이크로 프로세서(One Chip Microprocessor)&lt;/h3&gt;
&lt;p&gt;Processor Unit, Micro-Program Sequencer, Control Memory가 &lt;strong&gt;하나의 IC&lt;/strong&gt;로 구성된 프로세서를 의미.&lt;/p&gt;

&lt;p&gt;1개의 칩 안에 모든 기능을 집적한 고정된 형태를 가지므로 &lt;strong&gt;워드 길이, 명령 집합 등이 변경될 수 없다&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;중앙-처리-장치cpu&quot;&gt;중앙 처리 장치(CPU)&lt;/h2&gt;
&lt;h3 id=&quot;cpu의-구분&quot;&gt;CPU의 구분&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;스택 구조 CPU&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상체나 결과를 &lt;strong&gt;스택&lt;/strong&gt;에 넣어두고 운용하는 CPU&lt;/li&gt;
      &lt;li&gt;수식을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Postfix&lt;/code&gt; 표기법으로 변환 후, &lt;strong&gt;0-주소 명령어 형식&lt;/strong&gt;을 사용하여 연산&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단일 누산기 구조 CPU&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상체나 결과를 &lt;strong&gt;누산기&lt;/strong&gt;(Accumulator)에 넣고 운용하는 CPU&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;1-주소 명령어 형식&lt;/strong&gt;을 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;범용 레지스터 구조 CPU&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상체나 결과를 &lt;strong&gt;레지스터나 메모리&lt;/strong&gt;에 넣어두고 운용하는 CPU&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;2-주소 명령어 형식&lt;/strong&gt;을 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cpu의-구성&quot;&gt;CPU의 구성&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/cpu-architecture.png&quot; title=&quot;https://www.geeksforgeeks.org/last-minute-notes-computer-organization/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/cpu-architecture.png&quot; alt=&quot;&quot; title=&quot;CPU의 구성&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;연산 장치(ALU, Arithmetic and Logic Unit)&lt;/strong&gt;&lt;br /&gt;
산술 연산 및 논리 연산 등을 수행하는 장치&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;가산기&lt;/li&gt;
      &lt;li&gt;누산기&lt;/li&gt;
      &lt;li&gt;자리 올림 플립플롭&lt;/li&gt;
      &lt;li&gt;오버플로 체크 플립플롭&lt;/li&gt;
      &lt;li&gt;보수기 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제어 장치(Control Unit)&lt;/strong&gt;&lt;br /&gt;
주기억 장치에 기억되어 있는 명령어를 차례로 인출하여 해독하고, 해독한 결과에 따라 필요한 제어 신호를 각 장치에 보내는 역할을 수행&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;PC(Program Counter)&lt;/li&gt;
      &lt;li&gt;IR(Instruction Register)&lt;/li&gt;
      &lt;li&gt;명령 해독기(Instruction Decoder)&lt;/li&gt;
      &lt;li&gt;MBR(Memory Buffer Register)&lt;/li&gt;
      &lt;li&gt;MAR(Memory Address Register)&lt;/li&gt;
      &lt;li&gt;순서 제어기&lt;/li&gt;
      &lt;li&gt;주소 처리기&lt;/li&gt;
      &lt;li&gt;신호 방생 장치 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;메모리(Memory)&lt;/strong&gt;&lt;br /&gt;
입력된 자료, 상태 자료, 중간 계산 자료, 최종 결과 자료 등을 보관하는 위치&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;버스bus&quot;&gt;버스(Bus)&lt;/h3&gt;
&lt;p&gt;CPU에서 각 부분의 정보 교환은 어드레스 버스와 데이터 버스를 통하여 이루어진다. 정보 교환을 위해 버스를 사용하는 이유는 결선의 수를 줄일 수 있는 최선의 방법이기 때문이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버스의 형태
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;주소 버스(Address Bus)&lt;/strong&gt;
메모리의 특정 위치를 지정하기 위한 &lt;strong&gt;단방향&lt;/strong&gt; 신호 회선으로 신호선의 수는 &lt;strong&gt;메모리의 최대 용량&lt;/strong&gt;과 관계가 있다&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;주소 버스선의 수가 &lt;strong&gt;N&lt;/strong&gt;개 일 때, 메모리 용량은 &lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;데이터 버스(Data Bus)&lt;/strong&gt;
CPU와 주기억 장치 사이에서 데이터를 주고받기 위한 &lt;strong&gt;양방향&lt;/strong&gt; 회선으로 &lt;strong&gt;CPU가 한 번에 처리할 수 있는 Bit 수&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;제어 버스(Control Bus)&lt;/strong&gt;
CPU나 메모리 혹은 입출력 장치에 어떤 동작을 취하게 하기 위해 &lt;strong&gt;제어 신호를 전달&lt;/strong&gt;하는 &lt;strong&gt;단방향&lt;/strong&gt; 신호 회선&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cpu의-기능&quot;&gt;CPU의 기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;연산 기능&lt;/strong&gt; : CPU에 있는 ALU가 수행하는 기능으로 데이터에 대해 산술 처리나 논리 처리를 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;제어 기능&lt;/strong&gt; : CPU에 있는 제어 장치가 수행하는 기능으로 제어 신호를 발생시켜 하드웨어 요소들을 통제&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;기억 기능&lt;/strong&gt; : 정보를 일시적으로 저장하기 위한 &lt;strong&gt;레지스터&lt;/strong&gt;와 CPU나 프로그램의 상태를 나타내는데 쓰이는 &lt;strong&gt;플래그&lt;/strong&gt;들에 의해 수행되는 기능&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전달 기능&lt;/strong&gt; : 각 장치가 버스로 연결되어 정보를 주고받는 기능&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 05 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-processor/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-processor/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 주소 지정 방식</title>
        <description>&lt;h2 id=&quot;주소-설계-시-고려-사항&quot;&gt;주소 설계 시 고려 사항&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주소의 효율적 표현&lt;/strong&gt;&lt;br /&gt;
필요한 정보를 읽거나 저장하기 위해서는 읽을 위치나 저장 위치를 지정해 주어야 하는데 이 위치를 표현하기 위한 가장 작은 비트 수, &lt;strong&gt;가장 빠른 액세스를 가능하도록 하는 방법이나 절차&lt;/strong&gt;를 마련하는 것을 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;사용의 편리성&lt;/strong&gt;&lt;br /&gt;
사용자들이 주소를 사용하는 방법이 편리해야 한다는 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주소 공간과 기억 공간을 독립&lt;/strong&gt;&lt;br /&gt;
여러 개의 프로그램이 데이터를 사용하는데 있어 &lt;strong&gt;프로그램의 변경 없이&lt;/strong&gt; 서로 다른 시간에 데이터에 &lt;strong&gt;접근&lt;/strong&gt;할 수 있도록 &lt;strong&gt;재배치가 가능&lt;/strong&gt;하도록 하는 것을 의미&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주소-표현-방식&quot;&gt;주소 표현 방식&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;완전 주소&lt;/strong&gt; : 데이터가 기억된 장소를 직접 사상시킬 수 잇는 주소&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;약식 주소&lt;/strong&gt; : 주소의 일부분을 생략한 주소, 계산에 의한 주소 지정, 레지스터 이용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;생략 주소&lt;/strong&gt; : 주소를 구체적으로 지정하지 않는 경우, 스택, 누산기 지정시&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 자신&lt;/strong&gt; : 주소 표현 위치에 실제 데이터를 위치시키는 경우, 많은 비트 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주소-지정-방식&quot;&gt;주소 지정 방식&lt;/h2&gt;
&lt;h3 id=&quot;즉시-주소immediate-address&quot;&gt;즉시 주소(Immediate Address)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-immediate.png&quot; title=&quot;https://www.gatevidyalay.com/addressing-modes/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-immediate.png&quot; alt=&quot;&quot; title=&quot;즉시 주소 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;명령어의 주소 부분에 실제 데이터가 들어 있는 방식&lt;/strong&gt;으로 명령어 수행이 즉각적으로 이루어진다&lt;/li&gt;
  &lt;li&gt;실제 데이터를 가져오기 위해 &lt;strong&gt;메모리를 참조할 필요가 없다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;명령어에 실제 데이터를 포함하고 있으므로 &lt;strong&gt;수행 속도는 빠르지만&lt;/strong&gt; Operand에 실제 데이터를 넣기 위해서는 &lt;strong&gt;명령어 길이에 제약&lt;/strong&gt;이 따를 수 밖에 없다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;직접-주소direct-address&quot;&gt;직접 주소(Direct Address)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-direct.png&quot; title=&quot;https://www.studytonight.com/computer-architecture/addressingmodes-instructioncycle&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-direct.png&quot; alt=&quot;&quot; title=&quot;직접 주소 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어의 &lt;strong&gt;주소(Operand) 부분&lt;/strong&gt;에 데이터를 기억하고 있는 &lt;strong&gt;기억 장소의 주소를 지정&lt;/strong&gt;하는 방식&lt;/li&gt;
  &lt;li&gt;실제 데이터를 가져오기 위해 메모리는 &lt;strong&gt;한 번만 참조&lt;/strong&gt;하면 된다&lt;/li&gt;
  &lt;li&gt;단순한 대신에 &lt;strong&gt;융통성이 조금 떨어진다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;간접-주소indirect-address&quot;&gt;간접 주소(Indirect Address)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-indirect.png&quot; title=&quot;https://www.studytonight.com/computer-architecture/addressingmodes-instructioncycle&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-indirect.png&quot; alt=&quot;&quot; title=&quot;간접 주소 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어의 주소 부분이 지정하는 &lt;strong&gt;메모리 번지에 실제 데이터의 주소&lt;/strong&gt;가 저장되는 방식&lt;/li&gt;
  &lt;li&gt;실제 데이터를 가져오기 위해 메모리를 &lt;strong&gt;두 번 이상 참조&lt;/strong&gt;해야 한다&lt;/li&gt;
  &lt;li&gt;명령어의 길이가 짧고 제한되어 있어도 이것을 이용하여 &lt;strong&gt;긴 주소를 찾아갈 수 있기&lt;/strong&gt; 때문에 주소 지정에 많은 &lt;strong&gt;융통성이 있다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;계산에-의한-주소calculate-address&quot;&gt;계산에 의한 주소(Calculate Address)&lt;/h3&gt;
&lt;p&gt;오퍼랜드 부분에 있는 주소 값에 임의의 상수 값이나 레지스터에 있는 값을 더해서 유효 주소를 결정하는 방법&lt;/p&gt;

&lt;h4 id=&quot;인덱스-주소-지정index-register-address&quot;&gt;인덱스 주소 지정(Index Register Address)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-indexed.png&quot; title=&quot;https://www.gatevidyalay.com/addressing-modes/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-indexed.png&quot; alt=&quot;&quot; title=&quot;인덱스 주소 지정 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어 &lt;strong&gt;오퍼랜드 부분에 있는 주소 값&lt;/strong&gt;과 &lt;strong&gt;인덱스 레지스터&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IR&lt;/code&gt;, Index Register)에 들어 있는 값을 더해서 실제 데이터가 들어 있는 기억 장소의 위치를 지정하게 하는 방식&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;배열 엑세스 방식&lt;/strong&gt;에 주로 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;상대-주소relative-address&quot;&gt;상대 주소(Relative Address)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-relative.png&quot; title=&quot;https://www.gatevidyalay.com/addressing-modes/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-relative.png&quot; alt=&quot;&quot; title=&quot;상대 주소 지정 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어의 &lt;strong&gt;오퍼랜드 부분에 있는 주소 값&lt;/strong&gt;과 &lt;strong&gt;프로그램 카운터&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PC&lt;/code&gt;, Program Counter)에 들어 있는 값을 더해서 실제 데이터가 들어 있는 기억 장소의 위치를 지정하게 하는 방식&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 영역의 배치&lt;/strong&gt;와 &lt;strong&gt;프로그램 영역의 배치&lt;/strong&gt;가 &lt;strong&gt;유사한 경우&lt;/strong&gt;에 주로 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;분기 명령&lt;/strong&gt;에 많이 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;기준-주소-지정base-register-address&quot;&gt;기준 주소 지정(Base Register Address)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-base-register.png&quot; title=&quot;https://www.gatevidyalay.com/addressing-modes/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-base-register.png&quot; alt=&quot;&quot; title=&quot;기준 주소 지정 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어의 &lt;strong&gt;오퍼랜드 부분에 있는 주소 값&lt;/strong&gt;과 &lt;strong&gt;베이스 레지스터&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Base Register&lt;/code&gt;)에 들어 있는 값을 더해서 실제 데이터가 들어 있는 기억 장소의 위치를 지정하게 하는 방식&lt;/li&gt;
  &lt;li&gt;프로그램의 &lt;strong&gt;재배치&lt;/strong&gt;를 하는 경우에 상&lt;strong&gt;대적인 변위 지정만으로 해당 위치를 지정하기 위해&lt;/strong&gt; 많이 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다중 프로그래밍 기법&lt;/strong&gt;에서 주로 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;묵시적-주소implied-address&quot;&gt;묵시적 주소(Implied Address)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;0-주소 명령어나 1-주소 명령어 형식&lt;/strong&gt;&lt;a href=&quot;https://many258.github.io/study/electronic-calculator-instruction/#%ED%94%BC%EC%97%B0%EC%82%B0%EC%9E%90operand-address-%EA%B0%9C%EC%88%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B5%AC%EB%B6%84&quot; class=&quot;btn btn--info&quot;&gt;포스트 이동하기&lt;/a&gt;에서 스택이나 누산기의 위치를 지정할 때는 명시적으로 지정하는 것이 아니라 &lt;strong&gt;묵시적으로 가리키게 되는데&lt;/strong&gt;, 이 경우를 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;레지스터-주소register-address&quot;&gt;레지스터 주소(Register Address)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;명령어의 오퍼랜드에 레지스터의 위치를 지정하는 방식
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;레지스터 직접 모드&lt;/strong&gt;(Register Direct Mode)&lt;br /&gt;
레지스터에 실제 데이터가 있는 방식&lt;/p&gt;

        &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-register-direct.png&quot; title=&quot;https://www.gatevidyalay.com/addressing-modes/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-register-direct.png&quot; alt=&quot;&quot; title=&quot;레지스터 직접 주소 지정 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;레지스터 간접 모드&lt;/strong&gt;(Register Indirect Mode)&lt;br /&gt;
레지스터에 실제 데이터가 있는 기억 장소의 주소가 들어있는 방식&lt;/p&gt;

        &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-mode-register-indirect.png&quot; title=&quot;https://www.gatevidyalay.com/addressing-modes/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-mode-register-indirect.png&quot; alt=&quot;&quot; title=&quot;레지스터 간접 주소 지정 방식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주소-지정-방식-속도-비교&quot;&gt;주소 지정 방식 속도 비교&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/addressing-modes-speed.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/addressing-modes-speed.png&quot; alt=&quot;&quot; title=&quot;주소 지정 방식 속도 비교&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;입출력-장치의-주소-지정-방식&quot;&gt;입출력 장치의 주소 지정 방식&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;주소 지정 방식&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
      &lt;th&gt;장점&lt;/th&gt;
      &lt;th&gt;단점&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;기억 장치 사상 방식&lt;br /&gt;(Memory-Mapped)&lt;/td&gt;
      &lt;td&gt;입출력 장치와 주기억 장치가 &lt;strong&gt;하나의 주소 공간을 공유&lt;/strong&gt;해서 사용하는 방식&lt;/td&gt;
      &lt;td&gt;구조가 쉽고 관리하기 쉽다&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;주소가 한정&lt;/strong&gt;되어 있어 주기억 장치 확장일 때 문제가 있다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;분리형 입출력 방식&lt;br /&gt;(I/O Mapped)&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;입출력 주소와 기억 장치 주소가 각각 따로 존재&lt;/strong&gt;하는 방식&lt;/td&gt;
      &lt;td&gt;기억 장치 용량이 늘어나기 때문에 &lt;strong&gt;더 큰 프로그램 수행이 가능&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;기억 장치 주소와 입출력 주소를 구분하기 위해서 명령어를 사용해야 한다. 명령어가 늘어나면 제어하는 장치도 늘어나야 되서 &lt;strong&gt;하드웨어(CPU)가 복잡&lt;/strong&gt;해진다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Wed, 05 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-addressing-modes/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-addressing-modes/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 명령어</title>
        <description>&lt;h2 id=&quot;명령어instruction&quot;&gt;명령어(Instruction)&lt;/h2&gt;
&lt;h3 id=&quot;명령어의-구조&quot;&gt;명령어의 구조&lt;/h3&gt;
&lt;p&gt;명령어는 여러 동작을 실행하는데 필요한 정보를 가지고 있으며, 모든 컴퓨터에서 기본적으로 수행될 연산자와 그 연산에 사용할 대상체로 구성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;연산자(Operation, Op-Code)&lt;/strong&gt;&lt;br /&gt;
컴퓨터가 행하는 동작을 기호화해서 나타낸 정보로 연산자의 종류, 명령어 형식, 자료 종류 등의 정보를 나타내며, 명령어의 개수를 몇 개 사용할 것인지에 따라 사용 비트 수가 결정된다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Op-Code가 &lt;strong&gt;N&lt;/strong&gt;비트이면 생성될 수 있는 명령어의 개수는 &lt;strong&gt;2&lt;/strong&gt;&lt;sup&gt;&lt;strong&gt;N&lt;/strong&gt;&lt;/sup&gt;개&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;모드(Mod)&lt;/strong&gt;&lt;br /&gt;
대상체를 지정하는 방법으로 보통 &lt;strong&gt;직접 주소&lt;/strong&gt;와 &lt;strong&gt;간접 주소&lt;/strong&gt;로 구분&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주소(Address)&lt;/strong&gt;&lt;br /&gt;
처리할 정보 또는 처리된 정보를 기억시킬 곳을 나타내는 것으로 레지스터 번호나 메모리 주소를 나타내게 되는데, 메모리의 주소인 경우는 메모리 용량과 관계가 있다&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;어드레스 필드가 &lt;strong&gt;N&lt;/strong&gt;비트로 구성되어 있다고 할 때, 메모리 용량은 &lt;strong&gt;2&lt;/strong&gt;&lt;sup&gt;&lt;strong&gt;N&lt;/strong&gt;&lt;/sup&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p class=&quot;notice--info&quot;&gt;명렁어 세트의 &lt;strong&gt;효율성을 높이기 위한&lt;/strong&gt; 고려사항&lt;br /&gt;
&lt;br /&gt;
기억 공간, 사용 빈도, 함수 연산 기능 대 기타 연산 기능의 비율, 주기억 장치의 밴드폭 이용, 주소 지정 방식&lt;/p&gt;

    &lt;p class=&quot;notice--info&quot;&gt;명렁어 &lt;strong&gt;설계의&lt;/strong&gt; 고려사항&lt;br /&gt;
&lt;br /&gt;
어떤 종류의 연산자를 사용할 것인가?(연산자의 수 및 종류)&lt;br /&gt;
자료는 어떻게 지정할 것인가?(주소 지정 방식)&lt;br /&gt;
어떤 방식으로 연산자와 자료를 구조화할 것인가?(데이터 구조, Word 크기)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;연산자의-기능&quot;&gt;연산자의 기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;함수 연산 기능(Functional)&lt;/strong&gt;&lt;br /&gt;
산술적 연산과 논리적 연산을 수행하는 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;전달 기능(Transfer)&lt;/strong&gt;&lt;br /&gt;
버스 라인을 통해 레지스터 사이의 정보 이동 및 CPU와 주기억 장치의 정보를 이동시키는 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제어 기능(Control)&lt;/strong&gt;&lt;br /&gt;
제어 장치에 의해 명령어를 해독하여 명령어의 수행 순서를 제어하거나 연산 장치의 제어점 제어 기능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;입출력 기능(I/O)&lt;/strong&gt;&lt;br /&gt;
주기억 장치에 기억된 연산 결과를 출력 장치로 이동시키거나 입력 장치에 있는 데이터를 주기억 장치로 이동시키는 기능&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;명령어의-종류&quot;&gt;명령어의 종류&lt;/h3&gt;
&lt;h4 id=&quot;데이터-처리-명령어&quot;&gt;데이터 처리 명령어&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;산술 연산&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;ADD&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SUB&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;MUL&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;DIV&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;INC&lt;/strong&gt; : 1 증가시키는 명령&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;DEC&lt;/strong&gt; : 1 감소시키는 명령&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;논리 연산&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;AND&lt;/strong&gt; : 특정 문자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삭제&lt;/code&gt; 시 사용&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;OR&lt;/strong&gt; : 특정 문자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삽입&lt;/code&gt; 시 사용&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;XOR&lt;/strong&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비교&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;반전&lt;/code&gt; 시 사용&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;COMPLEMENT&lt;/strong&gt; : 1의 보수를 구할 때 사용&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;CLEAR&lt;/strong&gt; : 모든 내용을 0으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리셋&lt;/code&gt;할 때 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시프트 연산&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;산술 Shift&lt;/strong&gt; : 2로 곱하거나 나누기를 하기 위한 오른쪽이나 왼쪽으로의 이동 명령&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;논리 Shif&lt;/strong&gt;t : 자료를 오른쪽이나 왼쪽으로 이동시키기 위한 명령&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Rotate&lt;/strong&gt; : 문자의 위치 변환을 위한 이동 명령(ROL, ROR)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;데이터-전송-명령어&quot;&gt;데이터 전송 명령어&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;LOAD&lt;/strong&gt; : 메모리로부터 &lt;strong&gt;CPU의 레지스터로 자료를 가져오는&lt;/strong&gt; 명령&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;STORE&lt;/strong&gt; : CPU의 레지스터에 있는 자료를 &lt;strong&gt;메모리에 기억&lt;/strong&gt;시키는 명령&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MOVE&lt;/strong&gt; : 레지스터에서 레지스터로 데이터를 전달하는 명령&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PUSH&lt;/strong&gt;, &lt;strong&gt;POP&lt;/strong&gt; : 스택에 데이터를 입출력하는 명령&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;INPUT&lt;/strong&gt; : 입력 장치에 있는 데이터를 메모리로 전달&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OUTPUT&lt;/strong&gt; : 메모리에 있는 데이터를 출력 장치로 전달&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;데이터-제어-명령어&quot;&gt;데이터 제어 명령어&lt;/h4&gt;
&lt;p&gt;모든 명령어들이 상황에 맞게 적절히 수행될 수 있도록 조작을 가하는 명령어&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;JUMP&lt;/strong&gt; : 원하는 곳으로 무조건 분기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SKIP&lt;/strong&gt; : 다음 명령어를 건너뛰고 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SMA&lt;/strong&gt; : ACC가 0보다 작을 때 SKIP&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SZA&lt;/strong&gt; : ACC가 0과 같을 때 SKIP&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SZC&lt;/strong&gt; : C가 0과 같을 때 SKIP&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ISZ&lt;/strong&gt; : 1 증가하여 0과 같으면 SKIP&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RETI&lt;/strong&gt; : 인터럽트로부터 &lt;strong&gt;복귀&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CALL&lt;/strong&gt; : 서브 프로그램의 &lt;strong&gt;호출&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RETURN&lt;/strong&gt; : 서브 프로그램에서 &lt;strong&gt;메인 프로그램으로 복귀&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HALT&lt;/strong&gt; : 컴퓨터의 동작을 &lt;strong&gt;일시적으로 정지&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기타-명령&quot;&gt;기타 명령&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;리커션(Recursion)&lt;/strong&gt;&lt;br /&gt;
자기가 자신을 호출하는 경우로 되돌아올 복귀 주소를 스택에 PUSH하고 다시 자신을 실행한다. 잘못하면 무한 루프에 빠질 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;반복(Iteration)&lt;/strong&gt;&lt;br /&gt;
주어진 자료를 가지고 처음에 실시된 계산은 정확한 정보를 나타내 주지 못하므로 그 결과를 가지고 처음의 자료를 다시 수정하여 계산하는 방법을 반복적으로 행하는 것으로 루틴 내부에서 자료를 얻어야 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;매크로(Macro)&lt;/strong&gt;&lt;br /&gt;
반복되는 일련의 루틴을 별도로 작성해 놓은 측면에서 부 프로그램과 유사하다. 자주 사용하는 여러 개의 명령어를 묶어서 하나의 명령어로 만든 것이나 컴파일 시는 원래의 명령어로 대치되기 때문에 인수의 형은 신경쓸 필요가 없다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;부 프로그램(Sub Program)&lt;/strong&gt;&lt;br /&gt;
CALL 문으로 호출해 사용하는 반면 매크로의 경우는 본문 자체에 삽입되어 사용&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기타-프로그램&quot;&gt;기타 프로그램&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;연계 편집기(Linkage Editor)&lt;/strong&gt;&lt;br /&gt;
목적프로그램을 실행 가능한 로드 모듈로 변환하는 시스템 서비스 프로그램&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;기계어&lt;/strong&gt;&lt;br /&gt;
컴퓨터가 직접 이해하고 수행할 수 있는 언어로 수행 시간이 신속하나 프로그램 과정이 불편하고 언어의 호환성이 없다는 단점을 가지고 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;고급 언어&lt;/strong&gt;&lt;br /&gt;
기계어와는 달리 프로그래머가 익숙한 표현 형식을 사용하도록 하는 프로그래밍 언어로 하드웨어에 상관없이 컴파일러로 분역되어 하드웨어와 호환되도록 한 언어&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;번역 프로그램&lt;/strong&gt; &lt;a href=&quot;https://many258.github.io/study/os-system-software/&quot; class=&quot;btn btn--info&quot;&gt;포스트 이동하기&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;디버깅(Debugging)&lt;/strong&gt;&lt;br /&gt;
트레이서나 덤프등을 이용하여 프로그램의 오류를 발견하고 그 원인을 밝히는 작업을 의미&lt;br /&gt;
&lt;br /&gt;
&lt;strong&gt;트레이서(Tracer)&lt;/strong&gt; : 프로그램의 실행 과정을 출력하는 프로그램&lt;br /&gt;
&lt;strong&gt;덤프(Dump)&lt;/strong&gt; : 주기억장치의 내용을 그대로 화면이나 프린터 등에 출력&lt;/p&gt;

&lt;h3 id=&quot;명령어의-형식&quot;&gt;명령어의 형식&lt;/h3&gt;
&lt;h4 id=&quot;피연산자operand-address-개수에-따른-구분&quot;&gt;피연산자(Operand Address) 개수에 따른 구분&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;0-주소 명령어 형식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;오퍼레이션 부분&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;만&lt;/code&gt; 있고 &lt;strong&gt;오퍼랜드 부분인 주소가 없는 명령어 형식&lt;/strong&gt;을 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;스택(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt;) 구조 컴퓨터&lt;/strong&gt;에서 사용하는 명령어 형식&lt;/li&gt;
      &lt;li&gt;모든 연산은 스택상에 있는 두 값을 묵시적으로 지정하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POP&lt;/code&gt;해서 연산을 수행하고 결과를 다시 스택상에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUSH&lt;/code&gt;하기 때문에 &lt;strong&gt;원래의 데이터는 모두 잃어버리게 된다&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/0-address-instruction-format.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/0-address-instruction-format.png&quot; alt=&quot;&quot; title=&quot;0-주소 명령어 형식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;1-주소 명령어 형식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;오퍼레이션 부분과 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;개의 오퍼랜드 부분&lt;/strong&gt;으로 구성된 명령어 형식을 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;누산기(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACCumulator&lt;/code&gt;) 구조 컴퓨터&lt;/strong&gt;에서 사용하는 명령어 형식&lt;/li&gt;
      &lt;li&gt;연산 시 두 개의 자료 중 하나는 묵시적으로 누산기를 지정하여 연산하고, &lt;strong&gt;연산 결과 역시 누산기에 저장하는 방식&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/1-address-instruction-format.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/1-address-instruction-format.png&quot; alt=&quot;&quot; title=&quot;1-주소 명령어 형식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;2-주소 명령어 형식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;오퍼레이션 부분과 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;개의 오퍼랜드 부분&lt;/strong&gt;으로 구성된 명령어 형식을 의미&lt;/li&gt;
      &lt;li&gt;연산 시 두 개의 자료는 오퍼랜드가 지정한 2개의 자료를 대상으로 연산하고, 연산 결과는 주로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Operand-1&lt;/code&gt;에 저장&lt;/li&gt;
      &lt;li&gt;연산 후 결과가 Operand-1에 저장되므로 &lt;strong&gt;Operand-1의 위치에 있던 내용은 잃어버리게 된다&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;계산 결과를 시험할 필요가 있을 때 &lt;strong&gt;계산 결과가 기억 장치에 기억될 뿐 아니라 중앙 처리 장치에도 남아&lt;/strong&gt; 있어서 중앙 처리 장치 내에서 직접 시험이 가능&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/2-address-instruction-format.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/2-address-instruction-format.png&quot; alt=&quot;&quot; title=&quot;2-주소 명령어 형식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;3-주소 명령어 형식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;오퍼레이션 부분과 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt;개의 오퍼랜드 부분&lt;/strong&gt;으로 구성된 명령어의 형식을 의미&lt;/li&gt;
      &lt;li&gt;연산 시 두 개의 자료는 Operand-1과 Operand-2에서 지정된 2개의 자료를 대상으로 연산하고, &lt;strong&gt;연산 결과는&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; Operand-3&lt;/code&gt;에 저장&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;연산 후 결과는 &lt;strong&gt;Operand-3 또는 Operand-1에 저장&lt;/strong&gt;되므로 &lt;strong&gt;원래의 내용은 모두 보존할 수 있다&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;명령어의 길이가 길다&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/3-address-instruction-format.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/3-address-instruction-format.png&quot; alt=&quot;&quot; title=&quot;3-주소 명령어 형식&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;피연산자-위치에-따른-구분&quot;&gt;피연산자 위치에 따른 구분&lt;/h4&gt;
&lt;p&gt;연산 대상이 되는 자료를 어디에 보관하는가에 따라 분류하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;스택 명령어(SI, Stack Instruction)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상이 되는 자료가 &lt;strong&gt;스택&lt;/strong&gt;에 있고, 결과 또한 스택에 저장되는 경우&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;0-주소 명령어 형식&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;누산기 명령어(AI, Accumulator Instruction)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상이 되는 자료의 일부 도는 전부가 &lt;strong&gt;누산기&lt;/strong&gt;에 있고, 결과 또한 누산기에 저장되는 경우&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;1-주소 명령어 형식&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;레지스터-레지스터 명령어(RRI, Register-Register Instruction)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상이 되는 두 개의 자료가 모두 레지스터에 있는 경우&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;수행 속도가 빠름&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;전체 명령어의 &lt;strong&gt;길이가 짧다&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모리-레지스터 명령어(MRI, Memory-Register Instruction)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상이 되는 두 개의 자료 중 하나는 주기억 장치에 있고 하나는 레지스터에 있는 경우&lt;/li&gt;
      &lt;li&gt;주기억 장치에 &lt;strong&gt;한 번 접근&lt;/strong&gt;해야 하기 때문에 RRI에 비해 수행 속도가 느리다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메모리-메모리 명령어(MMI, Memory-Memory Instruction)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;연산 대상이 되는 두 개의 자료가 모두 주기억 장치에 있는 경우&lt;/li&gt;
      &lt;li&gt;주기억 장치에 &lt;strong&gt;두 번 접근&lt;/strong&gt;해야 하기 때문에 &lt;strong&gt;수행 속도가 느리다&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;strong&gt;명령어의 메모리 참조 방식&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
레지스터 참조 명령(RRI, Register Reference Instruction)&lt;br /&gt;
메모리 참조 명령(MRI, Memory Reference Instruction)&lt;br /&gt;
입출력 명령(IOI, Input/Output Instruction)&lt;/p&gt;
</description>
        <pubDate>Mon, 03 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-instruction/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-instruction/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 연산의 종류</title>
        <description>&lt;h2 id=&quot;연산의-분류&quot;&gt;연산의 분류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;성질에 따른 분류
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;비수치적 연산&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;NOT&lt;/li&gt;
          &lt;li&gt;AND&lt;/li&gt;
          &lt;li&gt;OR&lt;/li&gt;
          &lt;li&gt;E-OR(Exclusive OR)&lt;/li&gt;
          &lt;li&gt;논리 Shift&lt;/li&gt;
          &lt;li&gt;Rotate&lt;/li&gt;
          &lt;li&gt;Complement(보수)&lt;/li&gt;
          &lt;li&gt;MOVE&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;수치적 연산&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;팩 10진 연산&lt;a href=&quot;https://many258.github.io/study/electronic-calculator-data-form/#10%EC%A7%84%EC%88%98-%EC%A0%95%EC%88%98-%ED%91%9C%ED%98%84&quot; class=&quot;btn btn--info&quot;&gt;포스트 이동하기&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;ADD&lt;/li&gt;
          &lt;li&gt;SUB&lt;/li&gt;
          &lt;li&gt;MUL&lt;/li&gt;
          &lt;li&gt;DIV&lt;/li&gt;
          &lt;li&gt;산술 Shift&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;항에 따른 분류
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;단항 연산(Unary Operation)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;논리 Shift&lt;/li&gt;
          &lt;li&gt;산술 Shift&lt;/li&gt;
          &lt;li&gt;Rotate&lt;/li&gt;
          &lt;li&gt;Complement&lt;/li&gt;
          &lt;li&gt;NOT&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;이항 연산(Binary Operation)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;AND&lt;/li&gt;
          &lt;li&gt;OR&lt;/li&gt;
          &lt;li&gt;E-OR&lt;/li&gt;
          &lt;li&gt;ADD&lt;/li&gt;
          &lt;li&gt;SUB&lt;/li&gt;
          &lt;li&gt;MUL&lt;/li&gt;
          &lt;li&gt;DIV&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;연산 우선순위
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;산술 연산자(우선순위 높음)&lt;/strong&gt;
        &lt;blockquote&gt;
          &lt;p&gt;&lt;strong&gt;÷, ×, ＋, －&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;관계 연산자&lt;/strong&gt;
        &lt;blockquote&gt;
          &lt;p&gt;&lt;strong&gt;=, ＞, ＜, ≥, ≤, ≠&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;논리 연산자(우선순위 낮음)&lt;/strong&gt;
        &lt;blockquote&gt;
          &lt;p&gt;&lt;strong&gt;NOT, AND, OR&lt;/strong&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;비수치적-연산&quot;&gt;비수치적 연산&lt;/h3&gt;
&lt;h4 id=&quot;and-연산mask-마이크로-동작&quot;&gt;AND 연산(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Mask&lt;/code&gt; 마이크로 동작)&lt;/h4&gt;
&lt;p&gt;비수치 자료의 특정 비트나 문자를 &lt;strong&gt;삭제하는 경우&lt;/strong&gt;에 사용&lt;/p&gt;

&lt;p&gt;특정 위치의 문자를 지우기 위해서는 &lt;strong&gt;Mask(0000 0000)를 사용해서 이항 연산에 의해 삭제&lt;/strong&gt;한다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/and-operation.png&quot; title=&quot;https://icarus.cs.weber.edu/~dab/cs1410/textbook/2.Core/bitops.html&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/and-operation.png&quot; alt=&quot;&quot; title=&quot;AND 연산 MASK 마이크로 동작&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;or-연산selective-set-마이크로-동작&quot;&gt;OR 연산(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Selective-Set&lt;/code&gt; 마이크로 동작)&lt;/h4&gt;
&lt;p&gt;비수치적 자료에서 특정 &lt;strong&gt;비트 또는 문자를 삽입하거나 결합&lt;/strong&gt; 시 사용&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/or-operation.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/or-operation.png&quot; alt=&quot;&quot; title=&quot;OR 연산 Selective-Set 마이크로 동작&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;exclusive-orcompare-마이크로-동작&quot;&gt;Exclusive-OR(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Compare&lt;/code&gt; 마이크로 동작)&lt;/h4&gt;
&lt;p&gt;비수치적 자료의 &lt;strong&gt;비교 시 또는 검출&lt;/strong&gt; 시 사용하거나 &lt;strong&gt;특정 비트의 반전&lt;/strong&gt;에 사용&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/xor-operation.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/xor-operation.png&quot; alt=&quot;&quot; title=&quot;eXclusive-OR 연산 Compare 마이크로 동작&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;논리-shift-연산&quot;&gt;논리 Shift 연산&lt;/h4&gt;
&lt;p&gt;비수치적 자료의 모든 비트를 &lt;strong&gt;우측 또는 좌측으로 자리 이동&lt;/strong&gt;시키는 연산을 의미&lt;/p&gt;

&lt;p&gt;단항 연산자로 자료의 이동에 주로 사용하며, &lt;strong&gt;좌우측 Shift에 모두 0이 Padding(패딩)&lt;/strong&gt;된다&lt;/p&gt;

&lt;h4 id=&quot;rotate-연산&quot;&gt;ROTATE 연산&lt;/h4&gt;
&lt;p&gt;비수치적 자료에서 문자의 위치 변환에 사용&lt;/p&gt;

&lt;p&gt;논리 Shift에서 Truncation되는 비트가 반대편으로 회전해서 패딩되는 경우를 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1비트 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우&lt;/code&gt;측으로 Rotate인 경우&lt;br /&gt;
&lt;strong&gt;LSB&lt;/strong&gt;(최하위 비트, Least Significant Bit)에서 Truncation된 비트가 &lt;strong&gt;MSB&lt;/strong&gt;(최상위 비트, Most Significant Bit)로 패딩&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;1비트 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;좌&lt;/code&gt;측으로 Rotate인 경우&lt;br /&gt;
&lt;strong&gt;MSB&lt;/strong&gt;에서 Truncation된 비트가 &lt;strong&gt;LSB&lt;/strong&gt;로 패딩&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;complement보수-연산&quot;&gt;Complement(보수) 연산&lt;/h4&gt;
&lt;p&gt;단항 연산으로 1의 보수나 2의 보수를 구하는 연산&lt;/p&gt;

&lt;h3 id=&quot;수치적-연산&quot;&gt;수치적 연산&lt;/h3&gt;
&lt;h4 id=&quot;고정-소수점-연산&quot;&gt;고정 소수점 연산&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;부호화 절대치 연산&lt;/strong&gt;&lt;br /&gt;
부호가 같은 경우 &lt;strong&gt;가산기&lt;/strong&gt;, 부호가 다른 경우 &lt;strong&gt;감산기&lt;/strong&gt;를 사용하여 연산&lt;/p&gt;

    &lt;p&gt;부호가 다른 경우는 두 수를 비교하여 큰 수에서 작은 수를 감산기를 통해서 연산한 후 &lt;strong&gt;큰 수에 대한 부호를 결과&lt;/strong&gt;에 반영한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;1의 보수 연산&lt;/strong&gt;&lt;br /&gt;
덧셈기 하나만 있으면 덧셈과 뺄셈을 모두 연산할 수 있다&lt;/p&gt;

    &lt;p&gt;최상의 비트에서 &lt;strong&gt;캐리(Carry)가 발생하는 경우 1을 결과에 더한다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;2의 보수 연산&lt;/strong&gt;&lt;br /&gt;
최상의 비트에서 &lt;strong&gt;캐리가 발생하면 버린다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;부동-소수점-연산&quot;&gt;부동 소수점 연산&lt;/h4&gt;
&lt;p&gt;부동 소수점 표현이 &lt;strong&gt;부호, 지수, 가수&lt;/strong&gt;만 표현하므로 이것만 사용하여 연산 수행&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;덧셈과 뺄셈 과정&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;0인지 조사&lt;/li&gt;
      &lt;li&gt;지수값 비교&lt;/li&gt;
      &lt;li&gt;가수의 정렬&lt;/li&gt;
      &lt;li&gt;가수 부분 덧/뺄셈&lt;/li&gt;
      &lt;li&gt;정규화&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;곱셈 과정&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;0인지 조사&lt;/li&gt;
      &lt;li&gt;지수 &lt;strong&gt;덧셈&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;가수 곱셈&lt;/li&gt;
      &lt;li&gt;정규화&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;나눗셈 과정&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;0인지 조사&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;부호 결정&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;피제수의 위치 조정&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;지수 &lt;strong&gt;뺄셈&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;가수 나눗셈&lt;/li&gt;
      &lt;li&gt;정규화&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;산술-shift&quot;&gt;산술 Shift&lt;/h4&gt;
&lt;p&gt;우측이나 좌측으로 &lt;strong&gt;비트 전부를 한 비트씩 이동&lt;/strong&gt;시키는 것이며&lt;br /&gt;
&lt;strong&gt;우측 Shift&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;나눗셈&lt;/code&gt;), &lt;strong&gt;좌측 Shift&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;곱셈&lt;/code&gt;)을 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우측&lt;/code&gt; 산술 Shift (»)
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;부호와 절대치 표현&lt;/strong&gt;
&lt;a href=&quot;../../assets/images/electronic-calc/right-arithmetic-shift-abs.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/right-arithmetic-shift-abs.png&quot; alt=&quot;&quot; title=&quot;부호화 절대치 표현의 우측 시프트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;1의 보수&lt;/strong&gt;
&lt;a href=&quot;../../assets/images/electronic-calc/right-arithmetic-shift-1-complement.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/right-arithmetic-shift-1-complement.png&quot; alt=&quot;&quot; title=&quot;1의 보수의 우측 시프트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;2의 보수&lt;/strong&gt;
&lt;a href=&quot;../../assets/images/electronic-calc/right-arithmetic-shift-2-complement.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/right-arithmetic-shift-2-complement.png&quot; alt=&quot;&quot; title=&quot;2의 보수의 우측 시프트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;좌측&lt;/code&gt; 산술 Shift («)
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;부호와 절대치 표현&lt;/strong&gt;
&lt;a href=&quot;../../assets/images/electronic-calc/left-arithmetic-shift-abs.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/left-arithmetic-shift-abs.png&quot; alt=&quot;&quot; title=&quot;부호화 절대치 표현의 좌측 시프트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;1의 보수&lt;/strong&gt;
&lt;a href=&quot;../../assets/images/electronic-calc/left-arithmetic-shift-1-complement.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/left-arithmetic-shift-1-complement.png&quot; alt=&quot;&quot; title=&quot;1의 보수의 좌측 시프트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;2의 보수&lt;/strong&gt;
&lt;a href=&quot;../../assets/images/electronic-calc/left-arithmetic-shift-2-complement.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/left-arithmetic-shift-2-complement.png&quot; alt=&quot;&quot; title=&quot;2의 보수의 좌측 시프트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 30 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-operation-class/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-operation-class/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 자료 표현</title>
        <description>&lt;h2 id=&quot;자료-표현&quot;&gt;자료 표현&lt;/h2&gt;
&lt;p&gt;사람과 컴퓨터 간에 의사소통을 위해서 인간이 사용하는 기호나 숫자 또는 문자 등을 컴퓨터가 인식할 수 있도록 표현하기 위한 기술을 의미&lt;/p&gt;

&lt;h3 id=&quot;자료의-단위&quot;&gt;자료의 단위&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;단위&lt;/th&gt;
      &lt;th&gt;크기&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;비트&lt;/td&gt;
      &lt;td&gt;Bit&lt;/td&gt;
      &lt;td&gt;0,1의 표현으로 전산기 구조의 최소 단위&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;니블&lt;/td&gt;
      &lt;td&gt;Nibble&lt;/td&gt;
      &lt;td&gt;4개의 비트를 묶어 하나의 단위로 나타낸 것으로 보통 16진수표현 단위로 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;바이트&lt;/td&gt;
      &lt;td&gt;Byte&lt;/td&gt;
      &lt;td&gt;8개의 비트를 묶어 하나의 단위로 나타낸 것으로 문자 표현의 단위로 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;워드&lt;/td&gt;
      &lt;td&gt;Word&lt;/td&gt;
      &lt;td&gt;내부 표현이나 처리를 위해 사용되는 단위&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;하프 워드&lt;/td&gt;
      &lt;td&gt;Half Word&lt;/td&gt;
      &lt;td&gt;2Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;풀 워드&lt;/td&gt;
      &lt;td&gt;Full Word&lt;/td&gt;
      &lt;td&gt;4Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;더블 워드&lt;/td&gt;
      &lt;td&gt;Double Word&lt;/td&gt;
      &lt;td&gt;8Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;필드&lt;/td&gt;
      &lt;td&gt;Field&lt;/td&gt;
      &lt;td&gt;어떤 특성이나 속성 표현을 위한 단위로 최소의 논리적 단위&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;레코드&lt;/td&gt;
      &lt;td&gt;Record&lt;/td&gt;
      &lt;td&gt;워드가 모여서 이루는 논리적인 단위로 정보가 처리되는 단위&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;블록&lt;/td&gt;
      &lt;td&gt;Block&lt;/td&gt;
      &lt;td&gt;입출력을 위해 논리 레코드를 묶어 놓은 단위로 물리적 레코드라고 한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;파일&lt;/td&gt;
      &lt;td&gt;File&lt;/td&gt;
      &lt;td&gt;관련있는 종류의 레코드를 묶어 나타낸 단위로 저장 장치에 저장되는 단위&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;데이터베이스&lt;/td&gt;
      &lt;td&gt;Database&lt;/td&gt;
      &lt;td&gt;서로 관련이 있는 파일을 통합하여 묶어놓은 데이터 그룹&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;문자-자료의-표현&quot;&gt;문자 자료의 표현&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;표준 BCD Code&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;존(Zone) 2Bit와 디지트(Digit) 4비트&lt;/strong&gt;의 총 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6비트&lt;/code&gt;로 하나의 문자를 나타낸다. 최대 64문자까지 표현 가능하며 초창기에 사용하던 코드&lt;/p&gt;

    &lt;p&gt;영문자의 소문자는 표현이 불가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EBCDIC Code&lt;/strong&gt;&lt;br /&gt;
BCD 코드의 &lt;strong&gt;존 비트를 4비트 확장&lt;/strong&gt;(총 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8비트&lt;/code&gt;)하여 최대 256문자까지 표현할 수 있도록 한 확장된 BCD 코드(Zone 4비트, Digit 4비트)&lt;/p&gt;

    &lt;p&gt;IBM 사에서 개발한 것으로 대형 컴퓨터에 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ASCII Code(아스키코드)&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;7비트&lt;/strong&gt;(Zone 3Bit, Digit 4Bit)로 한 문자를 표현할 수 있어 128문자까지 표현 가능하며 &lt;strong&gt;1비트의 패리티 비트&lt;/strong&gt;를 합쳐 총 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8비트&lt;/code&gt;로 사용. 데이터 &lt;strong&gt;통신용&lt;/strong&gt;으로 널리 사용되며, 특히 개인용 및 소형 컴퓨터용으로 쓰인다&lt;/p&gt;

    &lt;p&gt;제어 부호 33개, 그래픽 기호 33개, 숫자 10개, 알파벳 대/소문자 52개로 구성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Unicode(유니코드)&lt;/strong&gt;&lt;br /&gt;
컴퓨터에서 세계 각국의 언어를 &lt;strong&gt;통일된 방법으로 표현&lt;/strong&gt;하도록 제안된 &lt;strong&gt;국제적인 문자 코드&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;세계 26개 언어의 문자와 특수 기호에 대해 코드값으로 구성되어 있다. ASCII를 인식할 수 있지만, &lt;strong&gt;ASCII에서는 유니코드의 특수 문자를 인식할 수 없다&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;수치-자료의-표현&quot;&gt;수치 자료의 표현&lt;/h3&gt;
&lt;h4 id=&quot;10진수-정수-표현&quot;&gt;10진수 정수 표현&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;언팩 10진 형식&lt;/strong&gt;(Unpack Decimal Format)&lt;br /&gt;
10진수 한 자리를 표현하기 위해 1바이트(8bit)를 사용하는 형식&lt;/p&gt;

    &lt;p&gt;존 영역(4Bit) + 수치 영역(4Bit). 부호(+/-)는 &lt;strong&gt;마지막 존 영역&lt;/strong&gt;에 표시(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; : &lt;strong&gt;1100(C)&lt;/strong&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; : &lt;strong&gt;1101(D)&lt;/strong&gt;)&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;연산할 수 없으&lt;/strong&gt;며 &lt;strong&gt;입출력&lt;/strong&gt;을 위해 사용한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;팩 10진 형식&lt;/strong&gt;(Pack Decimal Format)&lt;br /&gt;
연산이 가능하며 10진수 한 자리를 표현하기 위해 &lt;strong&gt;존 영역없이 4비트&lt;/strong&gt;를 사용&lt;/p&gt;

    &lt;p&gt;최하위 4비트에 부호를 표시(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; : &lt;strong&gt;1100(C)&lt;/strong&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt; : &lt;strong&gt;1101(D)&lt;/strong&gt;)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2진수-정수-표현&quot;&gt;2진수 정수 표현&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;부호와 절대치&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;최상위 1비트에 부호&lt;/strong&gt;를 표시(+ : 0, - : 1)
    &lt;blockquote&gt;
      &lt;p&gt;수의 표현 범위 : -(2&lt;sup&gt;n-1&lt;/sup&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt;) ~ 2&lt;sup&gt;n-1&lt;/sup&gt;-1&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;0의 표현은 0000 0000, 1000 0000 2가지로 표현 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;1의 보수&lt;/strong&gt;&lt;br /&gt;
임의의 양수 값이 있다면 양수 값의 &lt;strong&gt;1의 보수 값을 그 값의 음수&lt;/strong&gt; 값으로 사용하는 방식&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;수의 표현 범위 : -(2&lt;sup&gt;n-1&lt;/sup&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt;) ~ 2&lt;sup&gt;n-1&lt;/sup&gt;-1&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;0의 표현은 0000 0000, 1111 1111 2가지로 표현 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;2의 보수&lt;/strong&gt;&lt;br /&gt;
임의의 양수 값이 있다면 양수 값의 &lt;strong&gt;2의 보수 값을 그 값의 음수&lt;/strong&gt; 값으로 사용하는 방식&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;수의 표현 범위 : -(2&lt;sup&gt;n-1&lt;/sup&gt;) ~ 2&lt;sup&gt;n-1&lt;/sup&gt;-1&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2진수-실수-표현&quot;&gt;2진수 실수 표현&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;고정 소수점 표현
소수점이 항상 최상위 비트의 왼쪽에 고정되어 있는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;부동 소수점 표현
소수점위치를 변경시킴으로써 극히 작은 수에서 큰 수를 표현하는 방법&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;일반 부동 소수점 표현
        &lt;ul&gt;
          &lt;li&gt;부호(1) : 0(양수), 1(음수)&lt;/li&gt;
          &lt;li&gt;지수(7) : Bias 값 64에 지수값을 더해서 표현&lt;/li&gt;
          &lt;li&gt;가수(24) : 16진수로 표현&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;IEEE754 표준 부동 소수점 표현
        &lt;ul&gt;
          &lt;li&gt;부호(1) : 0(양수), 1(음수)&lt;/li&gt;
          &lt;li&gt;지수(8) : Bias 값 127에 지수 값을 더해서 표현&lt;/li&gt;
          &lt;li&gt;가수(23) : 2진수로 표현&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;정규화
        &lt;ul&gt;
          &lt;li&gt;유효숫자를 늘려 정밀도를 높이기 위한 목적으로 사용
            &lt;blockquote&gt;
              &lt;p&gt;일반 정규형 : 0.M × 16&lt;sup&gt;E&lt;/sup&gt;&lt;sub&gt;(단, M:가수, E:지수)&lt;/sub&gt;&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p class=&quot;notice--success&quot;&gt;&lt;strong&gt;메가플롭스(MFLOPS)&lt;/strong&gt; : 1초간에 실행되는 부동 소수점 연산의 수를 100만 단위로 하여 나타낸 수를 의미&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;코드의-표현&quot;&gt;코드의 표현&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;분류&lt;/th&gt;
      &lt;th&gt;코드 종류&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;가중치 코드&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt;&lt;br /&gt;Weighted Code&lt;/td&gt;
      &lt;td&gt;8421코드&lt;br /&gt;2421 코드&lt;br /&gt; 74&lt;span style=&quot;text-decoration:overline&quot;&gt;21&lt;/span&gt;코드&lt;br /&gt;8421 코드&lt;br /&gt; 5421코드&lt;br /&gt;51111 코드&lt;br /&gt;Biquinary 코드&lt;br /&gt;Ring Counter 코드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;비가중치 코드&lt;br /&gt;Unweighted Code&lt;/td&gt;
      &lt;td&gt;3초과 코드&lt;br /&gt;그레이 코드&lt;br /&gt;2-Out-of-5 코드&lt;br /&gt;3-Out-of-5 코드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;자기 보수 코드&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt;&lt;br /&gt;Self Complement Code&lt;/td&gt;
      &lt;td&gt;3초과 코드&lt;br /&gt;2421 코드&lt;br /&gt;5211 코드&lt;br /&gt;51111 코드&lt;br /&gt; 8421 코드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;에러 검출 코드&lt;br /&gt;Error Detecting Code&lt;/td&gt;
      &lt;td&gt;패리티 비트 코드&lt;br /&gt;해밍 코드&lt;br /&gt; Biquinary 코드&lt;br /&gt;Ring Counter 코드&lt;br /&gt;2-Out-of-5 코드&lt;br /&gt;3-Out-of-5 코드&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;가중치 코드&lt;/strong&gt; : 2진수 각 자리마다 &lt;strong&gt;고유의 기준치 값&lt;/strong&gt;이 있는 코드&lt;/p&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;자기 보수 코드&lt;/strong&gt; : 코드의 &lt;strong&gt;1의 보수가 10진수의 9의 보수&lt;/strong&gt;가 같은 코드&lt;/p&gt;

&lt;h4 id=&quot;8421-코드&quot;&gt;8421 코드&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;4비트(8,4,2,1)의 가중 값을 가지므로 &lt;strong&gt;가중치 코드&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;2진화 10진수로 사용될 때는 10진수 0~9까지 표현&lt;/li&gt;
  &lt;li&gt;4비트 표현이므로 2진 표현으로는 16가지 표현이 가능하나 &lt;strong&gt;10~15까지는 사용하지 않는다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2421-코드&quot;&gt;2421 코드&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;4비트(2,4,2,1)의 가중 값을 가지므로 &lt;strong&gt;가중치 코드&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자기 보수 코드&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;4비트 표현이므로 2진 표현으로는 16가지 표현이 가능하나 그 중 &lt;strong&gt;2~7까지(6가지)는 중복 표현&lt;/strong&gt;된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;7421-코드&quot;&gt;74&lt;span style=&quot;text-decoration:overline&quot;&gt;21&lt;/span&gt; 코드&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;4비트(7,4,-2,-1)의 가중 값을 가지므로 가중치 코드이며 가중치 값 중에 &lt;strong&gt;음수&lt;/strong&gt;를 가지고 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;허프만-코드huffman-code&quot;&gt;허프만 코드(Huffman Code)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;빈번히 발생&lt;/strong&gt;하는 데이터의 코드는 &lt;strong&gt;적은 수의 비트로 표현&lt;/strong&gt;하고, 빈번하지 않은 데이터는 상대적으로 많은 비트수로 표현하여 &lt;strong&gt;전체 데이터의 크기를 줄이는&lt;/strong&gt; 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;통계적인 부호화 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3초과-코드&quot;&gt;3초과 코드&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;비가중치 코드&lt;/strong&gt;, &lt;strong&gt;자기 보수 코드&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;8421 코드를 3초과시켜서 만든 코드&lt;/li&gt;
  &lt;li&gt;8421 코드는 뒤에서 6개의 코드 값을 사용하지 않지만 3초과 코드는 &lt;strong&gt;앞에서 3개, 뒤에서 3개를 사용하지 않는다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;연산 시 &lt;strong&gt;캐리 발생 여부만 판별&lt;/strong&gt;해서 3을 더해주거나 빼주면 되기 때문에 8421 코드에 비해 편리&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;그레이-코드gray-code&quot;&gt;그레이 코드(Gray Code)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;각 자리에 일정한 값을 부여하는 가중치 값이 없는 &lt;strong&gt;비가중치 코드&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;한 비트의 변환만으로 다음 값을 만들 수 있기 때문에 &lt;strong&gt;변화가 적다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;기계적인 동작을 제어하는 알맞은 코드&lt;/strong&gt;이며, 입출력 장치의 동작이나 &lt;strong&gt;아날로그 신호를 디지털 신호로 변환&lt;/strong&gt;하는데 사용할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;2진 코드 =&amp;gt; 그레이 코드&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;2진 코드에서 최상위 비트(MSB: Most Significant Bit)는 변하지 않고 그대로 Gray Code로 변환&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;좌측 비트에서 오른쪽으로 이웃한 비트&lt;/strong&gt;를 E-OR(Exclusive OR) 연산하여 차례로 그레이 코드의 다음 비트를 만들어 준다&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/binary-to-gray.png&quot; title=&quot;https://www.matrixlab-examples.com/gray-code.html&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/binary-to-gray.png&quot; alt=&quot;&quot; title=&quot;2진 코드에서 그레이 코드 변환&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;그레이 코드 =&amp;gt; 2진 코드&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;그레이 코드에서 최상위 비트(MSB)는 변하지 않고 그대로 Binary Code로 변환&lt;/li&gt;
      &lt;li&gt;변환된 2진 코드와 &lt;strong&gt;그레이 코드 오른쪽으로 이웃한 비트를 E-OR 연산&lt;/strong&gt; 차례로 바이너리 코드의 다음 비트를 만들어 준다&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/gray-to-binary.png&quot; title=&quot;https://www.matrixlab-examples.com/gray-code.html&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/gray-to-binary.png&quot; alt=&quot;&quot; title=&quot;그레이 코드에서 2진 코드로 변환&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;해밍-코드hamming-code포스트-이동하기&quot;&gt;해밍 코드(Hamming Code)&lt;a href=&quot;https://many258.github.io/study/data-communication-error-control/#%ED%95%B4%EB%B0%8D%EC%BD%94%EB%93%9Chamming-code&quot; class=&quot;btn btn--primary&quot;&gt;포스트 이동하기&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;에러 검출뿐만 아닌 수정까지 가능한 코드&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;패리티-비트parity-bit포스트-이동하기&quot;&gt;패리티 비트(Parity Bit)&lt;a href=&quot;https://many258.github.io/study/data-communication-error-control/#%ED%8C%A8%EB%A6%AC%ED%8B%B0-%EB%B9%84%ED%8A%B8&quot; class=&quot;btn btn--info&quot;&gt;포스트 이동하기&lt;/a&gt;&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;2진수로 이루어진 코드에서 1의 개수가 홀수 개가 되는지 짝수 개가 되는지를 체크하기 위해 추가되는 비트를 의미&lt;/li&gt;
  &lt;li&gt;패리티 비트는 &lt;strong&gt;1비트 오류 검출&lt;/strong&gt;이 가능&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 29 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-data-form/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-data-form/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 순서 논리 회로(Sequential Logic Circuit)</title>
        <description>&lt;h2 id=&quot;순서-논리-회로&quot;&gt;순서 논리 회로&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;기억 능력&lt;/strong&gt;을 갖추면서 &lt;strong&gt;입력과 내부 상태의 조합&lt;/strong&gt;에 의해 출력이 결정되는 회로&lt;/p&gt;

&lt;p&gt;플립플롭이나 레지스터 장치로 구성된다&lt;/p&gt;

&lt;h3 id=&quot;플립플롭flip-flop&quot;&gt;플립플롭(Flip-Flop)&lt;/h3&gt;
&lt;p&gt;순서 논리 회로를 구성하는 기본 기억 소자로 &lt;strong&gt;1비트를 기억&lt;/strong&gt;할 수 있는 &lt;strong&gt;2진 Cell&lt;/strong&gt;을 의미&lt;/p&gt;

&lt;h4 id=&quot;rs-플립플롭&quot;&gt;RS 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/rs-filp-flop.png&quot; title=&quot;https://www.electronicsengineering.nbcafe.in/rs-flip-flop/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/rs-filp-flop.png&quot; alt=&quot;&quot; title=&quot;RS 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;보통 NAND 게이트를 이용해서 구성&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SET&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt;) &lt;strong&gt;단자와&lt;/strong&gt; RESET(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt;) 단자를 갖으며, &lt;strong&gt;모두 1인 경우는 허용되지 않는다&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;jk-플립플롭&quot;&gt;JK 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/jk-flip-flop.png&quot; title=&quot;https://www.javatpoint.com/j-k-flip-flop&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/jk-flip-flop.png&quot; alt=&quot;&quot; title=&quot;JK 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RS 플립플롭에서 S와 R이 모두 1일 때 &lt;strong&gt;허용되지 않는 것을 보완&lt;/strong&gt;해서 이것이 허용되도록 고안된 플립플롭&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RS 플립플롭&lt;/strong&gt;의 내부 상태와 입력 상태를 &lt;strong&gt;AND 게이트&lt;/strong&gt;로 처리하여 입력하는 플립플롭&lt;/p&gt;

&lt;h4 id=&quot;d-플립플롭&quot;&gt;D 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/d-flip-flop.png&quot; title=&quot;https://www.javatpoint.com/d-flip-flop&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/d-flip-flop.png&quot; alt=&quot;&quot; title=&quot;D 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;RS나 JK 플립플롭에서 &lt;strong&gt;서로 베타적인 경우만 이용&lt;/strong&gt;되도록 고안된 플립플롭, &lt;strong&gt;1비트 지연 소자&lt;/strong&gt;로 사용된다&lt;br /&gt;
(S가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;이면 R은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;, S가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;이면 R은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&quot;t-플립플롭&quot;&gt;T 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/t-flip-flop.png&quot; title=&quot;https://www.javatpoint.com/t-flip-flop&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/t-flip-flop.png&quot; alt=&quot;&quot; title=&quot;T 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;JK 플립플롭에서 J, K가 같은 값이 입력될 때만 이용할 수 있도록 고안된 플립플롭, &lt;strong&gt;토글(Toggle) 기능&lt;/strong&gt;을 이용하고자 할 때 사용된다&lt;br /&gt;
(J가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;이면 K는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;, J가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;이면 K는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&quot;마스터-슬레이브master-slave-주종-플립플롭&quot;&gt;마스터 슬레이브(Master-Slave, 주종) 플립플롭&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/master-slave-flipflop.png&quot; title=&quot;http://www.barrywatson.se/dd/dd_sr_flip_flop_master_slave.html&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/master-slave-flipflop.png&quot; alt=&quot;&quot; title=&quot;마스터 슬레이브 플립플롭&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Race 현상&lt;/strong&gt;&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt;을 해결하기 위해 고안된 플립플롭&lt;/p&gt;

&lt;p class=&quot;notice--success&quot;&gt;&lt;strong&gt;Race 현상&lt;/strong&gt; : 출력이 입력에 피드백되어 플립플롭의 내부 상태가 변화되면 출력 상태가 변할 때 입력도 변하게 되므로 &lt;strong&gt;오동작이 발생&lt;/strong&gt;하게 되는 현상&lt;/p&gt;

&lt;p&gt;하나의 플립플롭(&lt;strong&gt;주 플립플롭&lt;/strong&gt;)이 주인 역할을 하고, 다른 하나의 플립플롭(&lt;strong&gt;종 플립플롭&lt;/strong&gt;)이 종속되어 동작하도록 두 개 이상의 플립플롭 회로를 결합한 것&lt;/p&gt;

&lt;p&gt;주 플립플롭은 &lt;strong&gt;시간 펄스가 상승&lt;/strong&gt;할 때 동작하고, 종 플립플롭은 &lt;strong&gt;시간 펄스가 하강&lt;/strong&gt;할 때 동작&lt;/p&gt;

&lt;h3 id=&quot;카운터counter&quot;&gt;카운터(Counter)&lt;/h3&gt;
&lt;p&gt;시간 펄스의 수를 카운트하거나 제어 장치에서 각종 회로의 동작을 제어하는데 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;리플 카운터(Ripple Counter)&lt;/strong&gt;&lt;br /&gt;
가장 기본이 되는 비동기형(Asynchronous) 카운터. 플립플롭의 수를 n이라 할 때, 2&lt;sup&gt;n&lt;/sup&gt;개까지의 독립된 수 전부를 표현&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;모드 카운터(MOD Counter)&lt;/strong&gt;&lt;br /&gt;
N개의 서로 다른 출력상태를 갖는 카운터. N개의 서로 다른 출력상태를 나타낸 후 다시 원래의 상태로 복귀해 다시 N개의 출력상태를 반복&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;레지스터register&quot;&gt;레지스터(Register)&lt;/h3&gt;
&lt;p&gt;연산에 사용될 데이터가 대기하거나 연산된 결과&lt;strong&gt;데이터가 임시적으로 대기&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;시프트 레지스터(Shift Register)&lt;/strong&gt;&lt;br /&gt;
현재 레지스터에 있는 내용을 왼쪽이나 오른쪽의 연결된 플립플롭을 &lt;strong&gt;1비트씩 이동&lt;/strong&gt;시켜 &lt;strong&gt;밀어내기와 같은 동작을 수행&lt;/strong&gt;하는 레지스터&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;병렬 시프트 레지스터(Parallel Shift Register)&lt;/strong&gt;&lt;br /&gt;
N개의 비트로 구성된 레지스터의 내용을 연결된 다른 레지스터로 &lt;strong&gt;한 번에 이동&lt;/strong&gt;시킬 수 있는 레지스터&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 28 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-sequential-logic/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-sequential-logic/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 조합 논리 회로(Combinational Logic Circuit)</title>
        <description>&lt;h2 id=&quot;조합-논리-회로&quot;&gt;조합 논리 회로&lt;/h2&gt;
&lt;p&gt;논리 게이트의 조합으로 만들어지는 회로로 현재의 입력에 의해서만 출력이 결정되는 회로를 의미&lt;/p&gt;

&lt;h3 id=&quot;반가산기half-adder&quot;&gt;반가산기(Half Adder)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/half-adder.png&quot; title=&quot;https://www.researchgate.net/figure/Half-adder-circuit-diagram_fig1_272015389&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/half-adder.png&quot; alt=&quot;&quot; title=&quot;반가산기&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2개의 2진 입력 변수 A와 B를 더한 합 &lt;strong&gt;S&lt;/strong&gt;(Sum)와 자리 올림 수 &lt;strong&gt;C&lt;/strong&gt;(Carry)를 얻는 회로&lt;/p&gt;

&lt;p&gt;하나의 &lt;strong&gt;AND 게이트&lt;/strong&gt;와 &lt;strong&gt;XOR&lt;/strong&gt;(eXclusive OR) 게이트를 조합해서 구성&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;S&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;합(Sum)&lt;/strong&gt; : S = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·B + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; = A ⊕ B&lt;br /&gt;
&lt;strong&gt;캐리(Carry)&lt;/strong&gt; : C = A · B&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;반감산기half-subtracter&quot;&gt;반감산기(Half Subtracter)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/half-subtracter.png&quot; title=&quot;https://www.engineersgarage.com/vhdl/vhdl-tutorial-11-designing-half-and-full-subtractor-circuits/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/half-subtracter.png&quot; alt=&quot;&quot; title=&quot;반감산기&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2개의 2진 입력 변수 X에서 Y를 뺀 차 D와 빌려온 수(자리 내림 수) B를 얻는 회로&lt;/p&gt;

&lt;p&gt;하나의 &lt;strong&gt;NOT 게이트&lt;/strong&gt; 및 &lt;strong&gt;AND 게이트&lt;/strong&gt;와 &lt;strong&gt;XOR 게이트&lt;/strong&gt;를 조합해서 구성&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;X&lt;/th&gt;
      &lt;th&gt;Y&lt;/th&gt;
      &lt;th&gt;D&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;차(Difference)&lt;/strong&gt; : D = X·&lt;span style=&quot;text-decoration:overline&quot;&gt;Y&lt;/span&gt; + &lt;span style=&quot;text-decoration:overline&quot;&gt;X&lt;/span&gt;·Y  = X ⊕ Y&lt;br /&gt;
&lt;strong&gt;빌려온 수(자리 내림, Borrow)&lt;/strong&gt; : B = &lt;span style=&quot;text-decoration:overline&quot;&gt;X&lt;/span&gt; · Y&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;전가산기full-adder&quot;&gt;전가산기(Full Adder)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/full-adder.png&quot; title=&quot;https://electronics.stackexchange.com/questions/492236/why-is-the-last-carry-blocks-gate-in-a-full-adder-an-or-gate-and-not-a-xor&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/full-adder.png&quot; alt=&quot;&quot; title=&quot;전가산기&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2진수 가산을 완전히 하기 위하여 아래 자리로부터 자리 올림된 수도 고려하여 3개의 2진수를 더할 수 있게 만든 회로&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;반가산기 2개&lt;/strong&gt;와 &lt;strong&gt;OR 게이트 1개&lt;/strong&gt;를 연결하여 구성&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;C&lt;/th&gt;
      &lt;th&gt;S&lt;/th&gt;
      &lt;th&gt;C&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;합(Sum)&lt;/strong&gt; : S = A⊕B⊕C&lt;br /&gt;
&lt;strong&gt;캐리(Carry)&lt;/strong&gt; : C&lt;sub&gt;0&lt;/sub&gt; = (A⊕B)·C + A·B = A·B + B·C + A·C&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;전감산기full-subtracter&quot;&gt;전감산기(Full Subtracter)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/full-subtractor.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/full-subtractor.png&quot; alt=&quot;&quot; title=&quot;전감산기&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2진수 감산을 완전히 하기 위하여 아래 자리로부터 자리 내림수도 고려하여 3개의 2진수를 감산할 수 있게 만든 회로&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;반감산기 2개&lt;/strong&gt;와 &lt;strong&gt;OR 게이트 1개&lt;/strong&gt;를 연결하여 구성&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;X&lt;/th&gt;
      &lt;th&gt;Y&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;D&lt;/th&gt;
      &lt;th&gt;B&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;차(Difference)&lt;/strong&gt; : D = X⊕Y⊕B&lt;br /&gt;
&lt;strong&gt;빌려온 수(Borrow)&lt;/strong&gt; : B&lt;sub&gt;1&lt;/sub&gt; = &lt;span style=&quot;text-decoration:overline&quot;&gt;(X⊕Y)&lt;/span&gt;·B + &lt;span style=&quot;text-decoration:overline&quot;&gt;X&lt;/span&gt;·Y&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;병렬-가산기parallel-adder&quot;&gt;병렬 가산기(Parallel Adder)&lt;/h3&gt;
&lt;p&gt;여러 비트를 가산하기 위한 회로&lt;/p&gt;

&lt;p&gt;반가산기 또는 전가산기를 여러 개 합쳐서 만들어진다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;전가산기로 구성&lt;/strong&gt;하여 N비트 병렬 가산기를 만들 경우&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;개의 전가산기 필요&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;반가산기로 구성&lt;/strong&gt;하여 N비트 병렬 가산기를 만들 경우&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(2N-1)&lt;/code&gt;개의 반가산기와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(N-1)&lt;/code&gt;개의 &lt;strong&gt;OR 게이트&lt;/strong&gt; 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/parallel-adder.png&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/parallel-adder.png&quot; alt=&quot;&quot; title=&quot;4비트 병렬 가산기의 여러 가지 블록 다이어그램&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;디코더decoder&quot;&gt;디코더(Decoder)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/decoder.png&quot; title=&quot;https://www.tutorialspoint.com/computer_logical_organization/combinational_circuits.htm&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/decoder.png&quot; alt=&quot;&quot; title=&quot;디코더&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;컴퓨터 내부에서 2진수로 코드화된 데이터를 해독하여 대응되는 한 개의 신호로 바꿔주기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;해독기&lt;/code&gt;라고도 한다&lt;br /&gt;
&lt;strong&gt;N개의 입력&lt;/strong&gt;으로 &lt;strong&gt;최대 2&lt;sup&gt;N&lt;/sup&gt;개의 출력&lt;/strong&gt;을 얻을 수 있다&lt;br /&gt;
AND 게이트로 만들어진다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A&lt;/th&gt;
      &lt;th&gt;B&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;3&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;인코더encoder&quot;&gt;인코더(Encoder)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/encoder.png&quot; title=&quot;https://en.wikipedia.org/wiki/Encoder_(digital)&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/encoder.png&quot; alt=&quot;&quot; title=&quot;인코더&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;입력 정보를 여러 자리의 2진수로 코드화하여 전달하는 회로&lt;br /&gt;
해독기와 정반대의 동작을 수행&lt;br /&gt;
&lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;개의 입력&lt;/strong&gt;을 받아 &lt;strong&gt;N개를 출력&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;입력&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;멀티플렉서multiplexer&quot;&gt;멀티플렉서(Multiplexer)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/multiplexer.png&quot; title=&quot;https://www.tutorialspoint.com/digital_circuits/digital_circuits_multiplexers.htm&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/multiplexer.png&quot; alt=&quot;&quot; title=&quot;멀티플렉서&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2&lt;sup&gt;N&lt;/sup&gt;개의 입력선&lt;/strong&gt;에서 &lt;strong&gt;N개의 선택선&lt;/strong&gt;을 가지고 &lt;strong&gt;하나의 출력&lt;/strong&gt;을 얻도록 구성&lt;br /&gt;
&lt;strong&gt;여러 개의 입력 회선&lt;/strong&gt;이 들어가서 &lt;strong&gt;하나의 특정 회선을 선택&lt;/strong&gt;하도록 하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선택기&lt;/code&gt;라고도 한다&lt;br /&gt;
공통적인 &lt;strong&gt;버스 라인을 구성&lt;/strong&gt;하는데 많이 사용&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;S&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;S&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;Y&lt;sub&gt;선택 회선&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;sub&gt;0&lt;/sub&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;I&lt;sub&gt;1&lt;/sub&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;sub&gt;2&lt;/sub&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;I&lt;sub&gt;3&lt;/sub&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;디멀티플렉서demultiplexer&quot;&gt;디멀티플렉서(Demultiplexer)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/demultiplexer.png&quot; title=&quot;https://electricalfundablog.com/demultiplexer-demux/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/demultiplexer.png&quot; alt=&quot;&quot; title=&quot;디멀티플렉서&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;하나의 입력 정보&lt;/strong&gt;를 &lt;strong&gt;N개의 선택선&lt;/strong&gt;을 가지고 2&lt;sup&gt;N&lt;/sup&gt;개의 출력을 얻도록 구성&lt;br /&gt;
중앙 처리 장치에서 어떤 내용을 특정 장치로 출력시킬 때 많이 사용&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;S&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;S&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;0&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;1&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;2&lt;/sub&gt;&lt;/th&gt;
      &lt;th&gt;D&lt;sub&gt;3&lt;/sub&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;I&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;비교기comparator&quot;&gt;비교기(Comparator)&lt;/h3&gt;
&lt;p&gt;논리적으로 두 수를 비교한다면 ‘같다’, ‘같지 않다’만 판별하면 되므로 두 수 A, B를 &lt;strong&gt;XNOR 게이트로 연결&lt;/strong&gt;하여 1이 얻어지면 ‘같다’고 판별할 수 있다&lt;/p&gt;

&lt;p&gt;N비트 논리 비교기를 만들기 위해서는 XNOR 게이트 N개가 필요&lt;/p&gt;

&lt;h3 id=&quot;3-상태-버퍼tri-state-buffer&quot;&gt;3-상태 버퍼(Tri-State Buffer)&lt;/h3&gt;
&lt;p&gt;3가지 상태 중&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;의 상태는 전기적으로 &lt;strong&gt;하이 레벨(H)&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;의 상태는 &lt;strong&gt;로우 레벨(L)&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;또 다른 상태&lt;/code&gt;는 &lt;strong&gt;고 임피던스&lt;/strong&gt;(회로가 끊어진 상태) 상태를 의미한다.&lt;/p&gt;

&lt;p&gt;3-상태 버퍼 회로는 인에이블(1) 또는 디스에이블(0) 단자에 의하여 데이터의 &lt;strong&gt;전송 방향을 하드웨어적으로 제어&lt;/strong&gt;하는 데 사용&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-combinational-logic/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-combinational-logic/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[전자계산기] 논리 회로</title>
        <description>&lt;h2 id=&quot;불-대수&quot;&gt;불 대수&lt;/h2&gt;
&lt;p&gt;논리 회로를 분석하고 수학적으로 그 연산을 표현하고자 사용하는 대수식으로 논리 대수라고도 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;논리 변수 사이의 진리표를 대수 형식으로 표시&lt;/li&gt;
  &lt;li&gt;논리 변수를 조작하여 주어진 회로 기능을 수행하는데 있어 가장 간단한 회로를 결정하고자 사용&lt;/li&gt;
  &lt;li&gt;불 대수의 모든 변수는 0과 1의 값을 가질 수 있다&lt;/li&gt;
  &lt;li&gt;논리 회로의 입출력 관계를 대수 형식으로 표시&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;불 대수의 연산
    &lt;ul&gt;
      &lt;li&gt;논리 부정(NOT, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;￣&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;＇&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;논리곱(AND, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;·&lt;/code&gt; )&lt;/li&gt;
      &lt;li&gt;논리합(OR, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; )&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A + A = A&lt;/td&gt;
      &lt;td&gt;A · A = A&lt;/td&gt;
      &lt;td&gt;A · 0 = 0&lt;/td&gt;
      &lt;td&gt;A + 0 = A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A + 1 = 1&lt;/td&gt;
      &lt;td&gt;A · 1 = A&lt;/td&gt;
      &lt;td&gt;0 + 0 = 0&lt;/td&gt;
      &lt;td&gt;0 · 0 = 0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1 + 0 = 1&lt;/td&gt;
      &lt;td&gt;1 · 0 = 0&lt;/td&gt;
      &lt;td&gt;1 + 1 = 1&lt;/td&gt;
      &lt;td&gt;1 · 1 = 1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A + A·B = A&lt;/td&gt;
      &lt;td&gt;A·(A + B) = A&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;논리-게이트&quot;&gt;논리 게이트&lt;/h2&gt;
&lt;p&gt;논리 회로를 구성하는 기본 소자, 2진 정보를 취급하는 기본 논리 회로&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/logic-gate.png&quot; title=&quot;https://www.pinterest.co.kr/pin/674203006705758186/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/logic-gate.png&quot; alt=&quot;&quot; title=&quot;논리 게이트&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;AND&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 모두 1일 때만 1 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;OR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 모두 0일 때만 0 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;NOT&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 0이면 1을 출력하고 1이면 0을 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;NAND&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 모두 1일 때만 0 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;NOR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;입력 값이 모두 0일 때만 1 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;XOR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;A, B 입력 값이 서로 다를 때는 1 출력, 같을 때는 0 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;XNOR&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;A, B 입력 값이 서로 같을 때는 1 출력, 같을 때는 1 출력&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;결선-게이트&quot;&gt;결선 게이트&lt;/h2&gt;
&lt;p&gt;필요할 때 게이트의 선을 연결하고, 단절하고 &lt;strong&gt;조절함으로써 다양한 기능&lt;/strong&gt;을 할 수 있도록 만든 게이트를 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;게이트들의 출력 단자를 논리적으로 직접 연결하여 논리 기능을 발휘할 수 있도록 했다&lt;/li&gt;
  &lt;li&gt;회로 비용을 절감할 수 있다&lt;/li&gt;
  &lt;li&gt;하나의 인쇄기판보다 많은 논리 기능을 포함시킬 수 있다&lt;/li&gt;
  &lt;li&gt;Open Collector TTL(Transistor-Transistor Logic)로 게이트들의 출력 단자를 묶어서 사용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;불-대수에-의한-최소화&quot;&gt;불 대수에 의한 최소화&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;최소항&lt;/strong&gt; : 진리표상에서 결과가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;인 부분을 표시할 때 사용하는 방식으로 불식을 형성하는 입력 변수 모두를 포함하는 &lt;strong&gt;논리곱&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;·&lt;/code&gt;)으로 나타내는 경우를 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;최대항&lt;/strong&gt; : 진리표상에서 결과가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;인 부분을 표시할 때 사용하는 방식으로 불식을 형성하는 입력 변수 모두를 포함하는 &lt;strong&gt;논리합&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt;)으로 나타내는 경우를 의미&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;A   B&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;F&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;최소항&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;수치 표현&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0   0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0   1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1   0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1   1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A · B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;최소항의 합 표현은 위 표에서와 같이 결과가 1이 되는 부분만을 논리곱으로 표현하여 이 논리곱들을 논리합으로 연결하면 된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;최소항의 합&lt;/strong&gt; : F = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · B&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;수치 표현&lt;/strong&gt; : F(A, B) = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · B = $\Sigma(0,2,3)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불 대수식의 최소화&lt;/strong&gt;&lt;br /&gt;
F = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · B&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; · (&lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; + A) + A · B
= &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A · B&lt;br /&gt;
= (&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A) · (&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + B)&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; + A&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;입력(A, B, C)&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;출력&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;최소항&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;수치 표현&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0 0 0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0 0 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0 1 0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt; · B · &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0 1 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 0 0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A · &lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt; · &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 0 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 1 0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;A · B · &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1 1 1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;최소항의 합&lt;/strong&gt; : Y = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·B·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·B·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수치 표현&lt;/strong&gt; : Y(A, B, C) = $\Sigma(0, 2, 4, 6)$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불 대수식의 최소화&lt;/strong&gt;&lt;br /&gt;
Y = &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·B·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·B·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;·(&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;+B) + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;·(&lt;span style=&quot;text-decoration:overline&quot;&gt;B&lt;/span&gt;+B)&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;A&lt;/span&gt;·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt; + A·&lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;br /&gt;
= &lt;span style=&quot;text-decoration:overline&quot;&gt;C&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;카르노-맵karnaugh-map에-의한-최소화&quot;&gt;카르노 맵(Karnaugh Map)에 의한 최소화&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/electronic-calc/karnaugh-map.png&quot; title=&quot;https://www.eetimes.com/karnaugh-maps-101/&quot;&gt;&lt;img src=&quot;../../assets/images/electronic-calc/karnaugh-map.png&quot; alt=&quot;&quot; title=&quot;카르노 맵에 의한 최소화&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/electronic-calculator-logic-circuit/</link>
        <guid isPermaLink="true">https://many258.github.io/study/electronic-calculator-logic-circuit/</guid>
        
        <category>전자계산기</category>
        
        
        <category>study</category>
        
      </item>
    
  </channel>
</rss>
