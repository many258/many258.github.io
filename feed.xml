<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://many258.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://many258.github.io/" rel="alternate" type="text/html" /><updated>2021-03-22T15:28:38+09:00</updated><id>https://many258.github.io/feed.xml</id><title type="html">My LifeChronicle</title><subtitle>Be a Imagineer.</subtitle><author><name>SG Yoo.</name></author><entry><title type="html">[알고리즘/데이터보안] 블록체인(Block-Chain)</title><link href="https://many258.github.io/study/block-chain/" rel="alternate" type="text/html" title="[알고리즘/데이터보안] 블록체인(Block-Chain)" /><published>2021-03-21T00:00:00+09:00</published><updated>2021-03-22T15:37:34+09:00</updated><id>https://many258.github.io/study/%7Bblock-chain%7D</id><content type="html" xml:base="https://many258.github.io/study/block-chain/">&lt;h1 id=&quot;블록-체인&quot;&gt;블록 체인&lt;/h1&gt;
&lt;p&gt;관리 대상 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블록&lt;/code&gt;이라고 하는 소규모 데이터들이 P2P방식을 기반으로 모여 이룬 체인 연결고리 분산 데이터 저장 환경&lt;/p&gt;

&lt;p&gt;즉, 네트워크에 중앙 서버가 아닌 참여하는 모든 사용자가 모든 거래 내역 등을 공동으로 기록, 관리하여 데이터를 분산, 저장하는 기술을 의미&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/block-chain.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;
&lt;p&gt;편집이 불가능하고 추가 작업(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APPEND&lt;/code&gt;)만 가능한 데이터베이스&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;탈중앙화&lt;/code&gt;(Decentralization) 데이터베이스의 복제본을 모두가 소유하고 있기 때문에 개인의 위조를 방지할 수 있다&lt;/p&gt;

&lt;h2 id=&quot;블록의-구성&quot;&gt;블록의 구성&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/block-chain-element.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; width=&quot;120%&quot; height=&quot;120%&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;블록 헤더&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;블록의 정체성
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;비전&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;이전블록의 해시&lt;/strong&gt; : 현재 블록이 이전 블록과 연결되어 있음을 의미&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;타임스탬프&lt;/strong&gt; : 채굴 경쟁과 직접적 연관이 있는 부분&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;난이도 목표&lt;/strong&gt; : 채굴 경쟁과 직접적 연관이 있는 부분&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;논스&lt;/strong&gt;: 채굴 경쟁과 직접적 연관이 있는 부분&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;머클루트&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;거래 카운터&lt;/strong&gt; : 거래의 개수&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;거래&lt;/strong&gt; : 블록에 기록된 거래 내역&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해시&quot;&gt;해시&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/hash-algorithm.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;단방향 암호화, 결정론적&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;임의의 길이를 갖는 문자열을 입력받아 &lt;strong&gt;고정된 길이&lt;/strong&gt;의 해시 값을 출력하는 함수를 해시 함수라 하는데 이 함수로 인해서 출력된 값을 해쉬 값이라 부른다. 이 때 해쉬 값으로부터 기존 메시지를 역산할 수는 없는 성질을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단방향성&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;또한, 메시지가 다르면 비슷하다 할지라도 해시값도 다르다는 특징이 있는데 해당 특징으로 인해 해시 함수를 무결성을 확인하기 위한 방안으로 사용하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결정론적&lt;/code&gt;이다라는 의미는 해시 알고리즘은 특정 입력 대해 항상 같은 해시 값을 반환한다는 것을 뜻한다.&lt;/p&gt;

&lt;p&gt;일반적인 해싱 알고리즘은 MD4, MD5, SHA, RIPEMD, WHIRLPOOL, TIGER가 있다.&lt;/p&gt;

&lt;p&gt;이전 블록 해쉬 + 데이터 =&amp;gt; 자기 자신만의 블록 해쉬 값
이렇게 해쉬 값을 가지고 블록을 연결시킨다는 의미에서 체인이라는 단어를 사용하는 것이다.&lt;/p&gt;

&lt;p&gt;데이터가 조금이라도 변경된다면 해쉬값도 변경되고 그 이후 블록에도 영향을 미치기 때문에 올바른 체인을 생성할 수 없게 된다.&lt;/p&gt;

&lt;p&gt;블록체인을 사용하는 모든 사용자들이 같은 체인을 가지고 있으며, 각자의 체인을 비교함으로서 같은 체인인지 검증이 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;머클-루트merkle-root&quot;&gt;머클 루트(Merkle Root)&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/merkle-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이진트리라는 이름으로도 알려져 있으며,&lt;/p&gt;

&lt;p&gt;두 개씩 거래를 묶은 다음 해싱 알고리즘을 통해 해시 값으로 나타내고 또 그렇게 묶은 값들을 다시 두 개씩 묶어서 다시 해싱하여 수 백개의 거래 값들을 가장 꼭대기에 위치한 하나의 데이터로 만들어준다.&lt;/p&gt;

&lt;p&gt;이렇게 이진트리 방식으로 구성하게되면 거래량이 기하급수적으로 늘어나도 특정 거래를 찾는 경로는 단순하다는 이점이 있다. 그렇기에 거래 내역을 위조하려는 시도가 있어도 머클트리의 경로를 따라가면 해시값이 다른 것이 나오게 되어 거래의 위변조도 쉽고 빠르게 알 수 있게 되고 이를 방지할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;종류&quot;&gt;종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;퍼블릭 블록체인&lt;/strong&gt;(Public BlockChain)&lt;br /&gt;
개방형 블록체인으로 누구나 트랜잭션을 생성할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프라이빗 블록체인&lt;/strong&gt;(Private BlockChain)&lt;br /&gt;
폐쇠형 블록체인으로 주로 기업에서 사용하기에 엔터프라이즈 블록체인(Enterprise BlockChain)이라고도 한다.서비스 제공자의 승인을 받아야만 참여가 가능한 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;콘소시엄 블록체인&lt;/strong&gt;(Consortium BloackChain)&lt;br /&gt;
프라이빗 블록체인을 확장한 방식으로 여러 기업또는 기관이 공동으로 참여한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;작업증명pow--proof-of-work&quot;&gt;작업증명(PoW : Proof of Work)&lt;/h2&gt;
&lt;p&gt;모든 블록(노드)가 포함된 거래 내역이 악의적인 공격자에 의해 변조되지 않은 올바른 블록체인을 공유하는 있다는 것을 입증하기 위해 P2P 네트워크, 공개키-개인키 암호, 공유된 데이터베이스에 정보를 저장하고 검증하는 방법을 관리하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;합의 알고리즘&lt;/code&gt;(Consensus Mechanism)이라는 것을 활용하는데 여러 종류 중에서도 비트코인의 경우 PoW(작업증명 : Proof of Work)라는 합의 알고리즘을 사용한다.&lt;/p&gt;

&lt;p&gt;블록체인은 이와 같은 요소 기술들을 결합해 네트워크 상에서 투명성을 확보하며 데이터의 위조/변조 방지 및 보안성을 강화한 기술이다&lt;/p&gt;

&lt;h2 id=&quot;마이닝mining&quot;&gt;마이닝(Mining)&lt;/h2&gt;
&lt;p&gt;PoW란 컴퓨팅 파워를 이용해 블록의 해쉬 값을 추적하여 블록체인 네트워크에 새로운 블록을 추가하는 방식의 알고리즘이다&lt;/p&gt;

&lt;p&gt;위 과정이 채굴(Mining)에 해당한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/security/block-chain/dodge-mining.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;비트코인의 경우 
채굴자가 네트워크에 새로운 블록들을 추가할 때 마다 받을 수 있으며
새로운 블록들을 추가하기 위해서는 네트워크의 질문에 원하는 답을 찾아서 논스 값을 변경해야 한다.&lt;/p&gt;

&lt;p&gt;논스(Nonce)는 채굴자가 변경할 수 있는 유일한 값이며 Nonce 값을 변경할 때 마다 해쉬 값이 달라지는데, 채굴자는 그중에서도 현재 난이도에 맞춰서 네트워크가 던지는 질문에 적절한 값을 가지는 해쉬를 만들어내야 한다.&lt;/p&gt;

&lt;h2 id=&quot;활용&quot;&gt;활용&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;암호화폐 거래&lt;/li&gt;
  &lt;li&gt;ICO(Initial Coin Offering)&lt;/li&gt;
  &lt;li&gt;NFT(Non-Fungible Token)&lt;/li&gt;
  &lt;li&gt;DEX(Decebtrakuzed Exchange)&lt;/li&gt;
  &lt;li&gt;스마트 컨트랙트(Smart Contract)
    &lt;blockquote&gt;
      &lt;p&gt;사전에 정해진 임의의 규칙에 따라 디지털 자산을 자동적으로 이전하는 시스템 - Vitalik Buter&lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;블록체인이 지니고 있는 탈중앙화를 기반으로 금융거래, 부동산 계약, 공증 등 다양한 형태의 계약을 체결하고 이행하는 것. (블록체인 2.0)&lt;/li&gt;
      &lt;li&gt;다른사람들과의 교류와 코드로 소통이 가능하며 또한 공유 네트워크에 업로드할 수 있다&lt;/li&gt;
      &lt;li&gt;수정은 불가하나 공유/검증/실행은 가능하다&lt;/li&gt;
      &lt;li&gt;원하는 소스를 다 활용할 수 없음(블록체인 네트워크 위에서만 실행 가능)&lt;/li&gt;
      &lt;li&gt;신뢰 기반이 아닌 특수한 네트워크, 환경을 요구&lt;/li&gt;
      &lt;li&gt;스마트 컨트랙 지원 암호화폐&lt;br /&gt;
이더리움, Kusama, Polkadot, Cardano, Cosmos&lt;/li&gt;
      &lt;li&gt;개발자들은 이더리움 상에서 스마트 컨트랙트를 활용하여 암호화폐 지갑, 금융 애플리케이션, 마켓, 게임과 같이 새로운 종류의 탈중앙화된 애플리케이션(DApps)을 개발할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;단점&quot;&gt;단점&lt;/h2&gt;
&lt;p&gt;블록체인 네트워크는 그 특성상 노드의 신뢰를 기반으로 하기 때문에, 신뢰가 무너지는 순간 블록체인 역시 급격하게 무너질 수 있다는 치명적인 맹점이 있다.&lt;/p&gt;

&lt;p&gt;또한 참여하는 노드 수(분산되어 데이터를 저장되는 주체의 수)가 매우 적을 경우에 외부 공격자와 침입에 취약하다&lt;/p&gt;

&lt;p&gt;탈중앙화, 보안성, 확장성의 문제로 이 세 가지 문제 중 어떠한 두 가지는 만족시킬 수 있지만, 남은 한 가지는 만족시킬 수 없는 트릴레마의 문제가 있으며 이 문제를 보완하기 위해 사이드체인, 샤딩, 인터체인, 라이트닝 네트워크, 플라즈마 기술이 있다.&lt;/p&gt;

&lt;h1 id=&quot;레퍼런스&quot;&gt;레퍼런스&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.banksalad.com/contents/%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%98%EB%8A%94-%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8-%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC-Merkle-Trees-%EB%9E%80-ilULl&quot;&gt;블록체인-개념-완벽-정리(뱅크샐러드)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://brownbears.tistory.com/372&quot;&gt;머클트리란? - 불곰님 티스토리 블로그&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kiri.or.kr/pdf/%EC%97%B0%EA%B5%AC%EC%9E%90%EB%A3%8C/%EC%97%B0%EA%B5%AC%EB%B3%B4%EA%B3%A0%EC%84%9C/nre2018-24_02.pdf&quot;&gt;블록체인의 이해&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Ca7Meu4z-F4&quot;&gt;노마드 코더 유튜브&lt;/a&gt;&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="Algorithm" /><category term="데이터 보안" /><summary type="html">블록 체인 관리 대상 데이터를 블록이라고 하는 소규모 데이터들이 P2P방식을 기반으로 모여 이룬 체인 연결고리 분산 데이터 저장 환경</summary></entry><entry><title type="html">[배민커넥트] 도보로 시작하기 및 주의사항과 소소한팁</title><link href="https://many258.github.io/life/baemin-connect/" rel="alternate" type="text/html" title="[배민커넥트] 도보로 시작하기 및 주의사항과 소소한팁" /><published>2021-03-20T00:00:00+09:00</published><updated>2021-03-20T20:37:34+09:00</updated><id>https://many258.github.io/life/%7Bbaemin-connect%7D</id><content type="html" xml:base="https://many258.github.io/life/baemin-connect/">&lt;h1 id=&quot;개요&quot;&gt;개요&lt;/h1&gt;
&lt;p&gt;몸이 굳어있던 추운 계절이 지나고 나들이나 운동을 하기 좋은 계절이 오고 있습니다.&lt;br /&gt;
하지만 코로나의 영향으로 아직까지는 헬스장을 가는게 꺼려지는 것은 제 주관적이지만 솔직히 말해서 사실입니다.&lt;/p&gt;

&lt;p&gt;이 때, 배민커넥트를 시작하기에 최적의 시기라고 생각합니다.&lt;/p&gt;

&lt;p&gt;필자는 걷는 것을 좋아해서 작년 여름에 주변 지인의 추천으로 배민 커넥트에 입문하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/life/baemin-connect_feature.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간단히 말해, 내가 원하는 시간에 운동과 동시에 부수입을 얻을 수 있다는 것이 배민커넥트의 최대 장점이라 할 수 있겠습니다&lt;/p&gt;

&lt;p&gt;마지막 이유로 현재 진행중인 친구초대 이벤트를 후술하겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;도보로-시작하기&quot;&gt;도보로 시작하기&lt;/h1&gt;

&lt;p&gt;다른 수단들과 비교하여 별다른 준비 없이 핸드폰, 보온가방, 튼튼한 두 다리만 있다면 가능하지만, 만약 ‘나는 수입이 목적이에요~’라는 사람이 있다면 권유는 드리지 않습니다.&lt;/p&gt;

&lt;p&gt;커넥트의 장점은 내가 &lt;strong&gt;원하는 시간&lt;/strong&gt;에 할 수 있다는 것이지, 수입을 목적으로 하기엔 어려운 면이 있습니다. 아무래도 당일 &lt;strong&gt;주문의 양&lt;/strong&gt;에 따라 그 날 수입이 들쑥날쑥하고 한 건당 &lt;strong&gt;시간 소요가 크기 때문에&lt;/strong&gt; 안타깝게도 어떤 날은 최저시급으로 계산한 것 보다 적게 지급받을 수도 있습니다.&lt;/p&gt;

&lt;p&gt;가방과 보조장비들은 우아한스토어에서 구매(가방만 구매시 26,400원)를 하시거나 중고 마켓을 이용하는 것도 방법 중 하나입니다.&lt;/p&gt;

&lt;p&gt;또한 매주 배송할 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;20시간&lt;/code&gt;으로 제한되어 있으며 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수요일&lt;/code&gt;에 초기화되며 가장 중요한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정산&lt;/code&gt;은 별다른 공지가 없으면 매주 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;금요일&lt;/code&gt;에 진행됩니다. 정산의 경우 한 건 이상을 배달을 수행하였다면, 약 3천원 정도의 &lt;strong&gt;산재보험료&lt;/strong&gt;가 부과된다는 점 알고 계시기 바랍니다.&lt;/p&gt;

&lt;p&gt;마지막으로 산업안전보건법에 따라 &lt;strong&gt;PC&lt;/strong&gt;에서 &lt;strong&gt;2시간&lt;/strong&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안전보건교육&lt;/code&gt; 이수 후에 첫 배달을 시작할 수 있습니다.&lt;/p&gt;

&lt;p&gt;무엇보다도 뚜벅이 커넥터일지라도 &lt;strong&gt;안전&lt;/strong&gt;이 &lt;strong&gt;최우선&lt;/strong&gt;으로 중요합니다!&lt;/p&gt;

&lt;h2 id=&quot;배송-과정&quot;&gt;배송 과정&lt;/h2&gt;
&lt;p&gt;처음 시도하는 입장에서 까다로울 것 같지만 한 두번 해보게 되면 전혀 어렵지않습니다.&lt;/p&gt;

&lt;p&gt;주문을 받는 시스템으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;일반 배차&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AI배차&lt;/code&gt;가 있으며&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;일반 배차&lt;/strong&gt;의 경우 실시간으로 주문(콜)이 올라오며 커넥터가 이 콜을 직접 선택하는 방식이고&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AI배차&lt;/strong&gt;의 경우 AI가 경로를 파악하며 고객에게 예정 시간에 배달이 가능한지 등을 종합적으로 고려해서 특정 배달 주문을 수행하기에 가장 적합한 위치의 커넥터에게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선적&lt;/code&gt;으로 콜을 보내는 방식입니다. 이 때, 약 30초간 선택할 수 있는 시간이 주어지고 시간이 초과될 때까지 결정을 못했다면 다른 커넥터/라이더에게 주문이 넘어갑니다.&lt;/p&gt;

&lt;p&gt;필자는 다른 커넥터/라이더들과 경쟁으로 인해 빨리빨리 콜을 잡아햐하는 일반배차보다 품목을 세부적으로 꼼꼼히 확인할 수 있는 &lt;strong&gt;AI배차&lt;/strong&gt;를 더 추천하는 바입니다.&lt;/p&gt;

&lt;p&gt;실제 배송 과정은 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;신규배달&lt;/code&gt; 알림이 도착한다(AI배차로 선택한 경우)&lt;/li&gt;
  &lt;li&gt;알림을 눌러 배송가능한 품목들인지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;확인&lt;/code&gt;을 한다&lt;/li&gt;
  &lt;li&gt;가능할 것 같다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;승낙&lt;/code&gt;을 누르고 다음 단계로, 어려울 것 같다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;거절&lt;/code&gt;을 누르고 1단계로 다시 돌아가 알림올 때까지 기다린다.&lt;/li&gt;
  &lt;li&gt;매장까지 이동하고 매장에 도착했다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;매장도착&lt;/code&gt; 버튼을 누른다&lt;/li&gt;
  &lt;li&gt;음식/물품이 완료될 때 까지 기다리고 주문번호 확인 후 받았으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;픽업완료&lt;/code&gt;를 누른다&lt;/li&gt;
  &lt;li&gt;고객에게 이동한 후 음식/물품을 건내주고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전달완료&lt;/code&gt;를 누른다&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;embed-responsive embed-responsive-16by9&quot;&gt;
  &lt;iframe class=&quot;embed-responsive-item&quot; width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/r3PXvZ6CxUI&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;

&lt;p class=&quot;align-center&quot;&gt;&lt;br /&gt;&lt;br /&gt;
자세한 사항은 &lt;a href=&quot;http://www.baeminriders.kr/connect/&quot;&gt;배민커넥트 홈페이지&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;주의-사항&quot;&gt;주의 사항&lt;/h2&gt;
&lt;h3 id=&quot;핸드폰은-생명이나-다름-없다&quot;&gt;핸드폰은 생명이나 다름 없다&lt;/h3&gt;
&lt;p&gt;핸드폰이 방전되었다면 사실상 할 수 있는 것이 없습니다.&lt;/p&gt;

&lt;p&gt;가능하다면 필히 &lt;strong&gt;보조배터리&lt;/strong&gt;를 소지하고 다니고 만약 고장이 난 경우,
주변 사람들의 도움을 받아 배달의 민족 고객센터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1600-9880&lt;/code&gt;으로 
연락 후 조치를 취하는 것이 가장 현명한 방법이라 생각합니다.&lt;/p&gt;

&lt;h3 id=&quot;모든-항목을-꼼꼼히-검토한다-욕심은-금물&quot;&gt;모든 항목을 꼼꼼히 검토한다. 욕심은 금물&lt;/h3&gt;
&lt;p&gt;배송 중에는 단지 힘들다고 또는 거리가 멀다고 중간에 그만두거나 배송 &lt;strong&gt;취소하기가 상당히 어렵습니다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;그래서, 항!상! 품목을 확인하고 내가 배송을 갈 수 있는 것인지 아닌지 판단하고 행동하는 것이 중요합니다. 자유에는 책임이 따른다는 명언이 생각나네요&lt;/p&gt;

&lt;p&gt;또한 &lt;strong&gt;고객요청사항&lt;/strong&gt; 중에 특히나 벨을 울리지 말아달라는 요청도 많으니 이 점 확실하게 유의해주셔야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;면국물-요리는-자신이-있을-때-잡자&quot;&gt;면/국물 요리는 자신이 있을 때 잡자&lt;/h3&gt;
&lt;p&gt;면/국물 요리는 특히 시간이 생명이라는 거 잘 알고 계실거라 생각됩니다.&lt;/p&gt;

&lt;p&gt;도보커넥터들은 보통 다른 운송수단보다 상대적으로 시간이 더 소요되기 때문에 보온/보냉가방을 사용하고 있고 거리가 가까운 경우가 아니라면 다른 커넥터/라이더 분께 양보해드리는 게 더 좋을 것 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;현금카드-결제는-미리-확인하자&quot;&gt;현금/카드 결제는 미리 확인하자&lt;/h3&gt;
&lt;p&gt;비마트의 경우에는 무조건 선결제로 이뤄지지만 일반 매장일 경우 현금이나 카드로 결제를 신청하는 분들이 꽤 있으십니다.&lt;/p&gt;

&lt;p&gt;그러므로, 배송수락 전 잔돈이 있는지 확인하는 것을 습관화합시다.&lt;/p&gt;

&lt;h3 id=&quot;손님에게-직접-건네주지-않는-한-사진을-꼭-찍어두자&quot;&gt;손님에게 직접 건네주지 않는 한 사진을 꼭 찍어두자&lt;/h3&gt;
&lt;p&gt;코로나로 인해 직접 대면하여 음식/물건을 전달하는 것보다 ‘집 앞에 놓아주세요’라고 요청하는 고객님들이 부쩍 늘었습니다.&lt;/p&gt;

&lt;p&gt;어플 기능 중에 고객에게 사진 전송하는 기능이 있는데 실제로 고객님이 사용하는 어플에 푸쉬알림으로 전해지게 됩니다.
혹여나 음식이나 물건을 전달받았음에도 불구하고 받지 못했다고 클레임을 진행하는 고객이 있을 수도 있으니(한번도 만나보지 못했지만..) 배송업무를 끝내고 증거(?)로 남겨두는 목적입니다.&lt;/p&gt;

&lt;h2 id=&quot;미세한-팁들&quot;&gt;미세한 팁들&lt;/h2&gt;
&lt;h3 id=&quot;거점을-정하자&quot;&gt;거점을 정하자&lt;/h3&gt;
&lt;p&gt;배민커넥트 카카오톡 플러스친구에서는 주마다 어느 지역에 배달이 많았는지 분포도로 알려주고 있습니다.&lt;/p&gt;

&lt;p&gt;이를 참고하여 어느 지점을 타겟팅을 할 것인지 &lt;strong&gt;개방화장실&lt;/strong&gt;의 위치정도는 미리 파악해두는 것이 도움이 될 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;점심시간과-저녁시간이-피크타임&quot;&gt;점심시간과 저녁시간이 피크타임&lt;/h3&gt;
&lt;p&gt;가능하면 시간대를 12시 ~ 2시, 6시 ~ 8시로 움직이는 것을 추천합니다.&lt;/p&gt;

&lt;p&gt;이 때가 가장 주문이 많은 편이며 각종 프로모션으로 배송비도 또한 많이 오르는 편입니다.&lt;/p&gt;

&lt;h3 id=&quot;휴식할-곳을-미리-파악하자&quot;&gt;휴식할 곳을 미리 파악하자&lt;/h3&gt;
&lt;p&gt;뚜벅이 커넥터들은 항상 다리가 아픕니다.&lt;/p&gt;

&lt;p&gt;배송이 끝난 후 남는 시간에 미리미리 휴식할 장소(특히 공원 벤치)을 찾아 체력을 비축해두는 것을 추천합니다.&lt;/p&gt;

&lt;h3 id=&quot;만보기-어플을-이용하자&quot;&gt;만보기 어플을 이용하자&lt;/h3&gt;
&lt;p&gt;우리의 목표는 운동과 부수입이라는 두 마리 토끼를 잡는 것입니다.&lt;/p&gt;

&lt;p&gt;이 만보기나 헬스케어 어플은 운동을 시각화해줌으로써 목표를 달성하면 하루의 보람을 느끼게 해주기도 하고 다음 날에도 계속 커넥트를 할 수 있게 끔 추진력과 원동력을 만들어 주기에 많은 도움을 줍니다.&lt;/p&gt;

&lt;h3 id=&quot;웨어러블-장비를-마련하자&quot;&gt;웨어러블 장비를 마련하자&lt;/h3&gt;
&lt;p&gt;이건 진짜 알려주기 싫을 정도로 꿀정보라고 할 수 있는데 필자는 현재 미밴드를 착용하면서 커넥트를 하고 있습니다.&lt;/p&gt;

&lt;p&gt;미밴드 뿐만 아니라 다른 스마트워치에도 대부분 존재하는 기능 중에 따로 지정한 어플에서 푸쉬알림이 오면 진동으로 알려주는 시스템이 있는데, 이 때, 핸드폰을 굳이 보고있지 않아도 알림이 오면 손목에서 진동으로 자칫 못보고 넘어갈 수 있는 알림을 알려주니까 확인하기 편해서 강력히 추천드립니다.&lt;/p&gt;

&lt;h1 id=&quot;마치며&quot;&gt;마치며..&lt;/h1&gt;
&lt;p&gt;앞서 말씀드린 것처럼 배민에서는 친구초대 이벤트를 현재 진행중입니다.&lt;/p&gt;

&lt;p&gt;기존 이벤트의 경우 추천인 코드를 입력한 사람이 배송임무를 진행할 경우, 추천받은 사람과 추천한 사람 모두 1만원을 제공하였으나 금일부로(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3월20일&lt;/code&gt;) 2만원으로 인상되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/life/baemin-connect.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이번에 한시적으로 진행하므로 이 기회에 지인과 함께 하시거나 저의 추천인코드(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BC642005&lt;/code&gt;)와 한 번 도전해보시는 것도 좋은 선택이라 생각됩니다.&lt;/p&gt;

&lt;p&gt;포스팅을 하는 지금 당장 생각나는 내용들은 이것으로 마무리하겠습니다.&lt;br /&gt;
블로그를 운영하지 얼마 지나지 않았고 글을 쓰는 재주도 없는 터라 많은 도움이 되셨는지는 모르겠습니다.&lt;/p&gt;

&lt;p&gt;그 밖에도 궁금하신 내용이나 질문들은 제가 경험한 선에서 답해드릴 수 있으니 좌측이나 우측에 있는 &lt;strong&gt;카카오톡 오픈톡방&lt;/strong&gt; 링크로 문의부탁드리겠습니다.&lt;/p&gt;

&lt;p&gt;감사합니다 XD&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="life" /><category term="배민커넥트" /><summary type="html">개요 몸이 굳어있던 추운 계절이 지나고 나들이나 운동을 하기 좋은 계절이 오고 있습니다. 하지만 코로나의 영향으로 아직까지는 헬스장을 가는게 꺼려지는 것은 제 주관적이지만 솔직히 말해서 사실입니다.</summary></entry><entry><title type="html">[알고리즘] 최소신장트리(MST)와 그래프의 순회(Graph Traversal)</title><link href="https://many258.github.io/study/algorithm-MST-graph-traversal/" rel="alternate" type="text/html" title="[알고리즘] 최소신장트리(MST)와 그래프의 순회(Graph Traversal)" /><published>2021-03-19T00:00:00+09:00</published><updated>2021-03-19T22:37:34+09:00</updated><id>https://many258.github.io/study/%7Balgorithm-MST-graph-traversal%7D</id><content type="html" xml:base="https://many258.github.io/study/algorithm-MST-graph-traversal/">&lt;h1 id=&quot;신장-트리spanning-tree&quot;&gt;신장 트리(Spanning Tree)&lt;/h1&gt;
&lt;p&gt;그래프 내의 모든 정점을 포함하는 트리&lt;br /&gt;
최소 연결 부분 그래프.&lt;/p&gt;

&lt;p&gt;N개의 정점을 가지는 그래프의 최소 간선의 수는 N-1개이며, N-1개의 간선으로 연결되어 있으면 필연적으로 트리 형태가 이루어지고 이것이 바로 Spanning Tree라 할 수 있다.&lt;/p&gt;

&lt;p&gt;하나의 그래프에는 많은 신장 트리가 존재할 수 있으며, 트리의 특수한 형태이므로 모든 정점들이 연결되어 있어야 하고 사이클을 &lt;strong&gt;포함해서는 안된다&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;최소-신장트리mst--minimum-spanning-tree&quot;&gt;최소 신장트리(MST : Minimum Spanning Tree)&lt;/h2&gt;
&lt;p&gt;가능한 신장트리에서 간선의 가중치 합이 최소인 신장트리를 의미&lt;/p&gt;

&lt;p&gt;최소 비용 신장 트리를 구하는 방법들은 모두 &lt;strong&gt;탐욕 알고리즘&lt;/strong&gt;(Greedy Algorithm)으로 구현&lt;/p&gt;

&lt;p&gt;** 탐욕 알고리즘 : 각 단계에서 최선의 선택이 최종 단계에서도 최선의 결과를 나타낼 것이라고 생각하는 알고리즘&lt;/p&gt;

&lt;h2 id=&quot;크루스칼-알고리즘kruskals-algorithm&quot;&gt;크루스칼 알고리즘(Kruskal’s Algorithm)&lt;/h2&gt;
&lt;p&gt;간선 위주의 알고리즘.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;모든 간선들의 가중치를 오름차순으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정렬&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;가중치가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소&lt;/code&gt;인 간선을 선택&lt;/li&gt;
  &lt;li&gt;위에서 선택한 간선이 연결하려는 2개의 노드가 서로 연결되지 않은 상태라면, 2개의 노드를 서로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연결&lt;/code&gt;(이 때, &lt;strong&gt;사이클이 발생하지 않도록 주의&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;최소신장트리가 만들어지기 전까지 2~3 과정 반복 수행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그래프 내 간선의 개수가 적은 &lt;strong&gt;희소 그래프&lt;/strong&gt;의 경우 크루스칼 알고리즘에 적합하다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/algorithm/graph/KruskalAlg.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프림-알고리즘prims-algorithm&quot;&gt;프림 알고리즘(Prim’s Algorithm)&lt;/h2&gt;
&lt;p&gt;정점 위주의 알고리즘&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;임의의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정점&lt;/code&gt;을 선택&lt;/li&gt;
  &lt;li&gt;정점에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인접&lt;/code&gt;한 간선 중 가중치가 최소인 간선으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연결&lt;/code&gt;된 정점을 선택&lt;/li&gt;
  &lt;li&gt;위 정점에서 다시 최소 간선으로 연결된 정점을 선택&lt;/li&gt;
  &lt;li&gt;최소신장트리가 만들어지기 전까지 2-3 과정 반복 수행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;그래프 내 간선의 개수가 많은 &lt;strong&gt;밀집 그래프&lt;/strong&gt;의 경우 프림 알고리즘이 적합하다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/algorithm/graph/PrimAlg.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;그래프의-순회graph-traversal&quot;&gt;그래프의 순회(Graph Traversal)&lt;/h1&gt;
&lt;p&gt;하나의 정점에서 시작하여 그래프에 있는 모든 정점을 한번씩 방문하는 것을 그래프 순회 또는 탐색이라 한다&lt;/p&gt;

&lt;h2 id=&quot;dfs깊이-우선-탐색--depth-first-search&quot;&gt;&lt;strong&gt;DFS&lt;/strong&gt;(깊이 우선 탐색 : Depth-First Search)&lt;/h2&gt;
&lt;p&gt;아직 방문하지 않은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자식&lt;/code&gt; 노드를 우선적으로 탐색&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;정점 i를 방문한다.&lt;/li&gt;
  &lt;li&gt;정점 i에 인접한 정점 중에서 아직 방문하지 않은 정점이 있으면 이 정점을 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;STACK&lt;/code&gt;에 저장한다&lt;/li&gt;
  &lt;li&gt;스택에서 정점을 삭제하여 새로운 i를 설정하고 다시 1단계부터 수행&lt;/li&gt;
  &lt;li&gt;스택이 공백이 되면 연산을 종료&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/algorithm/graph/DFS.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;특징&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;현 경로상의 노드만을 기억하면 되므로 저장 공간의 수요가 비교적 적지만, 한 경로가 무한히 깊을 경우 &lt;strong&gt;오버플로우&lt;/strong&gt;가 발생할 수 있다.&lt;br /&gt;
이를 방지하기 위해, 깊이에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제한&lt;/code&gt;을 두고 구현이 필요하다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;목표에 &lt;strong&gt;도달하지 못할 가능성이 존재&lt;/strong&gt;하며, 도달할지라도 해당 경로가 &lt;strong&gt;최단 경로라고 보장할 수 없다&lt;/strong&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bfs너비-우선-탐색--breadth-first-search&quot;&gt;&lt;strong&gt;BFS&lt;/strong&gt;(너비 우선 탐색 : Breadth-First Search)&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;형제&lt;/code&gt; 노드를 우선적으로 탐색하는 기법&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;임의의 시작 노드를 정해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QUEUE&lt;/code&gt;에 넣는다&lt;/li&gt;
  &lt;li&gt;Dequeue연산을 통해 큐에서 노드를 가져와 현재 노드로 정한다&lt;/li&gt;
  &lt;li&gt;현재 노드의 인접 노드 목록을 순회하면서 방문하지 않은 노드가 있는지 확인한다&lt;/li&gt;
  &lt;li&gt;방문하지 않은 노드가 있다면 그 노드를 큐에 넣고 방문한다.&lt;/li&gt;
  &lt;li&gt;큐가 공백이 될 때까지 2~4과정을 반복 수행&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/algorithm/graph/BFS.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;특징&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;큐에 다음에 탐색할 정점들을 저장해야 하므로 &lt;strong&gt;저장공간이 많이 필요&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;단순 검색속도가 DFS보다 빠르다&lt;/li&gt;
      &lt;li&gt;최단 경로를 보장함과 동시에 &lt;strong&gt;반드시 찾을 수 있다&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="Algorithm" /><category term="컴퓨터일반" /><category term="Programming" /><summary type="html">신장 트리(Spanning Tree) 그래프 내의 모든 정점을 포함하는 트리 최소 연결 부분 그래프.</summary></entry><entry><title type="html">[자료구조] 트리의 종류 및 특징</title><link href="https://many258.github.io/study/data-structure-tree-type/" rel="alternate" type="text/html" title="[자료구조] 트리의 종류 및 특징" /><published>2021-03-19T00:00:00+09:00</published><updated>2021-03-19T20:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdata-structure-tree-type%7D</id><content type="html" xml:base="https://many258.github.io/study/data-structure-tree-type/">&lt;h1 id=&quot;트리의-종류&quot;&gt;트리의 종류&lt;/h1&gt;
&lt;h2 id=&quot;이진-트리binary-tree&quot;&gt;이진 트리(Binary Tree)&lt;/h2&gt;
&lt;p&gt;기본적으로 자식노드를 최대 2개 가지는 트리를 의미&lt;/p&gt;

&lt;h3 id=&quot;완전-이진-트리complete-binary-tree&quot;&gt;완전 이진 트리(Complete Binary Tree)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;왼쪽&lt;/code&gt; 자식노드부터 채워지며 마지막 레벨을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제외&lt;/code&gt;하고는 모든 자식노드가 채워져있는 트리&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/complete-binary-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;힙heap&quot;&gt;힙(Heap)&lt;/h4&gt;
&lt;p&gt;부모 자식 노드 간의 대소 관계는 정의되어 있으나 형제간의 대소관계는 정의되어 있지 않은 완전 이진트리 자료구조를 의미&lt;/p&gt;

&lt;p&gt;힙에는 두가지 종류가 있으며, 부모노드의 키값이 자식노드의 키값보다 항상 큰 힙을 ‘최대 힙’, 부모노드의 키값이 자식노드의 키값보다 항상 작은 힙을 ‘최소 힙’이라고 명명한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/heap.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;포화-이진-트리perfect-binary-tree&quot;&gt;포화 이진 트리(Perfect Binary Tree)&lt;/h3&gt;
&lt;p&gt;모든 노드가 0 or 2개의 자식노드를 가지며 모든 리프노드가 똑같은 레벨에 있는 경우의 트리&lt;/p&gt;

&lt;p&gt;레벨의 수를 N이라 가정할 때, 2&lt;sup&gt;n&lt;/sup&gt;-1 개의 노드를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/perfect-binary-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;정-이진-트리full-binary-tree&quot;&gt;정 이진 트리(Full Binary Tree)&lt;/h3&gt;
&lt;p&gt;모든 노드가 0 or 2개의 자식노드를 가지는 트리를 의미&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/full-binary-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;편향-이진-트리skewed-binary-tree&quot;&gt;편향 이진 트리(Skewed Binary Tree)&lt;/h3&gt;
&lt;p&gt;노드들이 전부 한 방향으로 편향된 트리를 의미&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/skewed-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;이진-탐색-트리bst--binary-search-tree&quot;&gt;이진 탐색 트리(BST : Binary Search Tree)&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이진트리&lt;/code&gt;의 구조와 자료의 검색/삭제/삽입에 효율적이게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정렬&lt;/code&gt;의 개념이 추가된 형태&lt;/p&gt;

&lt;p&gt;기본적인 특징은 이진 트리와 같지만 하나 다른 점은 자기 왼쪽에는 자신보다 값이 작은 노드가, 오른쪽에는 자신보다 값이 큰 노드가 존재해야 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;중회 순회(Inorder) 시 순차적으로 데이터가 정렬된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자가-균형-이진-탐색-트리self-balancing-binary-search-tree&quot;&gt;자가 균형 이진 탐색 트리(Self-Balancing Binary Search Tree)&lt;/h2&gt;
&lt;p&gt;이진 탐색트리는 저장과 검색에 평균 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logN&lt;/code&gt;시간이 소요되지만 편향으로 구성되어있거나 균형이 무너지면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;에 근접한 시간이 소요될 수 있다.&lt;/p&gt;

&lt;p&gt;그래서, 고안해낸 것이 균형잡힌 이진탐색트리이다. 대표적으로 AVL트리와 레드블랙트리가 있으며 최악의 경우에도 이진트리의 균형이 잘 맞도록 유지한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AVL트리는 더욱 엄격한 균형을 이루고 있기 때문에 Red-Black 트리보다 더 빠른 검색을 제공&lt;/li&gt;
  &lt;li&gt;Red-Black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어지지 않기 때문에 AVL트리보다 빠르게 삽입/제거 작업을 수행&lt;/li&gt;
  &lt;li&gt;AVL트리는 각 노드에 대해 BF를 저장하므로 노드 당 int 저장이 필요
Red-Black 트리는 노드당 1bit의 정보만 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;avl-트리&quot;&gt;AVL 트리&lt;/h3&gt;
&lt;p&gt;스스로 균형을 잡는 이진 탐색 트리&lt;/p&gt;

&lt;p&gt;검색/삽입/삭제 평균과 최악의 경우 O(log N)의 시간복잡도를 가지며,&lt;br /&gt;
노드가 삽입 또는 삭제될 때 회전을 통해 트리를 재구성하여 높이 균형 성질을 유지시킨다&lt;/p&gt;

&lt;p&gt;균형인수(BF : Balance Factor)를 구성하며 왼쪽과 오른쪽 서브트리의 높이 차를 나타낸다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BF = hL - hR&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;값이 -1, 0, 1일 때만 균형있는 트리라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/AVL_Tree.gif&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;레드블랙-트리rb-tree--red-black-tree&quot;&gt;레드블랙 트리(RB Tree : Red-Black Tree)&lt;/h3&gt;
&lt;p&gt;레드-블랙 트리는 자료의 삽입과 삭제, 검색에서 최악의 경우에도 일정한 실행 시간을 보장한다.&lt;br /&gt;
이는 실시간 처리와 같은 실행 시간이 중요한 경우에 유용하며 일정한 실행 시간을 보장하는 다른 자료구조(대표적으로 STL의 Map)를 만드는 데에도 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/red-black-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RB Tree는 다음과 같은 특성을 가진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;각 모든 노드는 레드 or 블랙 색상을 갖는다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Root Property&lt;br /&gt;
트리의 루트는 항상 블랙이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;External Property&lt;br /&gt;
모든 리프 노드(NIL)들은 블랙이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Internal Property&lt;br /&gt;
노드가 레드이면 그 노드의 자식은 반드시 블랙이다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Depth Property&lt;br /&gt;
특정 노드에서 아래에 있는 모든 NULL 노드까지의 경로에서 만나는 블랙 색상의 노드의 수가 동일하다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;다원-탐색-트리-mst--m-way-search-tree&quot;&gt;다원 탐색 트리 (MST : M-way Search Tree)&lt;/h2&gt;
&lt;p&gt;균형을 유지한다는 점에서 균형 이진 트리와 유사하지만 트리의 각 &lt;strong&gt;노드가 여러 개의 자료&lt;/strong&gt;를 가질 수 있고, &lt;strong&gt;하위 트리의 수&lt;/strong&gt;를 임의로 설정 가능하다는 차이점이 존재한다.&lt;/p&gt;

&lt;p&gt;MST는 한개의 노드에 여러개의 키가 있을 수 있다. 자식 노드에도 여러 개의 키가 들어갈 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;각 노드는 0에서 최대 M개의 서브 트리를 가진다&lt;/li&gt;
      &lt;li&gt;K개의 서브 트리를 가지는 노드는 (K-1)개의 자료를 가진다(단, K&amp;lt;=M)&lt;/li&gt;
      &lt;li&gt;각 노드 안에서 자료들은 검색 키에 의해 정렬&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;b-트리b-tree&quot;&gt;B-트리(B Tree)&lt;/h3&gt;
&lt;p&gt;M원 탐색 트리의 차수가 많아져서 트리의 높이도 증가하면 점점 비효율적으로 변하게 된다. 그래서 B-트리를 고안해 규칙이 있는 MST를 구상했다.&lt;/p&gt;

&lt;p&gt;대량의 데이터를 처리해야 하는 검색 구조 주로 데이터베이스, 파일시스템에서 인덱스 저장 방법으로 사용하는 자료구조이다.&lt;/p&gt;

&lt;p&gt;노드 내 데이터 수가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;개라면 자식 노드의 수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(N+1)&lt;/code&gt;이며, 노드의 데이터는 항상 정렬된 상태여야 한다.&lt;/p&gt;

&lt;p&gt;노드 내 최대 데이터 수에 따라 2차 B-Tree(2개), 3차 B-Tree(3개), …라 명명&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/b-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;특징&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;루트 노드의 자식 수는 2 이상이어야 한다&lt;/li&gt;
      &lt;li&gt;모든 단말노드는 같은 레벨을 가진다&lt;/li&gt;
      &lt;li&gt;Internal 노드는 ⌈M/2⌉이상 M이하의 자식을 갖는다.&lt;/li&gt;
      &lt;li&gt;각 노드의 원소 수는 최소[M/2-1]개 이상 최대[M-1]개를 가진다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;b트리b-plus-tree&quot;&gt;B+트리(B Plus Tree)&lt;/h3&gt;
&lt;p&gt;B-트리는 특성상 순회 작업이 상당히 난감하다. B+ 트리는 색인구조에서 순차접근에 대한 문제의 해결책으로 제시되었다.&lt;/p&gt;

&lt;p&gt;B트리의 특징을 가지고 있지만 모든 키 값들이 Leaf 노드에 정렬되어 있는 트리 구조.&lt;/p&gt;

&lt;p&gt;Leaf 노드들은 연결 리스트 형태로 서로 연결되어 있고 이를 순차집합(sequence set)이라고 하며 오름차순으로 정렬이 되어 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;B+ 트리의 비단말 노드(not leaf)들은 데이터의 빠른 접근을 위한 인덱스 역할 수행(Index Set)&lt;/li&gt;
  &lt;li&gt;오직 리프노드에만 데이터 저장 가능하고 리프 노드에 모든 데이터가 있기 때문에 키 중복이 있다&lt;/li&gt;
  &lt;li&gt;리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용 가능&lt;/li&gt;
  &lt;li&gt;하나의 노드에 더 많은 key들을 담을 수 있기에 트리의 높이는 더 낮아진다.&lt;/li&gt;
  &lt;li&gt;B+tree는 리프 노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 되기 때문에 B-tree에 비해 빠르다. B-tree의 경우에는 모든 노드를 확인해야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/B-plus-tree.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;b트리b-star-tree&quot;&gt;B*트리(B Star Tree)&lt;/h3&gt;
&lt;p&gt;삽입 또는 삭제 작업 수행 시 발생하는 노드 분리를 줄이기 위해 노드의 약 2/3 이상이 채워지는 B트리.&lt;/p&gt;

&lt;p&gt;노드가 꽉 차면 분리하지 않고 키와 포인터를 재배치하여 다른 형제 노드로 옮김&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리프를 제외한 모든 노드는 m개의 서브트리 이상을 가질 수 없다&lt;/li&gt;
  &lt;li&gt;루트와 리프를 제외한 모든 노드는 적어도 [(2m-2)/3]+1개의 서브트리를 갖는다&lt;/li&gt;
  &lt;li&gt;루트는 리프가 아닌 이상 최소 2개, 적어도 2[(2m-2)/3]+1개의 서브트리를 갖는다.&lt;/li&gt;
  &lt;li&gt;모든 단말노드는 같은 레벨을 가진다&lt;/li&gt;
  &lt;li&gt;각 리프노드는 최소[(2m-2)/3]개, 최대 m-1개의 키 값을 갖는다&lt;/li&gt;
  &lt;li&gt;노드에 저장되는 자료가 넘치는 경우(Overflow), 일단 형제 노드들로 재분배하는 과정 수행. 모든 형제 노드들이 가득 찬 경우에만 B-트리의 분할 연산을 수행(보조 연산 최소화)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;트라이trie&quot;&gt;트라이(Trie)&lt;/h2&gt;
&lt;p&gt;문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조
주로 검색어 자동완성, 사전찾기, 문자열 검사에서 사용&lt;/p&gt;

&lt;p&gt;원하는 원소를 찾을 때, 원소의 길이가 L일 경우 O(L)의 시간복잡도를 가진다.&lt;/p&gt;

&lt;p&gt;빠르게 탐색이 가능하다는 장점이 있으나 각 노드에서 자식들에 대한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;포인터&lt;/code&gt;들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;배열&lt;/code&gt;로 모두 저장하고 있다는 점에서 저장공간의 크기(공간복잡도)가 크다는 단점을 지니고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/tree/trie.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="자료구조" /><category term="컴퓨터일반" /><category term="Programming" /><summary type="html">트리의 종류 이진 트리(Binary Tree) 기본적으로 자식노드를 최대 2개 가지는 트리를 의미</summary></entry><entry><title type="html">[데이터베이스] SQL</title><link href="https://many258.github.io/study/database-sql/" rel="alternate" type="text/html" title="[데이터베이스] SQL" /><published>2021-03-17T00:00:00+09:00</published><updated>2021-03-17T16:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-sql%7D</id><content type="html" xml:base="https://many258.github.io/study/database-sql/">&lt;h1 id=&quot;sqlstructured-query-language&quot;&gt;SQL(Structured Query Language)&lt;/h1&gt;
&lt;p&gt;ANSI, ISO에서 선정한 관계 데이터베이스 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;표준&lt;/code&gt; 언어&lt;br /&gt;
관계 대수와 관계 해석을 기초로 한 혼합 언어&lt;br /&gt;
데이터 정의, 조작, 제어 기능을 모두 갖추고 있다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비절차식&lt;/code&gt; 언어이며 대화식 질의어로 사용 가능&lt;br /&gt;
다른 프로그램 언어(COBOL, PL/1, C, Pascal)에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삽입된 형태&lt;/code&gt;로 사용 가능&lt;/p&gt;

&lt;h2 id=&quot;sql에서-사용하는-테이블&quot;&gt;SQL에서 사용하는 테이블&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기본 테이블&lt;br /&gt;
DDL에 의해 만들어지는 테이블로 독립적으로 존재하며 테이블명을 기록하게 되어 있다&lt;/li&gt;
  &lt;li&gt;뷰 테이블&lt;br /&gt;
역시 DDL에 의해 만들어지며 기본 테이블에서 유도되어 만들어지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가상&lt;/code&gt; 테이블&lt;/li&gt;
  &lt;li&gt;임시 테이블&lt;br /&gt;
질의 처리과정에서 DML에 의해 만들어지는 테이블로 임시적으로 만들어지는 테이블&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sql에서-사용하는-자료형의-종류&quot;&gt;SQL에서 사용하는 자료형의 종류&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;타입명&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BIT(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비트열&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;고정길이로 Bit단위로 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;VARBIT(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비트열&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;가변길이로 Bit단위로 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CHAR(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;문자열&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;고정 길이로 N개 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;VARCHAR(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;문자열&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;가변 길이로 N개 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SMALLINT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정수형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2바이트 고정 소수점 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;INT or INTEGER&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정수형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4바이트 고정 소수점 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FLOAT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;실수형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4바이트 부동 소수점 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DOUBLE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;실수형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8바이트 부동 소수점 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DECIMAL(i,j)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10진형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;i는 10진수의 개수, j는 소수점 이하 자리수&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;GRAPHIC(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;그래픽형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;그림 형태의 내용을 기억시킬 기억 장소 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;LOGICAL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;논리형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TRUE, FALSE를 기억시킬 기억 장소&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DATE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;날짜형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;YY-MM-DD 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TIME&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;시간형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;HH:MM:SS 형식&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;sql-명령어의-분류&quot;&gt;SQL 명령어의 분류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;데이터 정의어&lt;/strong&gt;(DDL : Data Definition Language)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#create&quot;&gt;CREATE&lt;/a&gt; : 테이블/인덱스/뷰의 생성&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#alter&quot;&gt;ALTER&lt;/a&gt; : 테이블의 변경&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#drop&quot;&gt;DROP&lt;/a&gt; : 테이블/인덱스/뷰의 제거&lt;/li&gt;
      &lt;li&gt;TRUNCATE : 테이블 초기화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 조작어&lt;/strong&gt;(DML : Data Manipulation Language)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#select&quot;&gt;SELECT&lt;/a&gt; : 데이터 검색&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#update&quot;&gt;UPDATE&lt;/a&gt; : 데이터 갱신&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#insert&quot;&gt;INSERT&lt;/a&gt; : 데이터 삽입&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#delete&quot;&gt;DELETE&lt;/a&gt; : 데이터 삭제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 제어어&lt;/strong&gt;(DCL : Data Control Language)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#grant&quot;&gt;GRANT&lt;/a&gt; : 사용자에게 권한 부여&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#revoke&quot;&gt;REVOKE&lt;/a&gt; : 사용자의 권한 해제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;트랜잭션 제어어&lt;/strong&gt;(TCL : Transaction Control Language)
    &lt;ul&gt;
      &lt;li&gt;COMMIT : 데이터를 데이터베이스에 저장하고 트랜잭션을 성공적으로 종료&lt;/li&gt;
      &lt;li&gt;ROLLBACK : 데이터의 변경사항을 취소하고 원상태로 복귀한 후 트랜잭션 종료&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-정의어&quot;&gt;데이터 정의어&lt;/h2&gt;
&lt;h3 id=&quot;create&quot;&gt;CREATE&lt;/h3&gt;
&lt;p&gt;테이블, 뷰, 인덱스 등을 생성할 때 사용&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테이블 생성 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{속성의&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;멤버&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;정의&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;UNIQUE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;FOREIGN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;REFERENCES&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;기본테이블&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;RESTRICT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;RESTRICT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CHECK&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;NOT NULL&lt;/strong&gt; : 널 값을 허용하지 않을 때 지정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PRIMARY KEY&lt;/strong&gt; : 기본키를 구성하는 속성을 지정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FOREIGN KEY&lt;/strong&gt; : 외래키로 어떤 릴레이션의 기본키를 참조하는지를 지정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RESTRICT&lt;/strong&gt; : 동작이 취소(제한)됨&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CASCADE&lt;/strong&gt; : 연속으로 같은 동작을 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SET NULL&lt;/strong&gt; : 모두 NULL로 바꿔주는 동작 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SET DEFAULT&lt;/strong&gt; : 주어진 초기 값으로 설정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CHECK&lt;/strong&gt; : 속성의 제약조건 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;뷰 생성 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VIEW&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;뷰이름&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;인덱스 생성 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;UNIQUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;색인명&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ASC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DESC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CLUSTER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;UNIQUE&lt;/strong&gt; : 색인화되어야 할 하나의 필드나 필드 조합이 중복되어서 같은 값이 나타나지 않게 하고자 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ASC/DESC&lt;/strong&gt; : 명시하지 않으면 오름차순(ASC)으로 자동설정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CLUSTER&lt;/strong&gt; : 색인 값과 물리적인 실제 데이터를 일치시킬 때 사용하는 옵션으로 하나의 테이블에서 한번빡에 생성할 수 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;alter&quot;&gt;ALTER&lt;/h3&gt;
&lt;p&gt;생성된 기본 테이블이나 도메인의 정의를 변경하고자 할 때 사용하는 명령어&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ADD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;MODIFY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;변경하고자&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;하는&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;ADD : 테이블에 속성 추가&lt;/li&gt;
  &lt;li&gt;ALTER : 도메인 정의 변경&lt;/li&gt;
  &lt;li&gt;DROP : 테이블에서 속성이나 제약조건 삭제&lt;/li&gt;
  &lt;li&gt;MODIFY : 속성의 데이터 유형, 제약조건에 대한 변경
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;MODIFY COLUMN 시 고려사항&lt;/p&gt;

        &lt;p&gt;해당 컬럼의 크기를 늘릴 수는 있지만 줄이지는 못한다. 이는 기존의 데이터가 훼손될 수 있기 때문이다.&lt;/p&gt;

        &lt;p&gt;해당 컬럼이 NULL 값만 가지고 있거나 테이블에 아무 행도 없으면 컬럼의 폭을 줄일 수 있다.&lt;/p&gt;

        &lt;p&gt;해당 컬럼이 NULL 값만을 가지고 있으면 데이터 유형을 변경할 수 있다.&lt;/p&gt;

        &lt;p&gt;해당 컬럼의 DEFAULT 값을 바꾸면 변경 작업 이후 발생하는 행 삽입에만 영향을 미치게 된다.&lt;/p&gt;

        &lt;p&gt;해당 컬럼에 NULL 값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;drop&quot;&gt;DROP&lt;/h3&gt;
&lt;p&gt;테이블, 뷰, 인덱스의 정의를 제거&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이름&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASCADE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;RESTRICT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VIEW&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;뷰&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이름&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASCADE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;RESTRICT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;인덱스&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이름&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;데이터-조작어&quot;&gt;데이터 조작어&lt;/h2&gt;
&lt;h3 id=&quot;select&quot;&gt;SELECT&lt;/h3&gt;
&lt;p&gt;테이블이나 뷰에 접근해서 원하는 튜플이나 속성을 검색하는 명령어&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SUM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;AVG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;MIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;리스트&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BETWEEN&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;도메인값&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;집합형태&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;LIKE&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'문자'&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;HAVING&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ASC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DESC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ALL(*)&lt;/strong&gt; : 하나의 테이블에 있는 모든 속성 출력&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DISTINCT&lt;/strong&gt; : 중복을 제거하는 옵션&lt;/li&gt;
  &lt;li&gt;집계함수
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;COUNT&lt;/strong&gt; : 해당 열이 있는 총 튜플의 개수&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SUM&lt;/strong&gt; : 해당 열에 있는 데이터의 합&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;AVG&lt;/strong&gt; : 해당 열에 있는 데이터들의 평균&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;MAX&lt;/strong&gt; : 해당 열에 있는 데이터 중 최대값&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;MIN&lt;/strong&gt; : 해당 열에 있는 데이터 중 최소값&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BETWEEN&lt;/strong&gt; : 값1과 값2 사이에 해당하는 조건&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IS (NOT) NULL&lt;/strong&gt; : 값이 NULL일 경우(아닐 경우) 조건&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IN&lt;/strong&gt; : 연산자는 조건의 범위를 지정하는 데 사용된다. 값은 콤마( , )로 구분하여 괄호 내에 묶으며, 이 값 중에서 하나 이상과 일치하면 조건에 맞는 것으로 평가&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LIKE&lt;/strong&gt; : 문자열 연산으로 사용되며 부분적으로 일치하는 값을 검색(숫자로 되어있는 필드는 사용 불가)
    &lt;ul&gt;
      &lt;li&gt;‘_‘(하이픈) : 한 문자의 대표 문자&lt;/li&gt;
      &lt;li&gt;’%’(퍼센트) : 모든 문자의 대표 문자&lt;/li&gt;
      &lt;li&gt;예시)&lt;br /&gt;
‘유__’ : 문자 ‘유’로 시작하는 3글자 검색&lt;br /&gt;
‘유%’ : 문자 ‘유’로 시작되는 모든 문자열 검색&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GROUP BY&lt;/strong&gt; : 그룹 지정, 조건식으로 HAVING 문법 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ORDER BY&lt;/strong&gt; : 정렬 검색, [ASC: 오름차순 / DESC : 내림차순]&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;insert&quot;&gt;INSERT&lt;/h3&gt;
&lt;p&gt;원하는 테이블에 원하는 튜플을 삽입시키는 연산&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;삽입시킬&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성들&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;삽입시킬&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성에&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;삽입될&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;실제&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값들&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;update&quot;&gt;UPDATE&lt;/h3&gt;
&lt;p&gt;테이블에서 원하는 속성값을 변경시키는 연산&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;값&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;delete&quot;&gt;DELETE&lt;/h3&gt;
&lt;p&gt;원하는 테이블에서 원하는 레코드를 삭제시키는 연산&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;데이터-제어어&quot;&gt;데이터 제어어&lt;/h2&gt;
&lt;h3 id=&quot;grant&quot;&gt;GRANT&lt;/h3&gt;
&lt;p&gt;사용자에 따라서 접근할 수 있는 DB데이터와 사용할 수 있는 기능을 제한&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;권한&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIVILEGES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;데이터베이스&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;TO&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'아이디'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'호스트'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDENTIFIED&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'비밀번호'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WITH&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;OPTION&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;FLUSH&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIVILEGES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;WITH GRANT OPTION&lt;/strong&gt; : 권한을 할당받은 유저가 GRANT 명령어도 사용할 수 있는 권한을 가지게 된다. 권한의 해제는 REVOKE GRANT OPTION 명령어를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;revoke&quot;&gt;REVOKE&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;REVOKE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;권한&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;데이터베이스&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;사용자&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">SQL(Structured Query Language) ANSI, ISO에서 선정한 관계 데이터베이스 표준 언어 관계 대수와 관계 해석을 기초로 한 혼합 언어 데이터 정의, 조작, 제어 기능을 모두 갖추고 있다. 비절차식 언어이며 대화식 질의어로 사용 가능 다른 프로그램 언어(COBOL, PL/1, C, Pascal)에 삽입된 형태로 사용 가능</summary></entry><entry><title type="html">[자료구조] 자료구조 기본</title><link href="https://many258.github.io/study/datastructure/" rel="alternate" type="text/html" title="[자료구조] 자료구조 기본" /><published>2021-03-17T00:00:00+09:00</published><updated>2021-03-17T20:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatastructure%7D</id><content type="html" xml:base="https://many258.github.io/study/datastructure/">&lt;h1 id=&quot;자료구조data-structure&quot;&gt;자료구조(Data Structure)&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;문제 해결에 있어 가장 효율적으로 자료를 조직하고 구조화하며, 자료를 표현하고 연산하는 일련의 활동을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;자료구조의-분류&quot;&gt;자료구조의 분류&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;선형구조(Linear)
    &lt;ul&gt;
      &lt;li&gt;스택(Stack)&lt;/li&gt;
      &lt;li&gt;큐(Queue)&lt;/li&gt;
      &lt;li&gt;데크(Deque)&lt;/li&gt;
      &lt;li&gt;배열(Array)&lt;/li&gt;
      &lt;li&gt;연결리스트(Linked list)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비선형구조(Non-Linear)
    &lt;ul&gt;
      &lt;li&gt;트리(Tree)&lt;/li&gt;
      &lt;li&gt;그래프(Graph)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;자료의-표현&quot;&gt;자료의 표현&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;외부 표현
    &lt;ul&gt;
      &lt;li&gt;BCD 코드 : 6비트, 64가지 표현, 소문자는 표현 불가&lt;/li&gt;
      &lt;li&gt;ASCII 코드 : 7비트, PC와 데이터 통신에서 주로 사용&lt;/li&gt;
      &lt;li&gt;EBCDIC 코드 : 8비트, 대형 컴퓨터에서 주로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내부 표현
    &lt;ul&gt;
      &lt;li&gt;수치 표현 : 컴퓨터 내부에 크기를 표현하기 위한 방법&lt;/li&gt;
      &lt;li&gt;포인터 표현 : 컴퓨터 내부에서 주소를 표현하기 위한 방법&lt;/li&gt;
      &lt;li&gt;논리 표현 : 긍정과 부정의 개념을 컴퓨터 내부에 표현하기 위한 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예외 표현 : 10진수 표현, 에러 검출, 데이터 송수신 등 용도로 사용
    &lt;ul&gt;
      &lt;li&gt;그레이 코드&lt;/li&gt;
      &lt;li&gt;3초과 코드&lt;/li&gt;
      &lt;li&gt;패리티 코드&lt;/li&gt;
      &lt;li&gt;해밍 코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;음수 표현 방식
컴퓨터 내의 연산 시 감산기(뺄셈)을 따로 만들지 않고 가산기(덧셈)만을 이용하여 덧셈과 뺄셈을 수행하기 위해 숫자자료는 보수 표현을 사용한다
    &lt;ul&gt;
      &lt;li&gt;부호화 절대치 : 첫 번째 비트가 0이면 양수이고 1이면 음수를 사용하는 방식
        &lt;ul&gt;
          &lt;li&gt;수의 표현 범위 : -(2&lt;sup&gt;n-1&lt;/sup&gt;-1) ~ 2&lt;sup&gt;n-1&lt;/sup&gt;-1&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;부호화된 1의 보수 : 양수의 1의 보수값을 음수로 사용
        &lt;ul&gt;
          &lt;li&gt;수의 표현 범위 : -(2&lt;sup&gt;n-1&lt;/sup&gt;-1) ~ 2&lt;sup&gt;n-1&lt;/sup&gt;-1&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;부호화된 2의 보수 : 양수의 2의 보수값을 음수로 사용
        &lt;ul&gt;
          &lt;li&gt;수의 표현 범위 : -(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;&lt;sup&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n-1&lt;/code&gt;&lt;/sup&gt;) ~ 2&lt;sup&gt;n-1&lt;/sup&gt;-1&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;선형-구조&quot;&gt;선형 구조&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;데이터를 저장시키는데 있어 데이터와 데이터를 1:1 대응 구조로 관계 맺어 저장시키는 형태의 구조를 의미&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;스택stack&quot;&gt;스택(Stack)&lt;/h3&gt;
&lt;p&gt;처음 입력시킨 자료는 맨 마지막에 출력되고 맨 마지막에 입력시킨 자료는 맨 처음에 출력되는 LIFO(Last in First Out)구조&lt;/p&gt;

&lt;p&gt;한쪽에서만 입출력하는 구조&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스택의 응용 분야
    &lt;ul&gt;
      &lt;li&gt;함수 호출이나 서브 프로그램 호출 시 복귀를 지정할 때&lt;/li&gt;
      &lt;li&gt;인터럽트 분기 시 복귀 주소를 저장할 때&lt;/li&gt;
      &lt;li&gt;되부름 시 복귀 주소를 저장할 때&lt;/li&gt;
      &lt;li&gt;수식을 연산할 때&lt;/li&gt;
      &lt;li&gt;수식의 후위 표기법 변환&lt;/li&gt;
      &lt;li&gt;0주소 명령어 형식의 자료 저장소&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;삽입-알고리즘-push&quot;&gt;삽입 알고리즘 (PUSH)&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF TOP &amp;gt;= M Overflow
TOP ← TOP + 1
STACK(TOP) ← X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;TOP 포인터가 전체 크기 M보다 크거나 같으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오버플로&lt;/code&gt;가 발생하고 그렇지 않으면 TOP 포인터 값을 하나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;증가&lt;/code&gt;시켜 원하는 자료 X를 스택의 TOP포인터 위치에 삽입&lt;/p&gt;

&lt;h4 id=&quot;삭제-알고리즘-pop&quot;&gt;삭제 알고리즘 (POP)&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF TOP = 0 Underflow
X ← STACK(TOP)
TOP ← Top - 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;TOP 포인터가 0과 같으면 스택에 데이터가 없는 것이므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;언더플로&lt;/code&gt;가 발생하고 그렇지 않으면 스택에서 TOP 포인터 위치와 값을 X에 넣어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삭제&lt;/code&gt;시켜주고 TOP 포인터 값을 하나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;감소&lt;/code&gt;시킨다.&lt;/p&gt;

&lt;h3 id=&quot;큐queue&quot;&gt;큐(QUEUE)&lt;/h3&gt;
&lt;p&gt;먼저 입력된 자료가 먼저 출력되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIFO&lt;/code&gt;(First In First Out) 구조 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FCFS&lt;/code&gt;(First Come First Serve) 구조라 불린다.&lt;/p&gt;

&lt;p&gt;한쪽 방향에서는 입력만 하고, 다른 한쪽 방향에서는 출력만 이루어진다.&lt;/p&gt;

&lt;p&gt;삽입(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rear&lt;/code&gt; or Tail)과 삭제(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Front&lt;/code&gt; or Head) 포인터 두 개를 두고 운용한다.&lt;br /&gt;
삽입 시 Rear 값을 &lt;strong&gt;증가&lt;/strong&gt; 시키고 삭제 시 Front를 &lt;strong&gt;감소&lt;/strong&gt;시킨다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;큐의 응용 분야
    &lt;ul&gt;
      &lt;li&gt;스풀 운용 처리에 사용&lt;/li&gt;
      &lt;li&gt;운영체제의 스케줄링 작업에 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;삽입-알고리즘enqueue&quot;&gt;삽입 알고리즘(Enqueue)&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF rear &amp;gt;= M overflow
QUEUE(rear) ← X
rear ← rear + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Rear 포인터가 큐의 전체 크기 M보다 크거나 같으면 &lt;strong&gt;오버플로&lt;/strong&gt;가 발생하고 그렇지 않으면 큐에서 Rear 포인터가 가리키는 위치에 X라는 자료를 삽입하고 삽입 포인터 Rear를 하나 &lt;strong&gt;증가&lt;/strong&gt;시킨다.&lt;/p&gt;

&lt;h4 id=&quot;삭제-알고리즘dequeue&quot;&gt;삭제 알고리즘(Dequeue)&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;IF front = rear underflow
X ← QUEUE(front)
front ← front + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;삭제 표인터 Front와 삽입 포인터 Rear가 같으면 데이터가 없는 &lt;strong&gt;언더플로&lt;/strong&gt;가 발생하고 그렇지 않으면 큐에서 Front 포인터가 가리키는 위치의 값을 X에 치환하고 삭제 포인터 Front를 하나 &lt;strong&gt;증가&lt;/strong&gt;시킨다.&lt;/p&gt;

&lt;h3 id=&quot;데크deque&quot;&gt;데크(Deque)&lt;/h3&gt;
&lt;p&gt;포인터를 두 개 두고 운영(Left, Right)&lt;br /&gt;
양쪽끝에서 입출력이 일어나는 구조&lt;/p&gt;

&lt;p&gt;입력 제한 데크는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스크롤&lt;/code&gt;(Scroll), 출력 제한 데크는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;셀프&lt;/code&gt;(Shelf)&lt;/p&gt;

&lt;h3 id=&quot;환형-큐circular-queue&quot;&gt;환형 큐(Circular Queue)&lt;/h3&gt;
&lt;p&gt;선형 큐는 front가 증가하여 Size 에 도달했을때 다시 빈 공간을 활용할 수 없다는 단점이 있는데,&lt;br /&gt;
이 점을 보완하여, 원형 큐를 사용하면 원형으로 배열 요소를 접근하게 하여 빈 공간에 다시 재할당이 가능해진다&lt;/p&gt;

&lt;p&gt;큐가 가득 찬 경우와 큐가 비어있는 경우를 구분이 불가능한 단점&lt;br /&gt;
=&amp;gt; 배열을 가득 채우지 않고 배열의 길이 N일 경우 N-1개 채워졌을 때 이것을 가득 찬 것으로 가정하여 해결&lt;/p&gt;

&lt;h4 id=&quot;환형-큐의-상태-알고리즘&quot;&gt;환형 큐의 상태 알고리즘&lt;/h4&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Empty
IF QUEUE → Rear == QUEUE → Front
  EMPTY

// Full
IF (QUEUE → Rear + 1) % QUEUE_SIZE == QUEUE → Front
  FULL

// EnQueue
IF FULL(QUEUE) Overflow
QUEUE → Rear = (QUEUE → Rear + 1) % QUEUE_SIZE
QUEUE → Data[QUEUE → Rear] = X

// DeQueue  
IF EMPTY(QUEUE) Underflow
QUEUE → Front = (QUEUE → Front + 1) % QUEUE_SIZE
X = QUEUE → Data[QUEUE → Front]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;배열array&quot;&gt;배열(Array)&lt;/h3&gt;
&lt;p&gt;같은 크기의 기억 장소를 연속된 공간에 모아 놓고 원하는 데이터를 기록하거나 액세스하는 것을 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특징&lt;br /&gt;
엑세스 속도가 빠르다&lt;br /&gt;
삽입, 삭제가 어렵고 메모리에 종속적이다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;연결리스트linked-list&quot;&gt;연결리스트(Linked List)&lt;/h3&gt;
&lt;p&gt;자료를 구성할 때 포인터 자료를 포함해서 하나의 자료를 구성하는 형태로, 이 포인터를 이용해 현 자료와 관계있는 자료를 연결하는 형식으로 구성하여 저장&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특징&lt;br /&gt;
액세스 속도가 느리다&lt;br /&gt;
중간에 단절되면 다음 노드를 찾기 어렵다&lt;br /&gt;
메모리에 대해 독립적이며 삽입, 삭제가 간편하다&lt;br /&gt;
메모리 단편화를 방지하여 기억 장소를 절약할 수 있다&lt;br /&gt;
포인터를 위한 추가 공간이 별도로 필요&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;비선형-구조&quot;&gt;비선형 구조&lt;/h2&gt;
&lt;p&gt;자료가 있을 때, 이 자료와 관계를 맺고 있는 다른 자료가 여러 개 존재하는 경우 이러한 관계성(1:N, N:M)을 표현하기 위한 구조&lt;/p&gt;

&lt;h3 id=&quot;트리tree&quot;&gt;트리(Tree)&lt;/h3&gt;
&lt;p&gt;노드와 선분으로 되어 있고 정점 사이에 사이클이 형성되지 않으며, 자료 사이의 관계성이 계층 형식으로 나타나는 구조&lt;/p&gt;

&lt;p&gt;여기서는 트리의 용어와 종류만 간단하게 언급하고 다음 장에서 부가 설명을 할 계획&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;용어
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;근노드&lt;/strong&gt;(Root Node) : 트리의 뿌리가 되는 노드&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;단노드&lt;/strong&gt;(Terminal Node, Leaf) : 노드의 차수가 0인 노드 또는 자식이 없는 노드를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;간노드&lt;/strong&gt;(Nonterminal Node) : 노드의 차수가 0이 아닌 노드 또는 자식을 가지고 있는 노드를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;차수&lt;/strong&gt;(Degree) : 각 노드의 가지 수, 또는 각 노드가 가지고 있는 자식 노드의 수를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;트리의 차수&lt;/strong&gt;(Tree Degree) : 트리 전체에서 노드의 차수가 가장 큰 것을 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;레벨&lt;/strong&gt;(Level) : 근 노드를 1레벨로 하여 차례로 2, 3 레벨로 증가하여 표시&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;깊이&lt;/strong&gt;(Depth) : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;높이&lt;/strong&gt;(Height) : 트리의 총 레벨을 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;자노드&lt;/strong&gt;(Child Node) : 각 노드에 연결되어 있는 다음 레벨의 노드를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;부노드&lt;/strong&gt;(Parent Node) : 각 노드의 바로 상위 레벨에 있는 노드를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;제노드&lt;/strong&gt;(Sibling Node) : 같은 부노드에 연결되어 있는 노드를 의미&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;숲&lt;/strong&gt;(Forest) : 트리가 모여서 이루어진 집합&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;서브 트리&lt;/strong&gt;(Sub Tree) : 임의의 노드를 제거했을 때 생길 수 있는 트리의 집합을 의미&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트리의 운행(Tree Traversal)
    &lt;ul&gt;
      &lt;li&gt;중위 운행(Inorder Traversal) : &amp;lt;좌, 근, 우&amp;gt; 순서로 운행&lt;/li&gt;
      &lt;li&gt;전위 운행(Preorder Traversal) : &amp;lt;근, 좌, 우&amp;gt; 순서로 운행&lt;/li&gt;
      &lt;li&gt;후위 운행(Postorder Traversal) : &amp;lt;좌, 우, 근&amp;gt; 순서로 운행&lt;/li&gt;
      &lt;li&gt;레벨 순서 순회(Level-order Traversal) = 너비 우선 순회(Breadth-First Traversal) : 노드를 레벨 순서로 방문하는 순회 방법&lt;/li&gt;
      &lt;li&gt;위 3가지는 스택을 활용하여 구현이 가능하며, 레벨 순서 순회는 큐를 활용하여 구현이 가능하다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;이진 트리&lt;/li&gt;
      &lt;li&gt;이진 탐색 트리(AVL)&lt;/li&gt;
      &lt;li&gt;레드 블랙 트리&lt;/li&gt;
      &lt;li&gt;스레드 이진 트리&lt;/li&gt;
      &lt;li&gt;B-트리, B+트리&lt;/li&gt;
      &lt;li&gt;이집 힙&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;그래프graph&quot;&gt;그래프(Graph)&lt;/h3&gt;
&lt;p&gt;트리보다 더 일반적인 자료 구조이며, 그래프는 트리를 포함한다. 일반적으로 정점과 선분으로 되어있으면서 사이클이 형성되는 경우를 트리와 구별하여 그래프라 지칭&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;용어
    &lt;ul&gt;
      &lt;li&gt;그래프의 표시 : G = (V, E) {V: 정점들의 집합, E: 간선의 집합}&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;정점&lt;/strong&gt;(Vertex) : 표현하고자 하는 대상 자료의 집합&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;간선&lt;/strong&gt;(Edge) : 정점 사이에 관계&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;경로&lt;/strong&gt;(Path) : 임의의 정점과 정점을 연결하는 경로&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;사이클&lt;/strong&gt;(Cycle) : 경로의 길이가 2이상인 경로에서 종착점과 시작점이 같은 경로&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;차수&lt;/strong&gt;(Degree) : 임의의 정점에 연결되어 있는 가지 수, 간선의 수
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;진입 차수&lt;/strong&gt;(In-Degree) : 정점으로 들어오는 간선의 수&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;진출 차수&lt;/strong&gt;(Out-Degree) : 정점에서 나가는 간선의 수&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;임의의 두 노드가 하나의 간선으로 연결돼 있을 경우, 이 노드들은 서로 &lt;strong&gt;인접&lt;/strong&gt;(Adjacent)해 있으며, 간선은 두 노드에 &lt;strong&gt;부속&lt;/strong&gt;(Incident)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;그래프의-종류&quot;&gt;그래프의 종류&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;비방향성 그래프(Undirected Graph)&lt;br /&gt;
간선 사이에 방향이 표시되지 않은 그래프. G(A, B)로 표현&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;방향성 그래프(Directed Graph)&lt;br /&gt;
간선 사이에 방향이 표시되어 있는 그래프. G&amp;lt;A, B&amp;gt;로 표현&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;완전 그래프(Complete Graph)&lt;br /&gt;
그래프를 구성한 모든 정점에서 자기 자신을 제외한 모든 정점에 대하여 간선이 있는 경우를 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;레이블 그래프(Labeled Graph)&lt;br /&gt;
그래프에서 간선에 실수 레이블을 붙여 표시하는 그래프&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;그래프의-표현&quot;&gt;그래프의 표현&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;인접 행렬&lt;/li&gt;
  &lt;li&gt;인접 리스트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/data-structure/graph-expression.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="자료구조" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">자료구조(Data Structure) 문제 해결에 있어 가장 효율적으로 자료를 조직하고 구조화하며, 자료를 표현하고 연산하는 일련의 활동을 의미한다.</summary></entry><entry><title type="html">[데이터베이스] 관계 데이터 연산</title><link href="https://many258.github.io/study/database-relational-operation/" rel="alternate" type="text/html" title="[데이터베이스] 관계 데이터 연산" /><published>2021-03-16T00:00:00+09:00</published><updated>2021-03-16T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-relational-operation%7D</id><content type="html" xml:base="https://many258.github.io/study/database-relational-operation/">&lt;h1 id=&quot;관계-대수relational-algebra&quot;&gt;관계 대수(Relational Algebra)&lt;/h1&gt;
&lt;p&gt;릴레이션으로부터 필요한 &lt;strong&gt;릴레이션&lt;/strong&gt;을 만들어내는 연산자의 집합&lt;br /&gt;
주어진 릴레이션 조작을 위한 연산의 집합&lt;br /&gt;
원하는 정보와 그 정보를 어떻게 유도하는가(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;How&lt;/code&gt;)를 기술하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;절차적&lt;/code&gt;인 방법&lt;br /&gt;
관계 해석과 관계 대수는 표현 방법만 다를 뿐이지 표현 능력의 차이는 없다&lt;/p&gt;

&lt;h2 id=&quot;집합연산자set-operations&quot;&gt;집합연산자(Set Operations)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;합집합&lt;/strong&gt;(Union : ∪)&lt;br /&gt;
이항 연산으로 관계성이 있는 두 개의 릴레이션에 속하는 튜플의 집합을 구하여 &lt;strong&gt;하나의 릴레이션&lt;/strong&gt;으로 만들어 내는 연산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;교집합&lt;/strong&gt;(Intersection : ∩)&lt;br /&gt;
이항 연산으로 관계성이 있는 두 개의 릴레이션에서 &lt;strong&gt;중복된&lt;/strong&gt; 튜플을 선택하여 새로운 릴레이션을 만들어 내는 연산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;차집합&lt;/strong&gt;(Difference : -)&lt;br /&gt;
이항 연산으로 관계성이 있는 두 개의 릴레이션이 있을 때 그 중 하나의 릴레이션에서 또 다른 릴레이션의 튜플과 겹치는 튜플을 제거하여 새로운 릴레이션을 생성하는 연산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;곱집합&lt;/strong&gt;(Cartesian Product : ×)&lt;br /&gt;
이항 연산으로 두 개의 릴레이션이 있을 때 두 릴레이션의 튜플들을 접속하여 순서쌍의 집합을 만들어 새로운 릴레이션을 만들어 내는 연산&lt;/p&gt;

    &lt;p&gt;결과 릴레이션의 &lt;strong&gt;차수&lt;/strong&gt;는 연산 대상 릴레이션 차수를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;더해서&lt;/code&gt; 나오고 &lt;strong&gt;카디널리티&lt;/strong&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;곱해서&lt;/code&gt; 나온다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관계연산자relational-operations&quot;&gt;관계연산자(Relational Operations)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;설렉션&lt;/strong&gt;(Selection : σ(sigma))&lt;br /&gt;
단항 연산으로 릴레이션에서 조건에 맞는 레코드(튜플)을 분리해 내는 연산&lt;/p&gt;

    &lt;p&gt;하나의 릴레이션에서 수평적 부분집합을 취하는 연산&lt;/p&gt;

    &lt;p&gt;A와 B를 릴레이션 R의 애트리뷰트,&lt;br /&gt;
θ는 비교 연산자(=,≠, &amp;lt;, ≤, &amp;gt;, ≥),&lt;br /&gt;
v는 상수라고 할 때&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;σAθB(R) = {r&lt;/td&gt;
            &lt;td&gt;t∈R ∧ r.Aθv}&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td&gt;σAθB(R) = {r&lt;/td&gt;
            &lt;td&gt;t∈R ∧ r.Aθr.B}&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;위와 같이 설렉션 연산을 표현한다&lt;/p&gt;

    &lt;p&gt;설렉션에 표현된 식 r.Aθv나 r.Aθr.B을 비교식/조건식/프레디킷(Predicate)이라 하는데 셀렉션은 바로 이 프레디킷을 참으로 만드는 튜플을 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝션&lt;/strong&gt;(Projection : ∏(pi))&lt;br /&gt;
단항 연산으로 릴레이션에서 구하고자 하는 속성을 선택하여 분리해 내는 연산&lt;/p&gt;

    &lt;p&gt;하나의 릴레이션에서 수직적 부분집합을 취하는 연산&lt;/p&gt;

    &lt;p&gt;릴레이션 R이 있고, R에 속한 튜플을 t,
A, B가 R 릴레이션의 속성이라 할때 프로젝션 여산의 수학적 표현은 다음과 같다&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;∏&lt;sub&gt;A, B&lt;/sub&gt;(R) = {t.A, t.B&lt;/td&gt;
            &lt;td&gt;t∈R}&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;조인&lt;/strong&gt;(Join : ⋈)&lt;br /&gt;
두 개 이상의 릴레이션에서 조건에 맞는 속성이 들어 있는 튜플을 접속하여 새로운 릴레이션을 생성하는 연산&lt;/p&gt;

    &lt;p&gt;두 릴레이션 R과 K가 있다고 가정할 때&lt;br /&gt;
R에 속한 튜플을 r, K에 속한 튜플을 k,&lt;br /&gt;
R에 속한 속성을 A, K에 속한 속성을 B,&lt;br /&gt;
θ는 관계 연산자(=,≠, &amp;lt;, ≤, &amp;gt;, ≥)라 할 때 수학적 표현은 다음과 같다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;R⋈&lt;sub&gt;AθB&lt;/sub&gt;K = { r · k&lt;/td&gt;
            &lt;td&gt;r∈R ∨ k∈K ∧ (r.Aθk.B) }&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;세타 조인&lt;/strong&gt;(Theta Join)&lt;br /&gt;
조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플을 반환&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;동등 조인&lt;/strong&gt;(Equi Join)&lt;br /&gt;
세타조인에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt; 연산자를 사용한 조인을 의미&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;R⋈&lt;sub&gt;R.C=K.E&lt;/sub&gt;K&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;자연 조인&lt;/strong&gt;(Natural Join)&lt;br /&gt;
동등 조인에서 중복된 속성을 제거한 결과를 반환&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;R⋈&lt;sub&gt;N&lt;/sub&gt;K&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;세미 조인&lt;/strong&gt;(Semi Join)&lt;br /&gt;
자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;닫힌&lt;/code&gt; 쪽의 릴레이션 튜플만 반환&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;../../assets/images/database/semi-join-sign.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;외부 조인&lt;/strong&gt;(Outer Join)&lt;br /&gt;
자연 조인 시 조인에 실패한 튜플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환&lt;/p&gt;

        &lt;p&gt;종류 : 왼쪽 외부조인, 오른쪽 외부조인, 완전 외부조인&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;../../assets/images/database/outer-join-sign.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;../../assets/images/database/outer-join-diagram.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;디비전&lt;/strong&gt;(Division : ÷)&lt;br /&gt;
두 개의 릴레이션 R과 K가 있을 때 K 릴레이션의 모든 조건을 만족하는 경우의 튜플들을 릴레이션 R에서 분리해 내어 프로젝션하는 연산&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;관계-해석&quot;&gt;관계 해석&lt;/h1&gt;
&lt;p&gt;수학의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프레디킷 해석&lt;/code&gt;(Predicate Calculus)에 기반&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;질의하는&lt;/code&gt; 형식으로 원하는 형태의 릴레이션을 정의하는 연산&lt;br /&gt;
구하고자 하는 정보가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무엇&lt;/code&gt;(What)이라는 것만 명시하는 &lt;strong&gt;비절차적&lt;/strong&gt; 형태의 연산&lt;/p&gt;

&lt;h2 id=&quot;관계-해석-기호&quot;&gt;관계 해석 기호&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;∀ : 모든 것에 대하여(for all)&lt;/li&gt;
  &lt;li&gt;∃ : 존재한다(There exist)&lt;/li&gt;
  &lt;li&gt;∈ : t가 r에 속함( t ∈ r )&lt;/li&gt;
  &lt;li&gt;θ : 비교 또는 관계 연산자(=,≠, &amp;lt;, ≤, &amp;gt;, ≥)&lt;/li&gt;
  &lt;li&gt;∨ : OR 연산자&lt;/li&gt;
  &lt;li&gt;∧ : AND 연산자&lt;/li&gt;
  &lt;li&gt;ㄱ : NOT 연산자&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;튜플-관계-해석tuple-relational-calculus&quot;&gt;튜플 관계 해석(Tuple Relational Calculus)&lt;/h2&gt;
&lt;p&gt;원하는 릴레이션을 튜플 해석식으로 정의하는 표기법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정의
    &lt;blockquote&gt;
      &lt;p&gt;{t[A], t[B] | F(t)}&lt;br /&gt;
&lt;sub&gt;F(t) : 정형식 
/ t : 튜플변수 
/ t[A] : 한정 속성&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;도메인-관계-해석domain-relational-calculus&quot;&gt;도메인 관계 해석(Domain Relational Calculus)&lt;/h2&gt;
&lt;p&gt;원하는 릴레이션을 도메인 해석식으로 정의하는 표기법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정의
    &lt;blockquote&gt;
      &lt;p&gt;{ &amp;lt;x1,x2,…,xn&amp;gt;｜F(x1,…, xn, xn+1,…, xn+m)} &lt;br /&gt;
&lt;sub&gt;&amp;lt;x1,x2,…,xn&amp;gt;: 구해야 할 도메인 변수&lt;br /&gt;
F(x1,…, xn,…) : 정형식의 구성 원칙에 따라 구성된 식&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">관계 대수(Relational Algebra) 릴레이션으로부터 필요한 릴레이션을 만들어내는 연산자의 집합 주어진 릴레이션 조작을 위한 연산의 집합 원하는 정보와 그 정보를 어떻게 유도하는가(How)를 기술하는 절차적인 방법 관계 해석과 관계 대수는 표현 방법만 다를 뿐이지 표현 능력의 차이는 없다</summary></entry><entry><title type="html">[데이터베이스] 관계 데이터베이스</title><link href="https://many258.github.io/study/database-relationship/" rel="alternate" type="text/html" title="[데이터베이스] 관계 데이터베이스" /><published>2021-03-13T00:00:00+09:00</published><updated>2021-03-14T18:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-relationship%7D</id><content type="html" xml:base="https://many258.github.io/study/database-relationship/">&lt;h1 id=&quot;관계-데이터베이스&quot;&gt;관계 데이터베이스&lt;/h1&gt;
&lt;p&gt;데이터 간의 관계를 &lt;strong&gt;테이블&lt;/strong&gt; 구조로 나타내는 데이터베이스&lt;/p&gt;

&lt;p&gt;이 데이터베이스는 개체를 표현하는 데 있어 속성과 속성 간의 연관 관계를 파악하여 테이블의 형태로 표현하며, 개체와 개체 사이의 연관 관계도 테이블 형태로 표현한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/database/relation-element.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;관계-데이터베이스-용어&quot;&gt;관계 데이터베이스 용어&lt;/h2&gt;
&lt;h3 id=&quot;속성attribute&quot;&gt;속성(Attribute)&lt;/h3&gt;
&lt;p&gt;어떤 개체의 정보의 특성이나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;특징&lt;/code&gt;에 대한 이름을 의미. 파일 시스템의 레코드 필드와 유사&lt;/p&gt;

&lt;p&gt;속성이란 용어는 우리가 프로그래밍하게 되면 어떤 값을 넣을 변수를 선언하게 되는데 이 변수의 개념에 해당&lt;/p&gt;

&lt;h3 id=&quot;도메인domain&quot;&gt;도메인(Domain)&lt;/h3&gt;
&lt;p&gt;한 속성의 의미로 들어오는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실제&lt;/code&gt; 값(원자값)들의 집합&lt;/p&gt;

&lt;p&gt;변수를 선언하게 되면 그 선언 타입에 해당하는 개념&lt;/p&gt;

&lt;h3 id=&quot;튜플tuple&quot;&gt;튜플(Tuple)&lt;/h3&gt;
&lt;p&gt;릴레이션 스킴에 따라 각 속성으로 실제 값이 입력됐을 때 하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;행&lt;/code&gt; 값에 해당하는 개념&lt;br /&gt;
파일시스템의 레코드 개념과 유사&lt;/p&gt;

&lt;h3 id=&quot;릴레이션relation&quot;&gt;릴레이션(Relation)&lt;/h3&gt;
&lt;p&gt;데이터 간의 관계를 나타내는 표 자체&lt;/p&gt;

&lt;p&gt;한 개 이상 속성들의 집합으로 표현
릴레이션의 일반적 의미는 테이블과는 학술적으로 다르게 사용되어 진다
릴레이션이라는 것은 릴레이션 스킴과 릴레이션 어커런스를 합쳐 지칭하는 용어&lt;/p&gt;

&lt;h4 id=&quot;릴레이션-스킴relation-scheme&quot;&gt;릴레이션 스킴(Relation Scheme)&lt;/h4&gt;
&lt;p&gt;릴레이션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스키마&lt;/code&gt;(Schema), 릴레이션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;타입&lt;/code&gt;(Type) 또는 릴레이션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;내포&lt;/code&gt;(Intention)라고도 불리며&lt;br /&gt;
릴레이션의 논리적 구조를 정의하는 것으로 릴레이션 이름과 해당 릴레이션을 형성하는 하나 이상의 속성을 합쳐 정의하는 개념&lt;/p&gt;

&lt;h4 id=&quot;릴레이션-어커런스relation-occurrence&quot;&gt;릴레이션 어커런스(Relation Occurrence)&lt;/h4&gt;
&lt;p&gt;릴레이션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인스턴스&lt;/code&gt;(Instance) 또는 릴레이션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;외연&lt;/code&gt;(Extension)이라고도 하며&lt;br /&gt;
어느 한 시점(시간에 가변적인 특성)에서 릴레이션 스킴에 따라 실제 데이터로 입력된 튜플들의 집합을 의미하는 개념&lt;/p&gt;

&lt;h4 id=&quot;릴레이션의-특성&quot;&gt;릴레이션의 특성&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;튜플의 유일성&lt;/strong&gt;&lt;br /&gt;
모든 튜플은 다르다는 것으로, 하나의 릴레이션으로 입력되는 튜플은 &lt;strong&gt;중복된 튜플이 존재하지 않는다&lt;/strong&gt;는 개념&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;튜플간의 무순서&lt;/strong&gt;&lt;br /&gt;
릴레이션으로 입력되는 모든 튜플은 순서가 정해져 입력되는 것이 아니라 &lt;strong&gt;상황에 따라 순서 없이&lt;/strong&gt; 입력된다는 개념&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;속성값은 원자값&lt;/strong&gt;&lt;br /&gt;
릴레이션에서 하나의 속성으로 입력되는 도메인 값은 하나의 튜플에서 &lt;strong&gt;분해 될 수 없는&lt;/strong&gt; 형태로 입력되어야 한다는 개념&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;속성 간의 무순서&lt;/strong&gt;&lt;br /&gt;
하나의 릴레이션에서 속성 간의 &lt;strong&gt;논리적인 순서는 관계가 없다&lt;/strong&gt;는 개념&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;속성 이름의 유일성&lt;/strong&gt;&lt;br /&gt;
하나의 릴레이션에서 &lt;strong&gt;속성 이름은 유일&lt;/strong&gt;해야 한다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;차수degree&quot;&gt;차수(Degree)&lt;/h3&gt;
&lt;p&gt;하나의 릴레이션에서 정의된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;속성&lt;/code&gt;의 개수, 즉 필드의 개수를 표현&lt;br /&gt;
설계의 변경이 이루어지지 않는 한 항상 정적인 상태를 유지&lt;/p&gt;

&lt;h3 id=&quot;카디널리티cardinality&quot;&gt;카디널리티(Cardinality)&lt;/h3&gt;
&lt;p&gt;기수라고도 하며, 하나의 릴레이션에 형성된 튜플의 개수, 즉 레코드의 수를 의미&lt;br /&gt;
데이터 조작 연산에 의해 항상 변화하므로 동적인 상태&lt;/p&gt;

&lt;h3 id=&quot;null-값&quot;&gt;NULL 값&lt;/h3&gt;
&lt;p&gt;Empty, 모르는 값, 정의되어 있지 않은 값을 의미. 0과 공백의 의미와 다르다는 것을 유의&lt;/p&gt;

&lt;h2 id=&quot;관계-데이터베이스-키-제약사항&quot;&gt;관계 데이터베이스 키 제약사항&lt;/h2&gt;
&lt;p&gt;키(Key)는 각각의 튜플을 유일하게 구분할 수 있는 개념이며 유일한 식별성과 최소성을 가지고 있어야 하며, 하나의 릴레이션에는 최소한 하나의 키가 있어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;최소성&lt;/strong&gt;&lt;br /&gt;
가장 적은 개수의 어트리뷰트로 구성될 수 있는 성질&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유일성&lt;/strong&gt;&lt;br /&gt;
릴레이션으로 입력되는 모든 튜플을 유일하게 구별할 수 있는 성질&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;슈퍼키super-key&quot;&gt;슈퍼키(Super Key)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소성&lt;/code&gt; 없이 단지 튜플을 식별하기 위해 두 개 이상의 속성 집합으로 이루어진 키를 의미&lt;/p&gt;

&lt;h3 id=&quot;후보키candidate-key&quot;&gt;후보키(Candidate Key)&lt;/h3&gt;
&lt;p&gt;하나의 릴레이션에서 &lt;strong&gt;유일성&lt;/strong&gt;과 &lt;strong&gt;최소성&lt;/strong&gt;을 가지고 있는 모든 속성 또는 속성의 집합&lt;/p&gt;

&lt;h3 id=&quot;기본키primary-key&quot;&gt;기본키(Primary Key)&lt;/h3&gt;
&lt;p&gt;후보키들 중 데이터베이스의 설계자에 의해 선택된 한 개의 키를 의미&lt;/p&gt;

&lt;p&gt;기본키로 선택된 속성은 &lt;strong&gt;중복&lt;/strong&gt;되지 않으며 정의되지 않는(&lt;strong&gt;NULL&lt;/strong&gt;) 값을 &lt;strong&gt;가질 수 없다&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;대체키alternate-key&quot;&gt;대체키(Alternate Key)&lt;/h3&gt;
&lt;p&gt;후보키 중 기본키를 제외한 모든 키는 대체키의 역할을 한다.&lt;/p&gt;

&lt;h3 id=&quot;외래키foreign-key&quot;&gt;외래키(Foreign Key)&lt;/h3&gt;
&lt;p&gt;테이블의 필드(attribute) 중 다른 테이블의 행(row)을 식별할 수 있는 키를 의미&lt;/p&gt;

&lt;p&gt;두 테이블을 연결하는 연결다리 역할을 하며, 참조하는 테이블에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무결성&lt;/code&gt;을 높여주는 역할을 수행&lt;/p&gt;

&lt;h2 id=&quot;무결성integrity-제약사항&quot;&gt;무결성(Integrity) 제약사항&lt;/h2&gt;
&lt;p&gt;데이터베이스에 저장되는 데이터에 대한 &lt;strong&gt;정확성&lt;/strong&gt;을 부여할 목적으로 제약사항을 설정하는 것을 의미&lt;/p&gt;

&lt;h3 id=&quot;도메인-무결성domain-integrity&quot;&gt;도메인 무결성(Domain Integrity)&lt;/h3&gt;
&lt;p&gt;기본적인 무결성 규정으로 데이터베이스 릴레이션에서 주어진 속성으로 입력되는 모든 값은 그 속성으로 정의되거나 &lt;strong&gt;제약된 도메인 영역&lt;/strong&gt;에 있어야 한다는 규정을 의미&lt;/p&gt;

&lt;h3 id=&quot;개체-무결성entity-integrity&quot;&gt;개체 무결성(Entity Integrity)&lt;/h3&gt;
&lt;p&gt;하나의 개체 릴레이션에서 기본키를 구성하는 속성은 널(NULL)값이나 중복된 튜플이 &lt;strong&gt;존재해서는 안된다&lt;/strong&gt;는 규정을 의미&lt;/p&gt;

&lt;h3 id=&quot;참조-무결성referential-integrity&quot;&gt;참조 무결성(Referential Integrity)&lt;/h3&gt;
&lt;p&gt;외래키 값은 &lt;strong&gt;NULL 값&lt;/strong&gt;이거나 참조 릴레이션의 &lt;strong&gt;기본키&lt;/strong&gt;와 동일해야 한다. 즉, 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 의미&lt;/p&gt;

&lt;p&gt;릴레이션에 있는 튜플 정보가 다른 릴레이션에 있는 튜플 정보와 비교하여 관계성이 있으며, 관계되는 정보의 정확성을 유지하는 가를 규정하는 것&lt;/p&gt;

&lt;h3 id=&quot;고유-무결성&quot;&gt;고유 무결성&lt;/h3&gt;
&lt;p&gt;특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성값은 모두 달라야 하는 제약조건&lt;/p&gt;

&lt;h3 id=&quot;null-무결성&quot;&gt;NULL 무결성&lt;/h3&gt;
&lt;p&gt;특정 속성값에 NULL값을 가질 수 없다는 조건이 주어진 경우, 그 속성값은 NULL값이 올 수 없다는 제약조건&lt;/p&gt;

&lt;h3 id=&quot;키-무결성&quot;&gt;키 무결성&lt;/h3&gt;
&lt;p&gt;한 릴레이션에는 최소한 하나의 키가 존재해야 한다는 제약 조건&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">관계 데이터베이스 데이터 간의 관계를 테이블 구조로 나타내는 데이터베이스</summary></entry><entry><title type="html">[데이터베이스] 데이터베이스 정규화</title><link href="https://many258.github.io/study/database-normalization/" rel="alternate" type="text/html" title="[데이터베이스] 데이터베이스 정규화" /><published>2021-03-13T00:00:00+09:00</published><updated>2021-03-13T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-normalization%7D</id><content type="html" xml:base="https://many258.github.io/study/database-normalization/">&lt;h1 id=&quot;관계-스키마-설계&quot;&gt;관계 스키마 설계&lt;/h1&gt;
&lt;p&gt;데이터베이스 설계에서 중요한 사항 중 하나가 현실 세계를 가장 정확하게 표현하기 위한 데이터의 논리적 구조를 결정하는 것&lt;/p&gt;

&lt;h2 id=&quot;설계-원칙&quot;&gt;설계 원칙&lt;/h2&gt;
&lt;p&gt;필요한 속성, 개체, 관계성을 식별하여 릴레이션을 구성&lt;br /&gt;
불필요한 데이터의 중복이 발생하지 않도록 설계&lt;br /&gt;
속성 사이의 관계성과 데이터의 종속성을 고려하여 설계&lt;br /&gt;
효율적 데이터 처리와 일관성 유지 방법 등을 고려하여 설계&lt;/p&gt;

&lt;h2 id=&quot;스키마-변환schema-transformation&quot;&gt;스키마 변환(Schema Transformation)&lt;/h2&gt;
&lt;p&gt;관련된 어트리뷰트를 수집하고 이들 간에 존재하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;종속성&lt;/code&gt;을 파악하여 어트리뷰트의 집합인 릴레이션으로 만든 다음 보다 바람직한 형태의 릴레이션으로 다시 변환하는 과정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;스키마 변환 원칙&lt;/strong&gt;&lt;br /&gt;
공해의 원칙&lt;br /&gt;
정보 무손실 원칙&lt;br /&gt;
데이터 중복 감소의 원칙&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;이상anomaly-현상&quot;&gt;이상(Anomaly) 현상&lt;/h1&gt;
&lt;p&gt;관계 스킴이 잘못되면 불필요한 데이터 중복을 초래하게 된다. 이러한 데이터 중복은 릴레이션을 조작할 때 곤란한 현상을 발생시키는 현상을 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;삭제 이상&lt;/strong&gt;(Delete Anomaly)&lt;br /&gt;
임의의 튜플을 삭제했을 때 그것과 관계를 형성하고 있는 관계성까지 모두 삭제되는 현상&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;삽입 이상&lt;/strong&gt;(Insert Anomaly)&lt;br /&gt;
임의의 튜플을 삽입했을 때 삽입 의도가 없는 관계까지도 삽입되는 현상&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;갱신 이상&lt;/strong&gt;(Update Anomaly)&lt;br /&gt;
임의의 데이터를 갱신했을 때 그것과 관계를 맺고 있는 데이터에 대해 일관성을 유지할 수 없는 현상&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;정규화-과정&quot;&gt;정규화 과정&lt;/h1&gt;
&lt;p&gt;하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해 나가는 과정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;목적&lt;/strong&gt;
구성되는 릴레이션이 중복되지 않게 효과적으로 데이터베이스 내에 표현이 가능하도록 한다
보다 간단한 연산자에 의해 효과적인 연산이 가능하도록 한다
릴레이션에 삽입 이상, 삭제 이상, 갱신 이상의 목제가 발생하지 않도록 한다
새로운 형태의 데이터가 삽입될 때 릴레이션을 재구성할 필요성을 감소시키도록 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;필요성&lt;/strong&gt;
자료의 저장 공간을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소화&lt;/code&gt;
자료의 불일치를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소화&lt;/code&gt;
자료 구조 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안정화&lt;/code&gt;
자료의 삽입, 삭제, 갱신 시 이상 현상을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;방지&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;함수-종속&quot;&gt;함수 종속&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;어떤 릴레이션 R에서 A, B가 릴레이션 R의 부분 속성이라고 할 때,&lt;/p&gt;

  &lt;p&gt;임의 시점에서 A의 어떤 값도 반드시 B의 하나의 값에 대응되지만, B의 하나의 값이 A의 복수의 값에 대응되는 경우 B는 A의 함수 종속이라 하고, A → B로 표기한다.
여기서 A는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결정자&lt;/code&gt;, B는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;종속자&lt;/code&gt;라 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;기본-정규형&quot;&gt;기본 정규형&lt;/h2&gt;
&lt;h3 id=&quot;제1정규형&quot;&gt;제1정규형&lt;/h3&gt;
&lt;p&gt;어떤 릴레이션 R에 속한 모든 도메인이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;원자값&lt;/code&gt;(분해될 수 없는 값)으로만으로 되어 있다면 제1정규형에 속한다.&lt;/p&gt;

&lt;h3 id=&quot;제2정규형&quot;&gt;제2정규형&lt;/h3&gt;
&lt;p&gt;어떤 릴레이션 R이 제1정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완전 함수적 종속&lt;/code&gt;(부분 함수 종속 제거)이면 제 2정규형에 속한다.&lt;br /&gt;
기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;완전 함수 종속성&lt;br /&gt;
A, B가 각각 관계 R의 속성이고 B가 A에 함수 종속(A→B)인 경우, A의 임의의 부분 집합에 대하여 B의 어떤 값도 A의 부분 집합의 값에 대응하지 않으면 B는 A에 완전함수(적) 종속&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제3정규형&quot;&gt;제3정규형&lt;/h3&gt;
&lt;p&gt;어떤 릴레이션 R이 제2정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이행적 함수 종속&lt;/code&gt;이 아니면 제3정규형에 속한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이행 함수 종속성&lt;br /&gt;
A, B, C가 각각 관계 R에 상호 중복되지 않는 속성(다만, A는 1차 키 이외의 속성)인 경우에, A가 B에 함수 종속적이 아니면 이때 C는 A에 이행함수 종속이라고 한다. A-&amp;gt;B 이고 B-&amp;gt;C 일 경우에만 A-&amp;gt;C 이면 이행함수(적) 종속이라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;보이스-코드-정규형boyce-codd-normal-form--bcbf&quot;&gt;보이스 코드 정규형(Boyce-Codd Normal Form : BCBF)&lt;/h3&gt;
&lt;p&gt;릴레이션 R의 모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결정자&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;후보키&lt;/code&gt;이면 릴레이션 R은 BC(Boyce-Codd)정규형에 속한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;슈퍼키&lt;/strong&gt;&lt;br /&gt;
레코드를 유일하게 식별해낼 수 있는 속성들의 집합이다. 한 개의 테이블은 여러 개의 슈퍼키를 가질 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;후보키&lt;/strong&gt;&lt;br /&gt;
슈퍼 키에서 레코드를 유일하게 식별하는데 있어서 필요없는 속성을 제거한 슈퍼 키의 부분집합&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제4정규형&quot;&gt;제4정규형&lt;/h3&gt;
&lt;p&gt;릴레이션 R에 비당연 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVD&lt;/code&gt; A-»B가 존재할 때 R의 모든 속성도 A에 함수 종속이면 릴레이션 R은 제4정규형에 속한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;다치 종속성(MVD)&lt;/strong&gt;&lt;br /&gt;
어떤 레코드의 존재가 다른 레코드의 존재로 이어짐을 의미한다. 다치종속성은-»으로 표시하는데, R｛A,B,C｝일 때 (A,C)-»｛B｝≡(A) -&amp;gt;｛B｝ 성립한다. , A-»B이면 A-»C도 성립하고 A-»B│C이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제5정규형&quot;&gt;제5정규형&lt;/h3&gt;
&lt;p&gt;릴레이션 R에 존재하는 모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조인 종속&lt;/code&gt;(JD)이 릴레이션 R의 후보키를 통해서만 성립된다면 릴레이션 R은 제5정규형 또는 PJ/NF(Projection-Join Normal Form)에 속한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;조인 종속&lt;/strong&gt;&lt;br /&gt;
릴레이션 R이 그의 프로젝션 A,B,…..,Z의 조인과 동일하면 R은 JD*(A,B,….,Z )를 만족한다. 이때 A,B,….,Z는 R의 애트리뷰트에 대한 부분집합이다.&lt;br /&gt;
다시말해서, 테이블 R이 R의 속성의 부분집합을 가지는 여러 개의 테이블들을 조인하여 만들어질 수 있을 때, R은 조인 종속성을 가진다고 한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">관계 스키마 설계 데이터베이스 설계에서 중요한 사항 중 하나가 현실 세계를 가장 정확하게 표현하기 위한 데이터의 논리적 구조를 결정하는 것</summary></entry><entry><title type="html">[데이터베이스] 데이터 모델링</title><link href="https://many258.github.io/study/database-modeling/" rel="alternate" type="text/html" title="[데이터베이스] 데이터 모델링" /><published>2021-03-13T00:00:00+09:00</published><updated>2021-03-13T12:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-modeling%7D</id><content type="html" xml:base="https://many258.github.io/study/database-modeling/">&lt;h1 id=&quot;데이터-모델&quot;&gt;데이터 모델&lt;/h1&gt;
&lt;p&gt;현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위해 사용되는 도구&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;개념적 데이터 모델&lt;/strong&gt;(High-Level, Conceptual Data Model)&lt;br /&gt;
속성들로 기술된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개체&lt;/code&gt; 타입과 이 개체 타입들 간의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관계&lt;/code&gt;를 이용하여 현실 세계를 표현하는 방법
    &lt;ul&gt;
      &lt;li&gt;종류
        &lt;ul&gt;
          &lt;li&gt;E-R 모델(Entity-Relationship Model)&lt;/li&gt;
          &lt;li&gt;이진 모델(Binary Model)&lt;/li&gt;
          &lt;li&gt;의미적 데이터 모델(Semantic Data Model)&lt;/li&gt;
          &lt;li&gt;정보 논리 모델(Information Logical Model)&lt;/li&gt;
          &lt;li&gt;함수적 데이터 모델(Functional Data Model)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;논리적 데이터 모델&lt;/strong&gt;(Logical Data Model)&lt;br /&gt;
필드로 기술된 데이터 타입들 간의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관계&lt;/code&gt;를 이용하여 현실 세계를 표현하는 방법
    &lt;ul&gt;
      &lt;li&gt;종류
        &lt;ul&gt;
          &lt;li&gt;관계형 데이터 모델&lt;/li&gt;
          &lt;li&gt;계층형 데이터 모델&lt;/li&gt;
          &lt;li&gt;네트워크형 데이터 모델&lt;/li&gt;
          &lt;li&gt;객체지향형 데이터 모델&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-모델-구성요소&quot;&gt;데이터 모델 구성요소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Structure&lt;/strong&gt;&lt;br /&gt;
데이터의 논리적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구조&lt;/code&gt;&lt;br /&gt;
데이터 모델을 기술할 때는 데이터 사이의 관계성을 파악하여 그 논리적 구성 형태를 기술해 주어야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;br /&gt;
개체 인스턴스를 처리하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연산&lt;/code&gt;&lt;br /&gt;
실제 데이터를 어떤 방법으로 삽입, 선정, 변경, 삭제할 것인가 하는 사항을 기술해야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Constraint&lt;/strong&gt;&lt;br /&gt;
개체 인스턴스에 대한 논리적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제약 사항&lt;/code&gt;&lt;br /&gt;
실제 데이터의 특징과 특성을 파악하여 어떤 데이터만을 받아들이며 어떤 관계만을 허용할 것인가를 기술해야 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개념적-데이터-모델&quot;&gt;개념적 데이터 모델&lt;/h2&gt;
&lt;h3 id=&quot;개체-관계-모델entity-relationship-model&quot;&gt;개체 관계 모델(Entity-Relationship Model)&lt;/h3&gt;
&lt;p&gt;개념적 단계에서 개체 내의 관계, 개체와 개체 사이의 사상 관계를 표현하는 데 쓰이며 사용자의 관점에서 가장 좋은 도구로 많이 사용되는 모델&lt;/p&gt;

&lt;h4 id=&quot;특징&quot;&gt;특징&lt;/h4&gt;
&lt;p&gt;1976년 Peter Chen에 의해 제안된 이래 개념적 설계에 가장 많이 사용되는 모델&lt;br /&gt;
개체 타입과 관계 타입을 이용해서 현실 세계를 개념적으로 표현한 모델&lt;br /&gt;
개체라는 것은 현실 세계에 존재하는 객체들을 의미&lt;br /&gt;
관계라는 것은 개체들 사이의 관계를 표현하는 것&lt;br /&gt;
E-R 다이어그램은 그래프 형태로 표시&lt;br /&gt;
최초에는 Entity, Relationship, Attribute와 같은 개념들로 구성되었으나 나중에는 확장된 모델로 발전&lt;/p&gt;

&lt;h4 id=&quot;기호&quot;&gt;기호&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/database/EERD.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;사상-원소수mapping-cardinality&quot;&gt;사상 원소수(Mapping cardinality)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1:1&lt;/li&gt;
  &lt;li&gt;1:N&lt;/li&gt;
  &lt;li&gt;N:1&lt;/li&gt;
  &lt;li&gt;N:M&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;논리적-데이터-모델&quot;&gt;논리적 데이터 모델&lt;/h2&gt;
&lt;p&gt;논리적 단계에서 쓰이는 도구로서 개념적 단계에서 만들어진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개념적&lt;/code&gt; 구조를 컴퓨터에 저장시킬 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;논리적&lt;/code&gt; 구조로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;변환&lt;/code&gt;하고자 쓰이는 데이터 모델&lt;/p&gt;

&lt;p&gt;데이터베이스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전체적&lt;/code&gt;인 논리적 구조를 설명할 때 사용되는 데이터 모델
관계 표현 : 관계 데이터 모델 - &lt;strong&gt;테이블&lt;/strong&gt; 구조, 계층 데이터 모델 - &lt;strong&gt;트리&lt;/strong&gt; 구조, 네트워크 데이터 모델 - &lt;strong&gt;그래프&lt;/strong&gt; 구조&lt;/p&gt;

&lt;h3 id=&quot;관계형-데이터-모델relational-data-model&quot;&gt;관계형 데이터 모델(Relational Data Model)&lt;/h3&gt;
&lt;p&gt;통일적이고 단순한 데이터 구조로 되어 있다&lt;br /&gt;
사용자에게 가장 뛰어난 논리적 구조를 지원&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;릴레이션&lt;/code&gt; 구조로 운영되는 데이터베이스&lt;br /&gt;
개체나 관계 모두가 릴레이션 형태&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기본키&lt;/code&gt;와 이를 참조하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;외래키&lt;/code&gt;로 데이터 간의 관계를 표현&lt;/p&gt;

&lt;h3 id=&quot;계층형-데이터-모델hierarchical-data-model&quot;&gt;계층형 데이터 모델(Hierarchical Data Model)&lt;/h3&gt;
&lt;p&gt;데이터 간의 관계를 순서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트리&lt;/code&gt; 형태로 표현&lt;br /&gt;
속성 간의 관계를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;레코드&lt;/code&gt;, 레코드 간의 관계를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;링크&lt;/code&gt;로 표현&lt;br /&gt;
계층 정의 트리 형태로 나타낼 때 노드는 레코드 타입이 되며 가지는 두 레코드 타입 사이의 링크가 된다&lt;br /&gt;
모든 링크의 관계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1:N&lt;/code&gt; 관계&lt;br /&gt;
두 레코드 타입 간의 관계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나&lt;/code&gt;의 링크 관계만 있을 수 있으므로 별도의 이름을 부여하지 않음&lt;br /&gt;
레코드 타입 간에는 상하 계층이 존재, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사이클&lt;/code&gt;이 허용되지 않음&lt;br /&gt;
대표적인 DBMS = IMS&lt;/p&gt;

&lt;h3 id=&quot;네트워크-데이터-모델network-data-model&quot;&gt;네트워크 데이터 모델(Network Data Model)&lt;/h3&gt;
&lt;p&gt;데이터 간의 관계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그래프&lt;/code&gt; 구조 형태&lt;br /&gt;
1에 해당하는 레코드 타입을 오너 레코드 타입, N에 해당하는 레코드 타입을 멤버 레코드 타입, 이들의 관계를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오너-멤버&lt;/code&gt;(Owner-Member)관계라 한다.&lt;br /&gt;
레코드 타입 간의 관계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1:1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1:N&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N:1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N:M&lt;/code&gt;이 될 수 있다
다 대 다의 관계가 있기 때문에 데이터 간의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연계성&lt;/code&gt;이 매우 뛰어난 모델이나 복잡하고 구축 비용이 크다
노드는 레코드 타입이 되고 링크는 개체 집합 간의 관계성을 표현
링크는 어느 한쪽으로 반드시 함수적 관계로 해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;화살표&lt;/code&gt;로 표현
링크 위에는 두 레코드 타입 간의 관계를 레이블로 표시
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CDASYL&lt;/code&gt;(Conference On Data System Languages), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DBTG&lt;/code&gt;(Data Base Task Group) 보고서에서 DBTG 모델이라는 것을 정의하여 네트워크 데이터 모델에 대한 이론적 개념을 정립&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">데이터 모델 현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위해 사용되는 도구</summary></entry></feed>