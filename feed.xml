<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://many258.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://many258.github.io/" rel="alternate" type="text/html" /><updated>2021-03-17T16:47:34+09:00</updated><id>https://many258.github.io/feed.xml</id><title type="html">My expression</title><subtitle>My expression</subtitle><author><name>SG Yoo.</name><email>many258@naver.com</email></author><entry><title type="html">[데이터베이스] SQL</title><link href="https://many258.github.io/study/database-sql/" rel="alternate" type="text/html" title="[데이터베이스] SQL" /><published>2021-03-17T00:00:00+09:00</published><updated>2021-03-17T16:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-sql%7D</id><content type="html" xml:base="https://many258.github.io/study/database-sql/">&lt;h1 id=&quot;sqlstructured-query-language&quot;&gt;SQL(Structured Query Language)&lt;/h1&gt;
&lt;p&gt;ANSI, ISO에서 선정한 관계 데이터베이스 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;표준&lt;/code&gt; 언어&lt;br /&gt;
관계 대수와 관계 해석을 기초로 한 혼합 언어&lt;br /&gt;
데이터 정의, 조작, 제어 기능을 모두 갖추고 있다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비절차식&lt;/code&gt; 언어이며 대화식 질의어로 사용 가능&lt;br /&gt;
다른 프로그램 언어(COBOL, PL/1, C, Pascal)에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삽입된 형태&lt;/code&gt;로 사용 가능&lt;/p&gt;

&lt;h2 id=&quot;sql에서-사용하는-테이블&quot;&gt;SQL에서 사용하는 테이블&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기본 테이블&lt;br /&gt;
DDL에 의해 만들어지는 테이블로 독립적으로 존재하며 테이블명을 기록하게 되어 있다&lt;/li&gt;
  &lt;li&gt;뷰 테이블&lt;br /&gt;
역시 DDL에 의해 만들어지며 기본 테이블에서 유도되어 만들어지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가상&lt;/code&gt; 테이블&lt;/li&gt;
  &lt;li&gt;임시 테이블&lt;br /&gt;
질의 처리과정에서 DML에 의해 만들어지는 테이블로 임시적으로 만들어지는 테이블&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sql에서-사용하는-자료형의-종류&quot;&gt;SQL에서 사용하는 자료형의 종류&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;타입명&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BIT(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비트열&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;고정길이로 Bit단위로 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;VARBIT(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비트열&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;가변길이로 Bit단위로 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CHAR(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;문자열&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;고정 길이로 N개 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;VARCHAR(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;문자열&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;가변 길이로 N개 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SMALLINT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정수형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2바이트 고정 소수점 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;INT or INTEGER&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정수형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4바이트 고정 소수점 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FLOAT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;실수형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4바이트 부동 소수점 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DOUBLE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;실수형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8바이트 부동 소수점 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DECIMAL(i,j)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10진형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;i는 10진수의 개수, j는 소수점 이하 자리수&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;GRAPHIC(N)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;그래픽형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;그림 형태의 내용을 기억시킬 기억 장소 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;LOGICAL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;논리형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TRUE, FALSE를 기억시킬 기억 장소&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DATE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;날짜형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;YY-MM-DD 형식&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TIME&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;시간형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;HH:MM:SS 형식&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;sql-명령어의-분류&quot;&gt;SQL 명령어의 분류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;데이터 정의어&lt;/strong&gt;(DDL : Data Definition Language)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#create&quot;&gt;CREATE&lt;/a&gt; : 테이블/인덱스/뷰의 생성&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#alter&quot;&gt;ALTER&lt;/a&gt; : 테이블의 변경&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#drop&quot;&gt;DROP&lt;/a&gt; : 테이블/인덱스/뷰의 제거&lt;/li&gt;
      &lt;li&gt;TRUNCATE : 테이블 초기화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 조작어&lt;/strong&gt;(DML : Data Manipulation Language)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#select&quot;&gt;SELECT&lt;/a&gt; : 데이터 검색&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#update&quot;&gt;UPDATE&lt;/a&gt; : 데이터 갱신&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#insert&quot;&gt;INSERT&lt;/a&gt; : 데이터 삽입&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#delete&quot;&gt;DELETE&lt;/a&gt; : 데이터 삭제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 제어어&lt;/strong&gt;(DCL : Data Control Language)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#grant&quot;&gt;GRANT&lt;/a&gt; : 사용자에게 권한 부여&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#revoke&quot;&gt;REVOKE&lt;/a&gt; : 사용자의 권한 해제&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;트랜잭션 제어어&lt;/strong&gt;(TCL : Transaction Control Language)
    &lt;ul&gt;
      &lt;li&gt;COMMIT : 데이터를 데이터베이스에 저장하고 트랜잭션을 성공적으로 종료&lt;/li&gt;
      &lt;li&gt;ROLLBACK : 데이터의 변경사항을 취소하고 원상태로 복귀한 후 트랜잭션 종료&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-정의어&quot;&gt;데이터 정의어&lt;/h2&gt;
&lt;h3 id=&quot;create&quot;&gt;CREATE&lt;/h3&gt;
&lt;p&gt;테이블, 뷰, 인덱스 등을 생성할 때 사용&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;테이블 생성 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;명&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{속성의&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;멤버&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;정의&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;UNIQUE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;FOREIGN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;REFERENCES&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;기본테이블&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;RESTRICT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;RESTRICT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASCADE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CHECK&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;NOT NULL&lt;/strong&gt; : 널 값을 허용하지 않을 때 지정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PRIMARY KEY&lt;/strong&gt; : 기본키를 구성하는 속성을 지정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FOREIGN KEY&lt;/strong&gt; : 외래키로 어떤 릴레이션의 기본키를 참조하는지를 지정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RESTRICT&lt;/strong&gt; : 동작이 취소(제한)됨&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CASCADE&lt;/strong&gt; : 연속으로 같은 동작을 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SET NULL&lt;/strong&gt; : 모두 NULL로 바꿔주는 동작 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SET DEFAULT&lt;/strong&gt; : 주어진 초기 값으로 설정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CHECK&lt;/strong&gt; : 속성의 제약조건 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;뷰 생성 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VIEW&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;뷰이름&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;AS&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;인덱스 생성 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;UNIQUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;색인명&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ASC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DESC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CLUSTER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;UNIQUE&lt;/strong&gt; : 색인화되어야 할 하나의 필드나 필드 조합이 중복되어서 같은 값이 나타나지 않게 하고자 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ASC/DESC&lt;/strong&gt; : 명시하지 않으면 오름차순(ASC)으로 자동설정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CLUSTER&lt;/strong&gt; : 색인 값과 물리적인 실제 데이터를 일치시킬 때 사용하는 옵션으로 하나의 테이블에서 한번빡에 생성할 수 없음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;alter&quot;&gt;ALTER&lt;/h3&gt;
&lt;p&gt;생성된 기본 테이블이나 도메인의 정의를 변경하고자 할 때 사용하는 명령어&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ADD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;MODIFY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;변경하고자&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;하는&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;ADD : 테이블에 속성 추가&lt;/li&gt;
  &lt;li&gt;ALTER : 도메인 정의 변경&lt;/li&gt;
  &lt;li&gt;DROP : 테이블에서 속성이나 제약조건 삭제&lt;/li&gt;
  &lt;li&gt;MODIFY : 속성의 데이터 유형, 제약조건에 대한 변경
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;MODIFY COLUMN 시 고려사항&lt;/p&gt;

        &lt;p&gt;해당 컬럼의 크기를 늘릴 수는 있지만 줄이지는 못한다. 이는 기존의 데이터가 훼손될 수 있기 때문이다.&lt;/p&gt;

        &lt;p&gt;해당 컬럼이 NULL 값만 가지고 있거나 테이블에 아무 행도 없으면 컬럼의 폭을 줄일 수 있다.&lt;/p&gt;

        &lt;p&gt;해당 컬럼이 NULL 값만을 가지고 있으면 데이터 유형을 변경할 수 있다.&lt;/p&gt;

        &lt;p&gt;해당 컬럼의 DEFAULT 값을 바꾸면 변경 작업 이후 발생하는 행 삽입에만 영향을 미치게 된다.&lt;/p&gt;

        &lt;p&gt;해당 컬럼에 NULL 값이 없을 경우에만 NOT NULL 제약조건을 추가할 수 있다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;drop&quot;&gt;DROP&lt;/h3&gt;
&lt;p&gt;테이블, 뷰, 인덱스의 정의를 제거&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이름&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASCADE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;RESTRICT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VIEW&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;뷰&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이름&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CASCADE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;RESTRICT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;인덱스&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;이름&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;데이터-조작어&quot;&gt;데이터 조작어&lt;/h2&gt;
&lt;h3 id=&quot;select&quot;&gt;SELECT&lt;/h3&gt;
&lt;p&gt;테이블이나 뷰에 접근해서 원하는 튜플이나 속성을 검색하는 명령어&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;COUNT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SUM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;AVG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;MIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
  &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DISTINCT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;리스트&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BETWEEN&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;IN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;도메인값&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;집합형태&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;LIKE&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'문자'&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;HAVING&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ASC&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;DESC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ALL(*)&lt;/strong&gt; : 하나의 테이블에 있는 모든 속성 출력&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DISTINCT&lt;/strong&gt; : 중복을 제거하는 옵션&lt;/li&gt;
  &lt;li&gt;집계함수
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;COUNT&lt;/strong&gt; : 해당 열이 있는 총 튜플의 개수&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SUM&lt;/strong&gt; : 해당 열에 있는 데이터의 합&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;AVG&lt;/strong&gt; : 해당 열에 있는 데이터들의 평균&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;MAX&lt;/strong&gt; : 해당 열에 있는 데이터 중 최대값&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;MIN&lt;/strong&gt; : 해당 열에 있는 데이터 중 최소값&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BETWEEN&lt;/strong&gt; : 값1과 값2 사이에 해당하는 조건&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IS (NOT) NULL&lt;/strong&gt; : 값이 NULL일 경우(아닐 경우) 조건&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IN&lt;/strong&gt; : 연산자는 조건의 범위를 지정하는 데 사용된다. 값은 콤마( , )로 구분하여 괄호 내에 묶으며, 이 값 중에서 하나 이상과 일치하면 조건에 맞는 것으로 평가&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LIKE&lt;/strong&gt; : 문자열 연산으로 사용되며 부분적으로 일치하는 값을 검색(숫자로 되어있는 필드는 사용 불가)
    &lt;ul&gt;
      &lt;li&gt;‘_‘(하이픈) : 한 문자의 대표 문자&lt;/li&gt;
      &lt;li&gt;’%’(퍼센트) : 모든 문자의 대표 문자&lt;/li&gt;
      &lt;li&gt;예시)&lt;br /&gt;
‘유__’ : 문자 ‘유’로 시작하는 3글자 검색&lt;br /&gt;
‘유%’ : 문자 ‘유’로 시작되는 모든 문자열 검색&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GROUP BY&lt;/strong&gt; : 그룹 지정, 조건식으로 HAVING 문법 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ORDER BY&lt;/strong&gt; : 정렬 검색, [ASC: 오름차순 / DESC : 내림차순]&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;insert&quot;&gt;INSERT&lt;/h3&gt;
&lt;p&gt;원하는 테이블에 원하는 튜플을 삽입시키는 연산&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;삽입시킬&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성들&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;삽입시킬&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성에&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;삽입될&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;실제&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;값들&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;update&quot;&gt;UPDATE&lt;/h3&gt;
&lt;p&gt;테이블에서 원하는 속성값을 변경시키는 연산&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블명&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;속성&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;값&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;delete&quot;&gt;DELETE&lt;/h3&gt;
&lt;p&gt;원하는 테이블에서 원하는 레코드를 삭제시키는 연산&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;DELETE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;조건식&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;데이터-제어어&quot;&gt;데이터 제어어&lt;/h2&gt;
&lt;h3 id=&quot;grant&quot;&gt;GRANT&lt;/h3&gt;
&lt;p&gt;사용자에 따라서 접근할 수 있는 DB데이터와 사용할 수 있는 기능을 제한&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;기본 구문&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;권한&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIVILEGES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;데이터베이스&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;TO&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'아이디'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'호스트'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDENTIFIED&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'비밀번호'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;WITH&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;OPTION&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;FLUSH&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIVILEGES&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;WITH GRANT OPTION&lt;/strong&gt; : 권한을 할당받은 유저가 GRANT 명령어도 사용할 수 있는 권한을 가지게 된다. 권한의 해제는 REVOKE GRANT OPTION 명령어를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;revoke&quot;&gt;REVOKE&lt;/h3&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;REVOKE&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;권한&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;데이터베이스&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;테이블&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;사용자&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">SQL(Structured Query Language) ANSI, ISO에서 선정한 관계 데이터베이스 표준 언어 관계 대수와 관계 해석을 기초로 한 혼합 언어 데이터 정의, 조작, 제어 기능을 모두 갖추고 있다. 비절차식 언어이며 대화식 질의어로 사용 가능 다른 프로그램 언어(COBOL, PL/1, C, Pascal)에 삽입된 형태로 사용 가능</summary></entry><entry><title type="html">[데이터베이스] 관계 데이터 연산</title><link href="https://many258.github.io/study/database-relational-operation/" rel="alternate" type="text/html" title="[데이터베이스] 관계 데이터 연산" /><published>2021-03-16T00:00:00+09:00</published><updated>2021-03-16T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-relational-operation%7D</id><content type="html" xml:base="https://many258.github.io/study/database-relational-operation/">&lt;h1 id=&quot;관계-대수relational-algebra&quot;&gt;관계 대수(Relational Algebra)&lt;/h1&gt;
&lt;p&gt;릴레이션으로부터 필요한 &lt;strong&gt;릴레이션&lt;/strong&gt;을 만들어내는 연산자의 집합&lt;br /&gt;
주어진 릴레이션 조작을 위한 연산의 집합&lt;br /&gt;
원하는 정보와 그 정보를 어떻게 유도하는가(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;How&lt;/code&gt;)를 기술하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;절차적&lt;/code&gt;인 방법&lt;br /&gt;
관계 해석과 관계 대수는 표현 방법만 다를 뿐이지 표현 능력의 차이는 없다&lt;/p&gt;

&lt;h2 id=&quot;집합연산자set-operations&quot;&gt;집합연산자(Set Operations)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;합집합&lt;/strong&gt;(Union : ∪)&lt;br /&gt;
이항 연산으로 관계성이 있는 두 개의 릴레이션에 속하는 튜플의 집합을 구하여 &lt;strong&gt;하나의 릴레이션&lt;/strong&gt;으로 만들어 내는 연산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;교집합&lt;/strong&gt;(Intersection : ∩)&lt;br /&gt;
이항 연산으로 관계성이 있는 두 개의 릴레이션에서 &lt;strong&gt;중복된&lt;/strong&gt; 튜플을 선택하여 새로운 릴레이션을 만들어 내는 연산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;차집합&lt;/strong&gt;(Difference : -)&lt;br /&gt;
이항 연산으로 관계성이 있는 두 개의 릴레이션이 있을 때 그 중 하나의 릴레이션에서 또 다른 릴레이션의 튜플과 겹치는 튜플을 제거하여 새로운 릴레이션을 생성하는 연산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;곱집합&lt;/strong&gt;(Cartesian Product : ×)&lt;br /&gt;
이항 연산으로 두 개의 릴레이션이 있을 때 두 릴레이션의 튜플들을 접속하여 순서쌍의 집합을 만들어 새로운 릴레이션을 만들어 내는 연산&lt;/p&gt;

    &lt;p&gt;결과 릴레이션의 &lt;strong&gt;차수&lt;/strong&gt;는 연산 대상 릴레이션 차수를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;더해서&lt;/code&gt; 나오고 &lt;strong&gt;카디널리티&lt;/strong&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;곱해서&lt;/code&gt; 나온다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;관계연산자relational-operations&quot;&gt;관계연산자(Relational Operations)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;설렉션&lt;/strong&gt;(Selection : σ(sigma))&lt;br /&gt;
단항 연산으로 릴레이션에서 조건에 맞는 레코드(튜플)을 분리해 내는 연산&lt;/p&gt;

    &lt;p&gt;하나의 릴레이션에서 수평적 부분집합을 취하는 연산&lt;/p&gt;

    &lt;p&gt;A와 B를 릴레이션 R의 애트리뷰트,&lt;br /&gt;
θ는 비교 연산자(=,≠, &amp;lt;, ≤, &amp;gt;, ≥),&lt;br /&gt;
v는 상수라고 할 때&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;σAθB(R) = {r&lt;/td&gt;
            &lt;td&gt;t∈R ∧ r.Aθv}&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td&gt;σAθB(R) = {r&lt;/td&gt;
            &lt;td&gt;t∈R ∧ r.Aθr.B}&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;위와 같이 설렉션 연산을 표현한다&lt;/p&gt;

    &lt;p&gt;설렉션에 표현된 식 r.Aθv나 r.Aθr.B을 비교식/조건식/프레디킷(Predicate)이라 하는데 셀렉션은 바로 이 프레디킷을 참으로 만드는 튜플을 선택&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;프로젝션&lt;/strong&gt;(Projection : ∏(pi))&lt;br /&gt;
단항 연산으로 릴레이션에서 구하고자 하는 속성을 선택하여 분리해 내는 연산&lt;/p&gt;

    &lt;p&gt;하나의 릴레이션에서 수직적 부분집합을 취하는 연산&lt;/p&gt;

    &lt;p&gt;릴레이션 R이 있고, R에 속한 튜플을 t,
A, B가 R 릴레이션의 속성이라 할때 프로젝션 여산의 수학적 표현은 다음과 같다&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;∏&lt;sub&gt;A, B&lt;/sub&gt;(R) = {t.A, t.B&lt;/td&gt;
            &lt;td&gt;t∈R}&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;조인&lt;/strong&gt;(Join : ⋈)&lt;br /&gt;
두 개 이상의 릴레이션에서 조건에 맞는 속성이 들어 있는 튜플을 접속하여 새로운 릴레이션을 생성하는 연산&lt;/p&gt;

    &lt;p&gt;두 릴레이션 R과 K가 있다고 가정할 때&lt;br /&gt;
R에 속한 튜플을 r, K에 속한 튜플을 k,&lt;br /&gt;
R에 속한 속성을 A, K에 속한 속성을 B,&lt;br /&gt;
θ는 관계 연산자(=,≠, &amp;lt;, ≤, &amp;gt;, ≥)라 할 때 수학적 표현은 다음과 같다.&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;R⋈&lt;sub&gt;AθB&lt;/sub&gt;K = { r · k&lt;/td&gt;
            &lt;td&gt;r∈R ∨ k∈K ∧ (r.Aθk.B) }&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/blockquote&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;세타 조인&lt;/strong&gt;(Theta Join)&lt;br /&gt;
조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플을 반환&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;동등 조인&lt;/strong&gt;(Equi Join)&lt;br /&gt;
세타조인에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt; 연산자를 사용한 조인을 의미&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;R⋈&lt;sub&gt;R.C=K.E&lt;/sub&gt;K&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;자연 조인&lt;/strong&gt;(Natural Join)&lt;br /&gt;
동등 조인에서 중복된 속성을 제거한 결과를 반환&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;R⋈&lt;sub&gt;N&lt;/sub&gt;K&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;세미 조인&lt;/strong&gt;(Semi Join)&lt;br /&gt;
자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;닫힌&lt;/code&gt; 쪽의 릴레이션 튜플만 반환&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;../../assets/images/database/semi-join-sign.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;외부 조인&lt;/strong&gt;(Outer Join)&lt;br /&gt;
자연 조인 시 조인에 실패한 튜플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환&lt;/p&gt;

        &lt;p&gt;종류 : 왼쪽 외부조인, 오른쪽 외부조인, 완전 외부조인&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;../../assets/images/database/outer-join-sign.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;../../assets/images/database/outer-join-diagram.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;디비전&lt;/strong&gt;(Division : ÷)&lt;br /&gt;
두 개의 릴레이션 R과 K가 있을 때 K 릴레이션의 모든 조건을 만족하는 경우의 튜플들을 릴레이션 R에서 분리해 내어 프로젝션하는 연산&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;관계-해석&quot;&gt;관계 해석&lt;/h1&gt;
&lt;p&gt;수학의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프레디킷 해석&lt;/code&gt;(Predicate Calculus)에 기반&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;질의하는&lt;/code&gt; 형식으로 원하는 형태의 릴레이션을 정의하는 연산&lt;br /&gt;
구하고자 하는 정보가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무엇&lt;/code&gt;(What)이라는 것만 명시하는 &lt;strong&gt;비절차적&lt;/strong&gt; 형태의 연산&lt;/p&gt;

&lt;h2 id=&quot;관계-해석-기호&quot;&gt;관계 해석 기호&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;∀ : 모든 것에 대하여(for all)&lt;/li&gt;
  &lt;li&gt;∃ : 존재한다(There exist)&lt;/li&gt;
  &lt;li&gt;∈ : t가 r에 속함( t ∈ r )&lt;/li&gt;
  &lt;li&gt;θ : 비교 또는 관계 연산자(=,≠, &amp;lt;, ≤, &amp;gt;, ≥)&lt;/li&gt;
  &lt;li&gt;∨ : OR 연산자&lt;/li&gt;
  &lt;li&gt;∧ : AND 연산자&lt;/li&gt;
  &lt;li&gt;ㄱ : NOT 연산자&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;튜플-관계-해석tuple-relational-calculus&quot;&gt;튜플 관계 해석(Tuple Relational Calculus)&lt;/h2&gt;
&lt;p&gt;원하는 릴레이션을 튜플 해석식으로 정의하는 표기법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정의
    &lt;blockquote&gt;
      &lt;p&gt;{t[A], t[B] | F(t)}&lt;br /&gt;
&lt;sub&gt;F(t) : 정형식 
/ t : 튜플변수 
/ t[A] : 한정 속성&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;도메인-관계-해석domain-relational-calculus&quot;&gt;도메인 관계 해석(Domain Relational Calculus)&lt;/h2&gt;
&lt;p&gt;원하는 릴레이션을 도메인 해석식으로 정의하는 표기법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정의
    &lt;blockquote&gt;
      &lt;p&gt;{ &amp;lt;x1,x2,…,xn&amp;gt;｜F(x1,…, xn, xn+1,…, xn+m)} &lt;br /&gt;
&lt;sub&gt;&amp;lt;x1,x2,…,xn&amp;gt;: 구해야 할 도메인 변수&lt;br /&gt;
F(x1,…, xn,…) : 정형식의 구성 원칙에 따라 구성된 식&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">관계 대수(Relational Algebra) 릴레이션으로부터 필요한 릴레이션을 만들어내는 연산자의 집합 주어진 릴레이션 조작을 위한 연산의 집합 원하는 정보와 그 정보를 어떻게 유도하는가(How)를 기술하는 절차적인 방법 관계 해석과 관계 대수는 표현 방법만 다를 뿐이지 표현 능력의 차이는 없다</summary></entry><entry><title type="html">[데이터베이스] 데이터베이스 설계</title><link href="https://many258.github.io/study/database-design/" rel="alternate" type="text/html" title="[데이터베이스] 데이터베이스 설계" /><published>2021-03-13T00:00:00+09:00</published><updated>2021-03-13T22:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-design%7D</id><content type="html" xml:base="https://many258.github.io/study/database-design/">&lt;h1 id=&quot;데이터베이스-설계&quot;&gt;데이터베이스 설계&lt;/h1&gt;
&lt;h2 id=&quot;데이터베이스-설계-시-유의사항&quot;&gt;데이터베이스 설계 시 유의사항&lt;/h2&gt;
&lt;p&gt;저장된 데이터가 연산 수행 후에도 &lt;strong&gt;무결성&lt;/strong&gt;이 유지될 수 있도록 설계&lt;br /&gt;
시스템 장애 시 복구될 수 있도록 &lt;strong&gt;회복과 예비&lt;/strong&gt; 절차를 염두에 두고 설계&lt;br /&gt;
외부로부터 불법적인 접근을 방지할 수 있는 &lt;strong&gt;보안 절차&lt;/strong&gt;를 유의하여 설계&lt;br /&gt;
데이터 관리에 대한 &lt;strong&gt;효율성&lt;/strong&gt;과 &lt;strong&gt;일관성&lt;/strong&gt;이 유지되도록 설계&lt;br /&gt;
데이터베이스의 확장과 축소에 대비한 &lt;strong&gt;신축성&lt;/strong&gt;을 고려하여 설계&lt;/p&gt;

&lt;h2 id=&quot;데이터베이스의-생명주기&quot;&gt;데이터베이스의 생명주기&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;요구 조건 분석&lt;/strong&gt; : 범위 설정을 위한 사용자와 그 응용을 식별하는 단계&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;설계&lt;/strong&gt; : 개념적 설계, 논리적 설계, 물리적 설계까지의 단계&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;구현&lt;/strong&gt; : 스키마 정의, 빈 데이터베이스 파일 생성, 응용 소프트웨어 구현 단계&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;운영&lt;/strong&gt; : 실제로 운영하여 사용자에게 서비스를 제공하는 단계&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;감시 및 개선&lt;/strong&gt; : 응용 과정에서 새로운 요구조건에 대처하고 성능을 개선하는 단계&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터베이스-설계-순서&quot;&gt;데이터베이스 설계 순서&lt;/h2&gt;
&lt;h3 id=&quot;요구-조건-분석-단계&quot;&gt;요구 조건 분석 단계&lt;/h3&gt;
&lt;p&gt;사용자 식별 및 범위 설정&lt;/p&gt;

&lt;p&gt;요구되는 개체와 속성, 관계성, 제약조건, 트랜잭션의 유형, 실행 횟수 등을 파악&lt;br /&gt;
  사용기관의 사용 목적과 내규, 법적인 규정, 데이터베이스의 사용자 식별, 사용 범위 결정 등 분석&lt;/p&gt;

&lt;h3 id=&quot;개념적-설계-단계&quot;&gt;개념적 설계 단계&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;개념 스키마 모델링&lt;/strong&gt;&lt;br /&gt;
요구 분석 단계에서 나온 결과를 E-R 다이엉그램과 같은 DBMS에 독립적이고 고차원적인 표현 기법으로 기술하는 과정을 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;트랜잭션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모델링&lt;/code&gt;&lt;/strong&gt;&lt;br /&gt;
요구 조건 분석 결과로 식별된 응용을 검토해서 이들을 구현할 수 있는 트랜잭션을 고차원 명세로 기술하는 과정&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;논리적-설계-단계&quot;&gt;논리적 설계 단계&lt;/h3&gt;
&lt;p&gt;DBMS에 따라 논리적 모델로 변환, 트랜잭션의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인터페이스&lt;/code&gt; 설계, 스키마 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;평가&lt;/code&gt; 및 정제&lt;/p&gt;

&lt;h3 id=&quot;물리적-설계-단계&quot;&gt;물리적 설계 단계&lt;/h3&gt;
&lt;p&gt;물리적 구조 설계, 트랜잭션의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;세부 사항 설계&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;물리적 설계 사항
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;저장될 &lt;strong&gt;레코드의 양식&lt;/strong&gt; 설계&lt;br /&gt;
데이터 타입, 접근 횟수, 데이터 값의 분포 등을 고려&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;저장될 레코드들의 &lt;strong&gt;분포 및 집중&lt;/strong&gt;에 관한 설계&lt;br /&gt;
레코드의 저장 방식과 물리적 블록의 크기 고려&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;접근 경로&lt;/strong&gt;의 설계&lt;br /&gt;
데이터를 물리적 저장 장치에 어떻게 저장시킬 것이며, 그 저장된 데이터를 어떤 방법으로 가져다 쓸 것인지에 대한 접근 방법을 설계하는 것으로 인덱스 등을 설계&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;물리적 설계 옵션 선택 시 고려 사항
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;응답시간&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;저장 공간의 효율화&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;트랜잭션 처리도&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;물리적 데이터베이스 설계 시 결정 사항
    &lt;ul&gt;
      &lt;li&gt;어떤 인덱스를 만들 것인지 고려&lt;/li&gt;
      &lt;li&gt;성능 향상을 위한 개념 스키마의 변경 여부 검토&lt;/li&gt;
      &lt;li&gt;빈번한 질의와 트랜잭션들의 수행 속도를 높이기 위한 사항을 고려&lt;/li&gt;
      &lt;li&gt;파일에 대한 트랜잭션의 갱신과 참조 성향 검토&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;구현-단계&quot;&gt;구현 단계&lt;/h3&gt;
&lt;p&gt;DDL로 스키마 작성, 트랜잭션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그래밍&lt;/code&gt;(응용프로그램 작성)&lt;/p&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">데이터베이스 설계 데이터베이스 설계 시 유의사항 저장된 데이터가 연산 수행 후에도 무결성이 유지될 수 있도록 설계 시스템 장애 시 복구될 수 있도록 회복과 예비 절차를 염두에 두고 설계 외부로부터 불법적인 접근을 방지할 수 있는 보안 절차를 유의하여 설계 데이터 관리에 대한 효율성과 일관성이 유지되도록 설계 데이터베이스의 확장과 축소에 대비한 신축성을 고려하여 설계</summary></entry><entry><title type="html">[데이터베이스] 관계 데이터베이스</title><link href="https://many258.github.io/study/database-relationship/" rel="alternate" type="text/html" title="[데이터베이스] 관계 데이터베이스" /><published>2021-03-13T00:00:00+09:00</published><updated>2021-03-14T18:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-relationship%7D</id><content type="html" xml:base="https://many258.github.io/study/database-relationship/">&lt;h1 id=&quot;관계-데이터베이스&quot;&gt;관계 데이터베이스&lt;/h1&gt;
&lt;p&gt;데이터 간의 관계를 &lt;strong&gt;테이블&lt;/strong&gt; 구조로 나타내는 데이터베이스&lt;/p&gt;

&lt;p&gt;이 데이터베이스는 개체를 표현하는 데 있어 속성과 속성 간의 연관 관계를 파악하여 테이블의 형태로 표현하며, 개체와 개체 사이의 연관 관계도 테이블 형태로 표현한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/database/relation-element.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;관계-데이터베이스-용어&quot;&gt;관계 데이터베이스 용어&lt;/h2&gt;
&lt;h3 id=&quot;속성attribute&quot;&gt;속성(Attribute)&lt;/h3&gt;
&lt;p&gt;어떤 개체의 정보의 특성이나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;특징&lt;/code&gt;에 대한 이름을 의미. 파일 시스템의 레코드 필드와 유사&lt;/p&gt;

&lt;p&gt;속성이란 용어는 우리가 프로그래밍하게 되면 어떤 값을 넣을 변수를 선언하게 되는데 이 변수의 개념에 해당&lt;/p&gt;

&lt;h3 id=&quot;도메인domain&quot;&gt;도메인(Domain)&lt;/h3&gt;
&lt;p&gt;한 속성의 의미로 들어오는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실제&lt;/code&gt; 값(원자값)들의 집합&lt;/p&gt;

&lt;p&gt;변수를 선언하게 되면 그 선언 타입에 해당하는 개념&lt;/p&gt;

&lt;h3 id=&quot;튜플tuple&quot;&gt;튜플(Tuple)&lt;/h3&gt;
&lt;p&gt;릴레이션 스킴에 따라 각 속성으로 실제 값이 입력됐을 때 하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;행&lt;/code&gt; 값에 해당하는 개념&lt;br /&gt;
파일시스템의 레코드 개념과 유사&lt;/p&gt;

&lt;h3 id=&quot;릴레이션relation&quot;&gt;릴레이션(Relation)&lt;/h3&gt;
&lt;p&gt;데이터 간의 관계를 나타내는 표 자체&lt;/p&gt;

&lt;p&gt;한 개 이상 속성들의 집합으로 표현
릴레이션의 일반적 의미는 테이블과는 학술적으로 다르게 사용되어 진다
릴레이션이라는 것은 릴레이션 스킴과 릴레이션 어커런스를 합쳐 지칭하는 용어&lt;/p&gt;

&lt;h4 id=&quot;릴레이션-스킴relation-scheme&quot;&gt;릴레이션 스킴(Relation Scheme)&lt;/h4&gt;
&lt;p&gt;릴레이션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스키마&lt;/code&gt;(Schema), 릴레이션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;타입&lt;/code&gt;(Type) 또는 릴레이션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;내포&lt;/code&gt;(Intention)라고도 불리며&lt;br /&gt;
릴레이션의 논리적 구조를 정의하는 것으로 릴레이션 이름과 해당 릴레이션을 형성하는 하나 이상의 속성을 합쳐 정의하는 개념&lt;/p&gt;

&lt;h4 id=&quot;릴레이션-어커런스relation-occurrence&quot;&gt;릴레이션 어커런스(Relation Occurrence)&lt;/h4&gt;
&lt;p&gt;릴레이션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인스턴스&lt;/code&gt;(Instance) 또는 릴레이션 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;외연&lt;/code&gt;(Extension)이라고도 하며&lt;br /&gt;
어느 한 시점(시간에 가변적인 특성)에서 릴레이션 스킴에 따라 실제 데이터로 입력된 튜플들의 집합을 의미하는 개념&lt;/p&gt;

&lt;h4 id=&quot;릴레이션의-특성&quot;&gt;릴레이션의 특성&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;튜플의 유일성&lt;/strong&gt;&lt;br /&gt;
모든 튜플은 다르다는 것으로, 하나의 릴레이션으로 입력되는 튜플은 &lt;strong&gt;중복된 튜플이 존재하지 않는다&lt;/strong&gt;는 개념&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;튜플간의 무순서&lt;/strong&gt;&lt;br /&gt;
릴레이션으로 입력되는 모든 튜플은 순서가 정해져 입력되는 것이 아니라 &lt;strong&gt;상황에 따라 순서 없이&lt;/strong&gt; 입력된다는 개념&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;속성값은 원자값&lt;/strong&gt;&lt;br /&gt;
릴레이션에서 하나의 속성으로 입력되는 도메인 값은 하나의 튜플에서 &lt;strong&gt;분해 될 수 없는&lt;/strong&gt; 형태로 입력되어야 한다는 개념&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;속성 간의 무순서&lt;/strong&gt;&lt;br /&gt;
하나의 릴레이션에서 속성 간의 &lt;strong&gt;논리적인 순서는 관계가 없다&lt;/strong&gt;는 개념&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;속성 이름의 유일성&lt;/strong&gt;&lt;br /&gt;
하나의 릴레이션에서 &lt;strong&gt;속성 이름은 유일&lt;/strong&gt;해야 한다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;차수degree&quot;&gt;차수(Degree)&lt;/h3&gt;
&lt;p&gt;하나의 릴레이션에서 정의된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;속성&lt;/code&gt;의 개수, 즉 필드의 개수를 표현&lt;br /&gt;
설계의 변경이 이루어지지 않는 한 항상 정적인 상태를 유지&lt;/p&gt;

&lt;h3 id=&quot;카디널리티cardinality&quot;&gt;카디널리티(Cardinality)&lt;/h3&gt;
&lt;p&gt;기수라고도 하며, 하나의 릴레이션에 형성된 튜플의 개수, 즉 레코드의 수를 의미&lt;br /&gt;
데이터 조작 연산에 의해 항상 변화하므로 동적인 상태&lt;/p&gt;

&lt;h3 id=&quot;null-값&quot;&gt;NULL 값&lt;/h3&gt;
&lt;p&gt;Empty, 모르는 값, 정의되어 있지 않은 값을 의미. 0과 공백의 의미와 다르다는 것을 유의&lt;/p&gt;

&lt;h2 id=&quot;관계-데이터베이스-키-제약사항&quot;&gt;관계 데이터베이스 키 제약사항&lt;/h2&gt;
&lt;p&gt;키(Key)는 각각의 튜플을 유일하게 구분할 수 있는 개념이며 유일한 식별성과 최소성을 가지고 있어야 하며, 하나의 릴레이션에는 최소한 하나의 키가 있어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;최소성&lt;/strong&gt;&lt;br /&gt;
가장 적은 개수의 어트리뷰트로 구성될 수 있는 성질&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유일성&lt;/strong&gt;&lt;br /&gt;
릴레이션으로 입력되는 모든 튜플을 유일하게 구별할 수 있는 성질&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;슈퍼키super-key&quot;&gt;슈퍼키(Super Key)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소성&lt;/code&gt; 없이 단지 튜플을 식별하기 위해 두 개 이상의 속성 집합으로 이루어진 키를 의미&lt;/p&gt;

&lt;h3 id=&quot;후보키candidate-key&quot;&gt;후보키(Candidate Key)&lt;/h3&gt;
&lt;p&gt;하나의 릴레이션에서 &lt;strong&gt;유일성&lt;/strong&gt;과 &lt;strong&gt;최소성&lt;/strong&gt;을 가지고 있는 모든 속성 또는 속성의 집합&lt;/p&gt;

&lt;h3 id=&quot;기본키primary-key&quot;&gt;기본키(Primary Key)&lt;/h3&gt;
&lt;p&gt;후보키들 중 데이터베이스의 설계자에 의해 선택된 한 개의 키를 의미&lt;/p&gt;

&lt;p&gt;기본키로 선택된 속성은 &lt;strong&gt;중복&lt;/strong&gt;되지 않으며 정의되지 않는(&lt;strong&gt;NULL&lt;/strong&gt;) 값을 &lt;strong&gt;가질 수 없다&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;대체키alternate-key&quot;&gt;대체키(Alternate Key)&lt;/h3&gt;
&lt;p&gt;후보키 중 기본키를 제외한 모든 키는 대체키의 역할을 한다.&lt;/p&gt;

&lt;h3 id=&quot;외래키foreign-key&quot;&gt;외래키(Foreign Key)&lt;/h3&gt;
&lt;p&gt;테이블의 필드(attribute) 중 다른 테이블의 행(row)을 식별할 수 있는 키를 의미&lt;/p&gt;

&lt;p&gt;두 테이블을 연결하는 연결다리 역할을 하며, 참조하는 테이블에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무결성&lt;/code&gt;을 높여주는 역할을 수행&lt;/p&gt;

&lt;h2 id=&quot;무결성integrity-제약사항&quot;&gt;무결성(Integrity) 제약사항&lt;/h2&gt;
&lt;p&gt;데이터베이스에 저장되는 데이터에 대한 &lt;strong&gt;정확성&lt;/strong&gt;을 부여할 목적으로 제약사항을 설정하는 것을 의미&lt;/p&gt;

&lt;h3 id=&quot;도메인-무결성domain-integrity&quot;&gt;도메인 무결성(Domain Integrity)&lt;/h3&gt;
&lt;p&gt;기본적인 무결성 규정으로 데이터베이스 릴레이션에서 주어진 속성으로 입력되는 모든 값은 그 속성으로 정의되거나 &lt;strong&gt;제약된 도메인 영역&lt;/strong&gt;에 있어야 한다는 규정을 의미&lt;/p&gt;

&lt;h3 id=&quot;개체-무결성entity-integrity&quot;&gt;개체 무결성(Entity Integrity)&lt;/h3&gt;
&lt;p&gt;하나의 개체 릴레이션에서 기본키를 구성하는 속성은 널(NULL)값이나 중복된 튜플이 &lt;strong&gt;존재해서는 안된다&lt;/strong&gt;는 규정을 의미&lt;/p&gt;

&lt;h3 id=&quot;참조-무결성referential-integrity&quot;&gt;참조 무결성(Referential Integrity)&lt;/h3&gt;
&lt;p&gt;외래키 값은 &lt;strong&gt;NULL 값&lt;/strong&gt;이거나 참조 릴레이션의 &lt;strong&gt;기본키&lt;/strong&gt;와 동일해야 한다. 즉, 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 의미&lt;/p&gt;

&lt;p&gt;릴레이션에 있는 튜플 정보가 다른 릴레이션에 있는 튜플 정보와 비교하여 관계성이 있으며, 관계되는 정보의 정확성을 유지하는 가를 규정하는 것&lt;/p&gt;

&lt;h3 id=&quot;고유-무결성&quot;&gt;고유 무결성&lt;/h3&gt;
&lt;p&gt;특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 그 속성값은 모두 달라야 하는 제약조건&lt;/p&gt;

&lt;h3 id=&quot;null-무결성&quot;&gt;NULL 무결성&lt;/h3&gt;
&lt;p&gt;특정 속성값에 NULL값을 가질 수 없다는 조건이 주어진 경우, 그 속성값은 NULL값이 올 수 없다는 제약조건&lt;/p&gt;

&lt;h3 id=&quot;키-무결성&quot;&gt;키 무결성&lt;/h3&gt;
&lt;p&gt;한 릴레이션에는 최소한 하나의 키가 존재해야 한다는 제약 조건&lt;/p&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">관계 데이터베이스 데이터 간의 관계를 테이블 구조로 나타내는 데이터베이스</summary></entry><entry><title type="html">[데이터베이스] 데이터베이스 정규화</title><link href="https://many258.github.io/study/database-normalization/" rel="alternate" type="text/html" title="[데이터베이스] 데이터베이스 정규화" /><published>2021-03-13T00:00:00+09:00</published><updated>2021-03-13T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-normalization%7D</id><content type="html" xml:base="https://many258.github.io/study/database-normalization/">&lt;h1 id=&quot;관계-스키마-설계&quot;&gt;관계 스키마 설계&lt;/h1&gt;
&lt;p&gt;데이터베이스 설계에서 중요한 사항 중 하나가 현실 세계를 가장 정확하게 표현하기 위한 데이터의 논리적 구조를 결정하는 것&lt;/p&gt;

&lt;h2 id=&quot;설계-원칙&quot;&gt;설계 원칙&lt;/h2&gt;
&lt;p&gt;필요한 속성, 개체, 관계성을 식별하여 릴레이션을 구성&lt;br /&gt;
불필요한 데이터의 중복이 발생하지 않도록 설계&lt;br /&gt;
속성 사이의 관계성과 데이터의 종속성을 고려하여 설계&lt;br /&gt;
효율적 데이터 처리와 일관성 유지 방법 등을 고려하여 설계&lt;/p&gt;

&lt;h2 id=&quot;스키마-변환schema-transformation&quot;&gt;스키마 변환(Schema Transformation)&lt;/h2&gt;
&lt;p&gt;관련된 어트리뷰트를 수집하고 이들 간에 존재하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;종속성&lt;/code&gt;을 파악하여 어트리뷰트의 집합인 릴레이션으로 만든 다음 보다 바람직한 형태의 릴레이션으로 다시 변환하는 과정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;스키마 변환 원칙&lt;/strong&gt;&lt;br /&gt;
공해의 원칙&lt;br /&gt;
정보 무손실 원칙&lt;br /&gt;
데이터 중복 감소의 원칙&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;이상anomaly-현상&quot;&gt;이상(Anomaly) 현상&lt;/h1&gt;
&lt;p&gt;관계 스킴이 잘못되면 불필요한 데이터 중복을 초래하게 된다. 이러한 데이터 중복은 릴레이션을 조작할 때 곤란한 현상을 발생시키는 현상을 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;삭제 이상&lt;/strong&gt;(Delete Anomaly)&lt;br /&gt;
임의의 튜플을 삭제했을 때 그것과 관계를 형성하고 있는 관계성까지 모두 삭제되는 현상&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;삽입 이상&lt;/strong&gt;(Insert Anomaly)&lt;br /&gt;
임의의 튜플을 삽입했을 때 삽입 의도가 없는 관계까지도 삽입되는 현상&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;갱신 이상&lt;/strong&gt;(Update Anomaly)&lt;br /&gt;
임의의 데이터를 갱신했을 때 그것과 관계를 맺고 있는 데이터에 대해 일관성을 유지할 수 없는 현상&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;정규화-과정&quot;&gt;정규화 과정&lt;/h1&gt;
&lt;p&gt;하나의 릴레이션에 하나의 의미만 존재할 수 있도록 릴레이션을 분해해 나가는 과정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;목적&lt;/strong&gt;
구성되는 릴레이션이 중복되지 않게 효과적으로 데이터베이스 내에 표현이 가능하도록 한다
보다 간단한 연산자에 의해 효과적인 연산이 가능하도록 한다
릴레이션에 삽입 이상, 삭제 이상, 갱신 이상의 목제가 발생하지 않도록 한다
새로운 형태의 데이터가 삽입될 때 릴레이션을 재구성할 필요성을 감소시키도록 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;필요성&lt;/strong&gt;
자료의 저장 공간을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소화&lt;/code&gt;
자료의 불일치를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소화&lt;/code&gt;
자료 구조 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안정화&lt;/code&gt;
자료의 삽입, 삭제, 갱신 시 이상 현상을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;방지&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;함수-종속&quot;&gt;함수 종속&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;어떤 릴레이션 R에서 A, B가 릴레이션 R의 부분 속성이라고 할 때,&lt;/p&gt;

  &lt;p&gt;임의 시점에서 A의 어떤 값도 반드시 B의 하나의 값에 대응되지만, B의 하나의 값이 A의 복수의 값에 대응되는 경우 B는 A의 함수 종속이라 하고, A → B로 표기한다.
여기서 A는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결정자&lt;/code&gt;, B는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;종속자&lt;/code&gt;라 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;기본-정규형&quot;&gt;기본 정규형&lt;/h2&gt;
&lt;h3 id=&quot;제1정규형&quot;&gt;제1정규형&lt;/h3&gt;
&lt;p&gt;어떤 릴레이션 R에 속한 모든 도메인이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;원자값&lt;/code&gt;(분해될 수 없는 값)으로만으로 되어 있다면 제1정규형에 속한다.&lt;/p&gt;

&lt;h3 id=&quot;제2정규형&quot;&gt;제2정규형&lt;/h3&gt;
&lt;p&gt;어떤 릴레이션 R이 제1정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완전 함수적 종속&lt;/code&gt;(부분 함수 종속 제거)이면 제 2정규형에 속한다.&lt;br /&gt;
기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;완전 함수 종속성&lt;br /&gt;
A, B가 각각 관계 R의 속성이고 B가 A에 함수 종속(A→B)인 경우, A의 임의의 부분 집합에 대하여 B의 어떤 값도 A의 부분 집합의 값에 대응하지 않으면 B는 A에 완전함수(적) 종속&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제3정규형&quot;&gt;제3정규형&lt;/h3&gt;
&lt;p&gt;어떤 릴레이션 R이 제2정규형에 속하고 기본키에 속하지 않는 모든 속성이 기본키에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이행적 함수 종속&lt;/code&gt;이 아니면 제3정규형에 속한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이행 함수 종속성&lt;br /&gt;
A, B, C가 각각 관계 R에 상호 중복되지 않는 속성(다만, A는 1차 키 이외의 속성)인 경우에, A가 B에 함수 종속적이 아니면 이때 C는 A에 이행함수 종속이라고 한다. A-&amp;gt;B 이고 B-&amp;gt;C 일 경우에만 A-&amp;gt;C 이면 이행함수(적) 종속이라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;보이스-코드-정규형boyce-codd-normal-form--bcbf&quot;&gt;보이스 코드 정규형(Boyce-Codd Normal Form : BCBF)&lt;/h3&gt;
&lt;p&gt;릴레이션 R의 모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결정자&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;후보키&lt;/code&gt;이면 릴레이션 R은 BC(Boyce-Codd)정규형에 속한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;슈퍼키&lt;/strong&gt;&lt;br /&gt;
레코드를 유일하게 식별해낼 수 있는 속성들의 집합이다. 한 개의 테이블은 여러 개의 슈퍼키를 가질 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;후보키&lt;/strong&gt;&lt;br /&gt;
슈퍼 키에서 레코드를 유일하게 식별하는데 있어서 필요없는 속성을 제거한 슈퍼 키의 부분집합&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제4정규형&quot;&gt;제4정규형&lt;/h3&gt;
&lt;p&gt;릴레이션 R에 비당연 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MVD&lt;/code&gt; A-»B가 존재할 때 R의 모든 속성도 A에 함수 종속이면 릴레이션 R은 제4정규형에 속한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;다치 종속성(MVD)&lt;/strong&gt;&lt;br /&gt;
어떤 레코드의 존재가 다른 레코드의 존재로 이어짐을 의미한다. 다치종속성은-»으로 표시하는데, R｛A,B,C｝일 때 (A,C)-»｛B｝≡(A) -&amp;gt;｛B｝ 성립한다. , A-»B이면 A-»C도 성립하고 A-»B│C이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제5정규형&quot;&gt;제5정규형&lt;/h3&gt;
&lt;p&gt;릴레이션 R에 존재하는 모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조인 종속&lt;/code&gt;(JD)이 릴레이션 R의 후보키를 통해서만 성립된다면 릴레이션 R은 제5정규형 또는 PJ/NF(Projection-Join Normal Form)에 속한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;조인 종속&lt;/strong&gt;&lt;br /&gt;
릴레이션 R이 그의 프로젝션 A,B,…..,Z의 조인과 동일하면 R은 JD*(A,B,….,Z )를 만족한다. 이때 A,B,….,Z는 R의 애트리뷰트에 대한 부분집합이다.&lt;br /&gt;
다시말해서, 테이블 R이 R의 속성의 부분집합을 가지는 여러 개의 테이블들을 조인하여 만들어질 수 있을 때, R은 조인 종속성을 가진다고 한다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">관계 스키마 설계 데이터베이스 설계에서 중요한 사항 중 하나가 현실 세계를 가장 정확하게 표현하기 위한 데이터의 논리적 구조를 결정하는 것</summary></entry><entry><title type="html">[데이터베이스] 데이터 모델링</title><link href="https://many258.github.io/study/database-modeling/" rel="alternate" type="text/html" title="[데이터베이스] 데이터 모델링" /><published>2021-03-13T00:00:00+09:00</published><updated>2021-03-13T12:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-modeling%7D</id><content type="html" xml:base="https://many258.github.io/study/database-modeling/">&lt;h1 id=&quot;데이터-모델&quot;&gt;데이터 모델&lt;/h1&gt;
&lt;p&gt;현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위해 사용되는 도구&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;개념적 데이터 모델&lt;/strong&gt;(High-Level, Conceptual Data Model)&lt;br /&gt;
속성들로 기술된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개체&lt;/code&gt; 타입과 이 개체 타입들 간의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관계&lt;/code&gt;를 이용하여 현실 세계를 표현하는 방법
    &lt;ul&gt;
      &lt;li&gt;종류
        &lt;ul&gt;
          &lt;li&gt;E-R 모델(Entity-Relationship Model)&lt;/li&gt;
          &lt;li&gt;이진 모델(Binary Model)&lt;/li&gt;
          &lt;li&gt;의미적 데이터 모델(Semantic Data Model)&lt;/li&gt;
          &lt;li&gt;정보 논리 모델(Information Logical Model)&lt;/li&gt;
          &lt;li&gt;함수적 데이터 모델(Functional Data Model)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;논리적 데이터 모델&lt;/strong&gt;(Logical Data Model)&lt;br /&gt;
필드로 기술된 데이터 타입들 간의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관계&lt;/code&gt;를 이용하여 현실 세계를 표현하는 방법
    &lt;ul&gt;
      &lt;li&gt;종류
        &lt;ul&gt;
          &lt;li&gt;관계형 데이터 모델&lt;/li&gt;
          &lt;li&gt;계층형 데이터 모델&lt;/li&gt;
          &lt;li&gt;네트워크형 데이터 모델&lt;/li&gt;
          &lt;li&gt;객체지향형 데이터 모델&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-모델-구성요소&quot;&gt;데이터 모델 구성요소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Structure&lt;/strong&gt;&lt;br /&gt;
데이터의 논리적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;구조&lt;/code&gt;&lt;br /&gt;
데이터 모델을 기술할 때는 데이터 사이의 관계성을 파악하여 그 논리적 구성 형태를 기술해 주어야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Operation&lt;/strong&gt;&lt;br /&gt;
개체 인스턴스를 처리하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연산&lt;/code&gt;&lt;br /&gt;
실제 데이터를 어떤 방법으로 삽입, 선정, 변경, 삭제할 것인가 하는 사항을 기술해야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Constraint&lt;/strong&gt;&lt;br /&gt;
개체 인스턴스에 대한 논리적 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제약 사항&lt;/code&gt;&lt;br /&gt;
실제 데이터의 특징과 특성을 파악하여 어떤 데이터만을 받아들이며 어떤 관계만을 허용할 것인가를 기술해야 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;개념적-데이터-모델&quot;&gt;개념적 데이터 모델&lt;/h2&gt;
&lt;h3 id=&quot;개체-관계-모델entity-relationship-model&quot;&gt;개체 관계 모델(Entity-Relationship Model)&lt;/h3&gt;
&lt;p&gt;개념적 단계에서 개체 내의 관계, 개체와 개체 사이의 사상 관계를 표현하는 데 쓰이며 사용자의 관점에서 가장 좋은 도구로 많이 사용되는 모델&lt;/p&gt;

&lt;h4 id=&quot;특징&quot;&gt;특징&lt;/h4&gt;
&lt;p&gt;1976년 Peter Chen에 의해 제안된 이래 개념적 설계에 가장 많이 사용되는 모델&lt;br /&gt;
개체 타입과 관계 타입을 이용해서 현실 세계를 개념적으로 표현한 모델&lt;br /&gt;
개체라는 것은 현실 세계에 존재하는 객체들을 의미&lt;br /&gt;
관계라는 것은 개체들 사이의 관계를 표현하는 것&lt;br /&gt;
E-R 다이어그램은 그래프 형태로 표시&lt;br /&gt;
최초에는 Entity, Relationship, Attribute와 같은 개념들로 구성되었으나 나중에는 확장된 모델로 발전&lt;/p&gt;

&lt;h4 id=&quot;기호&quot;&gt;기호&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/database/EERD.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;사상-원소수mapping-cardinality&quot;&gt;사상 원소수(Mapping cardinality)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1:1&lt;/li&gt;
  &lt;li&gt;1:N&lt;/li&gt;
  &lt;li&gt;N:1&lt;/li&gt;
  &lt;li&gt;N:M&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;논리적-데이터-모델&quot;&gt;논리적 데이터 모델&lt;/h2&gt;
&lt;p&gt;논리적 단계에서 쓰이는 도구로서 개념적 단계에서 만들어진 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개념적&lt;/code&gt; 구조를 컴퓨터에 저장시킬 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;논리적&lt;/code&gt; 구조로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;변환&lt;/code&gt;하고자 쓰이는 데이터 모델&lt;/p&gt;

&lt;p&gt;데이터베이스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전체적&lt;/code&gt;인 논리적 구조를 설명할 때 사용되는 데이터 모델
관계 표현 : 관계 데이터 모델 - &lt;strong&gt;테이블&lt;/strong&gt; 구조, 계층 데이터 모델 - &lt;strong&gt;트리&lt;/strong&gt; 구조, 네트워크 데이터 모델 - &lt;strong&gt;그래프&lt;/strong&gt; 구조&lt;/p&gt;

&lt;h3 id=&quot;관계형-데이터-모델relational-data-model&quot;&gt;관계형 데이터 모델(Relational Data Model)&lt;/h3&gt;
&lt;p&gt;통일적이고 단순한 데이터 구조로 되어 있다&lt;br /&gt;
사용자에게 가장 뛰어난 논리적 구조를 지원&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;릴레이션&lt;/code&gt; 구조로 운영되는 데이터베이스&lt;br /&gt;
개체나 관계 모두가 릴레이션 형태&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기본키&lt;/code&gt;와 이를 참조하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;외래키&lt;/code&gt;로 데이터 간의 관계를 표현&lt;/p&gt;

&lt;h3 id=&quot;계층형-데이터-모델hierarchical-data-model&quot;&gt;계층형 데이터 모델(Hierarchical Data Model)&lt;/h3&gt;
&lt;p&gt;데이터 간의 관계를 순서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;트리&lt;/code&gt; 형태로 표현&lt;br /&gt;
속성 간의 관계를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;레코드&lt;/code&gt;, 레코드 간의 관계를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;링크&lt;/code&gt;로 표현&lt;br /&gt;
계층 정의 트리 형태로 나타낼 때 노드는 레코드 타입이 되며 가지는 두 레코드 타입 사이의 링크가 된다&lt;br /&gt;
모든 링크의 관계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1:N&lt;/code&gt; 관계&lt;br /&gt;
두 레코드 타입 간의 관계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나&lt;/code&gt;의 링크 관계만 있을 수 있으므로 별도의 이름을 부여하지 않음&lt;br /&gt;
레코드 타입 간에는 상하 계층이 존재, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사이클&lt;/code&gt;이 허용되지 않음&lt;br /&gt;
대표적인 DBMS = IMS&lt;/p&gt;

&lt;h3 id=&quot;네트워크-데이터-모델network-data-model&quot;&gt;네트워크 데이터 모델(Network Data Model)&lt;/h3&gt;
&lt;p&gt;데이터 간의 관계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그래프&lt;/code&gt; 구조 형태&lt;br /&gt;
1에 해당하는 레코드 타입을 오너 레코드 타입, N에 해당하는 레코드 타입을 멤버 레코드 타입, 이들의 관계를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오너-멤버&lt;/code&gt;(Owner-Member)관계라 한다.&lt;br /&gt;
레코드 타입 간의 관계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1:1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1:N&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N:1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N:M&lt;/code&gt;이 될 수 있다
다 대 다의 관계가 있기 때문에 데이터 간의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연계성&lt;/code&gt;이 매우 뛰어난 모델이나 복잡하고 구축 비용이 크다
노드는 레코드 타입이 되고 링크는 개체 집합 간의 관계성을 표현
링크는 어느 한쪽으로 반드시 함수적 관계로 해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;화살표&lt;/code&gt;로 표현
링크 위에는 두 레코드 타입 간의 관계를 레이블로 표시
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CDASYL&lt;/code&gt;(Conference On Data System Languages), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DBTG&lt;/code&gt;(Data Base Task Group) 보고서에서 DBTG 모델이라는 것을 정의하여 네트워크 데이터 모델에 대한 이론적 개념을 정립&lt;/p&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">데이터 모델 현실 세계를 데이터베이스에 표현하는 중간 과정, 즉 데이터베이스 설계 과정에서 데이터의 구조를 표현하기 위해 사용되는 도구</summary></entry><entry><title type="html">[네트워크] TCP/IP 전송 계층</title><link href="https://many258.github.io/study/tcp-ip-transmission/" rel="alternate" type="text/html" title="[네트워크] TCP/IP 전송 계층" /><published>2021-03-11T00:00:00+09:00</published><updated>2021-03-11T18:37:34+09:00</updated><id>https://many258.github.io/study/%7Btcp-ip-transmission%7D</id><content type="html" xml:base="https://many258.github.io/study/tcp-ip-transmission/">&lt;h1 id=&quot;transport-layer&quot;&gt;Transport Layer&lt;/h1&gt;
&lt;p&gt;수신측에 전달되는 데이터에 오류가 없고 데이터의 순서가 그대로 보존되도록 보장하는 &lt;strong&gt;연결 지향 서비스&lt;/strong&gt;의 역할을 하는 &lt;strong&gt;종단 간 서비스&lt;/strong&gt;(End-to-End) 계층&lt;/p&gt;

&lt;p&gt;신뢰성 있는 전송을 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP&lt;/code&gt;와 비신뢰성 전송을 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UDP&lt;/code&gt;가 존재&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Segment&lt;br /&gt;
애플리케이션 계층의 메시지에 TCP 혹은 UDP의 헤더를 붙인 것을 의미.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcptransmission-control-protocol&quot;&gt;TCP(Transmission Control Protocol)&lt;/h2&gt;
&lt;p&gt;클라이언트와 서버 간의 연결 지향, 신뢰성 있는 데이터 전송, 에러 제어, 흐름 제어, 완전이중 방식&lt;br /&gt;
신뢰성있는 데이터 전송을 위해 가상 연결 수행&lt;br /&gt;
송신자가 메시지를 전송하면 수신자는 ACK를 되돌려서 수신 여부를 확인&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;혼잡 제어&lt;/strong&gt;(Congestion Control)&lt;br /&gt;
수신자 동일한 ACK 번호를 반복적으로 전송 =&amp;gt; 데이터를 받지 못함 ==&amp;gt; GO-BACK-N 방법으로 재전송&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;흐름 제어&lt;/strong&gt;(Flow Control)&lt;br /&gt;
수신자가 메시지를 제대로 받지 못하면 송신자는 전송 속도를 늦추어 네트워크 효율성 제어&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;순서 제어&lt;/strong&gt; : Sequence 번호를 가지고 메시지의 순서 파악&lt;/li&gt;
  &lt;li&gt;Checksum : TCP, UDP 모두 존재. 송신 중 메시지의 변조 파악하기 위해 에러 체크&lt;/li&gt;
  &lt;li&gt;Receive Windows&lt;br /&gt;
수신자의 윈도우 크기이자 메모리 버퍼. 
수신자의 버퍼가 비어 있으면 송신자는 해당 버퍼의 크기만큼 데이터를 한꺼번에 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tcp의-상태-전이&quot;&gt;TCP의 상태 전이&lt;/h3&gt;
&lt;p&gt;netstat 명령어로 확인 가능&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt; 클라이언트는 서버에 연결요청 메시지인 SYN 신호를 보내고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN_SEND&lt;/code&gt; 상태 전환&lt;br /&gt;
&lt;strong&gt;2)&lt;/strong&gt; 서버는 기동되면 클라이언트의 연결을 받기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LISTEN&lt;/code&gt; 상태로 클라이언트의 연결 대기&lt;br /&gt;
&lt;strong&gt;3)&lt;/strong&gt; 서버는 클라이언트로부터 SYN 메시지가 수신되면 서버는 클라이언트에게 SYN, ACK를 전송하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN_RECEIVED&lt;/code&gt; 상태 전환&lt;br /&gt;
&lt;strong&gt;4)&lt;/strong&gt; 클라이언트는 ACK를 서버에 전송하고 클라이언트와 서버는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESTABLISHED&lt;/code&gt;(연결 확립) 상태&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/tcpip/tcp-state-machine.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tcp-프로토콜의-header-구조&quot;&gt;TCP 프로토콜의 Header 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;근원지 포트&lt;/strong&gt;(Source Port)&lt;br /&gt;
가상 선로의 송신측 포트(End point of Sender)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;목적지 포트&lt;/strong&gt;(Destination Port)&lt;br /&gt;
가상 선로의 수신측 포트(End point of receiver)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;일련번호&lt;/strong&gt;(Sequence Number)&lt;br /&gt;
송신자가 전송하는 데이터의 일련번호&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;전송확인&lt;/strong&gt;(Piggyback Acknowledgement)&lt;br /&gt;
수신자와 응답하는 받은 데이터의 수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TCP 헤더 길이&lt;/strong&gt;(Header Length)&lt;br /&gt;
TCP 헤더에 몇 개의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;32Bit&lt;/code&gt; 워드가 포함되어 있는가를 나타내는 필드&lt;br /&gt;
옵션 필드가 가변 길이를 갖기 때문에 필요, 이 값을 이용하여 실제 데이터의 시작점을 계산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;URG&lt;/strong&gt;(Urgent)&lt;br /&gt;
긴급 지점이 사용될 때 1로 설정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ACK&lt;/strong&gt;(Acknowledgement)&lt;br /&gt;
전송 확인을 필요로 할 때 설정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EOM&lt;/strong&gt;(End of Message)&lt;br /&gt;
마지막 메시지임을 가리킴&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;재설정&lt;/strong&gt;(RST)&lt;br /&gt;
연결의 재설정. 비정상적인 종료&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;동기화&lt;/strong&gt;(SYN, Synchronization)&lt;br /&gt;
연결 설정 요구&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FIN&lt;/strong&gt;(Finish)&lt;br /&gt;
연결 해제에 사용되며, 송신측에서 더 이상 전송할 데이터가 없음을 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;윈도우 크기&lt;/strong&gt;(Window size)&lt;br /&gt;
수신측에서 수신할 수 있는 최대 Byte 수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;체크썸&lt;/strong&gt;(Checksum)&lt;br /&gt;
전송 데이터에 대한 완벽한 신뢰성을 위한 것으로, 모든 데이터의 합에 대한 ‘1’의 보수로 계산
무결성을 확인하기 위해 CRC(Cyclic Redundancy Check)코드 사용
CRC : 데이터 통신에서 전송 중에 전송 오류가 발생하였는지 확인하기 위해 덧붙인 코드&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;급송 지점&lt;/strong&gt;(Urgent point)&lt;br /&gt;
다음에 이어지는 데이터가 급송되어야 함을 의미. 인터럽트 메시지 대신 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;옵션&lt;/strong&gt;&lt;br /&gt;
전송 셋업 과정의 버퍼 크기에 대한 통신 등 기타 목적에 활용&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;에러-제어&quot;&gt;에러 제어&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FEC&lt;/strong&gt;(Forward Error Correction)&lt;br /&gt;
송신측이 특정한 정보 비트를 함께 전송하여 수신측에서 이 정보 비트로 에러 발생 시 수정하는 방식(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수신측&lt;/code&gt;이 에러 처리)&lt;/p&gt;

    &lt;p&gt;데이터 전송과정에서 발생한 오류를 검출하여 오류를 재전송 요구 없이 수정&lt;br /&gt;
재전송 요구가 없어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;역 채널&lt;/code&gt;이 필요 없고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연속&lt;/code&gt;적인 데이터 전송 가능&lt;br /&gt;
오류 검출 및 수정을 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;잉여비트&lt;/code&gt;들이 추가 전송되므로 전송 효율 감소&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;해밍 코드&lt;/li&gt;
      &lt;li&gt;상승 코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BEC&lt;/strong&gt;(Backward Error Correction)&lt;br /&gt;
수신측이 에러 검출 후 송신측에게 에러가 발생한 데이터 블록을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;재전송&lt;/code&gt; 요청(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;송신측&lt;/code&gt;이 에러 처리, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARQ&lt;/code&gt;:Auto Repeat reQuest)&lt;/p&gt;

    &lt;p&gt;패리티 검사, CRC 등 CheckSum을 이용하여 오류 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;검출&lt;/code&gt; 후, 오류 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어&lt;/code&gt;는 ARQ가 처리&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Stop-And-Wait&lt;/strong&gt;&lt;br /&gt;
하나의 데이터를 송신하고 수신 확인 신호를 받을 때까지 기다린 다음 전송&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Go-Back-N&lt;/strong&gt;&lt;br /&gt;
수신자가 데이터를 수신 받지 못할 경우 마지막으로 수신 받은 데이터 이후의 모든 데이터 재전송
TCP에서 사용하는 방식&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Selective Repeat ARQ&lt;/strong&gt;&lt;br /&gt;
수신받은 데이터 중에서 중간에 빠져있는 것만 재전송&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Adaptive ARQ&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;흐름-제어&quot;&gt;흐름 제어&lt;/h3&gt;
&lt;p&gt;송수신측 사이의 전송 패킷의 양, 속도를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조절&lt;/code&gt;하여 네트워크를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;효율&lt;/code&gt;적으로 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;슬라이딩 윈도우&lt;/strong&gt;(Sliding Window)&lt;br /&gt;
호스트 간에 송수신 혹은 수신할 수 있는 Size 정보를 제공&lt;br /&gt;
&lt;strong&gt;Stop-And-Wait&lt;/strong&gt;의 단점을 보완한 방식으로 수신측의 확인 신호를 받지 않더라도 미리 정해진 프레임의 수만큼 연속적으로 전송&lt;br /&gt;
수신자의 버퍼 크기를 확인함으로서 최대한 전송 효율 극대화&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;혼잡-제어&quot;&gt;혼잡 제어&lt;/h3&gt;
&lt;p&gt;라우터가 패킷을 처리할 수 있는 속도보다 많은 패킷을 수신하는 경우 라우터는 패킷을 손실하게 된다.
송신측에서는 패킷을 재전송하게 되는데, 이러한 과정의 연속으로 데이터의 손실이나 지연이 발생
혼잡 제어는 송신 단말의 전송률을 직접 제어하여 혼잡으로 인해 손실된 데이터를 재전송하기 위함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TCP Slow Start&lt;/strong&gt;&lt;br /&gt;
TCP가 시작될 때 전송속도를 초기값부터 지속적으로 올리는 방법&lt;/p&gt;

    &lt;p&gt;송신측에서 패킷을 전송하는 비율과 수신측에서 수신된 ACK를 통해 Congestion Window(cwnd)를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지수&lt;/code&gt;의 크기로 증가.&lt;br /&gt;
cwnd는 계속적으로 증가하다가 임계값에 이르게 되면 Congestion Avoidance로 동작&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Congestion Avoidance&lt;/strong&gt;&lt;br /&gt;
Duplication ACK 값이 오거나 일정 시간 동안 ACK가 수신되지 않으면 전송속도를 낮춤&lt;br /&gt;
매번 ACK가 수신될 때마다 cwnd를 1/cwnd만큼 증가(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선형적&lt;/code&gt;인 증가)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fast Retransmit&lt;/strong&gt;&lt;br /&gt;
Retransmit Threshold 이상 연속된 Duplicate ACK를 수신하는 경우 TCP는 해당 Segment를 재전송&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fast Recovery&lt;/strong&gt;&lt;br /&gt;
Fast Retransmit한 이후 새로 Slow Start를 통해서 설정된 연결의 안전상태에 도달할 필요없이 Congestion Avoidance 상태에서 전송할 수 있도록 하는 것&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;udpuser-datagram-protocol&quot;&gt;UDP(User Datagram Protocol)&lt;/h2&gt;
&lt;p&gt;비연결성, 비신뢰성(블록 재전송 및 흐름 제어 등이 없음)을 특성으로 패킷을 고속 전달할 수 있는 프로토콜&lt;br /&gt;
비접속형 : 전달되는 패킷에 대한 상태 정보를 유지하지 않음&lt;br /&gt;
간단한 헤더구조(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8Byte&lt;/code&gt;), 블록 단위로 데이터 전송&lt;/p&gt;

&lt;h3 id=&quot;udp-프로토콜의-header-구조&quot;&gt;UDP 프로토콜의 Header 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;근원지 포트&lt;/strong&gt;(Source Port)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;목적지 포트&lt;/strong&gt;(Destination Port)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;수신자의 포트번호 길이&lt;/strong&gt;(Length)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;체크썸&lt;/strong&gt;(Checksum)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;voipvoice-over-ip&quot;&gt;VoIP(Voice Over IP)&lt;/h3&gt;
&lt;p&gt;UDP 프로토콜은 빠르게 데이터를 전송해야 하는 서비스에서 사용하는데 대표적인 활용이 VoIP&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RTP(Real Time Protocol) : 음성 전송&lt;/li&gt;
  &lt;li&gt;RTCP(Real Time Control Protocol) : 에러 처리&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="네트워크" /><category term="데이터통신" /><summary type="html">Transport Layer 수신측에 전달되는 데이터에 오류가 없고 데이터의 순서가 그대로 보존되도록 보장하는 연결 지향 서비스의 역할을 하는 종단 간 서비스(End-to-End) 계층</summary></entry><entry><title type="html">[네트워크] TCP/IP 인터넷, 네트워크 접근 계층</title><link href="https://many258.github.io/study/tcp-ip-internet-network-access/" rel="alternate" type="text/html" title="[네트워크] TCP/IP 인터넷, 네트워크 접근 계층" /><published>2021-03-11T00:00:00+09:00</published><updated>2021-03-11T23:37:34+09:00</updated><id>https://many258.github.io/study/%7Btcp-ip-internet-network-access%7D</id><content type="html" xml:base="https://many258.github.io/study/tcp-ip-internet-network-access/">&lt;h1 id=&quot;인터넷-계층internet-layer&quot;&gt;인터넷 계층(Internet Layer)&lt;/h1&gt;
&lt;p&gt;송신자의 IP주소와 수신자의 IP주소를 읽어서 경로를 결정하거나 전송하는 역할을 수행&lt;br /&gt;
다중 네트워크 링크를 통해 패킷의 발신지-대-목적지 전달에 대한 책임을 가진다.(데이터 링크 층은 노드간 전달 책임, Point-to-Point)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IP, ICMP&lt;/strong&gt;의 TCP/IP 프로토콜 군이 존재하고 멀티캐스팅을 위한 &lt;strong&gt;IGMP&lt;/strong&gt;, 라우팅을 위한 &lt;strong&gt;BGP, OSPF, RIP&lt;/strong&gt; 존재&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;경로설정&lt;/strong&gt;(Routing)&lt;br /&gt;
수신자의 IP주소를 읽어서 어떻게 목적기까지 가는 것이 최적의 경로인지를 판단하는 것. 라우터(Router)의 역할&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Point-To-Point&lt;/strong&gt; 패킷 전달&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;논리 주소&lt;/strong&gt; 지정 : IP주소로 변환하여 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주소 변환&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터그램&lt;/strong&gt; : 기존 패킷에 IP Header를 붙이는 것을 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;라우팅&quot;&gt;라우팅&lt;/h2&gt;
&lt;p&gt;목적지 IP주소를 읽어서 경로를 결정하는 작업.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정적&lt;/code&gt;&lt;/strong&gt; 경로 방법(Static Routing)&lt;br /&gt;
특정 목적지 네트워크로 가는 경로를 관리자가 직접 라우팅 테이블의 경로를 설정하는 방법&lt;br /&gt;
실시간으로 이루어지지 않기에 초기에 관리자가 다양한 라우팅 정보를 분석하여 최적의 경로 설정이 가능&lt;br /&gt;
라우터의 직접적인 처리 부하를 감소시킬 수 있어서 비교적 환경변화가 적은 형태의 네트워크에 적합
    &lt;ul&gt;
      &lt;li&gt;Floating static routing&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동적&lt;/code&gt;&lt;/strong&gt; 경로 방법(Dynamic Routing)&lt;br /&gt;
네트워크 상태를 파악해서 최적의 경로를 결정하는 방법&lt;br /&gt;
실시간으로 이루어지므로 네트워크 환경변화에 능동적인 대처가 가능&lt;br /&gt;
라우팅 알고리즘을 통해 자동으로 경로 설정이 이루어지며,&lt;br /&gt;
수시로 환경이 변화되는 형태의 네트워크에 적합
    &lt;ul&gt;
      &lt;li&gt;Distance Vector routing&lt;/li&gt;
      &lt;li&gt;Linked state routing&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;라우팅-프로토콜&quot;&gt;라우팅 프로토콜&lt;/h3&gt;
&lt;p&gt;인터네트워크를 통해서 데이터를 근원지에서 목적지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전달&lt;/code&gt;하는 기능 수행&lt;br /&gt;
경로 결정에서 최단경로 선정 및 전송 수행, 목적지에 대한 경로 정보를 인접한 라우터들과 교환하기 위한 규약&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IGP&lt;/strong&gt;(Internal Gateway Routing Protocol)&lt;br /&gt;
동일 그룹(기업 또는 ISP) 내에서 라우팅 정보를 교환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EGP&lt;/strong&gt;(Exterior Gateway Routing Protocol)&lt;br /&gt;
다른 그룹과의 라우팅 정보를 교환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Distance Vector routing&lt;/strong&gt;&lt;br /&gt;
최단 경로를 구하는 벨만 포드 알고리즘 기반&lt;br /&gt;
통과해야 하는 라우터의 수가 적은 쪽으로 경로를 결정. 일명 &lt;strong&gt;Hop Count&lt;/strong&gt; 또는 &lt;strong&gt;TTL&lt;/strong&gt;(Time to Live)&lt;br /&gt;
네트워크 변화 발생 시 해당 정보를 인접한 라우터에 정기적으로 전달하고,&lt;br /&gt;
인접 라우터에서는 라우팅 테이블 정보 갱신
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;라우팅 정보&lt;/strong&gt; : 모든 라우터까지의 거리 정보 보관&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;정보 전송 시점&lt;/strong&gt; : 일정주기(30초, 이웃 라우터와 공유)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;대표 프로토콜&lt;/strong&gt; : RIP, IGRP, EIGRP(내부 라우팅), BGP&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;br /&gt;
변화되는 라우팅 정보를 모든 라우터에 주기적으로 갱신(브로드캐스팅)하므로 망 자체 트래픽 유발&lt;br /&gt;
라우팅 정보를 변경하는 문제 발생 시 Routing Loop가 발생할 가능성 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Linked state routing&lt;/strong&gt;&lt;br /&gt;
최소 신상 트리를 구하는 다익스트라 알고리즘 기반&lt;br /&gt;
네트워크 대역폭, 지연정보 등을 종합적으로 고려해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cost&lt;/code&gt;를 산정하고 해당 Link의 Cost에 따라 경로를 결정하는 방법&lt;br /&gt;
네트워크 변화 감지 시 링크 상태 변경 정보를 인접한 라우터에게 즉각 전달하고 이를 저장
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;라우팅 정보&lt;/strong&gt; : 인정 라우터까지의 Link Cost 계산&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;정보 전송 시점&lt;/strong&gt; : 변화 발생 시에만&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;대표 프로토콜&lt;/strong&gt; : OSPF, IS-IS(소규모 네트워크)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;br /&gt;
네트워크 전체 정보 유지를 위한 많은 메모리 소요&lt;br /&gt;
라우터의 CPU 사용량이 많아짐&lt;br /&gt;
라우터간 회선의 대역차이로 동기화 실패할 가능성 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RIP&lt;/strong&gt;(Routing Information Protocol)&lt;br /&gt;
RFC 1058. 대표적인 거리 벡터 라우팅 프로토콜&lt;/p&gt;

    &lt;p&gt;라우터 간 거리 계산을 위한 척도로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;홉수&lt;/code&gt;(Hop Count) 사용&lt;br /&gt;
16Hop 이상이면 패킷을 폐기&lt;br /&gt;
180초 이내에 새로운 라우팅 정보가 수신되지 않으면 해당 경로를 이상 상태로 간주&lt;br /&gt;
수신된 목적지의 거리 값과 현재 거리 값을 비교하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;작은&lt;/code&gt; 것을 기준으로 라우팅 테이블을 변경&lt;/p&gt;

    &lt;p&gt;라우팅 정보 변경 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모든&lt;/code&gt; 망에 적용하므로 큰 규모의 망에는 부적합&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OSPF&lt;/strong&gt;(Open Shortest Path First)&lt;br /&gt;
RFC 1247. IP 라우팅 프로토콜&lt;/p&gt;

    &lt;p&gt;링크에서의 전송 시간을 링크 비용으로 사용하여 각 목적지별 최단 경로를 계산&lt;br /&gt;
네트워크에 변화가 발생했을 때 상대적으로 짧고 간단한 링크 상태 정보 교환&lt;/p&gt;

    &lt;p&gt;Link의 delay, throughput, reliability를 이용하여 기본적인 throughput만 이용하고, Hop수에 대한 제약이 없음&lt;br /&gt;
네트워크를 Area로 구분하여 많은 라우팅 정보의 교환으로 인한 라우터의 성능저하를 예방(대역폭을 절약)&lt;br /&gt;
Link 변화 감지 시 해당 Link에 대한 정보만을 즉시 모든 라우터에 전달하며 Convergence가 매우 빠름&lt;br /&gt;
Supernetting된 형태로 Routing Information을 전달할 수 있어 라우터 메모리 절약, 성능 향상 및 대역폭 절약&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ABR(Area Border Router)&lt;br /&gt;
Area에 백본망을 연결해주는 라우터&lt;/li&gt;
      &lt;li&gt;ASBR(Autonomous System Boundary Router)&lt;br /&gt;
다른 AS(Autonomous System)에 속한 라우터와 경로 정보를 교환&lt;/li&gt;
      &lt;li&gt;IR(Internal Router)&lt;br /&gt;
Area에 접속한 라우터&lt;/li&gt;
      &lt;li&gt;BR(Backbone Router)&lt;br /&gt;
백본망에 접속한 모든 라우터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BGP&lt;/strong&gt;(Border Gateway Protocol)&lt;br /&gt;
AS 상호 간의 routing에 적용되는 라우팅 프로토콜.&lt;br /&gt;
ISP(Internet Service Provider) 사업자들 상호 간에 주로 사용&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;EGP&lt;/strong&gt;라고 하는 Inter-Domain routing Protocol&lt;br /&gt;
인터넷을 AS 상호 간 연결 Path로 이루어진 방향성 그래프의 집단으로 인식&lt;br /&gt;
경로 벡터 라우팅 방법(&lt;strong&gt;path vector routing&lt;/strong&gt;)을 적용하며 경로 벡터 라우팅 테이블을 유지&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Looping Free Routing&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP&lt;/code&gt; 기반 라우팅&lt;br /&gt;
BGP 라우팅 정보는 라우터 간에 179번 포트를 통하여 TCP에 의해 신뢰성 있게 전달&lt;/li&gt;
      &lt;li&gt;라우팅 정보의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;점진적&lt;/code&gt; 갱신&lt;br /&gt;
BGP는 주기적으로 라우팅 정보를 갱신하지 않고, 변화가 있을 때 이웃 라우터에게 갱신 정보를 전달&lt;/li&gt;
      &lt;li&gt;다양한 라우팅 metric 사용&lt;br /&gt;
최상위 경로 선택을 위해 우선순위가 있는 각 metric을 참조&lt;/li&gt;
      &lt;li&gt;Class 없는 주소체계 지원&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CIDR&lt;/code&gt;(Classless Inter-Domain Routing) 지원&lt;/li&gt;
      &lt;li&gt;IBGP(Internal BGP) : 동일한 AS에 속한 BGP 라우터 간의 동작&lt;/li&gt;
      &lt;li&gt;EBGP(External BGP) : 서로 다른 AS에서 동작하는 BGP 프로토콜&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ipinternet-protocol&quot;&gt;IP(Internet Protocol)&lt;/h2&gt;
&lt;p&gt;IP 주소 형태로 송신자와 수신자의 IP를 가지고 있고 IP주소를 읽어서 최적의 경로를 결정할 수 있게 함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주소화&lt;/code&gt;, 데이터그램 포맷, 패킷 핸들링 등을 정의해놓은 인터넷 규약&lt;/li&gt;
  &lt;li&gt;IPv4 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;32bit&lt;/code&gt; 주소체계를 사용. (네트워크 ID + 호스트 ID)&lt;/li&gt;
  &lt;li&gt;IPv6 : IP주소의 부족 문제를 해결하기 위해 주소 비트수를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;128bit&lt;/code&gt;로 확장.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip-header-구조&quot;&gt;IP Header 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Version&lt;/strong&gt; : IPv4 버전&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Header Length&lt;/strong&gt; : Header의 전체 길이&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Type of Service&lt;/strong&gt; : 서비스 유형&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Total Length&lt;/strong&gt; : IP Datagram의 byte 수&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Identification&lt;/strong&gt; : Host에서 보낸 DataGram 식별&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Flags &amp;amp; Offset&lt;/strong&gt;&lt;br /&gt;
IP Datagram 단편화 정보&lt;br /&gt;
네트워크에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTU&lt;/code&gt;(Maximum Transmission Unit)라는 것이 존재하는데, 한 번에 통과할 수 있는 패킷의 최대 크기를 의미한다.&lt;/p&gt;

    &lt;p&gt;즉, MTU 값보다 크면 패킷은 분할(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단편화&lt;/code&gt; : Fragmentation)되고 그 정보를 Flags &amp;amp; Offset이 가지고 있게 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Time to Live&lt;/strong&gt;&lt;br /&gt;
Datagram이 통과할 수 있는 라우터 수(Linux 기본 = 64, Window 기본 = 128)&lt;br /&gt;
IP 패킷이 통과할 수 있는 라우터의 수를 의미. 라우터를 하나 통과 시 1씩 감소하며 0이 될 경우 자동 폐기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Protocol&lt;/strong&gt; : IP헤더 위의 상위 프로토콜 종류. ICMP, TCP, UDP&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Header Checksum&lt;/strong&gt; : IP Header 무결성 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip-주소의-구조&quot;&gt;IP 주소의 구조&lt;/h3&gt;
&lt;p&gt;클래스로 분류되며 클래스는 IP 주소를 분류하는 기준으로 사용.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Class&lt;/td&gt;
      &lt;td&gt;Content&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Class A&lt;/td&gt;
      &lt;td&gt;첫 바이트 7bit가 네트워크 식별자 한 네트워크에 가장 많은 호스트 수용 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Class B&lt;/td&gt;
      &lt;td&gt;14bit의 네트워크 식별자 한 네트워크에 약 2&lt;sup&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;16&lt;/code&gt;&lt;/sup&gt;대의 호스트 수용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Class C&lt;/td&gt;
      &lt;td&gt;세 번째 바이트까지 네트워크 식별자 한 네트워크에 254대까지 수용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Class D&lt;/td&gt;
      &lt;td&gt;멀티캐스트 주소로 사용&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/tcpip/ip-class.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;서브넷팅subnetting&quot;&gt;서브넷팅(Subnetting)&lt;/h3&gt;
&lt;p&gt;주어진 네트워크 주소를 작게 나누어 여러 개의 서브넷으로 구성&lt;br /&gt;
네트워크 식별자 부분을 구분하기 위한 Mask를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서브넷 마스크&lt;/code&gt;라고 함&lt;/p&gt;

&lt;h3 id=&quot;수퍼넷팅supernetting&quot;&gt;수퍼넷팅(Supernetting)&lt;/h3&gt;
&lt;p&gt;ISP(Internet Service Provider) 사업자가 많은 네트워크 망을 효율적을 관리하기 위해서 네트워크를 묶어 관리하는 방법&lt;/p&gt;

&lt;h3 id=&quot;cidrclassless-inter-domain-routing&quot;&gt;CIDR(Classless Inter-Domain Routing)&lt;/h3&gt;
&lt;p&gt;RFC 4632. IPv4의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IP 주소 고갈&lt;/code&gt; 및 라우팅 테이블 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대형화&lt;/code&gt;에 대한 해소책&lt;br /&gt;
기존의 클래스 A, B, C 네트워크 주소의 개념을 무시하고 IP주소와 서브넷 마스크를 이진 표기법으로 표현하여 기존의 고정크기 네트워크를 다양하고 세부적으로 분할한 것&lt;/p&gt;

&lt;h3 id=&quot;vlsmvariable-length-subnet-mask--가변길이-서브넷-마스크&quot;&gt;VLSM(Variable Length Subnet Mask : 가변길이 서브넷 마스크)&lt;/h3&gt;
&lt;p&gt;서브넷팅을 실시한 이후에도 IP 주소가 낭비되는 것을 방지하기 위해서 서브넷 마스크의 길이를 더 확장하여 늘리는 기능&lt;/p&gt;

&lt;h2 id=&quot;icmpinternet-control-message-protocol&quot;&gt;ICMP(Internet Control Message Protocol)&lt;/h2&gt;
&lt;p&gt;TCP/IP &lt;strong&gt;오류 제어&lt;/strong&gt; 프로토콜&lt;br /&gt;
호스트 및 라우터는 다른 호스트나 라우터가 현재 도달 가능한지의 여부를 결정&lt;br /&gt;
라우터는 특정 목적지 네트워크로 후속 IP 데이터그램을 보냈는데, 사용할 수 있는 최적의 경로가 있을 때 근원지 호스트에게 통지&lt;br /&gt;
호스트나 라우터는 그들이 처리하기에 너무 빠른 IP 데이터그램이 도착하면 다른 시스템에게 통보&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;오류 보고 메시지&lt;/strong&gt; : IP 패킷 처리 도중 발견된 문제를 보고&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;질의 메시지&lt;/strong&gt; : 다른 호스트로부터 특정 정보를 획득하기 위해 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;icmp-메시지-구조&quot;&gt;ICMP 메시지 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Type : ICMP 메시지 유형 표시&lt;/li&gt;
  &lt;li&gt;Code : Type과 같이 사용되며 세부적인 유형을 표현&lt;/li&gt;
  &lt;li&gt;Checksum : IP Datagram Checksum&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;icmp-메시지&quot;&gt;ICMP 메시지&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Type&lt;/td&gt;
      &lt;td&gt;Message&lt;/td&gt;
      &lt;td&gt;Content&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Destination Unreachable&lt;/td&gt;
      &lt;td&gt;라우터가 목적지를 찾지 못할 경우 보내는 메시지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Source Quench&lt;/td&gt;
      &lt;td&gt;패킷을 너무 빨리 보내 네트워크에 무리를 주는 호스트를 제지할 때 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Redirection&lt;/td&gt;
      &lt;td&gt;패킷 라우팅 경로를 수정, SMURF 공격에서 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8 or 0&lt;/td&gt;
      &lt;td&gt;Echo Request or Reply&lt;/td&gt;
      &lt;td&gt;Host의 존재를 확인&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;Time Exceeded&lt;/td&gt;
      &lt;td&gt;패킷을 보냈으나 시간이 경과하여 패킷이 삭제되었을 때 보내는 메시지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;Parameter Problem&lt;/td&gt;
      &lt;td&gt;IP 헤더 필드에 잘못된 정보가 있다는 것을 알림&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;13 or 14&lt;/td&gt;
      &lt;td&gt;Timestamp Request and Reply&lt;/td&gt;
      &lt;td&gt;Echo와 비슷하나 시간에 대한 정보 추가&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;데이터-전송-방식&quot;&gt;데이터 전송 방식&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Unicast&lt;br /&gt;
1:1 전송 방식.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Broadcast&lt;br /&gt;
1:N 전송 방식. 동일한 서브넷 상의 모든 수신자에게 전송&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Multicast&lt;br /&gt;
M:N 전송 방식. 하나 이상의 송신자들이 특정 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그룹&lt;/code&gt;의 수신자에게 전송&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IGMP&lt;/code&gt; : 그룹에 등록된 사용자를 관리하는 프로토콜
    &lt;ul&gt;
      &lt;li&gt;IGMP 메시지 구조 (8byte)
        &lt;ul&gt;
          &lt;li&gt;Version : IGMP 프로토콜의 버전&lt;/li&gt;
          &lt;li&gt;Type : 메시지 유형. (1 = 보고, 2 = 질의메시지)&lt;/li&gt;
          &lt;li&gt;Group ID&lt;br /&gt;
보고 메시지의 경우 호스트에서 신규 가입하고자 하는 멀티캐스트 서비스의 group id,&lt;br /&gt;
계속 받아보기를 원하는 멀티캐스트 서비스의 group id 질의 메시지인 경우는 ‘0’&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Anycast&lt;br /&gt;
그룹에 등록된 노드 중에서 최단경로 노드 한 개에만 전송.&lt;br /&gt;
IPv6에서 사용 (Broadcast 대신)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;arpaddress-resolution-protocol&quot;&gt;ARP(Address Resolution Protocol)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;IP주소&lt;/strong&gt;를 물리적 하드웨어 주소인 &lt;strong&gt;MAC 주소&lt;/strong&gt;로 변경하는 프로토콜&lt;br /&gt;
IP 주소와 이에 해당하는 물리적 네트워크 주소 정보는 각 IP 호스트의 &lt;strong&gt;ARP 캐시&lt;/strong&gt;라 불리는 메모리에 테이블 형태로 저장된 후 다음 패킷 전송 시에 다시 사용&lt;br /&gt;
ARP Cache Table : MAC 주소와 IP 주소를 보유하고 있는 매핑 테이블&lt;/p&gt;

&lt;h2 id=&quot;rarpreverse-address-resolution-protocol&quot;&gt;RARP(Reverse Address Resolution Protocol)&lt;/h2&gt;
&lt;p&gt;물리적인 &lt;strong&gt;주소 MAC&lt;/strong&gt;을 기반으로 논리적인 주소 &lt;strong&gt;IP&lt;/strong&gt;를 알아오는 프로토콜&lt;br /&gt;
운영체제도 없는 일종의 더미 터미널 Diskless Host에서 사용하는 것으로 자신의 물리적 주소인 MAC주소를 서버에 전송하고 IP주소를 수신 받아서 기동&lt;/p&gt;

&lt;h1 id=&quot;네트워크-접근-계층&quot;&gt;네트워크 접근 계층&lt;/h1&gt;
&lt;p&gt;논리적 주소인 IP 주소를 물리적 MAC 주소로 변환&lt;br /&gt;
Physical Layer가 이해할 수 있는 헤더를 붙여주는 Layer, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Frame&lt;/code&gt; 단위, MAC Address를 사용하는 계층&lt;/p&gt;

&lt;p&gt;Point-to-Point 간 신뢰성 있는 전송으로 &lt;strong&gt;흐름 제어&lt;/strong&gt; 기능을 담당&lt;br /&gt;
&lt;strong&gt;에러 제어&lt;/strong&gt; : Error Detection, Error Correction&lt;br /&gt;
&lt;strong&gt;MAC&lt;/strong&gt;(Media Access Control) : LAN 카드의 물리적 주소&lt;/p&gt;

&lt;h2 id=&quot;csmacd&quot;&gt;CSMA/CD&lt;/h2&gt;
&lt;p&gt;Carrier Sense Multiple Access/Collision Detection&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유선&lt;/code&gt; LAN에서 메시지를 송수신하기 위한 접근 방법. IEEE 802.3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt; 각 호스트들이 전송매체에 경쟁적으로 데이터를 전송&lt;br /&gt;
&lt;strong&gt;2)&lt;/strong&gt; 프레임을 전송하면서 충돌여부를 검사&lt;br /&gt;
&lt;strong&gt;3)&lt;/strong&gt; 전송 중 충돌이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;감지&lt;/code&gt;되면 패킷의 전송을 즉시 중단&lt;br /&gt;
&lt;strong&gt;4)&lt;/strong&gt; 충돌이 발생한 사실을 모든 스텐이션들이 알 수 있도록 간단한 통보신호 송신&lt;br /&gt;
&lt;strong&gt;5)&lt;/strong&gt; 통보신호에 따라 전송을 조절&lt;/p&gt;

&lt;p&gt;Collision이 일어난 경우 &lt;strong&gt;Back off&lt;/strong&gt; 알고리즘을 이용하여 재전송&lt;br /&gt;
&lt;strong&gt;리피터&lt;/strong&gt;와 &lt;strong&gt;허브&lt;/strong&gt;를 이용하면 Collision이 발생하나 &lt;strong&gt;Switch&lt;/strong&gt;는 Collision을 막을 수 있다&lt;br /&gt;
&lt;strong&gt;Switch&lt;/strong&gt;는 브로드캐스트를 막을 수 없고 &lt;strong&gt;Router&lt;/strong&gt;가 브로드캐스트를 막을 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Non-Persistent&lt;br /&gt;
매채가 사용 중이 아니면 즉시 전송&lt;br /&gt;
매체가 사용 중이면, 확률분포에서 구한 재전송 지연시간만큼 대기
    &lt;ul&gt;
      &lt;li&gt;임의 지연 사용은 충돌 확률을 감소&lt;/li&gt;
      &lt;li&gt;매체가 비었을 때 임의 지연 때문에 데이터 전송이 없는 채널 휴지 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;1-Persistent&lt;br /&gt;
매체가 사용 중이 아니면 즉시 전송&lt;br /&gt;
매체가 사용 중이면 대기 후 채널이 비는 순간 즉시 전송
    &lt;ul&gt;
      &lt;li&gt;채널 휴지 시간을 제거하기 위해 사용&lt;/li&gt;
      &lt;li&gt;임의 지연이 없게 하여 채널 휴지는 거의 없지만 충돌 확률이 높음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;p-Persistent&lt;br /&gt;
매체가 사용 중이 아니라면, 확률 p로 전송하고 (1-p)의 확률료 하나의 시간단위를 지연&lt;br /&gt;
매체가 사용 중이면 기다렸다가 채널이 비는 순간 확률 p로 전송하고 확률 (1-p)로 대기
    &lt;ul&gt;
      &lt;li&gt;위 장단점을 상호보완하기 위해 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;csmaca&quot;&gt;CSMA/CA&lt;/h2&gt;
&lt;p&gt;Carrier Sense Multiple Access/Collision Avoidance&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무선&lt;/code&gt; LAN에서 메시지의 송수신하기 위한 접근 방법&lt;/p&gt;

&lt;p&gt;프레임 전송 이전에 제어 메시지를 이용하여 수신자로부터 간단한 전송 유발&lt;br /&gt;
제어 신호에 대한 응답이 도착하면 프레임 전송&lt;/p&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="네트워크" /><category term="데이터통신" /><summary type="html">인터넷 계층(Internet Layer) 송신자의 IP주소와 수신자의 IP주소를 읽어서 경로를 결정하거나 전송하는 역할을 수행 다중 네트워크 링크를 통해 패킷의 발신지-대-목적지 전달에 대한 책임을 가진다.(데이터 링크 층은 노드간 전달 책임, Point-to-Point)</summary></entry><entry><title type="html">[네트워크] TCP/IP 4계층 및 응용계층</title><link href="https://many258.github.io/study/tcp-ip-application/" rel="alternate" type="text/html" title="[네트워크] TCP/IP 4계층 및 응용계층" /><published>2021-03-11T00:00:00+09:00</published><updated>2021-03-10T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Btcp-ip-application%7D</id><content type="html" xml:base="https://many258.github.io/study/tcp-ip-application/">&lt;h1 id=&quot;tcpip&quot;&gt;TCP/IP&lt;/h1&gt;
&lt;p&gt;Transmission Control Protocol/Internet Protocol&lt;/p&gt;

&lt;p&gt;DoD(미국방성)모델이라고 하며 OSI 7계층과 흡사하나 OSI보다 먼저 만들어지고 가장 많이 사용중이다.&lt;/p&gt;

&lt;h2 id=&quot;tcpip-구조&quot;&gt;TCP/IP 구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Application&lt;/strong&gt;(Application/Presentation/Session)&lt;br /&gt;
네트워크를 실제로 사용하는 응용프로그램으로 구성&lt;br /&gt;
FTP, TELNET, SMTP 등등&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Transport&lt;/strong&gt;(Transport)&lt;br /&gt;
도착하고자 하는 시스템까지 데이터를 전송&lt;br /&gt;
Port를 가지고 있으며, 프로세스를 연결 또는 비연결해서 통신함&lt;br /&gt;
TCP, UDP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Internet&lt;/strong&gt;(Network)&lt;br /&gt;
Datagram을 정의하고 routing하는 일을 담당&lt;br /&gt;
IP, ARP, RARP, ICMP, IGMP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Network Access&lt;/strong&gt;(Data Link/Physical)&lt;br /&gt;
케이블, 송수신기, 링크 프로토콜, LAN 접속과 같은 물리적 연결 구성을 정의&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;application-layer&quot;&gt;Application Layer&lt;/h2&gt;
&lt;p&gt;일반 사용자들이 사용하는 프로그램이 있는 계층. 사용자는 프로그램을 사용하여 통신.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#ftp&quot;&gt;&lt;strong&gt;FTP&lt;/strong&gt;&lt;/a&gt;(File Transfer Protocol)&lt;br /&gt;
사용자 파일의 업로드 혹은 다운로드를 수행하는 프로그램
파일 전송을 위한 인터넷 표준으로 제어 접속과 데이터 접속을 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분리&lt;/code&gt;된 포트를 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DNS&lt;/strong&gt;(Domain Name Service)&lt;br /&gt;
DNS 쿼리를 사용해서 DNS서버에 URL을 전송하고 해당 URL에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;매핑&lt;/code&gt;되는 IP주소를 제공하는 서비스&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#http&quot;&gt;&lt;strong&gt;HTTP&lt;/strong&gt;&lt;/a&gt;(Hyper Text Transfer Protocol)
WWW(World Wide Web)로 시작되는 인터넷에서 웹브라우저와 웹 서버 사이에 웹 페이지의 Request 및 Response를 수행하는 W3C 표준 개방형 프로토콜&lt;br /&gt;
TCP 기반 프로토콜의 80번 포트를 사용, State-less로 프로토콜을 구성
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;HTTP v1.0&lt;br /&gt;
연결을 수행할 때 마다 3-Way Handshaking 기법 사용&lt;br /&gt;
HTML 페이지를 수신 받고 완전히 종료&lt;br /&gt;
필요 시 재연결하고 페이지를 수신받음&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HTTP v1.1&lt;br /&gt;
어느 정도 대기한 후에 연결을 종료(Keep Alive Connection)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HTTP v2.0&lt;br /&gt;
&lt;strong&gt;멀티플랙싱&lt;/strong&gt;(Multiplexing) : 순차적 연결이 아니라 동시 다발적인 양방향 통신 지원&lt;br /&gt;
&lt;strong&gt;헤더압축&lt;/strong&gt;(Header Compression) : 헤더 정보를 1/3 수준으로 압축. 속도 향상&lt;br /&gt;
&lt;strong&gt;서버푸시&lt;/strong&gt;(Server Push) : 웹 서버가 웹 브라우저에게 필요한 데이터를 알아서 미리 전송할 수 있는 기술&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Telnet&lt;/strong&gt;&lt;br /&gt;
특정 지역의 사용자가 지역적으로 다른 곳에 위치한 컴퓨터를 온라인으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연결&lt;/code&gt;하여 사용하는 서비스&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#smtp&quot;&gt;&lt;strong&gt;SMTP&lt;/strong&gt;&lt;/a&gt;(Simple Mail Transfer Protocol)&lt;br /&gt;
TCP 25 Port. RFC821에 명시된 인터넷 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전자우편&lt;/code&gt;(MIME 데이터 형식)을 위한 프로토콜로 메시지 전달을 위해 Store and Forward 방식을 사용&lt;br /&gt;
암호화 및 인증 기능 없이 사용자의 e-mail을 전송하는 프로토콜&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#snmp&quot;&gt;&lt;strong&gt;SNMP&lt;/strong&gt;&lt;/a&gt;(Simple Network Management Protocol)&lt;br /&gt;
네트워크에 대한 트래픽, 세션 등의 네트워크 상태를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모니터링&lt;/code&gt;하고 정보를 전달할 때 사용되는 프로토콜&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-way-handshaking&quot;&gt;3-Way Handshaking&lt;/h3&gt;
&lt;p&gt;1) 웹브라우저(클라이언트)가 웹 서버에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt; 메시지를 전송&lt;br /&gt;
2) 웹 서버는 웹브라우저에게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt;로 응답&lt;br /&gt;
3) 웹브라우저는 웹 서버에 최종 연결확립 메시지인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt;를 전송해 웹 서버와 연결 확립(ESTABLISHED 상태)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/tcpip/3-way-handshake.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;http&quot;&gt;HTTP&lt;/h3&gt;
&lt;p&gt;Header : Request 시 전달해야 하는 웹브라우저 정보, 요청방식, 파라미터&lt;br /&gt;
Body : Request 할 때는 사용하지 않고 POST 방식의 Request 시 Body에 파라미터 정보를 넣고 전송&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP &lt;span style=&quot;color:blue&quot;&gt;Request&lt;/span&gt; 시 Header 구조
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Request Method&lt;/strong&gt;&lt;br /&gt;
호출되는 메소드. GET/POST/OPTIONS/PUT/DELETE/TRACE/CONNECT&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Accept&lt;/strong&gt;&lt;br /&gt;
웹 브라우저에서 사용 가능한 미디어 타입. text/html..등&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Accept-Language&lt;/strong&gt;&lt;br /&gt;
웹 브라우저가 인식할 수 있는 언어를 의미&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;User-Agent&lt;/strong&gt;&lt;br /&gt;
웹 브라우저 정보 의미&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Accept-Encoding&lt;/strong&gt;&lt;br /&gt;
웹 브라우저에서 제공되는 인코딩 방식&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;br /&gt;
웹 서버의 기본 URL&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Connection&lt;/strong&gt;&lt;br /&gt;
연결 지속(Keep Alive) 및 연결 끊기(Close) 상태 표시&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP &lt;span style=&quot;color:blue&quot;&gt;Response&lt;/span&gt; 시 Header 구조
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Status Code&lt;/strong&gt;&lt;br /&gt;
HTTP 응답코드. 200 : 성공적으로 처리&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;br /&gt;
서버 프로그램 이름과 버전 전송&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;br /&gt;
자원의 만기일자&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Cache Control&lt;/strong&gt;&lt;br /&gt;
캐시 사용 여부. HTTP/1.1&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;br /&gt;
캐시 사용 여부. HTTP/1.0&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Content-Encoding&lt;/strong&gt;&lt;br /&gt;
응답되는 메시지의 인코딩 방식&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Content-Length&lt;/strong&gt;&lt;br /&gt;
바이트 단위로 응답되는 리소스의 크기&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;br /&gt;
연결 유지 시간을 의미&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Connection&lt;/strong&gt;&lt;br /&gt;
Keep-Alive 사용 여부&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Content-Type&lt;/strong&gt;&lt;br /&gt;
응답되는 미디어 타입&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP 요청 방식
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt; 방식&lt;br /&gt;
서버에 전달할 때 데이터를 URL에 포함시켜서 요청&lt;br /&gt;
전송할 수 있는 데이터 양이 제한(2Kbyte or 4Kbyte)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;POST&lt;/strong&gt; 방식&lt;br /&gt;
서버에 전달할 때 데이터를 Request Body에 포함시킴&lt;br /&gt;
데이터 전송량의 제한이 없음&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;쿠키(Cookie)&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;웹브라우저&lt;/code&gt;에서 저장할 수 있는 작은 공간으로 개발자가 프로그램에 필요한 정보를 임시적으로 저장 가능&lt;br /&gt;
쿠키 값은 변조가 가능하기에 보안 상 주의를 요함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;세션(Session)&lt;br /&gt;
클라이언트와 웹 서버 사이의 네트워크 연결이 지속적으로 유지되는 상태&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;smtp&quot;&gt;SMTP&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;구성요소
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;MTA&lt;/strong&gt;(Mail Transfer Agent)&lt;br /&gt;
메일을 전송하는 서버&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;MDA&lt;/strong&gt;(Mail Delivery Agent)&lt;br /&gt;
MTA에게 받은 메일을 사용자에게 전달(수신측에 고용된 우체부)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;MUA&lt;/strong&gt;(Mail User Agent)&lt;br /&gt;
사용자들이 사용하는 클라이언트 어플리케이션&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기본 동작 방식&lt;br /&gt;
1) 송신자가 보낸 전자우편은 전자우편을 관리하는 메일 서버에 전달&lt;br /&gt;
2) 메일 서버는 수신자의 전자우편 주소를 분석하고 최단 경로를 찾아 근접한 메일 서버에게 편지를 전달&lt;br /&gt;
3) 최종 수신자 측 메일 서버에 도착하기까지 연속적으로 전달하는 중계 작업을 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;POP3&lt;/strong&gt;&lt;br /&gt;
TCP 110 Port. 메일서버에 접속하여 저장된 메일을 내려 받는 MDA 프로그램&lt;br /&gt;
메시지를 읽은 후 메일 서버에서 해당 메일을 삭제&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IMAP &amp;amp; IMAP3&lt;/strong&gt;&lt;br /&gt;
TCP 143 Port. 위 POP과 역할은 유사하나 메일을 내려받아도 메일 서버에 원본을 계속 저장한다는 차이점이 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ftp&quot;&gt;FTP&lt;/h3&gt;
&lt;p&gt;해당 컴퓨터에 등록된 사용자만 파일전송이 가능하며, 그 외에는 익명으로 사용&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ftpuser&lt;/code&gt;에 등록된 사용자는 FTP 접근 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;불가&lt;/code&gt;&lt;br /&gt;
제어 접속과 데이터 접속 포트 분리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Active Mode&lt;br /&gt;
1) 클라이언트에서 서버 TCP 21번 포트로 접속 시도&lt;br /&gt;
2) 서버는 TCP 20번 포트로 데이터를 송수신&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Passive Mode&lt;br /&gt;
1) 클라이언트는 서버의 TCP/21번 포트로 접속 후 두 번째 포트를 질의&lt;br /&gt;
2) 서버는 클라이언트에게 데이터 연결을 위한 두 번째 포트(TCP 1024 ~ 65535)을 알림&lt;br /&gt;
3) 클라이언트는 서버가 알려 준 두 번째 포트로 접속&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;snmp&quot;&gt;SNMP&lt;/h3&gt;
&lt;p&gt;운영되는 네트워크의 안정성, 효율성을 높이기 위해 구성/장애/통계/상태 정볼르 실시간으로 수집 및 분석하는 네트워크 관리 시스템&lt;/p&gt;

&lt;p&gt;NMS(Network Management System)는 SNMP 프로토콜을 사용해서 네트워크 정보 수집&lt;br /&gt;
MIB(Management Information Base)는 SNMP에서 모니터링해야 하는 객체 정보를 소유&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SNMP 명령
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt;&lt;br /&gt;
장비의 상태 및 기동시간 등의 관리 정보 읽기&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;GET-NEXT&lt;/strong&gt;&lt;br /&gt;
정보가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;계층적&lt;/code&gt; 구조를 가지므로 관리자가 장비 조회를 해서 해당 트리보다 하위층 정보를 읽기&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;SET&lt;/strong&gt;&lt;br /&gt;
장비 MIB를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조작&lt;/code&gt;하여 장비 제어/관리자는 요청을 보내 초기화 혹은 장비 재구성&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;TRAP&lt;/strong&gt;&lt;br /&gt;
일반적으로 SNMP는 Polling 방식으로 주기적으로 정보 요청과 요청에 대한 정보 응답 방식으로 동작되는데,&lt;br /&gt;
이 때 만약 연결구간이 혼잡하게 될 경우 중요한 관리 정보가 손실되어 그 정보를 인지 못할 수도 있다는 문제점을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보완&lt;/code&gt;하기 위해 TRAP 기술 도입&lt;/p&gt;

        &lt;p&gt;Manager가 요청 않더라도 Agent에 의해 자의적으로 경고, 고장통지 등 미리 설정된 유형의 보고서를 생성/송신&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="네트워크" /><category term="데이터통신" /><summary type="html">TCP/IP Transmission Control Protocol/Internet Protocol</summary></entry><entry><title type="html">[네트워크] 네트워크 개요 및 일반</title><link href="https://many258.github.io/study/network-base/" rel="alternate" type="text/html" title="[네트워크] 네트워크 개요 및 일반" /><published>2021-03-10T00:00:00+09:00</published><updated>2021-03-10T15:37:34+09:00</updated><id>https://many258.github.io/study/%7Bnetwork-base%7D</id><content type="html" xml:base="https://many258.github.io/study/network-base/">&lt;h1 id=&quot;네트워크&quot;&gt;네트워크&lt;/h1&gt;
&lt;p&gt;송신자의 메시지를 수신자에게 &lt;strong&gt;전달&lt;/strong&gt;하는 과정으로 한 지점에서 원하는 다른 지점까지 의미 있는 &lt;strong&gt;정보&lt;/strong&gt;를 보다 정확하고 빠르게 상대방이 이해할 수 있도록 전송하는 것을 의미&lt;/p&gt;

&lt;h1 id=&quot;프로토콜&quot;&gt;프로토콜&lt;/h1&gt;
&lt;p&gt;송신자와 수신자가 통신이라는 것을 하려면 서로 메시지의 포맷, 언제 데이터를 보낼 것인지, 한 번 전송하고 한 번 응답받는 형태로 할 것인지에 관한 것을 서로 약속해야 한다.
이 때, 이러한 약속이 &lt;strong&gt;프로토콜&lt;/strong&gt;을 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;네트워크의-분류&quot;&gt;네트워크의 분류&lt;/h2&gt;
&lt;h3 id=&quot;거리에-따른-네트워크-유형&quot;&gt;거리에 따른 네트워크 유형&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PAN&lt;/strong&gt;(Personal Area Network)&lt;br /&gt;
3M 이내의 인접 지역 간의 통신 방법&lt;br /&gt;
짧은 거리로 인하여 유선보다는 무선의 WPAN이 많이 활용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LAN&lt;/strong&gt;(Local Area Network)&lt;br /&gt;
근거리 영역의 네트워크로 동일한 지역 내 고속의 전용 회선으로 연결하여 구성하는 통신망&lt;br /&gt;
Client/Server와 peer-to-peer 모델&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;WAN&lt;/strong&gt;(Wide Area Network)&lt;br /&gt;
광대역 네트워크망으로 서로 관련이 있는 LAN 간의 상호 연결망&lt;br /&gt;
LAN에 비해 선로 에러율이 높고, 전송 지연이 크다&lt;br /&gt;
두 목적지 사이를 최단경로로 연결시켜 주는 라우팅 알고리즘 필요&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MAN&lt;/strong&gt;(Metropolitan Area Network)&lt;br /&gt;
LAN과 WAN의 중간 형태의 네트워크로 데이터, 음성, 영상 등을 지원하기 위해 개발&lt;br /&gt;
DQDB(Distributed Queue Dual Bus)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-전송-방식&quot;&gt;데이터 전송 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;단방향(Simplex)&lt;/li&gt;
  &lt;li&gt;반이중(Half Duplex)&lt;/li&gt;
  &lt;li&gt;전이중(Full Duplex)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;회선교환circuit-switching&quot;&gt;회선교환(Circuit Switching)&lt;/h2&gt;
&lt;p&gt;교환기를 통해 통신 회선을 설정하여 직접 데이터를 교환하는 방식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;전송 전에 회선이 전용선으로 설정 : 동일한 경로(독점)&lt;/li&gt;
      &lt;li&gt;데이터 전송이 없더라도 회선 해제 요청이 없으면 계속 접속 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유지&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;전송 시작 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;후&lt;/code&gt; 오버헤드가 없음&lt;/li&gt;
      &lt;li&gt;Point-to-Point 전송 구조&lt;/li&gt;
      &lt;li&gt;전송된 데이터의 에러 제어나 흐름 제어는 사용자에 의해 수행되어야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;대용량의 데이터를 고속으로 전송할 때 좋으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;고정&lt;/code&gt;적인 대역폭 사용&lt;/li&gt;
      &lt;li&gt;접속에는 긴 시간이 소요되나 그 후 접속이 항상 유지되어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전송 지연&lt;/code&gt;이 없고, 데이터 전송률이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;일정&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;아날로그나 디지털 데이터로 직접 전달&lt;/li&gt;
      &lt;li&gt;연속적인 전송에 적합(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실시간&lt;/code&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;회선 이용률 면에서 비효율적&lt;/li&gt;
      &lt;li&gt;연결된 두 장치는 반드시 같은 전송률과 같은 기종 사이에서만 송수신이 가능&lt;/li&gt;
      &lt;li&gt;속도나 코드의 변환이 불가능 : 교환망 내에서의 에러 제어 기능이 어려움&lt;/li&gt;
      &lt;li&gt;실시간 전송보다 에러없는 데이터 전송이 요구되는 구조에서는 부적합&lt;/li&gt;
      &lt;li&gt;통신 비용 고가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;패킷교환packet-switching&quot;&gt;패킷교환(Packet Switching)&lt;/h2&gt;
&lt;p&gt;송신측에서 메시지를 일정한 크기의 패킷으로 분해/전송, 수신측에서 원래의 데이터로 조립&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;패킷 다중화, 논리 채널, 경로 선택 제어, 순서 제어, 트래픽 제어, 오류 제어&lt;/li&gt;
      &lt;li&gt;수신된 패킷의 저장기능(대기 큐)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;순서 제어&lt;/strong&gt; 기능 : 목적지에서 수신된 패킷의 순서를 재정렬&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;트래픽 제어&lt;/strong&gt; : 흐름 제어, 혼잡 제어, 교착상태&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;경로 배정 요소&lt;/strong&gt; : 성능 기준, 결정 시간, 결정 장소, 네트워크 정보&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;회선 이용률이 높고, 속도 변환, 프로토콜 변환 가능, 음성 통화&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;고신뢰성&lt;/strong&gt; : 상황에 따라 교환기 및 회선 등의 장애가 발생하더라도 패킷의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우회전송&lt;/code&gt;이 가능하므로 전송의 신뢰성 보장&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;고품질&lt;/strong&gt; : 디지털 전송이므로, 인접 간에 또는 단말기와 교환기 간에 전송, 오류 검사를 실시하여 오류 발생 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;재전송&lt;/code&gt; 가능&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;고효율&lt;/strong&gt; : 다중화를 사용하므로 전송로 사용 및 효율이 좋다&lt;/li&gt;
      &lt;li&gt;이 기종 단말장치 간 통신 : 전송 속도, 전송 제어 절차가 다르더라도 교환망이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;변환 처리&lt;/code&gt;를 제공하므로 통신 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;각 교환기의 경로에서 다소 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연&lt;/code&gt;이 발생&lt;/li&gt;
      &lt;li&gt;이러한 지연은 가변적임. 전송량이 증가함에 따라 지연이 더욱 심할 수 있음&lt;/li&gt;
      &lt;li&gt;패킷별 헤더 추가로 인한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오버헤드&lt;/code&gt; 발생 가능성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;패킷교환-방식의-종류&quot;&gt;패킷교환 방식의 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;가상회선&lt;/strong&gt;(Virtual Circuit)
    &lt;ul&gt;
      &lt;li&gt;패킷을 전송하기 전에 논리적인 연결을 먼저 수행 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연결형&lt;/code&gt; 서비스&lt;/li&gt;
      &lt;li&gt;호출 요구를 하고 호출 수신 패킷을 주고받아서 연결하는 방식(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X.21&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;회선교환처럼 사용하지만 교환기에 패킷이 일시적으로 저장되며 일정한 전송률 보장 불가&lt;/li&gt;
      &lt;li&gt;비교적 긴 메시지의 전송 시 더 효과적&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터그램&lt;/strong&gt;(Datagram)
    &lt;ul&gt;
      &lt;li&gt;각 전송 패킷을 미리 정해진 경로 없이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;독립적&lt;/code&gt;으로 처리하여 교환하는 방식&lt;/li&gt;
      &lt;li&gt;같은 목적지의 패킷도 같은 경로를 거치지 않고 서로 다른 경로를 통해서 목적지에 도달&lt;/li&gt;
      &lt;li&gt;망의 한 부분이 혼잡할 때 패킷에 다른 경로를 지정하여 배정 가능, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;융통성&lt;/code&gt; 있는 경로를 설정&lt;/li&gt;
      &lt;li&gt;특정 교환기의 고장 시 모든 패킷을 잃어버리는 가상회선 방식과는 달리, 그 경로를 피해서 전송할 수 있음 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;신뢰성&lt;/code&gt; 보장&lt;/li&gt;
      &lt;li&gt;짧은 메시지의 패킷들을 전송할 때 효과적, 재정렬 기능 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;네트워크-토폴로지network-topology&quot;&gt;네트워크 토폴로지(Network Topology)&lt;/h2&gt;
&lt;p&gt;컴퓨터 네트워크의 요소들(링크, 노드)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/base/NetworkTopologies.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;계층형&lt;/strong&gt;(트리형)
    &lt;ul&gt;
      &lt;li&gt;Tree 구조, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최상위&lt;/code&gt;에 있는 노드가 네트워크 제어&lt;/li&gt;
      &lt;li&gt;통제 및 유지 보수 용이&lt;/li&gt;
      &lt;li&gt;단말기의 추가나 제거 및 에러 발생 시 발견이 쉬움&lt;/li&gt;
      &lt;li&gt;병목 현상 발생 가능, 중앙 노드 장애 발생 시 전체 통신망 마비&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수평형&lt;/strong&gt;(버스형)
    &lt;ul&gt;
      &lt;li&gt;중앙 통신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;회선&lt;/code&gt; 하나에 여러 대의 노드를 연결하는 방식&lt;/li&gt;
      &lt;li&gt;근거리 통신망에서 볼 수 있는 일반적인 형태&lt;/li&gt;
      &lt;li&gt;하나의 컴퓨터가 다운되어도 나머지 컴퓨터에는 지장이 없음&lt;/li&gt;
      &lt;li&gt;DTE 추가 삭제가 용이&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위&lt;/code&gt; 제어가 어려움&lt;/li&gt;
      &lt;li&gt;통신 회선의 길이에 제한, 충돌이 자주 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성형&lt;/strong&gt;(스타형)
    &lt;ul&gt;
      &lt;li&gt;중앙에 있는 컴퓨터를 중심으로 터미널이 연결된 중앙 집중식 형태&lt;/li&gt;
      &lt;li&gt;유지보수 및 관리가 용이, 단말기 고장 시 발견이 용이&lt;/li&gt;
      &lt;li&gt;중앙 컴퓨터 고장 시 전체 네트워크 마비&lt;/li&gt;
      &lt;li&gt;통신망 제어가 복잡&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;원형&lt;/strong&gt;(링형)
    &lt;ul&gt;
      &lt;li&gt;인접해 있는 노드들을 연결하는 단방향 전송 형태&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;매채 엑세스&lt;/code&gt; 방식&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;토큰 링&lt;/code&gt; 이용, 동축/광섬유 케이블 이용&lt;/li&gt;
      &lt;li&gt;전송 매체와 DTE 고장 시 발견이 용이&lt;/li&gt;
      &lt;li&gt;단말기 추가 및 삭제가 어려움&lt;/li&gt;
      &lt;li&gt;전송 지연 발생 시 DTE 간의 순차적 전송때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중계기&lt;/code&gt; 기능이 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;망형&lt;/strong&gt;(메쉬형)
    &lt;ul&gt;
      &lt;li&gt;모든 노드들이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상호&lt;/code&gt; 연결&lt;/li&gt;
      &lt;li&gt;통신 회선 장애 시 다른 경로로 데이터 전송이 가능&lt;/li&gt;
      &lt;li&gt;DTE 고장과 병목 현상에 대해 면역성이 있음&lt;/li&gt;
      &lt;li&gt;가장 많은 통신 선로가 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;osi-7계층&quot;&gt;OSI 7계층&lt;/h2&gt;
&lt;p&gt;Open System Interconnection 7-layer&lt;br /&gt;
개방형 시스템 네트워크의 효율적인 이용을 위하여 모든 데이터 통신 기준으로 계층을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분할&lt;/code&gt;하고, 각 계층 간의 필요한 프로토콜을 규정한다.&lt;/p&gt;

&lt;p&gt;정보가 전달되는 Framework를 제공하며, 네트워크 형태에 차이가 발생해도 데이터 통신을 지원&lt;/p&gt;

&lt;h3 id=&quot;osi-7계층-구조&quot;&gt;OSI 7계층 구조&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;OSI 7계층&lt;/td&gt;
      &lt;td&gt;주요 내용&lt;/td&gt;
      &lt;td&gt;주요 프로토콜(매체)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7. Application&lt;/td&gt;
      &lt;td&gt;사용자 소프트웨어를 네트워크에 접근 가능하도록 함.&lt;br /&gt;사용자에게 최종 서비스를 제공&lt;/td&gt;
      &lt;td&gt;FTP, SNMP, HTTP, Mail, Telnet 등&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6. Presentation&lt;/td&gt;
      &lt;td&gt;포맷 기능, 압축, 암호화&lt;br /&gt;텍스트 및 그래픽 정보를 컴퓨터가 이해할 수 있는 16진수 데이터로 변환&lt;/td&gt;
      &lt;td&gt;압축, 암호, 코드 변환  GIF, ASCII, EBCDIC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5. Session&lt;/td&gt;
      &lt;td&gt;세션 연결 및 동기화 수행, 통신 방식 결정&lt;br /&gt;가상 연결을 제공하여 Login/Logout 수행&lt;/td&gt;
      &lt;td&gt;반이중, 전이중, 완전이중 결정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4. Transport&lt;/td&gt;
      &lt;td&gt;가상연결, 에러 제어, 데이터 흐름 제어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Segment&lt;/code&gt; 단위&lt;br /&gt;두 개의 종단 간 End-To-End 데이터 흐름이 가능하도록 논리적 주소 연결&lt;br /&gt;신뢰도, 품질보증, 오류탐지 및 교정 기능 제공  다중화(Multiplexing) 발생&lt;/td&gt;
      &lt;td&gt;TCP, UDP&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3. Network&lt;/td&gt;
      &lt;td&gt;경로선택, 라우팅 수행, 논리적 주소 연결(IP)&lt;br /&gt;데이터 흐름 조절, 주소 지정 메커니즘 구현  네트워크에서 노드에 전송되는 패킷 흐름을 통제하고, 상태메시지가 네트워크상에서 어떻게 노드로 전송되는 가를 정의, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Datagram&lt;/code&gt;(Packet) 단위&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2. Data Link&lt;/td&gt;
      &lt;td&gt;물리주소 결정, 에러 제어, 흐름 제어, 데이터 전송&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Frame&lt;/code&gt; 단위, 전송 오류를 처리하는 최초의 계층&lt;/td&gt;
      &lt;td&gt;흐름제어, 오류제어(ARQ)  브리지, PPTP, L2TP, HDLC  Frame Relay&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1. Physical&lt;/td&gt;
      &lt;td&gt;전기적, 기계적 연결 정의, 실제 Data Bit 전송&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bit&lt;/code&gt; 단위, 전기적 신호, 전압구성, 케이블, 인터페이스 등을 구성&lt;br /&gt;Data Rates, Line noise Control, 동기화 기능 수행&lt;/td&gt;
      &lt;td&gt;매체: 동축케이블, 광섬유, Twisted Pair Cable&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;End-to-End&lt;/strong&gt; : 7 ~ 4계층, 송수신자 간의 에러 제어&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Point-to-Point&lt;/strong&gt; : 4 ~ 1계층, 각 구간에 대해 에러 제어&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;osi-계층별-하드웨어-장비&quot;&gt;OSI 계층별 하드웨어 장비&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Physical
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Cable&lt;/strong&gt;&lt;br /&gt;
Twisted Pair Cable, Coaxial, Fiber-Optic Cable&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Repeater&lt;/strong&gt;&lt;br /&gt;
네트워크 구간 케이블의 전기적 신호를 재생하고 증폭하는 장치
디지털 신호를 제공, 아날로그 신호 증폭 시 잡음과 왜곡까지 증폭&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data Link
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Bridge&lt;/strong&gt;&lt;br /&gt;
서로 다른 LAN Segment를 연결, 관리자에게 MAC 주소 기반 필터링 제공하여 더 나은 대역폭 사용과 트래픽을 통제
리피터와 같이 데이터 신호를 증폭하지만 MAC 기반에서 동작&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Switch&lt;/strong&gt;&lt;br /&gt;
목적지의 MAC 주소를 알고 있는 지정된 포트로 데이터를 전송
Repeater와 Bridge의 기능을 결합
네트워크의 속도 및 효율적 운영, Data Link 계층에서도 작동&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Network
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Router&lt;/strong&gt;&lt;br /&gt;
패킷을 받아 경로를 설정하고 패킷을 전달
Bridge는 MAC 주소를 참조하지만, Router는 네트워크 주소를 참조하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;경로&lt;/code&gt;를 설정
패킷 헤더 정보에서 IP 주소를 확인하여 목적지 네트워크로만 전달하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Broadcasting&lt;/code&gt;을 차단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Application
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Gateway&lt;/strong&gt;&lt;br /&gt;
서로 다른 네트워크망과의 연결(PSTN, Internet, Wireless Network 등)
패킷 헤더의 주소 및 포트 외 거의 모든 정보를 참조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-전송-방식-1&quot;&gt;데이터 전송 방식&lt;/h3&gt;
&lt;h4 id=&quot;직렬-전송serial-transmission&quot;&gt;직렬 전송(Serial Transmission)&lt;/h4&gt;
&lt;p&gt;한 문자의 각 비트 열을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나의&lt;/code&gt; 전송 선로를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;순차적&lt;/code&gt;으로 전송하는 방식(모뎀)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시프트 레지스터를 이용하여 병렬을 직렬화한 후 송신&lt;/li&gt;
  &lt;li&gt;동기 전송 방식의 요구&lt;/li&gt;
  &lt;li&gt;전송 에러가 적고, 장거리에 적합&lt;/li&gt;
  &lt;li&gt;통신 회선 설치 비용이 저렴&lt;/li&gt;
  &lt;li&gt;전송 속도가 느림&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;병렬-전송parallel-transmission&quot;&gt;병렬 전송(Parallel Transmission)&lt;/h4&gt;
&lt;p&gt;한 문자를 이루는 각 비트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;각각의&lt;/code&gt; 전송로를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;한꺼번에&lt;/code&gt; 전송되는 방식(프린터)
블록 버퍼를 이용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;송수신 문자 간격을 식별하는 스트로브 신호와 BUSY 신호로 다음 문자의 송신 시기 결정&lt;/li&gt;
  &lt;li&gt;단위 시간에 다량의 데이터를 빠른 속도로 전송&lt;/li&gt;
  &lt;li&gt;전송 길이가 길어지면 에러 발생 가능성 농후&lt;/li&gt;
  &lt;li&gt;통신 회선 설치 비용이 커짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;동기-방식synchronous-method&quot;&gt;동기 방식(Synchronous Method)&lt;/h4&gt;
&lt;p&gt;전송할 데이터를 여러 블록으로 나누어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블록&lt;/code&gt; 단위로 전송하는 방식
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 정보&lt;/code&gt;를 데이터의 앞뒤에 붙여 프레임을 구성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;전송 단위&lt;/strong&gt; : 프레임, 문자 중심 / 비트 중심&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;에러 검출&lt;/strong&gt; : CRC&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오버헤드&lt;/strong&gt; : 프레임당 고정된 크기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 속도&lt;/strong&gt; : 고속&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 효율&lt;/strong&gt; : 높다(휴지 간격 없음, 채널 할당 시간 공백 없음)&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;원거리 전송에 이용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;에러 발생 확률이 높다&lt;/li&gt;
      &lt;li&gt;고가(별도의 하드웨어 장치가 필요)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;비동기-방식asynchronous-method&quot;&gt;비동기 방식(Asynchronous Method)&lt;/h4&gt;
&lt;p&gt;한 번에 한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;문자씩&lt;/code&gt; 전송하는 방식(한 문자 전송 시마다 동기화하는 방식)&lt;br /&gt;
start-stop 비트를 사용, 패리티 비트, 정지 비트 ‘1’ 시작비트 ‘0’&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;전송 단위&lt;/strong&gt; : 문자 단위의 비트 블록&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;에러 검출&lt;/strong&gt; : 패리티 비트&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오버헤드&lt;/strong&gt; : 문자당 고정된 크기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 속도&lt;/strong&gt; : 저속&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 효율&lt;/strong&gt; : 낮음&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;동기화가 단순하며 저렴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;문자당 2~3비트의 오버헤드가 발생&lt;/li&gt;
      &lt;li&gt;프레임 에러가 발생할 가능성이 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="데이터통신" /><category term="네트워크" /><summary type="html">네트워크 송신자의 메시지를 수신자에게 전달하는 과정으로 한 지점에서 원하는 다른 지점까지 의미 있는 정보를 보다 정확하고 빠르게 상대방이 이해할 수 있도록 전송하는 것을 의미</summary></entry></feed>