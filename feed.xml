<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://many258.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://many258.github.io/" rel="alternate" type="text/html" /><updated>2021-03-12T18:54:46+09:00</updated><id>https://many258.github.io/feed.xml</id><title type="html">My expression</title><subtitle>My expression</subtitle><author><name>SG Yoo.</name><email>many258@naver.com</email></author><entry><title type="html">[네트워크] TCP/IP 4계층 및 응용계층</title><link href="https://many258.github.io/study/tcp-ip-application/" rel="alternate" type="text/html" title="[네트워크] TCP/IP 4계층 및 응용계층" /><published>2021-03-11T00:00:00+09:00</published><updated>2021-03-10T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Btcp-ip-application%7D</id><content type="html" xml:base="https://many258.github.io/study/tcp-ip-application/">&lt;h1 id=&quot;tcpip&quot;&gt;TCP/IP&lt;/h1&gt;
&lt;p&gt;Transmission Control Protocol/Internet Protocol&lt;/p&gt;

&lt;p&gt;DoD(미국방성)모델이라고 하며 OSI 7계층과 흡사하나 OSI보다 먼저 만들어지고 가장 많이 사용중이다.&lt;/p&gt;

&lt;h2 id=&quot;tcpip-구조&quot;&gt;TCP/IP 구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Application&lt;/strong&gt;(Application/Presentation/Session)&lt;br /&gt;
네트워크를 실제로 사용하는 응용프로그램으로 구성&lt;br /&gt;
FTP, TELNET, SMTP 등등&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Transport&lt;/strong&gt;(Transport)&lt;br /&gt;
도착하고자 하는 시스템까지 데이터를 전송&lt;br /&gt;
Port를 가지고 있으며, 프로세스를 연결 또는 비연결해서 통신함&lt;br /&gt;
TCP, UDP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Internet&lt;/strong&gt;(Network)&lt;br /&gt;
Datagram을 정의하고 routing하는 일을 담당&lt;br /&gt;
IP, ARP, RARP, ICMP, IGMP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Network Access&lt;/strong&gt;(Data Link/Physical)&lt;br /&gt;
케이블, 송수신기, 링크 프로토콜, LAN 접속과 같은 물리적 연결 구성을 정의&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;application-layer&quot;&gt;Application Layer&lt;/h2&gt;
&lt;p&gt;일반 사용자들이 사용하는 프로그램이 있는 계층. 사용자는 프로그램을 사용하여 통신.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#ftp&quot;&gt;&lt;strong&gt;FTP&lt;/strong&gt;&lt;/a&gt;(File Transfer Protocol)&lt;br /&gt;
사용자 파일의 업로드 혹은 다운로드를 수행하는 프로그램
파일 전송을 위한 인터넷 표준으로 제어 접속과 데이터 접속을 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분리&lt;/code&gt;된 포트를 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DNS&lt;/strong&gt;(Domain Name Service)&lt;br /&gt;
DNS 쿼리를 사용해서 DNS서버에 URL을 전송하고 해당 URL에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;매핑&lt;/code&gt;되는 IP주소를 제공하는 서비스&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#http&quot;&gt;&lt;strong&gt;HTTP&lt;/strong&gt;&lt;/a&gt;(Hyper Text Transfer Protocol)
WWW(World Wide Web)로 시작되는 인터넷에서 웹브라우저와 웹 서버 사이에 웹 페이지의 Request 및 Response를 수행하는 W3C 표준 개방형 프로토콜&lt;br /&gt;
TCP 기반 프로토콜의 80번 포트를 사용, State-less로 프로토콜을 구성
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;HTTP v1.0&lt;br /&gt;
연결을 수행할 때 마다 3-Way Handshaking 기법 사용&lt;br /&gt;
HTML 페이지를 수신 받고 완전히 종료&lt;br /&gt;
필요 시 재연결하고 페이지를 수신받음&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HTTP v1.1&lt;br /&gt;
어느 정도 대기한 후에 연결을 종료(Keep Alive Connection)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;HTTP v2.0&lt;br /&gt;
&lt;strong&gt;멀티플랙싱&lt;/strong&gt;(Multiplexing) : 순차적 연결이 아니라 동시 다발적인 양방향 통신 지원&lt;br /&gt;
&lt;strong&gt;헤더압축&lt;/strong&gt;(Header Compression) : 헤더 정보를 1/3 수준으로 압축. 속도 향상&lt;br /&gt;
&lt;strong&gt;서버푸시&lt;/strong&gt;(Server Push) : 웹 서버가 웹 브라우저에게 필요한 데이터를 알아서 미리 전송할 수 있는 기술&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Telnet&lt;/strong&gt;&lt;br /&gt;
특정 지역의 사용자가 지역적으로 다른 곳에 위치한 컴퓨터를 온라인으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연결&lt;/code&gt;하여 사용하는 서비스&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;#smtp&quot;&gt;&lt;strong&gt;SMTP&lt;/strong&gt;&lt;/a&gt;(Simple Mail Transfer Protocol)&lt;br /&gt;
TCP 25 Port. RFC821에 명시된 인터넷 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전자우편&lt;/code&gt;(MIME 데이터 형식)을 위한 프로토콜로 메시지 전달을 위해 Store and Forward 방식을 사용&lt;br /&gt;
암호화 및 인증 기능 없이 사용자의 e-mail을 전송하는 프로토콜&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#snmp&quot;&gt;&lt;strong&gt;SNMP&lt;/strong&gt;&lt;/a&gt;(Simple Network Management Protocol)&lt;br /&gt;
네트워크에 대한 트래픽, 세션 등의 네트워크 상태를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모니터링&lt;/code&gt;하고 정보를 전달할 때 사용되는 프로토콜&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;3-way-handshaking&quot;&gt;3-Way Handshaking&lt;/h3&gt;
&lt;p&gt;1) 웹브라우저(클라이언트)가 웹 서버에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt; 메시지를 전송&lt;br /&gt;
2) 웹 서버는 웹브라우저에게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt;로 응답&lt;br /&gt;
3) 웹브라우저는 웹 서버에 최종 연결확립 메시지인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt;를 전송해 웹 서버와 연결 확립(ESTABLISHED 상태)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/tcpip/3-way-handshake.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;http&quot;&gt;HTTP&lt;/h3&gt;
&lt;p&gt;Header : Request 시 전달해야 하는 웹브라우저 정보, 요청방식, 파라미터&lt;br /&gt;
Body : Request 할 때는 사용하지 않고 POST 방식의 Request 시 Body에 파라미터 정보를 넣고 전송&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP &lt;span style=&quot;color:blue&quot;&gt;Request&lt;/span&gt; 시 Header 구조
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Request Method&lt;/strong&gt;&lt;br /&gt;
호출되는 메소드. GET/POST/OPTIONS/PUT/DELETE/TRACE/CONNECT&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Accept&lt;/strong&gt;&lt;br /&gt;
웹 브라우저에서 사용 가능한 미디어 타입. text/html..등&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Accept-Language&lt;/strong&gt;&lt;br /&gt;
웹 브라우저가 인식할 수 있는 언어를 의미&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;User-Agent&lt;/strong&gt;&lt;br /&gt;
웹 브라우저 정보 의미&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Accept-Encoding&lt;/strong&gt;&lt;br /&gt;
웹 브라우저에서 제공되는 인코딩 방식&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;br /&gt;
웹 서버의 기본 URL&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Connection&lt;/strong&gt;&lt;br /&gt;
연결 지속(Keep Alive) 및 연결 끊기(Close) 상태 표시&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP &lt;span style=&quot;color:blue&quot;&gt;Response&lt;/span&gt; 시 Header 구조
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Status Code&lt;/strong&gt;&lt;br /&gt;
HTTP 응답코드. 200 : 성공적으로 처리&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;br /&gt;
서버 프로그램 이름과 버전 전송&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;br /&gt;
자원의 만기일자&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Cache Control&lt;/strong&gt;&lt;br /&gt;
캐시 사용 여부. HTTP/1.1&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;br /&gt;
캐시 사용 여부. HTTP/1.0&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Content-Encoding&lt;/strong&gt;&lt;br /&gt;
응답되는 메시지의 인코딩 방식&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Content-Length&lt;/strong&gt;&lt;br /&gt;
바이트 단위로 응답되는 리소스의 크기&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;br /&gt;
연결 유지 시간을 의미&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Connection&lt;/strong&gt;&lt;br /&gt;
Keep-Alive 사용 여부&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Content-Type&lt;/strong&gt;&lt;br /&gt;
응답되는 미디어 타입&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP 요청 방식
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt; 방식&lt;br /&gt;
서버에 전달할 때 데이터를 URL에 포함시켜서 요청&lt;br /&gt;
전송할 수 있는 데이터 양이 제한(2Kbyte or 4Kbyte)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;POST&lt;/strong&gt; 방식&lt;br /&gt;
서버에 전달할 때 데이터를 Request Body에 포함시킴&lt;br /&gt;
데이터 전송량의 제한이 없음&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;쿠키(Cookie)&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;웹브라우저&lt;/code&gt;에서 저장할 수 있는 작은 공간으로 개발자가 프로그램에 필요한 정보를 임시적으로 저장 가능&lt;br /&gt;
쿠키 값은 변조가 가능하기에 보안 상 주의를 요함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;세션(Session)&lt;br /&gt;
클라이언트와 웹 서버 사이의 네트워크 연결이 지속적으로 유지되는 상태&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;smtp&quot;&gt;SMTP&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;구성요소
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;MTA&lt;/strong&gt;(Mail Transfer Agent)&lt;br /&gt;
메일을 전송하는 서버&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;MDA&lt;/strong&gt;(Mail Delivery Agent)&lt;br /&gt;
MTA에게 받은 메일을 사용자에게 전달(수신측에 고용된 우체부)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;MUA&lt;/strong&gt;(Mail User Agent)&lt;br /&gt;
사용자들이 사용하는 클라이언트 어플리케이션&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기본 동작 방식&lt;br /&gt;
1) 송신자가 보낸 전자우편은 전자우편을 관리하는 메일 서버에 전달&lt;br /&gt;
2) 메일 서버는 수신자의 전자우편 주소를 분석하고 최단 경로를 찾아 근접한 메일 서버에게 편지를 전달&lt;br /&gt;
3) 최종 수신자 측 메일 서버에 도착하기까지 연속적으로 전달하는 중계 작업을 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;POP3&lt;/strong&gt;&lt;br /&gt;
TCP 110 Port. 메일서버에 접속하여 저장된 메일을 내려 받는 MDA 프로그램&lt;br /&gt;
메시지를 읽은 후 메일 서버에서 해당 메일을 삭제&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;IMAP &amp;amp; IMAP3&lt;/strong&gt;&lt;br /&gt;
TCP 143 Port. 위 POP과 역할은 유사하나 메일을 내려받아도 메일 서버에 원본을 계속 저장한다는 차이점이 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ftp&quot;&gt;FTP&lt;/h3&gt;
&lt;p&gt;해당 컴퓨터에 등록된 사용자만 파일전송이 가능하며, 그 외에는 익명으로 사용&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ftpuser&lt;/code&gt;에 등록된 사용자는 FTP 접근 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;불가&lt;/code&gt;&lt;br /&gt;
제어 접속과 데이터 접속 포트 분리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Active Mode&lt;br /&gt;
1) 클라이언트에서 서버 TCP 21번 포트로 접속 시도&lt;br /&gt;
2) 서버는 TCP 20번 포트로 데이터를 송수신&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Passive Mode&lt;br /&gt;
1) 클라이언트는 서버의 TCP/21번 포트로 접속 후 두 번째 포트를 질의&lt;br /&gt;
2) 서버는 클라이언트에게 데이터 연결을 위한 두 번째 포트(TCP 1024 ~ 65535)을 알림&lt;br /&gt;
3) 클라이언트는 서버가 알려 준 두 번째 포트로 접속&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;snmp&quot;&gt;SNMP&lt;/h3&gt;
&lt;p&gt;운영되는 네트워크의 안정성, 효율성을 높이기 위해 구성/장애/통계/상태 정볼르 실시간으로 수집 및 분석하는 네트워크 관리 시스템&lt;/p&gt;

&lt;p&gt;NMS(Network Management System)는 SNMP 프로토콜을 사용해서 네트워크 정보 수집&lt;br /&gt;
MIB(Management Information Base)는 SNMP에서 모니터링해야 하는 객체 정보를 소유&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SNMP 명령
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;GET&lt;/strong&gt;&lt;br /&gt;
장비의 상태 및 기동시간 등의 관리 정보 읽기&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;GET-NEXT&lt;/strong&gt;&lt;br /&gt;
정보가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;계층적&lt;/code&gt; 구조를 가지므로 관리자가 장비 조회를 해서 해당 트리보다 하위층 정보를 읽기&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;SET&lt;/strong&gt;&lt;br /&gt;
장비 MIB를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조작&lt;/code&gt;하여 장비 제어/관리자는 요청을 보내 초기화 혹은 장비 재구성&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;TRAP&lt;/strong&gt;&lt;br /&gt;
일반적으로 SNMP는 Polling 방식으로 주기적으로 정보 요청과 요청에 대한 정보 응답 방식으로 동작되는데,&lt;br /&gt;
이 때 만약 연결구간이 혼잡하게 될 경우 중요한 관리 정보가 손실되어 그 정보를 인지 못할 수도 있다는 문제점을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보완&lt;/code&gt;하기 위해 TRAP 기술 도입&lt;/p&gt;

        &lt;p&gt;Manager가 요청 않더라도 Agent에 의해 자의적으로 경고, 고장통지 등 미리 설정된 유형의 보고서를 생성/송신&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="네트워크" /><category term="데이터통신" /><summary type="html">TCP/IP Transmission Control Protocol/Internet Protocol</summary></entry><entry><title type="html">[네트워크] TCP/IP 전송 계층</title><link href="https://many258.github.io/study/tcp-ip-transmission/" rel="alternate" type="text/html" title="[네트워크] TCP/IP 전송 계층" /><published>2021-03-11T00:00:00+09:00</published><updated>2021-03-11T18:37:34+09:00</updated><id>https://many258.github.io/study/%7Btcp-ip-transmission%7D</id><content type="html" xml:base="https://many258.github.io/study/tcp-ip-transmission/">&lt;h1 id=&quot;transport-layer&quot;&gt;Transport Layer&lt;/h1&gt;
&lt;p&gt;수신측에 전달되는 데이터에 오류가 없고 데이터의 순서가 그대로 보존되도록 보장하는 &lt;strong&gt;연결 지향 서비스&lt;/strong&gt;의 역할을 하는 &lt;strong&gt;종단 간 서비스&lt;/strong&gt;(End-to-End) 계층&lt;/p&gt;

&lt;p&gt;신뢰성 있는 전송을 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP&lt;/code&gt;와 비신뢰성 전송을 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UDP&lt;/code&gt;가 존재&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Segment&lt;br /&gt;
애플리케이션 계층의 메시지에 TCP 혹은 UDP의 헤더를 붙인 것을 의미.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tcptransmission-control-protocol&quot;&gt;TCP(Transmission Control Protocol)&lt;/h2&gt;
&lt;p&gt;클라이언트와 서버 간의 연결 지향, 신뢰성 있는 데이터 전송, 에러 제어, 흐름 제어, 완전이중 방식&lt;br /&gt;
신뢰성있는 데이터 전송을 위해 가상 연결 수행&lt;br /&gt;
송신자가 메시지를 전송하면 수신자는 ACK를 되돌려서 수신 여부를 확인&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;혼잡 제어&lt;/strong&gt;(Congestion Control)&lt;br /&gt;
수신자 동일한 ACK 번호를 반복적으로 전송 =&amp;gt; 데이터를 받지 못함 ==&amp;gt; GO-BACK-N 방법으로 재전송&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;흐름 제어&lt;/strong&gt;(Flow Control)&lt;br /&gt;
수신자가 메시지를 제대로 받지 못하면 송신자는 전송 속도를 늦추어 네트워크 효율성 제어&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;순서 제어&lt;/strong&gt; : Sequence 번호를 가지고 메시지의 순서 파악&lt;/li&gt;
  &lt;li&gt;Checksum : TCP, UDP 모두 존재. 송신 중 메시지의 변조 파악하기 위해 에러 체크&lt;/li&gt;
  &lt;li&gt;Receive Windows&lt;br /&gt;
수신자의 윈도우 크기이자 메모리 버퍼. 
수신자의 버퍼가 비어 있으면 송신자는 해당 버퍼의 크기만큼 데이터를 한꺼번에 전송&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tcp의-상태-전이&quot;&gt;TCP의 상태 전이&lt;/h3&gt;
&lt;p&gt;netstat 명령어로 확인 가능&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt; 클라이언트는 서버에 연결요청 메시지인 SYN 신호를 보내고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN_SEND&lt;/code&gt; 상태 전환&lt;br /&gt;
&lt;strong&gt;2)&lt;/strong&gt; 서버는 기동되면 클라이언트의 연결을 받기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LISTEN&lt;/code&gt; 상태로 클라이언트의 연결 대기&lt;br /&gt;
&lt;strong&gt;3)&lt;/strong&gt; 서버는 클라이언트로부터 SYN 메시지가 수신되면 서버는 클라이언트에게 SYN, ACK를 전송하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN_RECEIVED&lt;/code&gt; 상태 전환&lt;br /&gt;
&lt;strong&gt;4)&lt;/strong&gt; 클라이언트는 ACK를 서버에 전송하고 클라이언트와 서버는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESTABLISHED&lt;/code&gt;(연결 확립) 상태&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/tcpip/tcp-state-machine.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tcp-프로토콜의-header-구조&quot;&gt;TCP 프로토콜의 Header 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;근원지 포트&lt;/strong&gt;(Source Port)&lt;br /&gt;
가상 선로의 송신측 포트(End point of Sender)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;목적지 포트&lt;/strong&gt;(Destination Port)&lt;br /&gt;
가상 선로의 수신측 포트(End point of receiver)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;일련번호&lt;/strong&gt;(Sequence Number)&lt;br /&gt;
송신자가 전송하는 데이터의 일련번호&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;전송확인&lt;/strong&gt;(Piggyback Acknowledgement)&lt;br /&gt;
수신자와 응답하는 받은 데이터의 수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TCP 헤더 길이&lt;/strong&gt;(Header Length)&lt;br /&gt;
TCP 헤더에 몇 개의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;32Bit&lt;/code&gt; 워드가 포함되어 있는가를 나타내는 필드&lt;br /&gt;
옵션 필드가 가변 길이를 갖기 때문에 필요, 이 값을 이용하여 실제 데이터의 시작점을 계산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;URG&lt;/strong&gt;(Urgent)&lt;br /&gt;
긴급 지점이 사용될 때 1로 설정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ACK&lt;/strong&gt;(Acknowledgement)&lt;br /&gt;
전송 확인을 필요로 할 때 설정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EOM&lt;/strong&gt;(End of Message)&lt;br /&gt;
마지막 메시지임을 가리킴&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;재설정&lt;/strong&gt;(RST)&lt;br /&gt;
연결의 재설정. 비정상적인 종료&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;동기화&lt;/strong&gt;(SYN, Synchronization)&lt;br /&gt;
연결 설정 요구&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FIN&lt;/strong&gt;(Finish)&lt;br /&gt;
연결 해제에 사용되며, 송신측에서 더 이상 전송할 데이터가 없음을 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;윈도우 크기&lt;/strong&gt;(Window size)&lt;br /&gt;
수신측에서 수신할 수 있는 최대 Byte 수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;체크썸&lt;/strong&gt;(Checksum)&lt;br /&gt;
전송 데이터에 대한 완벽한 신뢰성을 위한 것으로, 모든 데이터의 합에 대한 ‘1’의 보수로 계산
무결성을 확인하기 위해 CRC(Cyclic Redundancy Check)코드 사용
CRC : 데이터 통신에서 전송 중에 전송 오류가 발생하였는지 확인하기 위해 덧붙인 코드&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;급송 지점&lt;/strong&gt;(Urgent point)&lt;br /&gt;
다음에 이어지는 데이터가 급송되어야 함을 의미. 인터럽트 메시지 대신 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;옵션&lt;/strong&gt;&lt;br /&gt;
전송 셋업 과정의 버퍼 크기에 대한 통신 등 기타 목적에 활용&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;에러-제어&quot;&gt;에러 제어&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FEC&lt;/strong&gt;(Forward Error Correction)&lt;br /&gt;
송신측이 특정한 정보 비트를 함께 전송하여 수신측에서 이 정보 비트로 에러 발생 시 수정하는 방식(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수신측&lt;/code&gt;이 에러 처리)&lt;/p&gt;

    &lt;p&gt;데이터 전송과정에서 발생한 오류를 검출하여 오류를 재전송 요구 없이 수정&lt;br /&gt;
재전송 요구가 없어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;역 채널&lt;/code&gt;이 필요 없고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연속&lt;/code&gt;적인 데이터 전송 가능&lt;br /&gt;
오류 검출 및 수정을 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;잉여비트&lt;/code&gt;들이 추가 전송되므로 전송 효율 감소&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;해밍 코드&lt;/li&gt;
      &lt;li&gt;상승 코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BEC&lt;/strong&gt;(Backward Error Correction)&lt;br /&gt;
수신측이 에러 검출 후 송신측에게 에러가 발생한 데이터 블록을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;재전송&lt;/code&gt; 요청(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;송신측&lt;/code&gt;이 에러 처리, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARQ&lt;/code&gt;:Auto Repeat reQuest)&lt;/p&gt;

    &lt;p&gt;패리티 검사, CRC 등 CheckSum을 이용하여 오류 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;검출&lt;/code&gt; 후, 오류 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어&lt;/code&gt;는 ARQ가 처리&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Stop-And-Wait&lt;/strong&gt;&lt;br /&gt;
하나의 데이터를 송신하고 수신 확인 신호를 받을 때까지 기다린 다음 전송&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Go-Back-N&lt;/strong&gt;&lt;br /&gt;
수신자가 데이터를 수신 받지 못할 경우 마지막으로 수신 받은 데이터 이후의 모든 데이터 재전송
TCP에서 사용하는 방식&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Selective Repeat ARQ&lt;/strong&gt;&lt;br /&gt;
수신받은 데이터 중에서 중간에 빠져있는 것만 재전송&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Adaptive ARQ&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;흐름-제어&quot;&gt;흐름 제어&lt;/h3&gt;
&lt;p&gt;송수신측 사이의 전송 패킷의 양, 속도를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조절&lt;/code&gt;하여 네트워크를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;효율&lt;/code&gt;적으로 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;슬라이딩 윈도우&lt;/strong&gt;(Sliding Window)&lt;br /&gt;
호스트 간에 송수신 혹은 수신할 수 있는 Size 정보를 제공&lt;br /&gt;
&lt;strong&gt;Stop-And-Wait&lt;/strong&gt;의 단점을 보완한 방식으로 수신측의 확인 신호를 받지 않더라도 미리 정해진 프레임의 수만큼 연속적으로 전송&lt;br /&gt;
수신자의 버퍼 크기를 확인함으로서 최대한 전송 효율 극대화&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;혼잡-제어&quot;&gt;혼잡 제어&lt;/h3&gt;
&lt;p&gt;라우터가 패킷을 처리할 수 있는 속도보다 많은 패킷을 수신하는 경우 라우터는 패킷을 손실하게 된다.
송신측에서는 패킷을 재전송하게 되는데, 이러한 과정의 연속으로 데이터의 손실이나 지연이 발생
혼잡 제어는 송신 단말의 전송률을 직접 제어하여 혼잡으로 인해 손실된 데이터를 재전송하기 위함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TCP Slow Start&lt;/strong&gt;&lt;br /&gt;
TCP가 시작될 때 전송속도를 초기값부터 지속적으로 올리는 방법&lt;/p&gt;

    &lt;p&gt;송신측에서 패킷을 전송하는 비율과 수신측에서 수신된 ACK를 통해 Congestion Window(cwnd)를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지수&lt;/code&gt;의 크기로 증가.&lt;br /&gt;
cwnd는 계속적으로 증가하다가 임계값에 이르게 되면 Congestion Avoidance로 동작&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Congestion Avoidance&lt;/strong&gt;&lt;br /&gt;
Duplication ACK 값이 오거나 일정 시간 동안 ACK가 수신되지 않으면 전송속도를 낮춤&lt;br /&gt;
매번 ACK가 수신될 때마다 cwnd를 1/cwnd만큼 증가(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선형적&lt;/code&gt;인 증가)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fast Retransmit&lt;/strong&gt;&lt;br /&gt;
Retransmit Threshold 이상 연속된 Duplicate ACK를 수신하는 경우 TCP는 해당 Segment를 재전송&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fast Recovery&lt;/strong&gt;&lt;br /&gt;
Fast Retransmit한 이후 새로 Slow Start를 통해서 설정된 연결의 안전상태에 도달할 필요없이 Congestion Avoidance 상태에서 전송할 수 있도록 하는 것&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;udpuser-datagram-protocol&quot;&gt;UDP(User Datagram Protocol)&lt;/h2&gt;
&lt;p&gt;비연결성, 비신뢰성(블록 재전송 및 흐름 제어 등이 없음)을 특성으로 패킷을 고속 전달할 수 있는 프로토콜&lt;br /&gt;
비접속형 : 전달되는 패킷에 대한 상태 정보를 유지하지 않음&lt;br /&gt;
간단한 헤더구조(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;8Byte&lt;/code&gt;), 블록 단위로 데이터 전송&lt;/p&gt;

&lt;h3 id=&quot;udp-프로토콜의-header-구조&quot;&gt;UDP 프로토콜의 Header 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;근원지 포트&lt;/strong&gt;(Source Port)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;목적지 포트&lt;/strong&gt;(Destination Port)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;수신자의 포트번호 길이&lt;/strong&gt;(Length)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;체크썸&lt;/strong&gt;(Checksum)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;voipvoice-over-ip&quot;&gt;VoIP(Voice Over IP)&lt;/h3&gt;
&lt;p&gt;UDP 프로토콜은 빠르게 데이터를 전송해야 하는 서비스에서 사용하는데 대표적인 활용이 VoIP&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RTP(Real Time Protocol) : 음성 전송&lt;/li&gt;
  &lt;li&gt;RTCP(Real Time Control Protocol) : 에러 처리&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="네트워크" /><category term="데이터통신" /><summary type="html">Transport Layer 수신측에 전달되는 데이터에 오류가 없고 데이터의 순서가 그대로 보존되도록 보장하는 연결 지향 서비스의 역할을 하는 종단 간 서비스(End-to-End) 계층</summary></entry><entry><title type="html">[네트워크] TCP/IP 인터넷, 네트워크 접근 계층</title><link href="https://many258.github.io/study/tcp-ip-internet-network-access/" rel="alternate" type="text/html" title="[네트워크] TCP/IP 인터넷, 네트워크 접근 계층" /><published>2021-03-11T00:00:00+09:00</published><updated>2021-03-11T23:37:34+09:00</updated><id>https://many258.github.io/study/%7Btcp-ip-internet-network-access%7D</id><content type="html" xml:base="https://many258.github.io/study/tcp-ip-internet-network-access/">&lt;h1 id=&quot;인터넷-계층internet-layer&quot;&gt;인터넷 계층(Internet Layer)&lt;/h1&gt;
&lt;p&gt;송신자의 IP주소와 수신자의 IP주소를 읽어서 경로를 결정하거나 전송하는 역할을 수행&lt;br /&gt;
다중 네트워크 링크를 통해 패킷의 발신지-대-목적지 전달에 대한 책임을 가진다.(데이터 링크 층은 노드간 전달 책임, Point-to-Point)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IP, ICMP&lt;/strong&gt;의 TCP/IP 프로토콜 군이 존재하고 멀티캐스팅을 위한 &lt;strong&gt;IGMP&lt;/strong&gt;, 라우팅을 위한 &lt;strong&gt;BGP, OSPF, RIP&lt;/strong&gt; 존재&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;경로설정&lt;/strong&gt;(Routing)&lt;br /&gt;
수신자의 IP주소를 읽어서 어떻게 목적기까지 가는 것이 최적의 경로인지를 판단하는 것. 라우터(Router)의 역할&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Point-To-Point&lt;/strong&gt; 패킷 전달&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;논리 주소&lt;/strong&gt; 지정 : IP주소로 변환하여 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주소 변환&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터그램&lt;/strong&gt; : 기존 패킷에 IP Header를 붙이는 것을 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;라우팅&quot;&gt;라우팅&lt;/h2&gt;
&lt;p&gt;목적지 IP주소를 읽어서 경로를 결정하는 작업.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;정적&lt;/code&gt;&lt;/strong&gt; 경로 방법(Static Routing)&lt;br /&gt;
특정 목적지 네트워크로 가는 경로를 관리자가 직접 라우팅 테이블의 경로를 설정하는 방법&lt;br /&gt;
실시간으로 이루어지지 않기에 초기에 관리자가 다양한 라우팅 정보를 분석하여 최적의 경로 설정이 가능&lt;br /&gt;
라우터의 직접적인 처리 부하를 감소시킬 수 있어서 비교적 환경변화가 적은 형태의 네트워크에 적합
    &lt;ul&gt;
      &lt;li&gt;Floating static routing&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동적&lt;/code&gt;&lt;/strong&gt; 경로 방법(Dynamic Routing)&lt;br /&gt;
네트워크 상태를 파악해서 최적의 경로를 결정하는 방법&lt;br /&gt;
실시간으로 이루어지므로 네트워크 환경변화에 능동적인 대처가 가능&lt;br /&gt;
라우팅 알고리즘을 통해 자동으로 경로 설정이 이루어지며,&lt;br /&gt;
수시로 환경이 변화되는 형태의 네트워크에 적합
    &lt;ul&gt;
      &lt;li&gt;Distance Vector routing&lt;/li&gt;
      &lt;li&gt;Linked state routing&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;라우팅-프로토콜&quot;&gt;라우팅 프로토콜&lt;/h3&gt;
&lt;p&gt;인터네트워크를 통해서 데이터를 근원지에서 목적지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전달&lt;/code&gt;하는 기능 수행&lt;br /&gt;
경로 결정에서 최단경로 선정 및 전송 수행, 목적지에 대한 경로 정보를 인접한 라우터들과 교환하기 위한 규약&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IGP&lt;/strong&gt;(Internal Gateway Routing Protocol)&lt;br /&gt;
동일 그룹(기업 또는 ISP) 내에서 라우팅 정보를 교환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EGP&lt;/strong&gt;(Exterior Gateway Routing Protocol)&lt;br /&gt;
다른 그룹과의 라우팅 정보를 교환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Distance Vector routing&lt;/strong&gt;&lt;br /&gt;
최단 경로를 구하는 벨만 포드 알고리즘 기반&lt;br /&gt;
통과해야 하는 라우터의 수가 적은 쪽으로 경로를 결정. 일명 &lt;strong&gt;Hop Count&lt;/strong&gt; 또는 &lt;strong&gt;TTL&lt;/strong&gt;(Time to Live)&lt;br /&gt;
네트워크 변화 발생 시 해당 정보를 인접한 라우터에 정기적으로 전달하고,&lt;br /&gt;
인접 라우터에서는 라우팅 테이블 정보 갱신
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;라우팅 정보&lt;/strong&gt; : 모든 라우터까지의 거리 정보 보관&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;정보 전송 시점&lt;/strong&gt; : 일정주기(30초, 이웃 라우터와 공유)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;대표 프로토콜&lt;/strong&gt; : RIP, IGRP, EIGRP(내부 라우팅), BGP&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;br /&gt;
변화되는 라우팅 정보를 모든 라우터에 주기적으로 갱신(브로드캐스팅)하므로 망 자체 트래픽 유발&lt;br /&gt;
라우팅 정보를 변경하는 문제 발생 시 Routing Loop가 발생할 가능성 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Linked state routing&lt;/strong&gt;&lt;br /&gt;
최소 신상 트리를 구하는 다익스트라 알고리즘 기반&lt;br /&gt;
네트워크 대역폭, 지연정보 등을 종합적으로 고려해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cost&lt;/code&gt;를 산정하고 해당 Link의 Cost에 따라 경로를 결정하는 방법&lt;br /&gt;
네트워크 변화 감지 시 링크 상태 변경 정보를 인접한 라우터에게 즉각 전달하고 이를 저장
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;라우팅 정보&lt;/strong&gt; : 인정 라우터까지의 Link Cost 계산&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;정보 전송 시점&lt;/strong&gt; : 변화 발생 시에만&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;대표 프로토콜&lt;/strong&gt; : OSPF, IS-IS(소규모 네트워크)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;br /&gt;
네트워크 전체 정보 유지를 위한 많은 메모리 소요&lt;br /&gt;
라우터의 CPU 사용량이 많아짐&lt;br /&gt;
라우터간 회선의 대역차이로 동기화 실패할 가능성 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RIP&lt;/strong&gt;(Routing Information Protocol)&lt;br /&gt;
RFC 1058. 대표적인 거리 벡터 라우팅 프로토콜&lt;/p&gt;

    &lt;p&gt;라우터 간 거리 계산을 위한 척도로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;홉수&lt;/code&gt;(Hop Count) 사용&lt;br /&gt;
16Hop 이상이면 패킷을 폐기&lt;br /&gt;
180초 이내에 새로운 라우팅 정보가 수신되지 않으면 해당 경로를 이상 상태로 간주&lt;br /&gt;
수신된 목적지의 거리 값과 현재 거리 값을 비교하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;작은&lt;/code&gt; 것을 기준으로 라우팅 테이블을 변경&lt;/p&gt;

    &lt;p&gt;라우팅 정보 변경 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모든&lt;/code&gt; 망에 적용하므로 큰 규모의 망에는 부적합&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OSPF&lt;/strong&gt;(Open Shortest Path First)&lt;br /&gt;
RFC 1247. IP 라우팅 프로토콜&lt;/p&gt;

    &lt;p&gt;링크에서의 전송 시간을 링크 비용으로 사용하여 각 목적지별 최단 경로를 계산&lt;br /&gt;
네트워크에 변화가 발생했을 때 상대적으로 짧고 간단한 링크 상태 정보 교환&lt;/p&gt;

    &lt;p&gt;Link의 delay, throughput, reliability를 이용하여 기본적인 throughput만 이용하고, Hop수에 대한 제약이 없음&lt;br /&gt;
네트워크를 Area로 구분하여 많은 라우팅 정보의 교환으로 인한 라우터의 성능저하를 예방(대역폭을 절약)&lt;br /&gt;
Link 변화 감지 시 해당 Link에 대한 정보만을 즉시 모든 라우터에 전달하며 Convergence가 매우 빠름&lt;br /&gt;
Supernetting된 형태로 Routing Information을 전달할 수 있어 라우터 메모리 절약, 성능 향상 및 대역폭 절약&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;ABR(Area Border Router)&lt;br /&gt;
Area에 백본망을 연결해주는 라우터&lt;/li&gt;
      &lt;li&gt;ASBR(Autonomous System Boundary Router)&lt;br /&gt;
다른 AS(Autonomous System)에 속한 라우터와 경로 정보를 교환&lt;/li&gt;
      &lt;li&gt;IR(Internal Router)&lt;br /&gt;
Area에 접속한 라우터&lt;/li&gt;
      &lt;li&gt;BR(Backbone Router)&lt;br /&gt;
백본망에 접속한 모든 라우터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BGP&lt;/strong&gt;(Border Gateway Protocol)&lt;br /&gt;
AS 상호 간의 routing에 적용되는 라우팅 프로토콜.&lt;br /&gt;
ISP(Internet Service Provider) 사업자들 상호 간에 주로 사용&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;EGP&lt;/strong&gt;라고 하는 Inter-Domain routing Protocol&lt;br /&gt;
인터넷을 AS 상호 간 연결 Path로 이루어진 방향성 그래프의 집단으로 인식&lt;br /&gt;
경로 벡터 라우팅 방법(&lt;strong&gt;path vector routing&lt;/strong&gt;)을 적용하며 경로 벡터 라우팅 테이블을 유지&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Looping Free Routing&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP&lt;/code&gt; 기반 라우팅&lt;br /&gt;
BGP 라우팅 정보는 라우터 간에 179번 포트를 통하여 TCP에 의해 신뢰성 있게 전달&lt;/li&gt;
      &lt;li&gt;라우팅 정보의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;점진적&lt;/code&gt; 갱신&lt;br /&gt;
BGP는 주기적으로 라우팅 정보를 갱신하지 않고, 변화가 있을 때 이웃 라우터에게 갱신 정보를 전달&lt;/li&gt;
      &lt;li&gt;다양한 라우팅 metric 사용&lt;br /&gt;
최상위 경로 선택을 위해 우선순위가 있는 각 metric을 참조&lt;/li&gt;
      &lt;li&gt;Class 없는 주소체계 지원&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CIDR&lt;/code&gt;(Classless Inter-Domain Routing) 지원&lt;/li&gt;
      &lt;li&gt;IBGP(Internal BGP) : 동일한 AS에 속한 BGP 라우터 간의 동작&lt;/li&gt;
      &lt;li&gt;EBGP(External BGP) : 서로 다른 AS에서 동작하는 BGP 프로토콜&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ipinternet-protocol&quot;&gt;IP(Internet Protocol)&lt;/h2&gt;
&lt;p&gt;IP 주소 형태로 송신자와 수신자의 IP를 가지고 있고 IP주소를 읽어서 최적의 경로를 결정할 수 있게 함&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주소화&lt;/code&gt;, 데이터그램 포맷, 패킷 핸들링 등을 정의해놓은 인터넷 규약&lt;/li&gt;
  &lt;li&gt;IPv4 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;32bit&lt;/code&gt; 주소체계를 사용. (네트워크 ID + 호스트 ID)&lt;/li&gt;
  &lt;li&gt;IPv6 : IP주소의 부족 문제를 해결하기 위해 주소 비트수를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;128bit&lt;/code&gt;로 확장.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip-header-구조&quot;&gt;IP Header 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Version&lt;/strong&gt; : IPv4 버전&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Header Length&lt;/strong&gt; : Header의 전체 길이&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Type of Service&lt;/strong&gt; : 서비스 유형&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Total Length&lt;/strong&gt; : IP Datagram의 byte 수&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Identification&lt;/strong&gt; : Host에서 보낸 DataGram 식별&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Flags &amp;amp; Offset&lt;/strong&gt;&lt;br /&gt;
IP Datagram 단편화 정보&lt;br /&gt;
네트워크에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTU&lt;/code&gt;(Maximum Transmission Unit)라는 것이 존재하는데, 한 번에 통과할 수 있는 패킷의 최대 크기를 의미한다.&lt;/p&gt;

    &lt;p&gt;즉, MTU 값보다 크면 패킷은 분할(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단편화&lt;/code&gt; : Fragmentation)되고 그 정보를 Flags &amp;amp; Offset이 가지고 있게 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Time to Live&lt;/strong&gt;&lt;br /&gt;
Datagram이 통과할 수 있는 라우터 수(Linux 기본 = 64, Window 기본 = 128)&lt;br /&gt;
IP 패킷이 통과할 수 있는 라우터의 수를 의미. 라우터를 하나 통과 시 1씩 감소하며 0이 될 경우 자동 폐기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Protocol&lt;/strong&gt; : IP헤더 위의 상위 프로토콜 종류. ICMP, TCP, UDP&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Header Checksum&lt;/strong&gt; : IP Header 무결성 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip-주소의-구조&quot;&gt;IP 주소의 구조&lt;/h3&gt;
&lt;p&gt;클래스로 분류되며 클래스는 IP 주소를 분류하는 기준으로 사용.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Class&lt;/td&gt;
      &lt;td&gt;Content&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Class A&lt;/td&gt;
      &lt;td&gt;첫 바이트 7bit가 네트워크 식별자 한 네트워크에 가장 많은 호스트 수용 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Class B&lt;/td&gt;
      &lt;td&gt;14bit의 네트워크 식별자 한 네트워크에 약 2&lt;sup&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;16&lt;/code&gt;&lt;/sup&gt;대의 호스트 수용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Class C&lt;/td&gt;
      &lt;td&gt;세 번째 바이트까지 네트워크 식별자 한 네트워크에 254대까지 수용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Class D&lt;/td&gt;
      &lt;td&gt;멀티캐스트 주소로 사용&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/tcpip/ip-class.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;서브넷팅subnetting&quot;&gt;서브넷팅(Subnetting)&lt;/h3&gt;
&lt;p&gt;주어진 네트워크 주소를 작게 나누어 여러 개의 서브넷으로 구성&lt;br /&gt;
네트워크 식별자 부분을 구분하기 위한 Mask를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서브넷 마스크&lt;/code&gt;라고 함&lt;/p&gt;

&lt;h3 id=&quot;수퍼넷팅supernetting&quot;&gt;수퍼넷팅(Supernetting)&lt;/h3&gt;
&lt;p&gt;ISP(Internet Service Provider) 사업자가 많은 네트워크 망을 효율적을 관리하기 위해서 네트워크를 묶어 관리하는 방법&lt;/p&gt;

&lt;h3 id=&quot;cidrclassless-inter-domain-routing&quot;&gt;CIDR(Classless Inter-Domain Routing)&lt;/h3&gt;
&lt;p&gt;RFC 4632. IPv4의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IP 주소 고갈&lt;/code&gt; 및 라우팅 테이블 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대형화&lt;/code&gt;에 대한 해소책&lt;br /&gt;
기존의 클래스 A, B, C 네트워크 주소의 개념을 무시하고 IP주소와 서브넷 마스크를 이진 표기법으로 표현하여 기존의 고정크기 네트워크를 다양하고 세부적으로 분할한 것&lt;/p&gt;

&lt;h3 id=&quot;vlsmvariable-length-subnet-mask--가변길이-서브넷-마스크&quot;&gt;VLSM(Variable Length Subnet Mask : 가변길이 서브넷 마스크)&lt;/h3&gt;
&lt;p&gt;서브넷팅을 실시한 이후에도 IP 주소가 낭비되는 것을 방지하기 위해서 서브넷 마스크의 길이를 더 확장하여 늘리는 기능&lt;/p&gt;

&lt;h2 id=&quot;icmpinternet-control-message-protocol&quot;&gt;ICMP(Internet Control Message Protocol)&lt;/h2&gt;
&lt;p&gt;TCP/IP &lt;strong&gt;오류 제어&lt;/strong&gt; 프로토콜&lt;br /&gt;
호스트 및 라우터는 다른 호스트나 라우터가 현재 도달 가능한지의 여부를 결정&lt;br /&gt;
라우터는 특정 목적지 네트워크로 후속 IP 데이터그램을 보냈는데, 사용할 수 있는 최적의 경로가 있을 때 근원지 호스트에게 통지&lt;br /&gt;
호스트나 라우터는 그들이 처리하기에 너무 빠른 IP 데이터그램이 도착하면 다른 시스템에게 통보&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;오류 보고 메시지&lt;/strong&gt; : IP 패킷 처리 도중 발견된 문제를 보고&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;질의 메시지&lt;/strong&gt; : 다른 호스트로부터 특정 정보를 획득하기 위해 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;icmp-메시지-구조&quot;&gt;ICMP 메시지 구조&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Type : ICMP 메시지 유형 표시&lt;/li&gt;
  &lt;li&gt;Code : Type과 같이 사용되며 세부적인 유형을 표현&lt;/li&gt;
  &lt;li&gt;Checksum : IP Datagram Checksum&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;icmp-메시지&quot;&gt;ICMP 메시지&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Type&lt;/td&gt;
      &lt;td&gt;Message&lt;/td&gt;
      &lt;td&gt;Content&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Destination Unreachable&lt;/td&gt;
      &lt;td&gt;라우터가 목적지를 찾지 못할 경우 보내는 메시지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Source Quench&lt;/td&gt;
      &lt;td&gt;패킷을 너무 빨리 보내 네트워크에 무리를 주는 호스트를 제지할 때 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Redirection&lt;/td&gt;
      &lt;td&gt;패킷 라우팅 경로를 수정, SMURF 공격에서 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8 or 0&lt;/td&gt;
      &lt;td&gt;Echo Request or Reply&lt;/td&gt;
      &lt;td&gt;Host의 존재를 확인&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;Time Exceeded&lt;/td&gt;
      &lt;td&gt;패킷을 보냈으나 시간이 경과하여 패킷이 삭제되었을 때 보내는 메시지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;Parameter Problem&lt;/td&gt;
      &lt;td&gt;IP 헤더 필드에 잘못된 정보가 있다는 것을 알림&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;13 or 14&lt;/td&gt;
      &lt;td&gt;Timestamp Request and Reply&lt;/td&gt;
      &lt;td&gt;Echo와 비슷하나 시간에 대한 정보 추가&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;데이터-전송-방식&quot;&gt;데이터 전송 방식&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Unicast&lt;br /&gt;
1:1 전송 방식.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Broadcast&lt;br /&gt;
1:N 전송 방식. 동일한 서브넷 상의 모든 수신자에게 전송&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Multicast&lt;br /&gt;
M:N 전송 방식. 하나 이상의 송신자들이 특정 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그룹&lt;/code&gt;의 수신자에게 전송&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IGMP&lt;/code&gt; : 그룹에 등록된 사용자를 관리하는 프로토콜
    &lt;ul&gt;
      &lt;li&gt;IGMP 메시지 구조 (8byte)
        &lt;ul&gt;
          &lt;li&gt;Version : IGMP 프로토콜의 버전&lt;/li&gt;
          &lt;li&gt;Type : 메시지 유형. (1 = 보고, 2 = 질의메시지)&lt;/li&gt;
          &lt;li&gt;Group ID&lt;br /&gt;
보고 메시지의 경우 호스트에서 신규 가입하고자 하는 멀티캐스트 서비스의 group id,&lt;br /&gt;
계속 받아보기를 원하는 멀티캐스트 서비스의 group id 질의 메시지인 경우는 ‘0’&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Anycast&lt;br /&gt;
그룹에 등록된 노드 중에서 최단경로 노드 한 개에만 전송.&lt;br /&gt;
IPv6에서 사용 (Broadcast 대신)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;arpaddress-resolution-protocol&quot;&gt;ARP(Address Resolution Protocol)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;IP주소&lt;/strong&gt;를 물리적 하드웨어 주소인 &lt;strong&gt;MAC 주소&lt;/strong&gt;로 변경하는 프로토콜&lt;br /&gt;
IP 주소와 이에 해당하는 물리적 네트워크 주소 정보는 각 IP 호스트의 &lt;strong&gt;ARP 캐시&lt;/strong&gt;라 불리는 메모리에 테이블 형태로 저장된 후 다음 패킷 전송 시에 다시 사용&lt;br /&gt;
ARP Cache Table : MAC 주소와 IP 주소를 보유하고 있는 매핑 테이블&lt;/p&gt;

&lt;h2 id=&quot;rarpreverse-address-resolution-protocol&quot;&gt;RARP(Reverse Address Resolution Protocol)&lt;/h2&gt;
&lt;p&gt;물리적인 &lt;strong&gt;주소 MAC&lt;/strong&gt;을 기반으로 논리적인 주소 &lt;strong&gt;IP&lt;/strong&gt;를 알아오는 프로토콜&lt;br /&gt;
운영체제도 없는 일종의 더미 터미널 Diskless Host에서 사용하는 것으로 자신의 물리적 주소인 MAC주소를 서버에 전송하고 IP주소를 수신 받아서 기동&lt;/p&gt;

&lt;h1 id=&quot;네트워크-접근-계층&quot;&gt;네트워크 접근 계층&lt;/h1&gt;
&lt;p&gt;논리적 주소인 IP 주소를 물리적 MAC 주소로 변환&lt;br /&gt;
Physical Layer가 이해할 수 있는 헤더를 붙여주는 Layer, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Frame&lt;/code&gt; 단위, MAC Address를 사용하는 계층&lt;/p&gt;

&lt;p&gt;Point-to-Point 간 신뢰성 있는 전송으로 &lt;strong&gt;흐름 제어&lt;/strong&gt; 기능을 담당&lt;br /&gt;
&lt;strong&gt;에러 제어&lt;/strong&gt; : Error Detection, Error Correction&lt;br /&gt;
&lt;strong&gt;MAC&lt;/strong&gt;(Media Access Control) : LAN 카드의 물리적 주소&lt;/p&gt;

&lt;h2 id=&quot;csmacd&quot;&gt;CSMA/CD&lt;/h2&gt;
&lt;p&gt;Carrier Sense Multiple Access/Collision Detection&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유선&lt;/code&gt; LAN에서 메시지를 송수신하기 위한 접근 방법. IEEE 802.3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt; 각 호스트들이 전송매체에 경쟁적으로 데이터를 전송&lt;br /&gt;
&lt;strong&gt;2)&lt;/strong&gt; 프레임을 전송하면서 충돌여부를 검사&lt;br /&gt;
&lt;strong&gt;3)&lt;/strong&gt; 전송 중 충돌이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;감지&lt;/code&gt;되면 패킷의 전송을 즉시 중단&lt;br /&gt;
&lt;strong&gt;4)&lt;/strong&gt; 충돌이 발생한 사실을 모든 스텐이션들이 알 수 있도록 간단한 통보신호 송신&lt;br /&gt;
&lt;strong&gt;5)&lt;/strong&gt; 통보신호에 따라 전송을 조절&lt;/p&gt;

&lt;p&gt;Collision이 일어난 경우 &lt;strong&gt;Back off&lt;/strong&gt; 알고리즘을 이용하여 재전송&lt;br /&gt;
&lt;strong&gt;리피터&lt;/strong&gt;와 &lt;strong&gt;허브&lt;/strong&gt;를 이용하면 Collision이 발생하나 &lt;strong&gt;Switch&lt;/strong&gt;는 Collision을 막을 수 있다&lt;br /&gt;
&lt;strong&gt;Switch&lt;/strong&gt;는 브로드캐스트를 막을 수 없고 &lt;strong&gt;Router&lt;/strong&gt;가 브로드캐스트를 막을 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Non-Persistent&lt;br /&gt;
매채가 사용 중이 아니면 즉시 전송&lt;br /&gt;
매체가 사용 중이면, 확률분포에서 구한 재전송 지연시간만큼 대기
    &lt;ul&gt;
      &lt;li&gt;임의 지연 사용은 충돌 확률을 감소&lt;/li&gt;
      &lt;li&gt;매체가 비었을 때 임의 지연 때문에 데이터 전송이 없는 채널 휴지 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;1-Persistent&lt;br /&gt;
매체가 사용 중이 아니면 즉시 전송&lt;br /&gt;
매체가 사용 중이면 대기 후 채널이 비는 순간 즉시 전송
    &lt;ul&gt;
      &lt;li&gt;채널 휴지 시간을 제거하기 위해 사용&lt;/li&gt;
      &lt;li&gt;임의 지연이 없게 하여 채널 휴지는 거의 없지만 충돌 확률이 높음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;p-Persistent&lt;br /&gt;
매체가 사용 중이 아니라면, 확률 p로 전송하고 (1-p)의 확률료 하나의 시간단위를 지연&lt;br /&gt;
매체가 사용 중이면 기다렸다가 채널이 비는 순간 확률 p로 전송하고 확률 (1-p)로 대기
    &lt;ul&gt;
      &lt;li&gt;위 장단점을 상호보완하기 위해 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;csmaca&quot;&gt;CSMA/CA&lt;/h2&gt;
&lt;p&gt;Carrier Sense Multiple Access/Collision Avoidance&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무선&lt;/code&gt; LAN에서 메시지의 송수신하기 위한 접근 방법&lt;/p&gt;

&lt;p&gt;프레임 전송 이전에 제어 메시지를 이용하여 수신자로부터 간단한 전송 유발&lt;br /&gt;
제어 신호에 대한 응답이 도착하면 프레임 전송&lt;/p&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="네트워크" /><category term="데이터통신" /><summary type="html">인터넷 계층(Internet Layer) 송신자의 IP주소와 수신자의 IP주소를 읽어서 경로를 결정하거나 전송하는 역할을 수행 다중 네트워크 링크를 통해 패킷의 발신지-대-목적지 전달에 대한 책임을 가진다.(데이터 링크 층은 노드간 전달 책임, Point-to-Point)</summary></entry><entry><title type="html">[네트워크] 네트워크 개요 및 일반</title><link href="https://many258.github.io/study/network-base/" rel="alternate" type="text/html" title="[네트워크] 네트워크 개요 및 일반" /><published>2021-03-10T00:00:00+09:00</published><updated>2021-03-10T15:37:34+09:00</updated><id>https://many258.github.io/study/%7Bnetwork-base%7D</id><content type="html" xml:base="https://many258.github.io/study/network-base/">&lt;h1 id=&quot;네트워크&quot;&gt;네트워크&lt;/h1&gt;
&lt;p&gt;송신자의 메시지를 수신자에게 &lt;strong&gt;전달&lt;/strong&gt;하는 과정으로 한 지점에서 원하는 다른 지점까지 의미 있는 &lt;strong&gt;정보&lt;/strong&gt;를 보다 정확하고 빠르게 상대방이 이해할 수 있도록 전송하는 것을 의미&lt;/p&gt;

&lt;h1 id=&quot;프로토콜&quot;&gt;프로토콜&lt;/h1&gt;
&lt;p&gt;송신자와 수신자가 통신이라는 것을 하려면 서로 메시지의 포맷, 언제 데이터를 보낼 것인지, 한 번 전송하고 한 번 응답받는 형태로 할 것인지에 관한 것을 서로 약속해야 한다.
이 때, 이러한 약속이 &lt;strong&gt;프로토콜&lt;/strong&gt;을 의미한다.&lt;/p&gt;

&lt;h2 id=&quot;네트워크의-분류&quot;&gt;네트워크의 분류&lt;/h2&gt;
&lt;h3 id=&quot;거리에-따른-네트워크-유형&quot;&gt;거리에 따른 네트워크 유형&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PAN&lt;/strong&gt;(Personal Area Network)&lt;br /&gt;
3M 이내의 인접 지역 간의 통신 방법&lt;br /&gt;
짧은 거리로 인하여 유선보다는 무선의 WPAN이 많이 활용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LAN&lt;/strong&gt;(Local Area Network)&lt;br /&gt;
근거리 영역의 네트워크로 동일한 지역 내 고속의 전용 회선으로 연결하여 구성하는 통신망&lt;br /&gt;
Client/Server와 peer-to-peer 모델&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;WAN&lt;/strong&gt;(Wide Area Network)&lt;br /&gt;
광대역 네트워크망으로 서로 관련이 있는 LAN 간의 상호 연결망&lt;br /&gt;
LAN에 비해 선로 에러율이 높고, 전송 지연이 크다&lt;br /&gt;
두 목적지 사이를 최단경로로 연결시켜 주는 라우팅 알고리즘 필요&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MAN&lt;/strong&gt;(Metropolitan Area Network)&lt;br /&gt;
LAN과 WAN의 중간 형태의 네트워크로 데이터, 음성, 영상 등을 지원하기 위해 개발&lt;br /&gt;
DQDB(Distributed Queue Dual Bus)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-전송-방식&quot;&gt;데이터 전송 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;단방향(Simplex)&lt;/li&gt;
  &lt;li&gt;반이중(Half Duplex)&lt;/li&gt;
  &lt;li&gt;전이중(Full Duplex)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;회선교환circuit-switching&quot;&gt;회선교환(Circuit Switching)&lt;/h2&gt;
&lt;p&gt;교환기를 통해 통신 회선을 설정하여 직접 데이터를 교환하는 방식&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;전송 전에 회선이 전용선으로 설정 : 동일한 경로(독점)&lt;/li&gt;
      &lt;li&gt;데이터 전송이 없더라도 회선 해제 요청이 없으면 계속 접속 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유지&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;전송 시작 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;후&lt;/code&gt; 오버헤드가 없음&lt;/li&gt;
      &lt;li&gt;Point-to-Point 전송 구조&lt;/li&gt;
      &lt;li&gt;전송된 데이터의 에러 제어나 흐름 제어는 사용자에 의해 수행되어야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;대용량의 데이터를 고속으로 전송할 때 좋으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;고정&lt;/code&gt;적인 대역폭 사용&lt;/li&gt;
      &lt;li&gt;접속에는 긴 시간이 소요되나 그 후 접속이 항상 유지되어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전송 지연&lt;/code&gt;이 없고, 데이터 전송률이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;일정&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;아날로그나 디지털 데이터로 직접 전달&lt;/li&gt;
      &lt;li&gt;연속적인 전송에 적합(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;실시간&lt;/code&gt;)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;회선 이용률 면에서 비효율적&lt;/li&gt;
      &lt;li&gt;연결된 두 장치는 반드시 같은 전송률과 같은 기종 사이에서만 송수신이 가능&lt;/li&gt;
      &lt;li&gt;속도나 코드의 변환이 불가능 : 교환망 내에서의 에러 제어 기능이 어려움&lt;/li&gt;
      &lt;li&gt;실시간 전송보다 에러없는 데이터 전송이 요구되는 구조에서는 부적합&lt;/li&gt;
      &lt;li&gt;통신 비용 고가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;패킷교환packet-switching&quot;&gt;패킷교환(Packet Switching)&lt;/h2&gt;
&lt;p&gt;송신측에서 메시지를 일정한 크기의 패킷으로 분해/전송, 수신측에서 원래의 데이터로 조립&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;패킷 다중화, 논리 채널, 경로 선택 제어, 순서 제어, 트래픽 제어, 오류 제어&lt;/li&gt;
      &lt;li&gt;수신된 패킷의 저장기능(대기 큐)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;순서 제어&lt;/strong&gt; 기능 : 목적지에서 수신된 패킷의 순서를 재정렬&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;트래픽 제어&lt;/strong&gt; : 흐름 제어, 혼잡 제어, 교착상태&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;경로 배정 요소&lt;/strong&gt; : 성능 기준, 결정 시간, 결정 장소, 네트워크 정보&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;회선 이용률이 높고, 속도 변환, 프로토콜 변환 가능, 음성 통화&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;고신뢰성&lt;/strong&gt; : 상황에 따라 교환기 및 회선 등의 장애가 발생하더라도 패킷의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우회전송&lt;/code&gt;이 가능하므로 전송의 신뢰성 보장&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;고품질&lt;/strong&gt; : 디지털 전송이므로, 인접 간에 또는 단말기와 교환기 간에 전송, 오류 검사를 실시하여 오류 발생 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;재전송&lt;/code&gt; 가능&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;고효율&lt;/strong&gt; : 다중화를 사용하므로 전송로 사용 및 효율이 좋다&lt;/li&gt;
      &lt;li&gt;이 기종 단말장치 간 통신 : 전송 속도, 전송 제어 절차가 다르더라도 교환망이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;변환 처리&lt;/code&gt;를 제공하므로 통신 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;각 교환기의 경로에서 다소 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지연&lt;/code&gt;이 발생&lt;/li&gt;
      &lt;li&gt;이러한 지연은 가변적임. 전송량이 증가함에 따라 지연이 더욱 심할 수 있음&lt;/li&gt;
      &lt;li&gt;패킷별 헤더 추가로 인한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오버헤드&lt;/code&gt; 발생 가능성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;패킷교환-방식의-종류&quot;&gt;패킷교환 방식의 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;가상회선&lt;/strong&gt;(Virtual Circuit)
    &lt;ul&gt;
      &lt;li&gt;패킷을 전송하기 전에 논리적인 연결을 먼저 수행 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;연결형&lt;/code&gt; 서비스&lt;/li&gt;
      &lt;li&gt;호출 요구를 하고 호출 수신 패킷을 주고받아서 연결하는 방식(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X.21&lt;/code&gt;)&lt;/li&gt;
      &lt;li&gt;회선교환처럼 사용하지만 교환기에 패킷이 일시적으로 저장되며 일정한 전송률 보장 불가&lt;/li&gt;
      &lt;li&gt;비교적 긴 메시지의 전송 시 더 효과적&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터그램&lt;/strong&gt;(Datagram)
    &lt;ul&gt;
      &lt;li&gt;각 전송 패킷을 미리 정해진 경로 없이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;독립적&lt;/code&gt;으로 처리하여 교환하는 방식&lt;/li&gt;
      &lt;li&gt;같은 목적지의 패킷도 같은 경로를 거치지 않고 서로 다른 경로를 통해서 목적지에 도달&lt;/li&gt;
      &lt;li&gt;망의 한 부분이 혼잡할 때 패킷에 다른 경로를 지정하여 배정 가능, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;융통성&lt;/code&gt; 있는 경로를 설정&lt;/li&gt;
      &lt;li&gt;특정 교환기의 고장 시 모든 패킷을 잃어버리는 가상회선 방식과는 달리, 그 경로를 피해서 전송할 수 있음 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;신뢰성&lt;/code&gt; 보장&lt;/li&gt;
      &lt;li&gt;짧은 메시지의 패킷들을 전송할 때 효과적, 재정렬 기능 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;네트워크-토폴로지network-topology&quot;&gt;네트워크 토폴로지(Network Topology)&lt;/h2&gt;
&lt;p&gt;컴퓨터 네트워크의 요소들(링크, 노드)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/base/NetworkTopologies.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;계층형&lt;/strong&gt;(트리형)
    &lt;ul&gt;
      &lt;li&gt;Tree 구조, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최상위&lt;/code&gt;에 있는 노드가 네트워크 제어&lt;/li&gt;
      &lt;li&gt;통제 및 유지 보수 용이&lt;/li&gt;
      &lt;li&gt;단말기의 추가나 제거 및 에러 발생 시 발견이 쉬움&lt;/li&gt;
      &lt;li&gt;병목 현상 발생 가능, 중앙 노드 장애 발생 시 전체 통신망 마비&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수평형&lt;/strong&gt;(버스형)
    &lt;ul&gt;
      &lt;li&gt;중앙 통신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;회선&lt;/code&gt; 하나에 여러 대의 노드를 연결하는 방식&lt;/li&gt;
      &lt;li&gt;근거리 통신망에서 볼 수 있는 일반적인 형태&lt;/li&gt;
      &lt;li&gt;하나의 컴퓨터가 다운되어도 나머지 컴퓨터에는 지장이 없음&lt;/li&gt;
      &lt;li&gt;DTE 추가 삭제가 용이&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;우선순위&lt;/code&gt; 제어가 어려움&lt;/li&gt;
      &lt;li&gt;통신 회선의 길이에 제한, 충돌이 자주 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성형&lt;/strong&gt;(스타형)
    &lt;ul&gt;
      &lt;li&gt;중앙에 있는 컴퓨터를 중심으로 터미널이 연결된 중앙 집중식 형태&lt;/li&gt;
      &lt;li&gt;유지보수 및 관리가 용이, 단말기 고장 시 발견이 용이&lt;/li&gt;
      &lt;li&gt;중앙 컴퓨터 고장 시 전체 네트워크 마비&lt;/li&gt;
      &lt;li&gt;통신망 제어가 복잡&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;원형&lt;/strong&gt;(링형)
    &lt;ul&gt;
      &lt;li&gt;인접해 있는 노드들을 연결하는 단방향 전송 형태&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;매채 엑세스&lt;/code&gt; 방식&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;토큰 링&lt;/code&gt; 이용, 동축/광섬유 케이블 이용&lt;/li&gt;
      &lt;li&gt;전송 매체와 DTE 고장 시 발견이 용이&lt;/li&gt;
      &lt;li&gt;단말기 추가 및 삭제가 어려움&lt;/li&gt;
      &lt;li&gt;전송 지연 발생 시 DTE 간의 순차적 전송때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중계기&lt;/code&gt; 기능이 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;망형&lt;/strong&gt;(메쉬형)
    &lt;ul&gt;
      &lt;li&gt;모든 노드들이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상호&lt;/code&gt; 연결&lt;/li&gt;
      &lt;li&gt;통신 회선 장애 시 다른 경로로 데이터 전송이 가능&lt;/li&gt;
      &lt;li&gt;DTE 고장과 병목 현상에 대해 면역성이 있음&lt;/li&gt;
      &lt;li&gt;가장 많은 통신 선로가 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;osi-7계층&quot;&gt;OSI 7계층&lt;/h2&gt;
&lt;p&gt;Open System Interconnection 7-layer&lt;br /&gt;
개방형 시스템 네트워크의 효율적인 이용을 위하여 모든 데이터 통신 기준으로 계층을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분할&lt;/code&gt;하고, 각 계층 간의 필요한 프로토콜을 규정한다.&lt;/p&gt;

&lt;p&gt;정보가 전달되는 Framework를 제공하며, 네트워크 형태에 차이가 발생해도 데이터 통신을 지원&lt;/p&gt;

&lt;h3 id=&quot;osi-7계층-구조&quot;&gt;OSI 7계층 구조&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;OSI 7계층&lt;/td&gt;
      &lt;td&gt;주요 내용&lt;/td&gt;
      &lt;td&gt;주요 프로토콜(매체)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7. Application&lt;/td&gt;
      &lt;td&gt;사용자 소프트웨어를 네트워크에 접근 가능하도록 함.&lt;br /&gt;사용자에게 최종 서비스를 제공&lt;/td&gt;
      &lt;td&gt;FTP, SNMP, HTTP, Mail, Telnet 등&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6. Presentation&lt;/td&gt;
      &lt;td&gt;포맷 기능, 압축, 암호화&lt;br /&gt;텍스트 및 그래픽 정보를 컴퓨터가 이해할 수 있는 16진수 데이터로 변환&lt;/td&gt;
      &lt;td&gt;압축, 암호, 코드 변환  GIF, ASCII, EBCDIC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5. Session&lt;/td&gt;
      &lt;td&gt;세션 연결 및 동기화 수행, 통신 방식 결정&lt;br /&gt;가상 연결을 제공하여 Login/Logout 수행&lt;/td&gt;
      &lt;td&gt;반이중, 전이중, 완전이중 결정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4. Transport&lt;/td&gt;
      &lt;td&gt;가상연결, 에러 제어, 데이터 흐름 제어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Segment&lt;/code&gt; 단위&lt;br /&gt;두 개의 종단 간 End-To-End 데이터 흐름이 가능하도록 논리적 주소 연결&lt;br /&gt;신뢰도, 품질보증, 오류탐지 및 교정 기능 제공  다중화(Multiplexing) 발생&lt;/td&gt;
      &lt;td&gt;TCP, UDP&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3. Network&lt;/td&gt;
      &lt;td&gt;경로선택, 라우팅 수행, 논리적 주소 연결(IP)&lt;br /&gt;데이터 흐름 조절, 주소 지정 메커니즘 구현  네트워크에서 노드에 전송되는 패킷 흐름을 통제하고, 상태메시지가 네트워크상에서 어떻게 노드로 전송되는 가를 정의, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Datagram&lt;/code&gt;(Packet) 단위&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2. Data Link&lt;/td&gt;
      &lt;td&gt;물리주소 결정, 에러 제어, 흐름 제어, 데이터 전송&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Frame&lt;/code&gt; 단위, 전송 오류를 처리하는 최초의 계층&lt;/td&gt;
      &lt;td&gt;흐름제어, 오류제어(ARQ)  브리지, PPTP, L2TP, HDLC  Frame Relay&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1. Physical&lt;/td&gt;
      &lt;td&gt;전기적, 기계적 연결 정의, 실제 Data Bit 전송&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bit&lt;/code&gt; 단위, 전기적 신호, 전압구성, 케이블, 인터페이스 등을 구성&lt;br /&gt;Data Rates, Line noise Control, 동기화 기능 수행&lt;/td&gt;
      &lt;td&gt;매체: 동축케이블, 광섬유, Twisted Pair Cable&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;End-to-End&lt;/strong&gt; : 7 ~ 4계층, 송수신자 간의 에러 제어&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Point-to-Point&lt;/strong&gt; : 4 ~ 1계층, 각 구간에 대해 에러 제어&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;osi-계층별-하드웨어-장비&quot;&gt;OSI 계층별 하드웨어 장비&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Physical
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Cable&lt;/strong&gt;&lt;br /&gt;
Twisted Pair Cable, Coaxial, Fiber-Optic Cable&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Repeater&lt;/strong&gt;&lt;br /&gt;
네트워크 구간 케이블의 전기적 신호를 재생하고 증폭하는 장치
디지털 신호를 제공, 아날로그 신호 증폭 시 잡음과 왜곡까지 증폭&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data Link
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Bridge&lt;/strong&gt;&lt;br /&gt;
서로 다른 LAN Segment를 연결, 관리자에게 MAC 주소 기반 필터링 제공하여 더 나은 대역폭 사용과 트래픽을 통제
리피터와 같이 데이터 신호를 증폭하지만 MAC 기반에서 동작&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Switch&lt;/strong&gt;&lt;br /&gt;
목적지의 MAC 주소를 알고 있는 지정된 포트로 데이터를 전송
Repeater와 Bridge의 기능을 결합
네트워크의 속도 및 효율적 운영, Data Link 계층에서도 작동&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Network
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Router&lt;/strong&gt;&lt;br /&gt;
패킷을 받아 경로를 설정하고 패킷을 전달
Bridge는 MAC 주소를 참조하지만, Router는 네트워크 주소를 참조하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;경로&lt;/code&gt;를 설정
패킷 헤더 정보에서 IP 주소를 확인하여 목적지 네트워크로만 전달하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Broadcasting&lt;/code&gt;을 차단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Application
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Gateway&lt;/strong&gt;&lt;br /&gt;
서로 다른 네트워크망과의 연결(PSTN, Internet, Wireless Network 등)
패킷 헤더의 주소 및 포트 외 거의 모든 정보를 참조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-전송-방식-1&quot;&gt;데이터 전송 방식&lt;/h3&gt;
&lt;h4 id=&quot;직렬-전송serial-transmission&quot;&gt;직렬 전송(Serial Transmission)&lt;/h4&gt;
&lt;p&gt;한 문자의 각 비트 열을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나의&lt;/code&gt; 전송 선로를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;순차적&lt;/code&gt;으로 전송하는 방식(모뎀)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시프트 레지스터를 이용하여 병렬을 직렬화한 후 송신&lt;/li&gt;
  &lt;li&gt;동기 전송 방식의 요구&lt;/li&gt;
  &lt;li&gt;전송 에러가 적고, 장거리에 적합&lt;/li&gt;
  &lt;li&gt;통신 회선 설치 비용이 저렴&lt;/li&gt;
  &lt;li&gt;전송 속도가 느림&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;병렬-전송parallel-transmission&quot;&gt;병렬 전송(Parallel Transmission)&lt;/h4&gt;
&lt;p&gt;한 문자를 이루는 각 비트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;각각의&lt;/code&gt; 전송로를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;한꺼번에&lt;/code&gt; 전송되는 방식(프린터)
블록 버퍼를 이용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;송수신 문자 간격을 식별하는 스트로브 신호와 BUSY 신호로 다음 문자의 송신 시기 결정&lt;/li&gt;
  &lt;li&gt;단위 시간에 다량의 데이터를 빠른 속도로 전송&lt;/li&gt;
  &lt;li&gt;전송 길이가 길어지면 에러 발생 가능성 농후&lt;/li&gt;
  &lt;li&gt;통신 회선 설치 비용이 커짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;동기-방식synchronous-method&quot;&gt;동기 방식(Synchronous Method)&lt;/h4&gt;
&lt;p&gt;전송할 데이터를 여러 블록으로 나누어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블록&lt;/code&gt; 단위로 전송하는 방식
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제어 정보&lt;/code&gt;를 데이터의 앞뒤에 붙여 프레임을 구성&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;전송 단위&lt;/strong&gt; : 프레임, 문자 중심 / 비트 중심&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;에러 검출&lt;/strong&gt; : CRC&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오버헤드&lt;/strong&gt; : 프레임당 고정된 크기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 속도&lt;/strong&gt; : 고속&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 효율&lt;/strong&gt; : 높다(휴지 간격 없음, 채널 할당 시간 공백 없음)&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;원거리 전송에 이용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;에러 발생 확률이 높다&lt;/li&gt;
      &lt;li&gt;고가(별도의 하드웨어 장치가 필요)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;비동기-방식asynchronous-method&quot;&gt;비동기 방식(Asynchronous Method)&lt;/h4&gt;
&lt;p&gt;한 번에 한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;문자씩&lt;/code&gt; 전송하는 방식(한 문자 전송 시마다 동기화하는 방식)&lt;br /&gt;
start-stop 비트를 사용, 패리티 비트, 정지 비트 ‘1’ 시작비트 ‘0’&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;전송 단위&lt;/strong&gt; : 문자 단위의 비트 블록&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;에러 검출&lt;/strong&gt; : 패리티 비트&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오버헤드&lt;/strong&gt; : 문자당 고정된 크기&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 속도&lt;/strong&gt; : 저속&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 효율&lt;/strong&gt; : 낮음&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;동기화가 단순하며 저렴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;문자당 2~3비트의 오버헤드가 발생&lt;/li&gt;
      &lt;li&gt;프레임 에러가 발생할 가능성이 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="데이터통신" /><category term="네트워크" /><summary type="html">네트워크 송신자의 메시지를 수신자에게 전달하는 과정으로 한 지점에서 원하는 다른 지점까지 의미 있는 정보를 보다 정확하고 빠르게 상대방이 이해할 수 있도록 전송하는 것을 의미</summary></entry><entry><title type="html">[웹프로그래밍] Ajax</title><link href="https://many258.github.io/study/web-ajax/" rel="alternate" type="text/html" title="[웹프로그래밍] Ajax" /><published>2021-03-10T00:00:00+09:00</published><updated>2021-03-10T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bweb-ajax%7D</id><content type="html" xml:base="https://many258.github.io/study/web-ajax/">&lt;blockquote&gt;
  &lt;p&gt;보통 우리가 생각하는 웹프로그래밍은 클릭과 같은 이벤트를 통해 웹 서버에 요청하고 요청에 대한 응답을 클라이언트에게 보내주어 갱신되는 것이 일반적이다.&lt;/p&gt;

  &lt;p&gt;하지만, 구글 지도와 같은 몇 웹페이지에서는 신기하게도 전체 페이지를 다시 새로고침하지 않고도 지도 정보만 갱신되는 것을 볼 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;ajax&quot;&gt;Ajax&lt;/h1&gt;
&lt;p&gt;(Asynchronous JavaScript and XML, 에이잭스)&lt;br /&gt;
비동기적인 웹 애플리케이션의 제작을 위해 아래와 같은 조합을 이용하는 웹 개발 기법&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;표현 정보를 위한 HTML (또는 XHTML) 과 CSS&lt;/li&gt;
  &lt;li&gt;동적인 화면 출력 및 표시 정보와의 상호작용을 위한 DOM, 자바스크립트&lt;/li&gt;
  &lt;li&gt;웹 서버와 비동기적으로 데이터를 교환하고 조작하기 위한 XML, XSLT, XMLHttpRequest&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JavaScript의 라이브러리 중 하나이며, JavaScript를 사용한 비동기 통신, 클라이언트와 서버 간에 XML 데이터를 주고받는 기술이다.&lt;/p&gt;

&lt;p&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자바스크립트&lt;/code&gt;를 통해 다양한 형태의 데이터(JSON, XML, CSV)를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서버&lt;/code&gt;와 주고받을 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;비동기-방식&quot;&gt;비동기 방식&lt;/h2&gt;
&lt;p&gt;웹페이지를 새로고침하지 않고 데이터를 불러오는 방식.&lt;/p&gt;

&lt;p&gt;보통 자주가는 카페를 예로 들어보자면,&lt;br /&gt;
동기 방식의 경우는 손님이 들어올 때마다 주문을 받고 손님은 커피를 받기 전까지 카운터에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기다리는&lt;/code&gt; 상황이고&lt;br /&gt;
비동기 방식은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;진동벨&lt;/code&gt;을 구비해서 손님의 주문을 받음과 동시에 진동벨을 배분하고 일을 하다가 중간에 다른 손님이 오더라도 주문을 받을 수 있는 상황과 유사하다고 할 수 있다.&lt;/p&gt;

&lt;p&gt;위 예시에서 손님이 갑자기 몰려온다고 생각해보자.&lt;br /&gt;
동기 방식에서는 손님이 주문하고 커피를 준비하고 넘겨주어야 다음 손님을 맞을 수 있으므로 시간 낭비가 심하다.&lt;br /&gt;
하지만, 비동기 방식에서는 손님을 기다리게 하고 다른 업무를 할 수 있으니 시간적으로 효율이 좋다.&lt;/p&gt;

&lt;p&gt;즉, 비동기 방식의 &lt;strong&gt;장점&lt;/strong&gt;은&lt;br /&gt;
기존의 변경할 필요가 없는 이미지, 스크립트 등은 남겨두고 필요한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부분만&lt;/code&gt; 갱신해 사용할 수 있다는 점이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/web/ajax/processing model.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;데이터-전송-방식&quot;&gt;데이터 전송 방식&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt;&lt;br /&gt;
지정한 URL의 데이터를 열람하기 위한 메소드&lt;br /&gt;
사용이 간편하고 전송량이 적으나 사용자정보를 URL에 노출함으로 보안상 취약할 수 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt;&lt;br /&gt;
지정한 URL에 데이터를 생성하기 위한 메소드(수정 및 삭제 작업도 수행 가능)&lt;/li&gt;
  &lt;li&gt;PUT&lt;br /&gt;
지정한 URL의 데이터를 갱신하기 위한 메소드&lt;/li&gt;
  &lt;li&gt;DELETE&lt;br /&gt;
지정한 URL의 데이터를 삭제하기 위한 메소드&lt;/li&gt;
  &lt;li&gt;HEAD&lt;br /&gt;
지정한 URL의 헤더 정보를 요청하는 메소드&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ajax의-장점&quot;&gt;AJAX의 장점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;웹페이지 &lt;strong&gt;속도&lt;/strong&gt; 향상&lt;/li&gt;
  &lt;li&gt;서버 처리를 기다리지 않고, 비동기 요청 가능&lt;/li&gt;
  &lt;li&gt;수신하는 데이터의 양을 줄일 수 있고, 클라이언트에게 처리를 위임할 수도 있다.&lt;/li&gt;
  &lt;li&gt;플러그인 없이도 인터렉티브한 웹페이지 구현이 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ajax의-단점&quot;&gt;AJAX의 단점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Ajax를 쓸 수 없는 브라우저에 대한 문제가 있음&lt;/li&gt;
  &lt;li&gt;HTTP 클라이언트 기능이 한정되어 있음&lt;/li&gt;
  &lt;li&gt;페이지 이동없는 통신으로 인한 보안상의 문제 발생 가능성&lt;/li&gt;
  &lt;li&gt;히스토리 관리가 되지 않음&lt;/li&gt;
  &lt;li&gt;지원하는 Charset이 한정&lt;/li&gt;
  &lt;li&gt;스크립트로 작성되므로 디버깅이 용이하지 않음&lt;/li&gt;
  &lt;li&gt;요청을 남발하면 역으로 서버 부하가 늘 수 있음&lt;/li&gt;
  &lt;li&gt;동일-출처 정책으로 인하여 다른 도메인과는 통신이 불가능(Cross-Domain문제)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ajax-프레임워크&quot;&gt;AJAX 프레임워크&lt;/h2&gt;
&lt;p&gt;Ajax를 이용하여 개발을 손쉽게 할 수 있도록 미리 여러 가지 기능을 포함해 놓은 개발 환경&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JQuery&lt;/li&gt;
  &lt;li&gt;Prototype&lt;/li&gt;
  &lt;li&gt;script.acul.us&lt;/li&gt;
  &lt;li&gt;dojo&lt;/li&gt;
  &lt;li&gt;Google Web Toolkit&lt;/li&gt;
  &lt;li&gt;ASP.NET AJAX&lt;/li&gt;
  &lt;li&gt;YUI&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ajax-예제&quot;&gt;AJAX 예제&lt;/h2&gt;
&lt;h3 id=&quot;javascript에서-ajax&quot;&gt;JavaScript에서 Ajax&lt;/h3&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;XMLHttpRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;XMLHttpRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ActiveXObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Microsoft.XMLHTTP&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onreadystatechange&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;readyState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;//통신 성공시 구현부분&lt;/span&gt;

         &lt;span class=&quot;c1&quot;&gt;//readState : Ajax 통신의 진행중인 상태 표시&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 0 : 초기화되지 않은 상태(open 메소드가 호출되지 않은 상태)&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 1 : open 메소드가 호출된 상태(send메소드는 호출되지 않은 상태)&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 2 : 송신완료, 요청을 시작한 상태(요청은 하지 않았지만 데이터가 아직 오지 않은 상태)&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 3 : 수신 중인 상태(데이터를 받고 있는 상태)&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 4 : 수신 완료(데이터를 모두 받은 상태)&lt;/span&gt;

         &lt;span class=&quot;c1&quot;&gt;//status : 데이터 수신의 성공 여부를 판단해주는 속성값&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 0 : 로컬로 접근 성공을 의미&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 200 : 해당 URL로 접근 성공한 상태&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 403 : 접근이 거부됨.&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 404 : 해당 URL이 없음&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// 500 : 서버오류&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;exam.xml&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;xmlhttp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JavaScript에서 Ajax는 텍스트/XML 타입으로만 데이터를 가져올 수 있기 때문에 JSON/CSV 형식으로 데이터를 받기 위해서는 따로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파싱&lt;/code&gt;(Parsing)하는 코드 작업이 필요.&lt;/p&gt;

&lt;h3 id=&quot;jquery에서-ajax&quot;&gt;JQuery에서 Ajax&lt;/h3&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;script&lt;/span&gt;  &lt;span class=&quot;nx&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;http://code.jquery.com/jquery-latest.min.js&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/script&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//request 보낼 서버의 경로&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 메소드(get, post, put 등)&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;yoo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//보낼 데이터&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;datatype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//서버로부터 정상적으로 응답이 왔을 때 실행&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;//서버로부터 응답이 정상적으로 처리되지 못햇을 때 실행&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;또는&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//request 보낼 서버의 경로&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 메소드(get, post, put 등)&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;yoo&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//보낼 데이터&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;datatype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// HTTP 요청이 성공하면 요청한 데이터가 done 메소드로 전달&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;xhr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;errorThrown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// HTTP 요청이 실패하면 오류와 상태에 대한 정보가 fail 메소드로 전달&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;always&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;xhr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// HTTP 요청이 성공, 실패에 상관없이 언제나 alway 메서드 실행&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="AJAX" /><summary type="html">보통 우리가 생각하는 웹프로그래밍은 클릭과 같은 이벤트를 통해 웹 서버에 요청하고 요청에 대한 응답을 클라이언트에게 보내주어 갱신되는 것이 일반적이다. 하지만, 구글 지도와 같은 몇 웹페이지에서는 신기하게도 전체 페이지를 다시 새로고침하지 않고도 지도 정보만 갱신되는 것을 볼 수 있다.</summary></entry><entry><title type="html">[운영체제/OS] RAID</title><link href="https://many258.github.io/study/os-raid/" rel="alternate" type="text/html" title="[운영체제/OS] RAID" /><published>2021-03-09T00:00:00+09:00</published><updated>2021-03-09T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bos-raid%7D</id><content type="html" xml:base="https://many258.github.io/study/os-raid/">&lt;h1 id=&quot;raid&quot;&gt;RAID&lt;/h1&gt;
&lt;p&gt;Redundant Array of Independent/Inexpensive Disks : 복수 배열 독립 디스크&lt;br /&gt;
여러 대의 물리적 디스크를 하나의 논리적 디스크로 인식시키는 기술&lt;br /&gt;
여러 개의 하드 디스크에 일부 중복된 데이터를 나눠서 저장하는 기술 = 디스크 어레이&lt;/p&gt;

&lt;p&gt;데이터를 나누는 다양한 방법이 존재하며, 이 방법들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;레벨&lt;/code&gt;이라 하는데, 레벨에 따라 저장장치의 신뢰성을 높이거나 전체적인 성능을 향상시키는 등의 다양한 목적을 만족시킬 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;raid의-사용-목적&quot;&gt;RAID의 사용 목적&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;무정지 구현(가용성)&lt;/li&gt;
  &lt;li&gt;성능 향상&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;주의)&lt;/strong&gt; 데이터의 무결성, 안전, 백업에 대한 목적은 아니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;raid-0&quot;&gt;RAID 0&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스트라이핑&lt;/code&gt; Striping&lt;/p&gt;

&lt;p&gt;일련의 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나의 논리적 디스크&lt;/code&gt; 배열에 일정한 크기로 나누어서 분산 저장하는 기법&lt;br /&gt;
사용자와 시스템 데이터는 하나의 논리 디스크상에 저장되어 있는 것으로 인식하며 디스크는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스트립&lt;/code&gt;(Strip)이라는 일정한 크기의 섹터 또는 물리적 블록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단위&lt;/code&gt;로 나누어 연속적인 배열 구성요소와 대응되도록 순환할당된다.&lt;br /&gt;
이와 같이 하나의 스트립들과 각 배열의 구성요소가 대응하는 논리적으로 연속적인 스트립의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;집합&lt;/code&gt;을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스트라이프&lt;/code&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;RAID 0 방식은 데이터를 입출력할 때, RAID 컨트롤러에서 여러 개의 하드 디스크로 나눠서 쓰고 읽어 들이므로 중요하지 않은 데이터에 대한 빠른 데이터 입출력 성능이 요구되는 동영상 편집 등에 적합&lt;/p&gt;

&lt;p&gt;데이터를 중복해서 기록하지 않으므로 장애발생에 대비한 여분의 저장 공간을 가지고 있지 않다. 즉, 어느 한 드라이브에서 장애가 발생하면 데이터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;손실&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/150px-RAID_0.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-1&quot;&gt;RAID 1&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;미러링&lt;/code&gt; Mirroring + 스트라이핑 Striping&lt;/p&gt;

&lt;p&gt;RAID 0 과 같이 데이터 스트라이핑을 사용하면서 배열 내의 모든 디스크가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동일&lt;/code&gt;한 데이터를 가지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;미러 디스크&lt;/code&gt;를 가진다.
각 논리적 스트립은 두 개의 별도 디스크에 대응되므로 미러링이라고도 하는데, 중복 저장된 데이터를 가진 적어도 두 개의 드라이브로 구성&lt;/p&gt;

&lt;p&gt;멤버 디스크 중 하나만 살아남으면 데이터는 보존되며 복원도 1:1복사로 매우 간단하기 때문에 서버에서 끊김없이 지속적으로 서비스를 제공하기 위해 사용&lt;/p&gt;

&lt;p&gt;읽기 요구는 요구 데이터를 가지고 있는 두 개의 디스크 중 어떤 디스크에서도 서비스를 받을 수 있기 때문에 성능이 향상될 수 있으나,
데이터를 분할 저장하지 않기 때문에 두 스트립이 모두 갱신되어야 하며 쓰기 요구는 단일 디스크 드라이브의 경우와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/150px-RAID_1.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-2&quot;&gt;RAID 2&lt;/h2&gt;
&lt;p&gt;스트라이핑 + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;허밍 코드&lt;/code&gt; Hamming Code&lt;/p&gt;

&lt;p&gt;디스크들 간에 데이터 스트라이핑을 사용하며 오류 검출 능력이 없는 드라이브를 위해 허밍 코드 기법을 사용한다.(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;안전성&lt;/code&gt; 확보)&lt;br /&gt;
몇몇 디스크들은 오류를 감지하고 수정하는 데 사용되는 오류정정코드(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECC&lt;/code&gt;, Error Correcting Code)정보를 저장&lt;/p&gt;

&lt;p&gt;허밍 오류정정코드는 패리티 비트를 사용해 디스크로부터 전송된 데이터에 오류가 있는지 검사 및 정정&lt;/p&gt;

&lt;p&gt;실시간 오류수정이 가능하다는 장점이 있지만, 현재의 SCSI 드라이브들이 자체 오류 검출 능력을 갖고 있기 때문에 실제 잘 쓰이지 않음.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/350px-RAID2_arch.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-3&quot;&gt;RAID 3&lt;/h2&gt;
&lt;p&gt;RAID 0과 같이 스트라이브를 사용하며, 오류 검출과 수정을 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;별도의 드라이브&lt;/code&gt; 한 개를 패리티 드라이브로 사용&lt;br /&gt;
각각의 데이터 디스크에 데이터를 비트 단위로 스트라이핑하여 기록&lt;/p&gt;

&lt;p&gt;대형 레코드가 많이 사용되는 단일 사용자 시스템과 다량의 데이터 전송이 요구되는 작업에 적합&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/300px-RAID_3.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-4&quot;&gt;RAID 4&lt;/h2&gt;
&lt;p&gt;데이터 분산 저장을 위해 스트라이핑과 패리티 드라이브를 사용한다는 점에서 RAID 3과 유사하지만, 각 드라이브에 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블록 단위&lt;/code&gt;로 분산 저장한다는 점에서 다름&lt;/p&gt;

&lt;p&gt;쓰기 요청이 있을 때마다 사용자 데이터와 함께 패리티 정보를 갱신해야 하기 때문에 추가시간이 소요되므로 크기가 작은 입출력이 요청될 때 쓰기 성능 저하(입출력의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;병목현상&lt;/code&gt; 유발)&lt;br /&gt;
데이터 읽기 요청은 RAID 0과 비슷한 성능을 가짐&lt;/p&gt;

&lt;p&gt;여러 드라이브 중에서 한 대의 드라이브만이 여분의 패리티 정보를 기록하는데 사용되기 때문에 용량당 비용은 높지않아 저렴한 가격으로 장애 복구 능력이 요구되거나 빠른 판독속도가 필요한 경우에 사용&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/300px-RAID_4.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-5&quot;&gt;RAID 5&lt;/h2&gt;
&lt;p&gt;RAID 4 구성과 유사하며 별도의 패리티 드라이브 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;모든&lt;/code&gt; 드라이브에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;패리티&lt;/code&gt; 정보를 나누어 저장. (디스크 병목현상 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;해결&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;다중 프로세스 시스템에서와 같이 작고 잦은 데이터 기록이 있을 경우 더 빠르지만, 읽기 요청의 경우 각 드라이브에서 패리티 정보를 건너뛰어야 하기 때문에 RAID 4보다 속도가 느리다.&lt;/p&gt;

&lt;p&gt;최소한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt;대, 일반적으로 5대 이상의 드라이브가 필요. N개의 디스크를 사용하면 (N-1)배의 저장 공간을 사용 가능하다.&lt;/p&gt;

&lt;p&gt;데이터는 각 데이터 영역에 블록 단위로 스트라이핑하여 저장된다.&lt;br /&gt;
병렬 입출력이 가능하기 때문에 기록과 읽기가 동시에 가능하며 데이터 입출력 선능이 아주 빠르면서도 안전성 또한 높은 편으로 파일 서버 등의 입출력이 빈번한 업무에 적합하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/300px-RAID_5.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-6&quot;&gt;RAID 6&lt;/h2&gt;
&lt;p&gt;RAID 5와 원리는 같으며, 서로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다른 방식&lt;/code&gt;의 패리티 2개를 동시에 사용한다.&lt;br /&gt;
성능과 용량을 희생해서 가용성을 높인 셈.&lt;/p&gt;

&lt;p&gt;N개의 디스크를 사용하면 (N-2)배의 저장 공간을 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/OS/raid/300px-RAID_6.svg.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;nested-raid&quot;&gt;Nested RAID&lt;/h2&gt;
&lt;p&gt;레이드 볼륨의 멤버로 다른 레이드 볼륨을 사용하는 형태.&lt;br /&gt;
멤버 디스크를 묶는 배열을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하위&lt;/code&gt; 배열, 하위 배열을 묶는 배열을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상위&lt;/code&gt; 배열이라고 한다.
표기 방법은 m(하위 배열)n(상위 배열)이며 m=0이면 뒤에 +를 붙인다.&lt;/p&gt;

&lt;h3 id=&quot;raid-01&quot;&gt;RAID 0+1&lt;/h3&gt;
&lt;p&gt;RAID 0으로 스트라이핑 된 볼륨을 RAID 1로 미러링. (적어도 4개의 디스크 필요)&lt;/p&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="OS" /><summary type="html">RAID Redundant Array of Independent/Inexpensive Disks : 복수 배열 독립 디스크 여러 대의 물리적 디스크를 하나의 논리적 디스크로 인식시키는 기술 여러 개의 하드 디스크에 일부 중복된 데이터를 나눠서 저장하는 기술 = 디스크 어레이</summary></entry><entry><title type="html">[데이터베이스/DB] 트랜잭션(Transaction)과 병행제어 및 회복</title><link href="https://many258.github.io/study/database-transaction/" rel="alternate" type="text/html" title="[데이터베이스/DB] 트랜잭션(Transaction)과 병행제어 및 회복" /><published>2021-03-09T00:00:00+09:00</published><updated>2021-03-09T14:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdatabase-transaction%7D</id><content type="html" xml:base="https://many258.github.io/study/database-transaction/">&lt;h1 id=&quot;트랜잭션&quot;&gt;트랜잭션&lt;/h1&gt;
&lt;p&gt;데이터베이스의 상태를 하나의 상태에서 또 다른 일관된 상태로 변화시켜주는 일련의 논리적인 연산 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;집합&lt;/code&gt;&lt;br /&gt;
한번에 모두 소행되어야하는 연산들의 집합, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나의 작업&lt;/code&gt;을 처리하기위한 작업 단위&lt;br /&gt;
하나의 트랜잭션은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완료&lt;/code&gt;(Commit)되거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복귀&lt;/code&gt;(Rollback)되어야 한다&lt;/p&gt;

&lt;h2 id=&quot;트랜잭션의-성질&quot;&gt;트랜잭션의 성질&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Atomicity&lt;/strong&gt;(원자성)&lt;br /&gt;
트랜잭션이라는 것은 연산의 집단을 의미하지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;논리적&lt;/code&gt;으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나&lt;/code&gt;의 의미
연산들은 모두 수행되거나 모두 수행되지 않아야한다(= 일부의 완료는 존재하지 않는다)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Consistency&lt;/strong&gt;(일관성)&lt;br /&gt;
고정 요소는 트랜잭션 실행 전과 후가 같아야 한다는 성질
트랜잭션이 실행되고 나서도 데이터베이스의 상태는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무결성&lt;/code&gt;이 유지되고 모순되지 말아야 된다는 성질&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Isolation&lt;/strong&gt;(독립성,격리성)&lt;br /&gt;
트랜잭션이 실행되는 중간에는 다른 트랜잭션 연산이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;침범&lt;/code&gt;하지 못하는 성질
같은 자원에 대해 여러 개의 트랜잭션이 동시에 사용할 수 없다는 성질&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Durability&lt;/strong&gt;(영속성,지속성)&lt;br /&gt;
트랜잭션에 의해서 변화된 상태는 계속해서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유지&lt;/code&gt;될 수 있어야 한다는 성질&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;트랜잭션의-상태&quot;&gt;트랜잭션의 상태&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;활동(Active)&lt;br /&gt;
트랜잭션이 실행 중인 상태&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;부분 완료(Partially Committed)&lt;br /&gt;
트랜잭션이 마지막 연산을 끝내고 데이터베이스에 실행 결과를 적용하기 직전의 상태&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;완료(Committed)&lt;br /&gt;
트랜잭션이 연산을 완료하고 연산의 결과를 데이터베이스에 적용한 상태&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실패(Failed)&lt;br /&gt;
트랜잭션이 실행 중 어떤 오류에 의해서 더 이상 진행될 수 없는 상태&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;철회(Aborted)&lt;br /&gt;
트랜잭션 실행이 실패하여 복귀된 상태&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;병행제어&quot;&gt;병행제어&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다중&lt;/code&gt; 프로그램의 이점을 활용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동시&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;여러&lt;/code&gt; 개의 트랜잭션을 병행수행할 때,&lt;br /&gt;
동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호작용을 제어하는 것을 의미.&lt;/p&gt;

&lt;h2 id=&quot;목적&quot;&gt;목적&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;데이터베이스의 공유를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최대화&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;시스템의 활용도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최대화&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;데이터베이스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;일관성&lt;/code&gt; 유지&lt;/li&gt;
  &lt;li&gt;사용자에 대한 응답시간 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소화&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;제약없는-병행-처리concurrency-processing-시-문제점&quot;&gt;제약없는 병행 처리(Concurrency Processing) 시 문제점&lt;/h2&gt;
&lt;p&gt;병행제어 기법에 의한 제어 없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용할 경우 다음과 같은 문제점이 발생&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;분실된 갱신(Lost Update)&lt;br /&gt;
두 개의 트랜잭션이 같은 데이터에 대해서 동시에 갱신 작업을 하면 하나의 갱신 작업이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분실&lt;/code&gt;되는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모순성(Inconsistency, 불일치)&lt;br /&gt;
한 개의 트랜잭션 작업이 갱신 작업을 하고 있는 상태에서 또 하나의 트랜잭션이 같은 작업 구역에 침범하여 작업하게 되면, 트랜잭션이 모두 끝나게 되더라도 그 데이터에 대한 결과는 사용자가 원하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;결과&lt;/code&gt;와 일치하지 않는 상태가 되어 데이터베이스의 일관성을 해치는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;연쇄 복귀(CasCading Rollback)&lt;br /&gt;
다른 트랜잭션이 처리하는 과정에서 실패하게 되면 두 개의 트랜잭션 모두 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복귀&lt;/code&gt;되는 현상&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비완료 의존성(Uncommitted Dependency)&lt;br /&gt;
한 개의 트랜잭션이 수행과정에서 실패하였을 때, 이 트랜잭션이 회복되기 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전&lt;/code&gt;에 다른 트랜잭션이 이 트랜잭션의 수행 결과를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;참조&lt;/code&gt;하는 현상&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;병행제어-기법의-종류&quot;&gt;병행제어 기법의 종류&lt;/h2&gt;
&lt;h3 id=&quot;로킹&quot;&gt;로킹&lt;/h3&gt;
&lt;p&gt;자원 이용에 대하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상호배제&lt;/code&gt; 기능을 이용하는 기법&lt;/p&gt;

&lt;p&gt;직렬성을 보장하기 위해 하나의 트랜잭션이 어떤 데이터에 대해서 액세스하는 동안 또 다른 트랜잭션이 이 데이터에 대해 액세스하기 위해서는 로크를 소유하고 있어야만 가능하도록 하는 방법.&lt;br /&gt;
언제 로크를 소유하고 해제하는가 하는 로킹 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;규칙&lt;/code&gt;을 정해놓고 해결.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로킹 기법
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;공유 잠금(Shared Lock)&lt;br /&gt;
잠금 걸린 데이터에 대해 읽기 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가능&lt;/code&gt;, 쓰기 불가능&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;베타 잠금(Exclusive Lock)&lt;br /&gt;
잠금 걸린 데이터에 대해 읽기, 쓰기 불가능&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;로킹단위(Locking Granularity)&lt;br /&gt;
병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기&lt;br /&gt;
주요 단위로는 DB, DBSPACE, 테이블, 페이지 등
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;로킹 단위가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;작다&lt;/code&gt;&lt;br /&gt;
데이터의 공유도와 병행성이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;증가&lt;/code&gt;하나 로크의 수가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;많아&lt;/code&gt; 병행 제어 기법이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복잡&lt;/code&gt;하고 관리가 어렵다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;로킹 단위가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;크다&lt;/code&gt;&lt;br /&gt;
데이터의 공유도와 병행성 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;감소&lt;/code&gt;하고 로크의 수가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;적어&lt;/code&gt; 병행 제어 기법이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;간단&lt;/code&gt;하고 관리가 쉽다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;2단계 로킹 규약(Two-Phase Locking Protocol)&lt;br /&gt;
트랜잭션 스케쥴의 직렬성을 보장하는 대표적인 기법
    &lt;ul&gt;
      &lt;li&gt;요청단계(Growing Phase) = 확장 단계&lt;br /&gt;
로크를 얻는 과정에서는 어떠한 로크도 반납될 수 없다는 것을 나타내는 단계(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;잠금만&lt;/code&gt; 수행)&lt;/li&gt;
      &lt;li&gt;반납단계(Shrinking Phase) = 축소 단계&lt;br /&gt;
트랜잭션이 완료되는 시점에서 데이터에 대한 로크를 반납하는 과정에서는 어떠한 로크도 획득할 수 없는 단계(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;해제만&lt;/code&gt; 수행)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;타임스탬프&quot;&gt;타임스탬프&lt;/h3&gt;
&lt;p&gt;시스템에 진입하는 트랜잭션 순서대로 타임스탬프를 지정하여 동시성을 제어하는 기법&lt;/p&gt;

&lt;h3 id=&quot;검증-기법&quot;&gt;검증 기법&lt;/h3&gt;
&lt;p&gt;= 최적 병행수행, 확인 기법, 낙관적 기법&lt;/p&gt;

&lt;p&gt;읽기 단계, 검증 단계, 기록 단계를 이용하여 직렬성을 보장하는 기법&lt;/p&gt;

&lt;h3 id=&quot;다중버전-기법&quot;&gt;다중버전 기법&lt;/h3&gt;
&lt;p&gt;= 다중 버전 타임 스탬프 기법&lt;/p&gt;

&lt;p&gt;갱신 연산 때마다 새로운 버전을 만들어 병렬수행을 제어하는 기법&lt;/p&gt;

&lt;h1 id=&quot;회복recovery&quot;&gt;회복(Recovery)&lt;/h1&gt;
&lt;p&gt;어떤 외부적인 장애 요인이나 내부적인 장애 요인에 의해서 데이터베이스의 상태가 일관성 유지에 제약이 걸렸을 때, 장애 이전의 일관된 상태가 되도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;복원&lt;/code&gt;하는 일&lt;/p&gt;

&lt;h2 id=&quot;장애failure의-유형&quot;&gt;장애(Failure)의 유형&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;실행 장애&lt;/li&gt;
  &lt;li&gt;트랜잭션 장애&lt;/li&gt;
  &lt;li&gt;시스템 장애&lt;br /&gt;
H/W 시스템 자체에서 발생할 수 잇는 장애&lt;/li&gt;
  &lt;li&gt;미디어 장애&lt;br /&gt;
디스크 자체의 손상으로 발생할 수 있는 장애&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;undo&quot;&gt;UNDO&lt;/h2&gt;
&lt;p&gt;변경된 데이터를 취소하여 원래의 내용으로 복원시키는 연산&lt;/p&gt;

&lt;p&gt;주로 트랜잭션이 실행 중인 상태에서 실행이 실패하였을 경우 원래의 내용으로 복원하는 경우에 사용&lt;/p&gt;

&lt;h2 id=&quot;redo&quot;&gt;REDO&lt;/h2&gt;
&lt;p&gt;이전 상태로 되돌아간 후, 실패가 발생하기 전까지의 과정을 그대로 따라가는 것을 의미&lt;/p&gt;

&lt;p&gt;주로 데이터베이스의 내용이 손상되었을 때, Backup 본으로 회복한 다음 Backup 본에 있는 데이터 이후는 로그에 갱신되어 있는 데이터를 데이터베이스에 적용하는데 사용&lt;/p&gt;

&lt;h2 id=&quot;회복-기법&quot;&gt;회복 기법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;로그 기반 회복 기법&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;즉시 갱신&lt;/strong&gt;&lt;br /&gt;
트랜잭션이 수행중인 상태에서도 그 결과를 즉시 데이터베이스에 반영&lt;br /&gt;
커밋 발생 이전의 갱신은 원자성이 보장되지 않는 미완료 갱신이므로 장애 발생 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNDO&lt;/code&gt; 연산 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;필요&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;지연 회복 기법&lt;/strong&gt;&lt;br /&gt;
트랜잭션의 갱신 결과를 로그에 기록하여 두었다가 트랜잭션의 연산이 완료되면 한번에 데이터베이스에 반영
처리 도중 장애가 생기더라도 데이터베이스에 반영되지 않았으므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNDO&lt;/code&gt; 연산이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;불필요&lt;/code&gt; (REDO 연산 수행)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;검사점(CheckPoint) 회복 기법&lt;/strong&gt; 
장애 발생 시 검사점 이전에 처리된 트랜잭션은 회복에서 제외하고 검사점 이후에 처리된 트랜잭션은 회복작업을 수행&lt;br /&gt;
장애 발생 시점 이전에 Commit이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;완료&lt;/code&gt;된 경우 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNDO&lt;/code&gt; 수행&lt;br /&gt;
장애 발생 시점 이전에 Commit을 못한 경우 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REDO&lt;/code&gt; 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;그림자페이징 기법&lt;/strong&gt;&lt;br /&gt;
로그를 이용하지 않으며 트랜잭션이 실행되는 메모리상의 현 페이지 테이블(Current Page Table)과 하드디스크의 그림자페이지 테이블(Shadow Page Table) 사용&lt;/p&gt;

    &lt;p&gt;트랜잭션 시작지점에서 현 페이지 테이블과 동일한 그림자페이지 테이블 사용&lt;br /&gt;
트랜잭션이 성공으로 완료될 경우, 그림자페이지 테이블 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;삭제&lt;/code&gt;&lt;br /&gt;
트랜잭션이 실패할 경우, 그림자페이지 테이블을 현 페이지 테이블로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;교체&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;미디어 회복 기법&lt;/strong&gt;&lt;br /&gt;
디스크와 같은 비휘발성 저장 장치가 손상되는 장애 발생을 대비한 회복 기법&lt;/p&gt;

    &lt;p&gt;데이터베이스의 내용을 백업/미러링/RAID 등을 통해 별도의 물리적 저장장치에 덤프&lt;br /&gt;
미디어 장애 시 가장 최근 덤프로 복구하고 로그 파일을 참조해 덤프 이후의 작업을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;REDO&lt;/code&gt; 수행 (UNDO는 수행하지 않음)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ARIES 회복 기법&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;REDO 중 역사 반복(Repeating history)&lt;br /&gt;
붕괴가 발생했을 때의 데이터베이스 상태를 복구하기 위하여 붕괴 발생 이전에 수행했던 모든 연산을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다시&lt;/code&gt; 한번 수행.&lt;br /&gt;
붕괴가 발생했을 때 완료되지 않은 상태였던 (진행 트랜잭션)은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNDO&lt;/code&gt; 된다.&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;UNDO 중 로깅(Logging)&lt;br /&gt;
UNDO를 할 때에도 로깅을 함으로써 회복을 수행하는 도중에 실패하여 회복을 다시 시작할 때에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이미&lt;/code&gt; 완료된 UNDO 연산은 반복하지 않는다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;주요 3단계
        &lt;ul&gt;
          &lt;li&gt;분석(Analysis)단계: 붕괴가 발생한 시점에 버퍼에 있는 수정된 페이지와 진행 트랜잭션을 파악, REDO가 시작되어야 하는 로그의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;위치&lt;/code&gt;를 결정&lt;/li&gt;
          &lt;li&gt;REDO 단계: 분석 단계에서 결정한 REDO 시작 위치의 로그로부터 로그가 끝날 때 까지 REDO를 수행, REDO 된 로그 레코드의 리스트를 관리하여 불필요한 REDO 연산이 수행되지 않도록 한다.&lt;/li&gt;
          &lt;li&gt;UNDO 단계: 로그를 역순으로 읽으면서 미완료된 트랜잭션의 연산을 UNDO 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;구성 요소
        &lt;ul&gt;
          &lt;li&gt;WAL(Write Ahead Logging)&lt;br /&gt;
DB 변경 사항에 대한 전체 로깅&lt;/li&gt;
          &lt;li&gt;LSN(Log Sequence Number)&lt;br /&gt;
모든 로그에 대한 고유 순서 번호&lt;/li&gt;
          &lt;li&gt;Repeating History&lt;br /&gt;
장애 시 이전의 데이터베이스 수행 기록을 모두 추적하여 REDO&lt;/li&gt;
          &lt;li&gt;Logging Changes&lt;br /&gt;
UNDO 완료된 트랙잭션을 기록하여 UNDO 반복 수행 회피&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="DB" /><category term="(구)정보처리기사" /><category term="컴퓨터일반" /><summary type="html">트랜잭션 데이터베이스의 상태를 하나의 상태에서 또 다른 일관된 상태로 변화시켜주는 일련의 논리적인 연산 집합 한번에 모두 소행되어야하는 연산들의 집합, 하나의 작업을 처리하기위한 작업 단위 하나의 트랜잭션은 완료(Commit)되거나 복귀(Rollback)되어야 한다</summary></entry><entry><title type="html">[정보보안기사/정보보안일반] 접근 통제 기술</title><link href="https://many258.github.io/study/access-control/" rel="alternate" type="text/html" title="[정보보안기사/정보보안일반] 접근 통제 기술" /><published>2021-03-08T00:00:00+09:00</published><updated>2021-03-08T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Baccess-control%7D</id><content type="html" xml:base="https://many258.github.io/study/access-control/">&lt;h1 id=&quot;접근통제&quot;&gt;접근통제&lt;/h1&gt;
&lt;h2 id=&quot;접근의-개요&quot;&gt;접근의 개요&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;주체&lt;br /&gt;
자원의 접근을 요구하는 활동 개체. (사람, 프로그램…)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;객체&lt;br /&gt;
자원을 가진 수동적인 개체(DB, 컴퓨터, 파일…)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;접근&lt;br /&gt;
주체와 객체의 정보 흐름&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정보-접근의-단계&quot;&gt;정보 접근의 단계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;식별(Identification)&lt;br /&gt;
사용자 ID를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;확인&lt;/code&gt;하는 과정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인증(Authentication)&lt;br /&gt;
패스워드가 정확한지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;판별&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인가(Authorization)&lt;br /&gt;
인증된 사용자에게 파일을 Read/Write/Execute &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;권한&lt;/code&gt;을 부여&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;접근-통제의-정의&quot;&gt;접근 통제의 정의&lt;/h2&gt;
&lt;p&gt;주체의 대한 객체의 접근을 통제.&lt;br /&gt;
사용자가 파일인 객체에 대해 읽기/쓰기/실행의 권한이 있는지 확인하고 권한이 있으면 권한을 부여하고 권한이 없으면 접근을 차단하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;접근-통제-원칙&quot;&gt;접근 통제 원칙&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;최소 권한의 원칙&lt;br /&gt;
최소한의 권한만을 허용하여 권한의 남용을 방지&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;직무분리&lt;br /&gt;
업무의 발생/승인/변경/확인/배포 등이 한 사람에 의해 처리되지 않도록 직무를 분리&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;참조-모니터&quot;&gt;참조 모니터&lt;/h2&gt;
&lt;p&gt;주체의 객체에 대한 접근 통제를 결정을 중재하는 OS의 보안 커널로서, 일련의 SW&lt;/p&gt;

&lt;p&gt;주체가 객체를 참조할 때 직접참조를 수행하지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보안 커널&lt;/code&gt;을 통해서 참조.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;보안 커널  &lt;br /&gt;
주체에 대해서 정당한 권한을 확인하고 접근한 객체에 대한 정보를 모두 로그에 기록&lt;br /&gt;
결함으로 발생할 수 있는 취약점 차단&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;참조-모니터의-3가지-요소&quot;&gt;참조 모니터의 3가지 요소&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;완전성(Completeness)&lt;br /&gt;
우회가 가능하지 않아야 함.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;격리(Isolation)&lt;br /&gt;
부정 조작이 불가능해야 함. (Tamper Proof)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;검증성(Verifiability)&lt;br /&gt;
분석하고 테스트할 정도로 충분히 작아야 함&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;접근-통제-기술&quot;&gt;접근 통제 기술&lt;/h2&gt;
&lt;h3 id=&quot;macmandatory-access-control&quot;&gt;MAC(Mandatory Access Control)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;강제적&lt;/code&gt; 접근 통제&lt;br /&gt;
주체의 객체에 대한 접근이 주체의 비밀 취급 인가 레이블(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Clearance Label&lt;/code&gt;) 및 객체의 민감도 레이블(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sensitivity Lable&lt;/code&gt;)에 따라 지정되는 방식&lt;/p&gt;

&lt;h4 id=&quot;mac-특징&quot;&gt;MAC 특징&lt;/h4&gt;
&lt;p&gt;데이터에 대한 접근을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템&lt;/code&gt;이 결정(정해진 룰에 의해)한다.&lt;br /&gt;
데이터 소유자가 아닌 오직 관리자만이 자원의 카테고리를 변경 가능&lt;br /&gt;
비밀성을 포함하고 있는 개체에 대해 주체가 가지고 있는 권한에 근거하여 객체의 접근을 제한하는 정책&lt;/p&gt;

&lt;p&gt;구현/운영의 어려움. 높은 비용&lt;/p&gt;

&lt;h4 id=&quot;mac-종류&quot;&gt;MAC 종류&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Rule-Based MAC&lt;br /&gt;
주체와 객체의 특성에 관계된 특정 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;규칙&lt;/code&gt;에 따른 접근 통제 방화벽&lt;/li&gt;
  &lt;li&gt;Administratively-directed MAC&lt;br /&gt;
객체에 접근할 수 있는 시스템 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관리자&lt;/code&gt;에 의한 통제&lt;/li&gt;
  &lt;li&gt;CBP(Compartment-Based-Policy)&lt;br /&gt;
일련의 객체 집합을 다른 객체들과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분리&lt;/code&gt;.&lt;br /&gt;
동일 수준의 접근허가를 갖는 부서라도 다른 보안등급을 가질 수 있다.&lt;/li&gt;
  &lt;li&gt;MLP(Multi-Level Policy)&lt;br /&gt;
각 객체별로 지정된 허용 등급을 할당하여 운영(Top Secret, Secret, Confidentiality…)&lt;br /&gt;
미국 국방성 컴퓨터 보안 평가지표에 사용. BLP 수학적 모델로 표현 가능&lt;br /&gt;
*BLP : 높은 등급의 사용자는 낮은 등급의 정보에 접근이 불가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dacdiscretionary-access-control&quot;&gt;DAC(Discretionary Access Control)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자율적&lt;/code&gt; 접근 통제&lt;br /&gt;
객체의 소유자가 권한 부여&lt;/p&gt;

&lt;h4 id=&quot;dac-특징&quot;&gt;DAC 특징&lt;/h4&gt;
&lt;p&gt;사용자의 신분에 따라 임의로 접근을 제어하는 방식(User-Based, Identity)&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;융통성&lt;/code&gt;이 좋아 UNIX, DBMS 등 상용 OS에서 구현 가능&lt;br /&gt;
접근 통제 목록(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACL&lt;/code&gt; : Access Control List) 사용&lt;br /&gt;
  – 특정 객체에 접근할 수 있는 사용자 목록과 접근 권한을 명시 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;객체 관점&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;트로이목마 공격에 취약, ID 도용 문제&lt;/p&gt;

&lt;h4 id=&quot;dac-종류&quot;&gt;DAC 종류&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Identity-Based DAC&lt;br /&gt;
주체와 객체의 ID에 따른 접근 통제. 주로 UNIX에서 사용&lt;/li&gt;
  &lt;li&gt;User-Based DAC&lt;br /&gt;
객체 소유자가 접근 권한을 설정 및 변경할 수 있는 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;non-dacnon-discretionary-access-control&quot;&gt;Non-DAC(Non-Discretionary Access Control)&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비임의적&lt;/code&gt; 접근 통제&lt;br /&gt;
주체의 직무와 역할에 따라 접근할 수 있는 객체를 지정하는 방식&lt;/p&gt;

&lt;h4 id=&quot;non-dac-특징&quot;&gt;Non-DAC 특징&lt;/h4&gt;
&lt;p&gt;MAC과 DAC의 단점을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보완&lt;/code&gt;하기 위한 대안&lt;br /&gt;
기업 내 개인의 작은 이동 및 조직 특성에 밀접하게 적용하기 위한 통제 방식&lt;br /&gt;
Role-Based, Task-Based 이라고도 함.&lt;br /&gt;
Central Authority(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중앙 인증&lt;/code&gt;) : 중앙 관리자에 의해 접근 규칙을 지정한다.&lt;br /&gt;
사용자별 접근 통제 규칙을 설정할 필요가 없다.&lt;/p&gt;

&lt;h4 id=&quot;non-dac-종류&quot;&gt;Non-DAC 종류&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Role-Based Accesss Control(RBAC)&lt;br /&gt;
사용자가 적절한 역할에 할당되고 역할에 적합한 권한이 할당된 경우만 사용자가 특정한 모드로 정보에 대한 접근을 통제할 수 있는 방법&lt;/li&gt;
  &lt;li&gt;Latice-Based Non-DAC&lt;br /&gt;
역할에 할당된 민감도 레벨에 의해 결정. 관련된 정보로만 접근 가능&lt;br /&gt;
주체와 객체의 관계에 의거하여 접근을 통제할 수 있는 Upper Bound와 Lower Bound를 설정하여 제어.&lt;/li&gt;
  &lt;li&gt;Task-Based Non-DAC&lt;br /&gt;
조직 내 개인의 임무에 의한 접근 통제&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;rbacrole-base-access-control&quot;&gt;RBAC(Role Base Access Control)&lt;/h3&gt;
&lt;p&gt;권한들의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;묶음&lt;/code&gt;으로 Role을 만들어서 사용자에게 Role 단위로 권한을 할당하고 관리&lt;/p&gt;

&lt;h4 id=&quot;rbac의-특징&quot;&gt;RBAC의 특징&lt;/h4&gt;
&lt;p&gt;관리 수월 - 관리자에게 편리한 관리 능력을 제공, 비용 감소&lt;br /&gt;
보안관리 단순화 - 권한 지정을 논리적/독립적으로 할당하거나 회수 가능&lt;br /&gt;
최소 권한 - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;최소한&lt;/code&gt;의 권한만을 허용하여 권한의 남용을 방지&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;직무분리&lt;/code&gt; - 시스템상에서 오용을 일으킬 정도의 충분한 특권이 사용된 사용자 방지&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 추상화&lt;/code&gt; - 역할에 대한 계층을 두어 상속 가능&lt;/p&gt;

&lt;h1 id=&quot;접근-통제-방법&quot;&gt;접근 통제 방법&lt;/h1&gt;
&lt;h2 id=&quot;capability-list&quot;&gt;Capability List&lt;/h2&gt;
&lt;p&gt;주체별로 객체를 링크드리스트로 연결하고 권한을 할당한 구조&lt;/p&gt;

&lt;p&gt;주체별로 모든 파일리스트가 존재하므로 권한을 알기 위한 탐색시간이 오래 걸리는 단점 존재.&lt;/p&gt;

&lt;h2 id=&quot;access-control-list&quot;&gt;Access Control List&lt;/h2&gt;
&lt;p&gt;주체와 객체간의 접근 권한을 테이블로 구성한 것&lt;br /&gt;
행에는 주체, 열에는 객체를 두고 행과 열의 교차점에는 주체가 객체에 대한 접근 권한(W/R/D/E)을 기술하여 이름 기반으로 제어하는 방식&lt;/p&gt;

&lt;h1 id=&quot;접근-통제-매트릭스-종류&quot;&gt;접근 통제 매트릭스 종류&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;객체 기반 접근 제어(ACL:Access Control List)&lt;br /&gt;
객체 관점에서 접근 권한을 테이블 형태로 기술하여 접근 제어&lt;br /&gt;
구분될 필요가 있는 사용자가 비교적 소수와 분포도가 안정적일 때 적합&lt;br /&gt;
지속적 변경 환경에서는 부적합&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;내용 의존 접근 통제(Content Dependent Acceess Control)&lt;br /&gt;
데이터베이스에서 가장 많이 사용.&lt;br /&gt;
접근 제어가 내용에 의해 이루어지는 접근 통제&lt;br /&gt;
(데이터베이스에 사용자 정보를 등록하고 입력된 정보와 비교하여 접근 통제를 수행)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;제한적 인터페이스(Restricted Interfaces)&lt;br /&gt;
특정 기능이나 자원에 대한 접근 권한이 없을 경우 아예 접근을 요청하지 못하도록 하는 방식&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;접근-통제-모델&quot;&gt;접근 통제 모델&lt;/h1&gt;
&lt;h2 id=&quot;bell-lapadula&quot;&gt;Bell-Lapadula&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기밀성&lt;/code&gt; 모델로서 높은 등급의 정보가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;낮은&lt;/code&gt; 레벨로 유출되는 것을 통제하는 모델&lt;br /&gt;
  정보 구분 : Top Secret / Secret / Unclassified&lt;br /&gt;
  최초의 수학적 모델. 보안 등급과 범주를 이용한 강제적 정책에 의한 접근 통제 모델&lt;br /&gt;
  미 국방성(DOD)의 지원을 받아 설계된 모델로서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오렌지북&lt;/code&gt;인 TCSEC의 근간이 됨.&lt;br /&gt;
  시스템의 비밀성을 보호하기 위한 보안 정책&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;No-Read-Up(NRU or ss-Property) : 단순 보안 규칙&lt;br /&gt;
주체는 자신보다 높은 등급의 객체를 읽을 수 없다.&lt;br /&gt;
주체의 취급인가가 객체의 비밀 등급보다 같거나 높아야 그 객체를 읽기 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;No-Write-Down(NWD or *-Property) : 스타-보안 규칙&lt;br /&gt;
주체는 자신보다 낮은 등급의 객체에 정보를 쓸 수 없다.&lt;br /&gt;
주체의 취급인가가 객체의 비밀 등급보다 같거나 낮을 때 그 객체를 주체가 기록 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Strong *-Property&lt;br /&gt;
더욱 강화된 모델. 주체는 자신과 등급이 다른 객체에 대해 읽기나 쓰기 불가&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;biba-모델&quot;&gt;Biba 모델&lt;/h2&gt;
&lt;p&gt;Bell-Lapadula 모델의 단점인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무결성&lt;/code&gt;을 보장할 수 있는 모델&lt;br /&gt;
주체의 의한 객체 접근의 항목으로 무결성을 다룬다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;No Read-Down(NRD or Simple Intergrity Axiom)&lt;/li&gt;
  &lt;li&gt;No Write-Up(NWU or *Intergrity Axiom)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;클락-윌슨-모델-clark-and-wilson&quot;&gt;클락 윌슨 모델 (Clark and Wilson)&lt;/h2&gt;
&lt;p&gt;무결성 중심의 상업용으로 설계. App의 보안 요구사항을 다룬다.&lt;br /&gt;
정보의 특성에 따라 비밀 노출 방지보다 자료의 변조 방지가 더 중요한 경우가 있음을 기초로 한다.&lt;br /&gt;
주체와 객체 사이에 프로그램이 존재, 객체는 항상 프로그램을 통해서만 접근이 가능&lt;br /&gt;
2가지 무결성을 정의 : 내부 일관성(시스템 이용), 외부 일관성(감사에 활용)&lt;/p&gt;

&lt;h2 id=&quot;만리장성-모델chinese-wall--brewer-nash&quot;&gt;만리장성 모델(Chinese Wall = Brewer-Nash)&lt;/h2&gt;
&lt;p&gt;서로 상충 관계에 있는 객체 간의 정보 접근을 통제하는 모델(이익 상충 금지)&lt;br /&gt;
상업적으로 기밀성 정책에 따른다.&lt;/p&gt;

&lt;h1 id=&quot;보안-운영체제&quot;&gt;보안 운영체제&lt;/h1&gt;
&lt;p&gt;보안 취약성으로부터 시스템 자체를 보호하기 위해 기존 운영체제의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널 등급&lt;/code&gt;에 추가적인 보안 기능을 강화시킨 OS&lt;/p&gt;

&lt;h2 id=&quot;secure-dbms-구조&quot;&gt;Secure DBMS 구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;신뢰 필터 구조&lt;br /&gt;
신뢰할 수 없는 전위 사용자 인터페이스와 후위 DB 사이에 신뢰 필터를 사용하여 데이터에 대한 접근 통제 및 보안 서비스 제공&lt;br /&gt;
신뢰 필터는 하부의 보안 운영체제가 제공하는 보안 서비스 및 메커니즘에 의존&lt;/p&gt;

    &lt;p&gt;장점 : 다른 구조에 비해 간단. 크기가 작음 ==&amp;gt; 보안 기능의 검증 및 평가가 용이&lt;br /&gt;
단점 : 데이터의 보안을 침해하는 일부의 위협에 대해서는 취약성을 가짐&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;커널 구조&lt;br /&gt;
TCB 분할 개념에 의해서 구현. 따라서 DB시스템은 보안 커널 외부에 존재하면서 임의적 보안만을 관리&lt;br /&gt;
DB 객체에 대한 임의적 접근 통제 - DBMS에 의해 수행&lt;br /&gt;
DB 파일에 대한 임의적 접근 통제 및 모든 강제적 접근 통제 - 하부의 보안 운영체제에 의하여 제공&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이중 커널 구조&lt;br /&gt;
강제적 보안 기능을 갖는 DB 시스템을 구현하고,&lt;br /&gt;
이를 보안 운영체제와 함께 시스템의 TCB(Trust Computing Base)로 간주하여 보안시스템을 평가&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;중복 구조&lt;br /&gt;
낮은 보호 수준의 데이터를 DB에 중복하여 저장하는 방식.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;*은닉 채널(Convert Channel)&lt;br /&gt;
기본 통신채널에 기생하는 통신채널로서, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스테가노그래피&lt;/code&gt;로 숨겨진 메시지를 송신자와 수신자만 확인 가능.&lt;br /&gt;
보안 메커니즘에 의해 통제되지 않는 정보 흐름으로 시스템의 보안 정책을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;위반&lt;/code&gt;하는 행위&lt;br /&gt;
은닉 채널의 위험은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대역폭&lt;/code&gt;에 따라 변경되기 때문에 한 번에 전달되는 정보량을 줄이기 위해 대역폭 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제한&lt;/code&gt; 필요&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;키-분배-프로토콜&quot;&gt;키 분배 프로토콜&lt;/h1&gt;
&lt;h2 id=&quot;대칭키-암호화symmetric-key&quot;&gt;대칭키 암호화(Symmetric Key)&lt;/h2&gt;
&lt;p&gt;Session Key, Shared Key, Secret Key, Conventional Key(관용키)라고도 한다.&lt;br /&gt;
암호화할 때 사용하는 암호화 키와 복호화할 때 사용하는 복호화 키가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동일&lt;/code&gt;한 암호화 기법(양방향 암호화 기법)&lt;br /&gt;
작은 비트의 암호호 키를 사용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;빠르게&lt;/code&gt; 암호화/복호화가 가능하다. (대용량 Data 암호화에 적합)&lt;br /&gt;
기밀성을 제공하나 무결성, 인증, 부인방지는 보장할 수 없다&lt;br /&gt;
같은 키를 사용하므로 안전한 키 전달 및 공유 방법이 필요&lt;/p&gt;

&lt;h3 id=&quot;대칭키-암호화의-종류&quot;&gt;대칭키 암호화의 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;스트림 암호(Stream Cipher)&lt;br /&gt;
하나의 비트/바이트 단위로 암호화&lt;br /&gt;
평문을 XOR로 1Bit 단위로 암호화&lt;br /&gt;
실시간 암호/복호화, 블록 암호화보다 빠르다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;종류&lt;/code&gt; : RC4, SEAL, OTP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;블록 암호(Block Cipher)&lt;br /&gt;
여러 개의 Bit를 묶어 블록 단위로 치환/대칭을 반복하여 암호화&lt;br /&gt;
대용량의 평문 암호화&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;종류&lt;/code&gt; : DES, 3DES, AES, IDEA, Blowfish, SEED&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;공개키-암호화public-key&quot;&gt;공개키 암호화(Public Key)&lt;/h2&gt;
&lt;p&gt;공개키와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;개인키&lt;/code&gt;라는 두개의 암호화 키를 사용하여 암호화/복호화&lt;br /&gt;
클라이언트 - 공개키를 수신 받은 후 공개키로 암호화하여 메시지 전송&lt;br /&gt;
수신자 - 개인키로 복호화&lt;/p&gt;

&lt;p&gt;대칭키 암호화 기법의 키 공유 문제를 해결한 방법이나, 암호화 키의 길이가 길어 암호화/복호화 성능 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;비효율&lt;/code&gt;&lt;br /&gt;
공개키/개인키를 사용하여 인증, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;서명&lt;/code&gt;, 암호화를 수행&lt;/p&gt;

&lt;h3 id=&quot;공개키-암호화-방식&quot;&gt;공개키 암호화 방식&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;암호모드&lt;br /&gt;
소량의 메시지 암호화 목적, 주로 키교환의 용도로 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인증모드&lt;br /&gt;
메시지를 인증(부인방지)하는 것이 목적&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/security/public-key-process.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;공개키-암호화-종류&quot;&gt;공개키 암호화 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Diffie Hellman - 이산대수&lt;br /&gt;
최초의 공개키, 키 분배 전용 알고리즘&lt;br /&gt;
필요 시에만 생성(저장 불필요)&lt;br /&gt;
암호 모드로 사용 불가, 위조에 취약&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RSA - 소인수분해&lt;br /&gt;
대표적 공개키 알고리즘&lt;br /&gt;
컴퓨터 속도의 발전으로 키 길이 증가&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DSA - 이산대수&lt;br /&gt;
간단한 구조를 가진 전자서명 전용 알고리즘 표준&lt;br /&gt;
암호화, 키 교환 불가&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ECC - 타원곡선&lt;br /&gt;
짧은 키로 높은 암호 강도. 160키 = RSA1024&lt;br /&gt;
오버헤드가 적으며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;키 테이블&lt;/code&gt;(20KB) 필요&lt;br /&gt;
PDA, 스마트폰&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="정보보안기사" /><summary type="html">접근통제 접근의 개요 주체 자원의 접근을 요구하는 활동 개체. (사람, 프로그램…)</summary></entry><entry><title type="html">[엑셀/Excel] 자주 출제 및 사용하는 함수</title><link href="https://many258.github.io/study/excel-function/" rel="alternate" type="text/html" title="[엑셀/Excel] 자주 출제 및 사용하는 함수" /><published>2021-03-07T00:00:00+09:00</published><updated>2021-03-07T19:37:34+09:00</updated><id>https://many258.github.io/study/%7Bexcel-function%7D</id><content type="html" xml:base="https://many258.github.io/study/excel-function/">&lt;h1 id=&quot;수학-관련-함수&quot;&gt;수학 관련 함수&lt;/h1&gt;
&lt;h2 id=&quot;통계&quot;&gt;통계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SUM&lt;/strong&gt;(숫자1, [숫자2], [숫자3],…)&lt;br /&gt;
지정된 셀 범위의 합계를 구하는 함수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SUMIF&lt;/strong&gt;(조건범위, 조건, [찾을범위])&lt;br /&gt;
조건을 만족하는 데이터의 합계&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SUMIFS&lt;/strong&gt;(합을 구할 범위, 참조할 범위1, 조건1, [참조할 범위2], [조건2], …)&lt;br /&gt;
범위 안 여러개의 조건을 만족하는 값의 합계&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DSUM&lt;/strong&gt;(전체범위, 찾을 열 필드, 조건범위)&lt;br /&gt;
조건을 만족하는 값의 합계를 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;AVERAGE&lt;/strong&gt;(숫자1, 숫자2, 숫자3,…)&lt;br /&gt;
지정된 셀 범위의 평균을 구하는 함수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DAVERAGE&lt;/strong&gt;(전체 범위, 찾을 열번호, 기준)&lt;br /&gt;
전체 데이터베이스 내에서 기준에 맞는 자료의 평균&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MAX&lt;/strong&gt;(숫자1, 숫자2, 숫자3,…)&lt;br /&gt;
지정된 셀 범위 내 최대값 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MIN&lt;/strong&gt;(숫자1, 숫자2, 숫자3,…)&lt;br /&gt;
지정된 셀 범위 내 최솟값 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LARGE&lt;/strong&gt;(인수 또는 셀범위, 숫자인수)&lt;br /&gt;
범위 내 [지정한 숫자인수 값] 번째로 큰 수 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SMALL&lt;/strong&gt;(인수 또는 셀범위, 숫자인수)&lt;br /&gt;
범위 내 [지정한 숫자인수 값] 번째로 작은 수 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MODE&lt;/strong&gt;(범위1, [범위2],…)&lt;br /&gt;
인수들 중 가장 많이 발생한 값인 최빈값 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RANK&lt;/strong&gt;(값, 범위, [논리값])&lt;br /&gt;
범위 내에서 지정한 수의 순위를 구한다.&lt;br /&gt;
논리값이 0이거나 생략되면 내림차순으로, 0이외의 값은 오름차순으로 표시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;COUNT&lt;/strong&gt;(숫자1, 숫자2, 숫자3,…)&lt;br /&gt;
인수로 입력된 숫자의 개수 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;COUNTA&lt;/strong&gt;(범위1, 범위2,…)&lt;br /&gt;
셀 범위 중 비어있지 않은 셀의 개수 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;COUNTBLANK&lt;/strong&gt;(범위)&lt;br /&gt;
비어있는 셀의 개수 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;COUNTIF&lt;/strong&gt;(범위, 조건)&lt;br /&gt;
범위 내 조건을 만족하는 셀의 개수 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;COUNTIFS&lt;/strong&gt;(범위1, 조건1, 범위2, 조건2, …)&lt;br /&gt;
범위 내 여러 조건을 만족하는 셀의 개수 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DCOUNT&lt;/strong&gt;(전체 범위, 찾을 열번호, 기준)&lt;br /&gt;
전체 데이터베이스 내에서 기준에 맞는 숫자 포함 셀들의 개수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DCOUNTA&lt;/strong&gt;(전체 범위, 찾을 열번호, 기준)&lt;br /&gt;
전체 데이터베이스 내에서 비어있는 셀은 무시하고 기준에 맞는 셀들의 개수&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;어림값&quot;&gt;어림값&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EVEN&lt;/strong&gt;(숫자)&lt;br /&gt;
가까운 짝수값으로 올림&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ODD&lt;/strong&gt;(숫자)&lt;br /&gt;
가까운 홀수값으로 올림&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ROUND&lt;/strong&gt;(인수, 소수점 이하 자릿수)&lt;br /&gt;
표시된 소수점 이하 자릿수에서 반올림&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ROUNDDOWN&lt;/strong&gt;(인수, 내림할 자릿수)&lt;br /&gt;
지정된 자릿수 아래의 수를 내림&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ROUNDUP&lt;/strong&gt;(인수, 올림할 자릿수)&lt;br /&gt;
지정된 자릿수 아래의 수를 올림&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TRUNC&lt;/strong&gt;(버림할 인수, 자릿수)&lt;br /&gt;
지정된 자릿수에서 버림하여 출력&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;표시-형식&quot;&gt;표시 형식&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;INT&lt;/strong&gt;(실수)&lt;br /&gt;
실수에서 소수점 이하 절삭 후 정수로 내림&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ABS&lt;/strong&gt;(숫자)&lt;br /&gt;
숫자의 절대값을 변환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SQRT&lt;/strong&gt;(양수)&lt;br /&gt;
양수의 제곱근을 구함&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CEILING&lt;/strong&gt;(숫자, 기준배수)&lt;br /&gt;
특정 배수를 기준으로 올림된 수를 반환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FLOOR&lt;/strong&gt;(숫자, 기준배수)&lt;br /&gt;
숫자의 배수 중 기준이 되는 배수와 가장 가까운 내림된 값을 반환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MROUND&lt;/strong&gt;(숫자, 기준배수)&lt;br /&gt;
특정값에 가장 가까운 배수를 계산&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EXP&lt;/strong&gt;(숫자)&lt;br /&gt;
인수를 자연로그의 밑 e의 지수로 올린다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FACT&lt;/strong&gt;(숫자)&lt;br /&gt;
인수의 팩토리얼을 표시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PI&lt;/strong&gt;()&lt;br /&gt;
원주율 값&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MOD&lt;/strong&gt;(나누어질 인수, 나눌 인수)&lt;br /&gt;
나머지 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PRODUCT&lt;/strong&gt;(인수 또는 셀 범위)&lt;br /&gt;
모든 셀을 곱한 값 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SUMPRODUCT&lt;/strong&gt;(배열1, 배열2,…)&lt;br /&gt;
배열을 n차원 벡터로 취급하고 내적&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;POWER&lt;/strong&gt;(인수, 승수)&lt;br /&gt;
인수의 지정한 승수만큼의 값 출력&lt;br /&gt;
예를 들어 = POWER(2, 3)면, 2&lt;sup&gt;3&lt;/sup&gt;&lt;br /&gt;
** 1번 인수가 음수라면, 2번 인수가 정수가 아닐 경우 계산 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;불가&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SUBTOTAL&lt;/strong&gt;(함수, 참조1, [참조2], …)&lt;br /&gt;
필터링으로 가려진 데이터들을 제외하고 계산 작업을 할 수 있게 돕는 함수&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;날짜시간-관련-함수&quot;&gt;날짜/시간 관련 함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DATE&lt;/strong&gt;(년, 월, 일)&lt;br /&gt;
특정 날짜 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TODAY&lt;/strong&gt;()&lt;br /&gt;
현재 컴퓨터 시스템의 날짜 표시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;NOW&lt;/strong&gt;()&lt;br /&gt;
현재 컴퓨터의 날짜와 시간을 표시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;YEAR&lt;/strong&gt;(날짜) / &lt;strong&gt;MONTH&lt;/strong&gt;(날짜) / &lt;strong&gt;DAY&lt;/strong&gt;(날짜)&lt;br /&gt;
연도/월/일 값 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;WEEKDAY&lt;/strong&gt;(날짜, 유형)&lt;br /&gt;
해당하는 요일 번호 표시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TIME&lt;/strong&gt;(시, 분, 초)&lt;br /&gt;
특정 시간 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;HOUR&lt;/strong&gt;(시간) / &lt;strong&gt;MINUTE&lt;/strong&gt;(시간) / &lt;strong&gt;SECOND&lt;/strong&gt;(시간)&lt;br /&gt;
시/분/초 값 출력&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;논리-관련-함수&quot;&gt;논리 관련 함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IF&lt;/strong&gt;(조건, 참값, 거짓값)&lt;br /&gt;
조건을 만족 시 참값, 불만족 시 거짓값으로 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IFERROR&lt;/strong&gt;(검사수식, 반환값)&lt;br /&gt;
수식에서 오류가 발생할 경우 사용자가 지정한 값을 반환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;AND&lt;/strong&gt;(조건1, 조건2,…)&lt;br /&gt;
모든 논리가 전부 참일 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TRUE&lt;/code&gt; 를 출력하고, 하나라도 거짓이 있을 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FALSE&lt;/code&gt; 를 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OR&lt;/strong&gt;(조건1, 조건2,…)&lt;br /&gt;
하나라도 참이 있을 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TRUE&lt;/code&gt; 를 출력하고, 전부 거짓일 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FALSE&lt;/code&gt; 를 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;NOT&lt;/strong&gt;(조건)&lt;br /&gt;
논리식의 결과 값을 반대로 출력&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문자열-관련-함수&quot;&gt;문자열 관련 함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LEFT&lt;/strong&gt;(문자열, 정수)&lt;br /&gt;
주어진 문자열 중 왼쪽으로부터 정수번째 있는 값 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RIGHT&lt;/strong&gt;(문자열, 정수)&lt;br /&gt;
주어진 문자열 중 마지막부터 정수번째 있는 값 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MID&lt;/strong&gt;(문자열 또는 문자열 참조 셀, n번째 글자, x개까지)&lt;br /&gt;
문자열의 가운데 부분을 추출해 표시한다. n번째 글자부터 x개만큼을 추출&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LOWER&lt;/strong&gt;(문자열)&lt;br /&gt;
입력된 문자열을 모두 소문자로 표시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;UPPER&lt;/strong&gt;(문자열)&lt;br /&gt;
입력된 문자열을 모두 대문자로 표시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PROPER&lt;/strong&gt;(문자열)&lt;br /&gt;
문자열에서 첫단어만 대문자로 표시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TRIM&lt;/strong&gt;(셀 또는 문자열)&lt;br /&gt;
해당 셀/문자열의 텍스트 양 끝에 있는 공백을 제외한 텍스트를 추출&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LEN&lt;/strong&gt;(문자열)&lt;br /&gt;
문자열의 길이 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FIND&lt;/strong&gt;(찾으려는 문자, 문자열, 시작위치)&lt;br /&gt;
특정문자가 시작하는 위치를 숫자로 반환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SEARCH&lt;/strong&gt;(찾을 문자, 검색할 문자열, [시작지점])&lt;br /&gt;
문자열에서 특정 문자의 시작위치 검색&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;REPLACE&lt;/strong&gt;(문자열, 시작위치, 문자열 수, 대체할 문자열)&lt;br /&gt;
문자열의 시작위치에서부터 지정하는 수 만큼 문자열을 다른 문자열로 대체&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SUBSTITUTE&lt;/strong&gt;(문자열, 찾을문자, 새로운문자, [바꿀지점])&lt;br /&gt;
문자열에서 특정 문자를 찾아 다른 문자로 대체
한 셀 내에 대상 텍스트가 여러 개가 있는 상황에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;바꿀지점&lt;/code&gt;을 활용할 수 있는데,&lt;/p&gt;

    &lt;p&gt;모두 바꾸려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;생략&lt;/code&gt;하고, 숫자를 입력하면 그만큼 왼쪽에서부터 대상 텍스트를 세어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;선택&lt;/code&gt;적으로 적용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CONCATENATE&lt;/strong&gt;(문자열1, 문자열2, …)&lt;br /&gt;
여러 문자열을 하나로 조인&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;REPT&lt;/strong&gt;(문자열, 반복 횟수)&lt;br /&gt;
문자열을 지정한 횟수만큼 반복&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;VALUE&lt;/strong&gt;(문자열)&lt;br /&gt;
문자열을 숫자로 변환&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;검색-기능-함수&quot;&gt;검색 기능 함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;COLUMN&lt;/strong&gt;(셀)&lt;br /&gt;
해당 셀의 가로열의 번호를 표시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ROW&lt;/strong&gt;(셀)&lt;br /&gt;
해당 셀의 세로행의 번호를 표시하는 함수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CHOOSE&lt;/strong&gt;(색인번호(1 이상 254이하의 정수형), 값1, [값2], …)&lt;br /&gt;
순번으로 구성된 색인을 참조하여 목록에서 해당 순번의 값을 반환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;INDEX&lt;/strong&gt;(배열, 행위치, 열위치)&lt;br /&gt;
배열 내의 몇 행 몇 열에 해당하는 대상을 찾아서 출력&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OFFSET&lt;/strong&gt;(시작지점, 행이동, 열이동, [높이], [넓이])&lt;br /&gt;
시작지점으로부터 지정한만큼 이동한 곳의 셀 참조 또는 값을 반환&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;VLOOKUP&lt;/strong&gt;(찾을 값, 참조범위, 열번호, [옵션])&lt;br /&gt;
가로(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수직&lt;/code&gt;)로 된 범위에서 값을 참조하여 다른 항목의 값을 반환
    &lt;ul&gt;
      &lt;li&gt;옵션&lt;br /&gt;
1 : 유사값이나 생략&lt;br /&gt;
0 : 정확한 값&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HLOOKUP&lt;/strong&gt;(찾을 값, 참조범위, 행번호, [옵션])&lt;br /&gt;
가로(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수평&lt;/code&gt;)로 된 범위에서 값을 참조하여 다른 항목의 값을 반환
    &lt;ul&gt;
      &lt;li&gt;옵션&lt;br /&gt;
1 : 유사값이나 생략&lt;br /&gt;
0 : 정확한 값&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;XLOOKUP&lt;/strong&gt;(찾을 값, 참조 범위, 출력 범위, [옵션], [검색옵션])&lt;br /&gt;
범위에서 일치하는 항목을 찾아 반환
    &lt;ul&gt;
      &lt;li&gt;옵션&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; : 정확히 일치하는 값만 반환하며 일치하는 값이 없을 경우 #N/A 반환&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt; : 일치하는 값이 없을 때 그보다 적으면서 가장 가까운 값 반환&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; : 일치하는 값이 없을 때 그보다 많으면서 가장 가까운 값 반환&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; : 와일드카드 옵션&lt;/li&gt;
      &lt;li&gt;검색옵션&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; : 오름차순&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt; : 내림차순&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; : 데이터가 정렬되었다고 가정한 오름차순&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-2&lt;/code&gt; : 데이터가 정렬되었다고 가정한 내림차순&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MATCH&lt;/strong&gt;(찾을값, 범위, [옵션])&lt;br /&gt;
배열 내에서 찾고자 하는 값이 몇 번째에 위치하는지 찾아서 숫자로 출력
    &lt;ul&gt;
      &lt;li&gt;옵션&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; : 정렬되지 않은 배열에서 정확히 일치하는 값을 검색. 여러 개가 검색되었을 경우 첫째 것을 출력&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; : 오름차순으로 정렬된 배열에서 작거나 같은 값 중 가장 큰 값&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt; : 내림차순으로 정렬된 배열에서 크거나 같은 값 중 가장 작은 값&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;XMATCH&lt;/strong&gt;(찾을 값, 찾을 범위, [옵션], [검색옵션])&lt;br /&gt;
배열 또는 범위에서 특정 값의 상대 위치(순번)을 반환
    &lt;ul&gt;
      &lt;li&gt;옵션&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; : 정확히 일치하는 값만 반환하며 일치하는 값이 없을 경우 #N/A 반환&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt; : 일치하는 값이 없을 때 그보다 적으면서 가장 가까운 값 반환&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; : 일치하는 값이 없을 때 그보다 많으면서 가장 가까운 값 반환&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; : 와일드카드 옵션&lt;/li&gt;
      &lt;li&gt;검색옵션&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; : 오름차순&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-1&lt;/code&gt; : 내림차순&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; : 데이터가 정렬되었다고 가정한 오름차순&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-2&lt;/code&gt; : 데이터가 정렬되었다고 가정한 내림차순&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="Excel" /><summary type="html">수학 관련 함수 통계 SUM(숫자1, [숫자2], [숫자3],…) 지정된 셀 범위의 합계를 구하는 함수</summary></entry><entry><title type="html">[정보보안기사/정보보안일반] 보안 기술 요소</title><link href="https://many258.github.io/study/security-access-control/" rel="alternate" type="text/html" title="[정보보안기사/정보보안일반] 보안 기술 요소" /><published>2021-03-05T00:00:00+09:00</published><updated>2021-03-04T19:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsecurity-access-control%7D</id><content type="html" xml:base="https://many258.github.io/study/security-access-control/">&lt;h1 id=&quot;정보보호&quot;&gt;정보보호&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;정보의 수집/가공/저장/검색/송신/수신 중에 정보를 훼손/변조/유출 등을 방지하기 위한 관리적/기술적 수단&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;정보보호-목표&quot;&gt;정보보호 목표&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기밀성(Confidentiality)&lt;br /&gt;
허가되지 않은 사용자가 기업 혹은 개인의 중요자료에 접근하거나 또는 중요자료가 유출되었을 때 그 내용을 알 수 없도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;암호화&lt;/code&gt;하는 것을 의미&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;접근 통제&lt;/code&gt; 측면에서 중요자료에 대해서 보안등급을 부여해 접근 및 열람이 가능한 주체를 정의하여 통제&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;무결성(Integrity)&lt;br /&gt;
중요자료에 대해서 임의적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;변경&lt;/code&gt;하지 못하도록 하는 것을 의미. 대표적인 방법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;해시함수&lt;/code&gt;이며 종류로는 MD2, MD4, MD5, SHA가 존재.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;가용성(Availability)&lt;br /&gt;
정당한 사용자가 서비스를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;요청&lt;/code&gt;할 때 서비스를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제공&lt;/code&gt;할 수 있는 특성을 의미.&lt;br /&gt;
가용성을 확보하기 위해 주로 디스크, 네트워크, 서버를 이중화하며 RAID, DRS의 방법을 사용.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RAID&lt;/code&gt; : 디스크를 이중적으로 구성하여 하나의 디스크에 장애가 발생할 경우 백업된 디스크를 사용해서 중단 없이 시스템을 이용.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DRS&lt;/code&gt; : 재해복구시스템으로 서버를 2대의 Active로 구성하여 한 대의 서버에 장애가 발생해도 2번째 서버를 이용하여 서비스 중단 상황을 방지.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정보보호-공격유형&quot;&gt;정보보호 공격유형&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;변조(Modification)&lt;br /&gt;
원래의 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;조작&lt;/code&gt;하는 행위.&lt;br /&gt;
소스 프로그램을 변경하여 악성코드를 실행하거나 특정 URL로 접속하게 유도&lt;br /&gt;
ex) Redirection&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;가로채기(Interception)&lt;br /&gt;
네트워크상에서 전송되는 데이터에 대하여 복사, 열람 등을 하는 공격유형&lt;br /&gt;
가로채기는 정보를 열람하는 것이고 이러한 공격을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;수동적 공격&lt;/code&gt;(Passive Attack)이라고 지칭.&lt;br /&gt;
ex) 스니핑(Sniffing)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;차단(Interruption)&lt;br /&gt;
정상적인 서비스를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;방해&lt;/code&gt;하는 행위.&lt;br /&gt;
ex) DoS 및 프로세스 고갈 공격&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위조(Fabrication)&lt;br /&gt;
송신되는 메시지를 변조하여 상대방을 속이는 행위.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정보보호-대책&quot;&gt;정보보호 대책&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;일반 통제&lt;br /&gt;
소프트웨어 생명주기에 대한 통제&lt;br /&gt;
모든 애플리케이션에 공통으로 적용하는 IT조직, 직무분리, 시스템 개발, 논리적 및 물리적 보안, 하드웨어 통제, 백업 및 복구, 비상계획 등을 수립하는 통제&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;응용 통제&lt;br /&gt;
정보시스템에서 발생시키는 트랜잭션과 데이터 무결성을 확보하기 위한 통제&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;시점별-분류&quot;&gt;시점별 분류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;예방 통제(Preventive)&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;능동&lt;/code&gt;적인 통제로, 발생가능한 문제점을 사전에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;식별&lt;/code&gt;하여 통제를 수행하는 것.&lt;br /&gt;
물리적 접근 통제 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;승인&lt;/code&gt;되지 않은 사람이 주요 정보시스템에 출입 방지. ex) 경비원&lt;br /&gt;
논리적 접근 통제 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인증&lt;/code&gt;받지 못한 사람이 주요 정보시스템에 접근 방지. ex) 방화벽&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;탐지 통제(Detective)&lt;br /&gt;
예방 통제를 우회하여 발생되는 문제점을 식별. ex) CCTV, 경보&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;교정 통제(Corrective)&lt;br /&gt;
탐지된 위협과 취약점에 대응하는 것. ex) 백신 S/W&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;복구 통제(Recovery)&lt;br /&gt;
자원과 능력을 복구.  ex) 백업 및 복구&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;사용자-인증-방식-및-원리&quot;&gt;사용자 인증 방식 및 원리&lt;/h1&gt;
&lt;h2 id=&quot;지식기반-인증&quot;&gt;지식기반 인증&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;사용자의 기억으로만 인증하는 방식. ex) 패스워드, PIN&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;패스워드 공격기법&lt;br /&gt;
무차별 공격(Brute Force Attack)&lt;br /&gt;
사전 공격(Dictionary Attack)&lt;br /&gt;
트로이목마 프로그램&lt;br /&gt;
사회 공학적 공격 : 예로 콜 센터 등에 전화하여 패스워드를 알아내는 심리적 공격 방법&lt;br /&gt;
전자적 모니터링 : 패스워드 입력/전송 시 스니핑&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;소유기반-인증&quot;&gt;소유기반 인증&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;대표적인 예로는 열쇠가 있으며 복제와 분실의 위험이 존재.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;스마트 카드 :&lt;br /&gt;
메모리 토큰과 달리 프로세스 능력 보유&lt;br /&gt;
통일성 결여(표준의 미흡)&lt;br /&gt;
주파수를 복제의 위험성이 존재&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;존재생체기반-인증&quot;&gt;존재(생체)기반 인증&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;불변의 특성을 지닌 생체적, 행동적 특징을 자동회된 수단으로 등록&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;생체인증-분류&quot;&gt;생체인증 분류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;존재 특징 : 생체 특성, 지문, 장문, 얼굴, 손 모양, 홍채&lt;/li&gt;
  &lt;li&gt;행동 특징 : 서명, 음성, 키보드 입력&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;생체인증-특징&quot;&gt;생체인증 특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;보편성(University)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;유일성(Uniqueness)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;지속성(Permanence)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;성능(Performance)
개인 확인 및 인식의 우수성, 시스템 성능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;수용성(Acceptance)
거부감이 없어야 함.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;저항성(Resistance)
위조가능성이 없어야 함.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;생체인증-평가항목&quot;&gt;생체인증 평가항목&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;FRR(False Reject Rate)&lt;br /&gt;
잘못된 거부율, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;편의성&lt;/code&gt; 관점, 정상적인 사람을 거부함&lt;/li&gt;
  &lt;li&gt;FAR(False Acceptance Rate)&lt;br /&gt;
잘못된 승인율, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보안&lt;/code&gt; 관점, 비인가자를 정상인 사람으로 받아들임&lt;/li&gt;
  &lt;li&gt;CER(Crossover Error Rate), ERR(Equal Error Rate)&lt;br /&gt;
FRR과 FAR가 교차되는 지점. 효율성 및 생체인증의 척도&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/security/biometrics-eval-indicator.jpg&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;행동기반-인증&quot;&gt;행동기반 인증&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;개인의 고유한 행동적 특성을 사용하여 인증하는 기술&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;서명, 키스트로크, 마우스 움직임, 걸음걸이, 모바일 단말기 사용패턴 등을 분석하여 인증&lt;/p&gt;

&lt;h2 id=&quot;커버로스kerberos-인증&quot;&gt;커버로스(Kerberos) 인증&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중앙 집중&lt;/code&gt;형 사용자 인증 프로토콜 = RFC1510&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;대칭키&lt;/code&gt; 암호화 기법에 바탕을 둔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;티켓기반&lt;/code&gt; 인증 프로토콜&lt;br /&gt;
3A 지원(AAA서버). Authentication(인증), Authorization(인가), Accounting(과금)&lt;/p&gt;

&lt;h3 id=&quot;커버로스-구성요소&quot;&gt;커버로스 구성요소&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;KDC(Key Distribution Center)&lt;br /&gt;
키 분배센터. TGS + AS로 구성&lt;br /&gt;
사용자와 서비스 암호화 키를 유지하고 인증 서비스를 제공하며 세션 키를 만들고 분배&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TGS(Ticket Granting Service)&lt;br /&gt;
티켓 부여 서비스. 티켓(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인증 토큰&lt;/code&gt;)을 만들고 세션 키를 포함한 Principals에 티켓을 분배하는 KDC의 한 부분&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AS(Authentication Service)&lt;br /&gt;
인증 서비스. 실질적 인증 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Principals&lt;br /&gt;
인증을 위하여 커버로스 프로토콜을 사용하는 모든 실제를 이르는 말&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TimeStamp&lt;br /&gt;
시간 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;제한&lt;/code&gt;을 설정하여 다른 사람이 티켓을 복사하여 나중에 그 사용자인 것처럼 위장하여 티켓을 사용하는 것(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Replay Attack&lt;/code&gt;)을 방지&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/security/Kerberos_protocol.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;</content><author><name>SG Yoo.</name><email>many258@naver.com</email></author><category term="study" /><category term="정보보안기사" /><summary type="html">정보보호 정보의 수집/가공/저장/검색/송신/수신 중에 정보를 훼손/변조/유출 등을 방지하기 위한 관리적/기술적 수단</summary></entry></feed>