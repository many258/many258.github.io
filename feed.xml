<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My LifeChronicle</title>
    <description>Be a Imagineer.</description>
    <link>https://many258.github.io/</link>
    <atom:link href="https://many258.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 04 Jun 2021 00:18:07 +0900</pubDate>
    <lastBuildDate>Fri, 04 Jun 2021 00:18:07 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>[에픽게임즈/Epic Games] 시작되는 2021 에픽스토어 메가세일과 무료 배포 게임(6/4)</title>
        <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://many258.github.io/hobby/games-epic-free-week-0521/&quot; class=&quot;red&quot;&gt;에픽게임즈 메가세일 - 5월 21일자 무료 배포 게임&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://many258.github.io/hobby/games-epic-free-week-0528/&quot; class=&quot;red&quot;&gt;에픽게임즈 메가세일 - 5월 28일자 무료 배포 게임&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/hobby/games/epic-mega-sale.png&quot;&gt;&lt;img src=&quot;../../assets/images/hobby/games/epic-mega-sale.png&quot; alt=&quot;&quot; title=&quot;에픽 메가 세일&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;메가세일 및 크레딧 쿠폰은 6/17까지&lt;/strong&gt; 계속 현재 진행되고 있습니다.&lt;/p&gt;

&lt;p&gt;기간은 이전과 마찬가지로 &lt;strong&gt;다음주 금요일인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6/11&lt;/code&gt; 자정 전&lt;/strong&gt;까지 진행됩니다.&lt;/p&gt;

&lt;p&gt;금주에 무료로 배포되는 &lt;strong&gt;3번째&lt;/strong&gt; 미스터리 게임은 [&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로스트 펑크(Frost Punk)&lt;/code&gt;]입니다.&lt;/p&gt;

&lt;p&gt;극한의 빙하 시대에서 생존하는 서바이벌 게임입니다.
자세히는 마을을 운영과 건설하면서 집단을 계속해서 유지해나가는 방식이에요.&lt;/p&gt;

&lt;p&gt;서바이벌 게임 중 [디스 워 오브 마인] 만큼 침울함과 우울함을 가지고 있어서 유저 간 호불호를 많이 타는 장르이기도 합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/hobby/games/06-04-epic-free-game.png&quot;&gt;&lt;img src=&quot;../../assets/images/hobby/games/06-04-epic-free-game.png&quot; alt=&quot;&quot; title=&quot;2021/06/04 에픽 무료 배포 게임 - 프로스트 펑크(Frost Punk)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음 주에도 미스터리 무료 배포 게임과 함께 포스팅 하겠습니다~&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;이 글은 순전히 정보 전달 목적으로 작성되었으며 일절 비용을 받지 않았습니다.&lt;/p&gt;
</description>
        <pubDate>Fri, 28 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/hobby/games-epic-free-week-0604/</link>
        <guid isPermaLink="true">https://many258.github.io/hobby/games-epic-free-week-0604/</guid>
        
        <category>Games</category>
        
        
        <category>hobby</category>
        
      </item>
    
      <item>
        <title>[에픽게임즈/Epic Games] 시작되는 2021 에픽스토어 메가세일과 무료 배포 게임(5/28)</title>
        <description>&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://many258.github.io/hobby/games-epic-free-week-0521/&quot; class=&quot;red&quot;&gt;에픽게임즈 메가세일 - 5월 21일자 무료 배포 게임&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/hobby/games/epic-mega-sale.png&quot;&gt;&lt;img src=&quot;../../assets/images/hobby/games/epic-mega-sale.png&quot; alt=&quot;&quot; title=&quot;에픽 메가 세일&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;메가세일 및 크레딧 쿠폰은 6/17까지&lt;/strong&gt; 계속 현재 진행되고 있습니다.&lt;/p&gt;

&lt;p&gt;금주에 무료로 배포되는 &lt;strong&gt;2번째&lt;/strong&gt; 미스터리 게임은 [&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;어몽어스(Among Us)&lt;/code&gt;]입니다.&lt;/p&gt;

&lt;p&gt;기간은 이전과 마찬가지로 &lt;strong&gt;다음주 금요일인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6/4&lt;/code&gt; 자정 전&lt;/strong&gt;까지 진행됩니다.(&lt;del&gt;포스팅을 작성하는 지금은 게임 심의중으로 받을 수 없는 오류가 있습니다&lt;/del&gt;.)&lt;/p&gt;

&lt;p&gt;마피아류 게임으로 알려져 있습니다. 특히나 게임 스트리머 및 유튜버들이 많이 플레이하셨죠 ㅎㅎ&lt;/p&gt;

&lt;p&gt;플레이어 사이에 숨어있는 임포스터(마피아)를 찾아내는 것이 목표이며 
지인 및 친구와 있다면 같이하기 좋은 &lt;strong&gt;협력과 배신이 판치는&lt;/strong&gt; 인성 게임입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/hobby/games/05-28-epic-free-game.png&quot;&gt;&lt;img src=&quot;../../assets/images/hobby/games/05-28-epic-free-game.png&quot; alt=&quot;&quot; title=&quot;2021/05/28 에픽 무료 배포 게임 - 어몽 어스(Among Us)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음 주에도 미스터리 무료 배포 게임과 함께 포스팅 하겠습니다~&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;이 글은 순전히 정보 전달 목적으로 작성되었으며 일절 비용을 받지 않았습니다.&lt;/p&gt;
</description>
        <pubDate>Fri, 28 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/hobby/games-epic-free-week-0528/</link>
        <guid isPermaLink="true">https://many258.github.io/hobby/games-epic-free-week-0528/</guid>
        
        <category>Games</category>
        
        
        <category>hobby</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/네트워크] 스푸핑(Spoofing) / 원격접속 공격</title>
        <description>&lt;h2 id=&quot;ip-spoofing&quot;&gt;IP Spoofing&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;자신의 IP를 속이는 행위(위장)&lt;/strong&gt;로서 공격자가 자신의 IP 주소를 공격하고자 하는 소스 IP 주소로 변조하여 해킹하는 방법이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP/IP의 구조적인 취약성/결함을 이용하는 공격&lt;/strong&gt;으로 자신의 IP를 속여서 접속하는 방법이다. 자세히 서술하면, TCP/IP의 취약점을 이용하여 순서 제어 번호 추측(Sequence Number Guessing), SYN Flooding, Connect Hijacking, RST/FIN을 이용한 접속 끊기, SYN/RST 패킷 생성 공격, IP 주소 인증(rlogin, rsh 등)을 수행한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DNS Spoofing&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;DNS의 IP 주소를 변경&lt;/strong&gt;하여 다른 사이트로 접속하게 하는 공격&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Web Spoofing&lt;/strong&gt;&lt;br /&gt;
공격자가 다른 컴퓨터로 전송되는 웹 페이지를 보거나 바꿀 수 있는 방법&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;가짜 홈페이지&lt;/strong&gt;를 만들어놓고 로그인을 유도하여 개인정보 획득한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;대응-방법&quot;&gt;대응 방법&lt;/h3&gt;
&lt;p&gt;라우터에서 불법적인 IP를 차단하거나 내부 IP 주소를 통해서 외부에서 유입되는 패킷을 차단한다. 또한 TCP의 Sequence Number를 Random하게 생성하여 세션 가로채기를 차단한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;대응 방법&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;내용&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;라우터에서 Source Routing 차단&lt;/td&gt;
      &lt;td&gt;외부에서 유입되는 패킷 중 출발지 IP에 내부망 IP 주소를 가지고 있는 패킷을 라우터 등에서 차단한다&lt;br /&gt;&lt;strong&gt;내부에서 발생한 IP Spoofing은 차단하지 못한다&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Sequence Number를 Random하게 발생&lt;/td&gt;
      &lt;td&gt;일부 운영체제 중에서 Sequence Number를 일정하게 증가시키면서 사용한다&lt;br /&gt;Random하게 발생하도록 서버 설정을 변경한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R-Command 취약점 제거&lt;/td&gt;
      &lt;td&gt;IP로 인증하는 서비스들을 가능하면 차단한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;암호화된 프로토콜&lt;/td&gt;
      &lt;td&gt;IP Spoofing 공격을 효과적으로 차단하지만 속도가 느려진다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;arp-spoofing&quot;&gt;ARP Spoofing&lt;/h2&gt;
&lt;p&gt;로컬 통신 과정에서 서버와 클라이언트는 IP와 MAC 주소로 통신을 수행하는데, 클라이언트의 &lt;strong&gt;MAC 주소를 중간에 공격자가 자신의 MAC 주소로 변조하&lt;/strong&gt;여 마치 서버와 클라이언트가 통신하는 것처럼 속이는 공격이다. 이러한 공격은 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fragrouter&lt;/code&gt;를 통하여 연결이 끊어지지 않도록 Release&lt;/strong&gt;를 해주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ARP는 인증을 하지 않기 때문에&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARP Reply&lt;/code&gt; 패킷을 각 호스트에 보내서 쉽게 ARP Cache를 갱신한다(변조된 ARP Reply를 &lt;strong&gt;지속적으로 보내서&lt;/strong&gt; 각 호스트들이 ARP Cache에 &lt;strong&gt;변조된 MAC 주소정보를 계속 유지&lt;/strong&gt;시켜야 한다)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;대응 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ARP Table을 &lt;strong&gt;정적(Static)&lt;/strong&gt;으로 설정
    &lt;blockquote&gt;
      &lt;p&gt;arp -s [IP 주소] [MAC 주소]&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;네트워크를 주기적으로 모니터링하여 비정상 ARP 패킷을 검사한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;원격접속-공격&quot;&gt;원격접속 공격&lt;/h2&gt;
&lt;p&gt;원격접속 공격은 RDP, Teamviewer, VNC, NetCat 등의 프로그램을 사용해서 원격으로 윈도우 시스템에 연결하여 윈도우 시스템을 모니터링하거나 명령을 실행하는 공격.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;윈도우 원격접속 프로그램&lt;/th&gt;
      &lt;th&gt;내용&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;RDP&lt;/td&gt;
      &lt;td&gt;Remote Desktop Protocol&lt;br /&gt;RDP는 MS에서 개발한 원격 데스크톱 연결 프로그램이 사용하는 프로토콜이다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Teamviewer&lt;/td&gt;
      &lt;td&gt;원격으로 시스템에 연결하는 프로그램&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VNC&lt;/td&gt;
      &lt;td&gt;Virtual Network Computing&lt;br /&gt;원격으로 대상 시스템을 모니터링하거나 관리할 수 있는 프로그램&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NetCat(NC)&lt;/td&gt;
      &lt;td&gt;원격으로 연결하여 명령을 실행할 수 있는 프로그램&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;대응-방법-1&quot;&gt;대응 방법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;윈도우 원격 데스크톱 프로토콜(RDP)&lt;/strong&gt;&lt;br /&gt;
윈도우 원격접속 프로그램인 RDP 서비스에 취약한 패스워드를 사용하면 &lt;strong&gt;무작위 공격(Brute Force Attack)&lt;/strong&gt;을 통해서 패스워드를 알아낼 수 있다.&lt;/p&gt;

    &lt;p&gt;공격자는 RDP에서 사용하는 기본포트(&lt;strong&gt;3389/TCP&lt;/strong&gt;)를 사용해서 접속 IP와 패스워드로 접속 후 원격제어 공격이 가능하다.&lt;/p&gt;

    &lt;p&gt;RDP 포트 변경은&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\&lt;br /&gt;
Control\TerminalServer\WinStations\&lt;strong&gt;RDP-Tcp&lt;/strong&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;경로에서 &lt;strong&gt;PortNumber키 값&lt;/strong&gt;을 통해 포트번호를 변경할 수 있다&lt;/p&gt;

    &lt;p&gt;원격 데스크톱 연결이 필요없으면 윈도우 제어판에서 “&lt;strong&gt;컴퓨터에 대한 원격 엑세스 허용&lt;/strong&gt;” 부분에서 원격 지원 연결을 해제한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;VNC&lt;/strong&gt;&lt;br /&gt;
패스워드 설정 시에 사용자 패스워드 복잡도를 준수하여 3-6개월 단위로 패스워드를 변경해야 한다.&lt;/p&gt;

    &lt;p&gt;VNC가 사용하는 포트번호(&lt;strong&gt;5800/tcp&lt;/strong&gt;, &lt;strong&gt;5900/tcp&lt;/strong&gt;)를 다른 포트번호로 변경하여 보안성을 향상시킨다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 26 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-network-spoofing-remote-attack/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-network-spoofing-remote-attack/</guid>
        
        <category>정보보안기사</category>
        
        <category>Network</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/네트워크] 스니핑(Sniffing)</title>
        <description>&lt;h2 id=&quot;스니핑sniffing&quot;&gt;스니핑(Sniffing)&lt;/h2&gt;
&lt;p&gt;네트워크로 전송되는 &lt;strong&gt;패킷을 훔쳐보는 도구&lt;/strong&gt;이다. 스니핑은 네트워크 관리자가 네트워크 장애를 식별하고 조치하기 위해서 사용되던 도구로 네트워크에 참여하는 송신자와 수신자 사이에 정상적으로 패킷이 전송되었는지 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;유선 및 무선 데이터 통신의 내용을 몰래 도청하는 행위 및 소프트웨어로 수동적(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Passive&lt;/code&gt;)인 공격 형태이다. 수동적(소극적)인 공격은 복제해도 알 수 없고 탐지가 어렵지만 &lt;strong&gt;예방은 가능하다&lt;/strong&gt;는 특징을 가지고 있다.&lt;/p&gt;

&lt;p&gt;하지만, 스니핑은 공격도구로도 사용할 수 있는데 송신자와 수신자의 패킷을 훔쳐보아서 송신자와 수신자의 &lt;strong&gt;IP 주소, 포트 번호 및 송수신되는 메시지까지 확인&lt;/strong&gt;이 가능하다.&lt;/p&gt;

&lt;p&gt;스니핑 도구를 실행시키면 기본적으로 &lt;strong&gt;정규모드&lt;/strong&gt;(Normal Mode)로 실행된다. Normal Node는 &lt;strong&gt;자신의 컴퓨터에 전송되는 패킷&lt;/strong&gt;만 수신받고 자신과 관련없는 패킷은 삭제한다. &lt;strong&gt;네트워크에 흘러다니는 모든 패킷을 모니터링&lt;/strong&gt;할 때는 &lt;strong&gt;무차별모드&lt;/strong&gt;(Promiscuours Mode)로 설정하고 스니핑을 실행해야 한다.&lt;/p&gt;

&lt;p&gt;스니핑을 할 수 있는 도구 중 하나가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tcpdump&lt;/code&gt; 프로그램이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;tcpdump Option&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-c&lt;/td&gt;
      &lt;td&gt;Count 수 만큼 패킷을 받는다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-e&lt;/td&gt;
      &lt;td&gt;MAC 주소 형태로 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-F&lt;/td&gt;
      &lt;td&gt;File에 Expression을 입력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-i&lt;/td&gt;
      &lt;td&gt;특정 인터페이스를 지정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-q&lt;/td&gt;
      &lt;td&gt;간결하게 표시&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-w&lt;/td&gt;
      &lt;td&gt;패킷을 파일로 저장한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r&lt;/td&gt;
      &lt;td&gt;저장한 파일을 읽는다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-t&lt;/td&gt;
      &lt;td&gt;Timestamp&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-v&lt;/td&gt;
      &lt;td&gt;자세히 표시&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;session-hijacking&quot;&gt;Session Hijacking&lt;/h2&gt;
&lt;p&gt;세션 하이재킹은 &lt;strong&gt;세션 값을 훔쳐가는 것을 의미&lt;/strong&gt;한다. 로그인 사용자에게 웹 서버가 세션 값이라는 문자열을 생성해서 전송해준다. 세션 값이라는 문자열만 획득하면, 로그인 과정없이 홈페이지에 접근할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이미 인증을 받아 세션을 생성, 유지하고 있는 연결을 빼앗는 공격을 총칭(스니핑 기술의 일종)한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인증을 위한 모든 검증을 우회&lt;/strong&gt; : TCP를 이용해서 통신하고 있을 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RST&lt;/code&gt; 패킷을 보내 일시적으로 TCP 세션을 끊고 &lt;strong&gt;시퀀스 넘버를 새로 생성하여 세션을 빼앗고 인증을 회피&lt;/strong&gt;한다&lt;/li&gt;
  &lt;li&gt;세션은 &lt;strong&gt;스니핑 추측(Brute-Force Guessing)&lt;/strong&gt;을 통해 도용하거나 가로채어 자신이 원하는 데이터를 보낼 수 있는 공격 방법이다.&lt;/li&gt;
  &lt;li&gt;원인 : 암호화되지 않은 프로토콜에서 정보를 평문으로 전송, 길이가 짧은 Session ID, 세션 타임아웃 부재&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;세션 하이재킹을 하기 위해서는 &lt;strong&gt;공격자 웹 서버에 세션 문자열을 기록하는 악성코드&lt;/strong&gt;를 만들어야 한다. 그리고 피해자는 정상적으로 사용하는 홈페이지에 로그인한다. 공격자는 만든 악성코드를 호출할 수 있도록 XSS를 사용한다.&lt;/p&gt;

&lt;p&gt;공격자는 웹프록시를 사용해서 피해자의 세션 값으로 변경하고 홈페이지에 접근하면 로그인 없이 접근할 수 있다. 사용자가 &lt;strong&gt;로그아웃을 하면 해당 세션 값은 초기화되기 때문에 로그인 순간에 사용&lt;/strong&gt;해야 한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;세션 하이재킹 도구&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;내용&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Hunt&lt;/td&gt;
      &lt;td&gt;네트워크상의 감시, 가로채기 등을 할 수 있는 도구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Arpspoof&lt;/td&gt;
      &lt;td&gt;공격자의 주소로 속이는 행위를 하는 도구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IP Watcher&lt;/td&gt;
      &lt;td&gt;네트워크상의 연결, 감시 및 세션을 가로채기 위한 다양한 기능을 제공하는 상용 프로그램&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ferret&lt;/td&gt;
      &lt;td&gt;세션 정보를 가로채는 도구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Hamster&lt;/td&gt;
      &lt;td&gt;Proxy 서버 상태로 만들어주는 도구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Paros&lt;/td&gt;
      &lt;td&gt;웹 Proxy 서버로서 사용할 수 있는 도구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Cain &amp;amp; Abel&lt;/td&gt;
      &lt;td&gt;스푸핑과 스캐닝 등 다양한 기능이 있는 도구&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WireShark&lt;/td&gt;
      &lt;td&gt;네트워크 패킷 분석 도구이며 다양한 패킷 정보를 볼 수 있는 도구&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Wed, 26 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-network-sniffing/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-network-sniffing/</guid>
        
        <category>정보보안기사</category>
        
        <category>Network</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/네트워크] 침입차단 시스템</title>
        <description>&lt;h2 id=&quot;침입차단-시스템firewall&quot;&gt;침입차단 시스템(Firewall)&lt;/h2&gt;
&lt;p&gt;가장 기본적인 네트워크 보안장비이며 침입차단 시스템은 네트워크를 경유해서 내부 시스템으로 진입하는 &lt;strong&gt;트래픽을 모니터링하고 접근 통제를 적용&lt;/strong&gt;하며 시스템에 접근이 &lt;strong&gt;허용 가능한 사용자 IP, 포트를 결정&lt;/strong&gt;한다. 반대로 접근 못하는 블랙리스트 IP를 등록하고 차단할 수 있다.&lt;/p&gt;

&lt;p&gt;즉, 인증되지 않은 데이터가 네트워크로 유입되는 것을 방지하고, 어떤 종류의 데이터가 어떻게 외부로 송신되지는지를 제한하는 접근 제어를 하는 보안장비이다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;인바운드&lt;/strong&gt;&lt;/span&gt;라는 것은 &lt;strong&gt;외부 네트워크에서 내부 네트워크로 들어오는 것&lt;/strong&gt;을 의미하고 &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;아웃바운드&lt;/strong&gt;&lt;/span&gt;라는 것은 &lt;strong&gt;내부에서 외부로 나가는 것을 의미&lt;/strong&gt;한다. 따라서, 인바운드 규칙이라는 것은 외부에서 내부로 들어오는 패킷 중에서 어떤 IP, 프로토콜, 포트 번호 및 프로그램을 차단할 것인지 허용할 것인지를 설정하는 것이다.&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;리버스 텔넷(Reverse Telnet)&lt;/strong&gt;&lt;br /&gt;
모의해킹 시 외부 망에서 내부 망으로 접근하는 인바운드는 대부분 차단되어 연결할 수 없다. 하지만, 내부 망에서 외부 망으로 접근하는 아웃바운드의 경우는 거의 차단되어 있지 않다. 그래서 내부 망에서 외부 망으로 Telnet을 통하여 연결하는 것이 리버스 텔넷이다. 결론적으로, 내부 망에서 공격자의 PC로 연결을 요청하는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;침입차단-시스템-구현방식에-따른-유형&quot;&gt;침입차단 시스템 구현방식에 따른 유형&lt;/h2&gt;
&lt;h3 id=&quot;패킷-필터링packet-filtering&quot;&gt;패킷 필터링(Packet Filtering)&lt;/h3&gt;
&lt;p&gt;OSI 7계층에서 &lt;strong&gt;네트워크 계층과 트랜스포트 계층&lt;/strong&gt;에 있는 데이터를 가지고 인바운드와 아웃바인드 서비스를 제공하는 것이다. 네트워크 계층은 IP 주소가 있고, 트랜스포트 계층은 포트번호와 프로토콜 종류(TCP, UDP)가 있다. 따라서, 패킷 필터링은 &lt;strong&gt;특정 IP, 프로토콜, 포트 차단 및 허용을 할 수 있는 것&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;미리 정해진 규칙에 따라 패킷 출발지 및 목적지 IP 주소 정보와 각 서비스의 Port 번호를 이용해 접속 제어&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다른 방화벽에 비해 &lt;strong&gt;속도가 빠름&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;사용자에게 투명성을 제공하며, 새로운 서비스에 대해 쉽게 &lt;strong&gt;연동 가능&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;TCP/IP 구조적인 문제로 인한 &lt;strong&gt;패킷의 헤더는 쉽게 조작이 가능&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;강력한 Logging 및 사용자 인증 기능을 제공하지 않는다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;애플리케이션-게이트웨이application-gateway&quot;&gt;애플리케이션 게이트웨이(Application Gateway)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;응용계층에서 기동&lt;/strong&gt;하기 때문에 &lt;strong&gt;접근 통제, 로그 관리 등의 막강한 기능&lt;/strong&gt;을 하고 있지만 성능이 느리다는 단점이 존재한다.&lt;/p&gt;

&lt;p&gt;각 프로토콜 별로 Proxy Daemon이 있어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Proxy Gateway&lt;/code&gt;라고도 하며, 사용자 및 응용 서비스에서 접근 제어를 제공하여 응용 프로그램 사용을 기록하여 감시 추적에 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Proxy 통해서만 연결이 허용되므로 내부 IP주소를 숨길 수 있다&lt;/li&gt;
  &lt;li&gt;Packet 필터링에 비해 보안성 우수&lt;/li&gt;
  &lt;li&gt;가장 강력한 Logging과 Audit 기능 제공&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;성능이 떨어진다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;새로운 서비스에 대해 &lt;strong&gt;유연성이 결여&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;회선-게이트웨이circuit-gateway&quot;&gt;회선 게이트웨이(Circuit Gateway)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;응용계층에서 세션계층 사이&lt;/strong&gt;에서 기동되며 방화벽을 통해 내부 시스템으로 접속하기 위해서는 Client 측에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Circuit Proxy&lt;/code&gt;를 인식할 수 있는 수정된 &lt;strong&gt;Client 프로그램이 필요&lt;/strong&gt;하며 설치된 Client만 Circuit 형성이 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내부의 IP 주소를 숨길 수 있고 투명한 서비스 제공&lt;/li&gt;
  &lt;li&gt;Application에 비해 관리가 수월&lt;/li&gt;
  &lt;li&gt;수정된 Client 프로그램 필요&lt;/li&gt;
  &lt;li&gt;비표준 포트로 우회 접근 시 방어 불가&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;상태-기반-패킷-검사stateful-packet-inspection&quot;&gt;상태 기반 패킷 검사(Stateful Packet Inspection)&lt;/h3&gt;
&lt;p&gt;상태 기반 패킷 검사는 &lt;strong&gt;OSI 전 계층에서 패킷의 컨텐츠를 해석&lt;/strong&gt;해서 침입차단을 제공하는 가장 강력한 기능을 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;패킷 필터링 방식에 비해 &lt;strong&gt;세션 추적 기능&lt;/strong&gt; 추가&lt;/li&gt;
  &lt;li&gt;패킷의 &lt;strong&gt;헤더 내용을 해석하여 순서에 위배되는 패킷 차단&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;패킷 필터링 기술을 사용하여 Client/Server 모델을 유지하면서 모든 계층의 &lt;strong&gt;전후 상황에 대한 문맥 데이터를 제공&lt;/strong&gt;하여 기존 방화벽의 한계 극복&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;방화벽 표준&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서비스에 대한 특성 및 통신 상태를 관리할 수 있기 때문에 &lt;strong&gt;돌아나가는 패킷에 대해서는 동적으로 접근 규칙을 자동 생성&lt;/strong&gt;한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터 내부에 악의적인 정보&lt;/strong&gt;를 포함할 수 있는 프로토콜에 대한 &lt;strong&gt;대응이 어렵다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;혼합형-타입hybrid-type&quot;&gt;혼합형 타입(Hybrid Type)&lt;/h3&gt;
&lt;p&gt;서비스 종류에 따라 복합적으로 구성할 수 있는 방화벽&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;서비스 종류에 따라서 사용자의 편의성, 보안성 등을 고려하여 방화벽 기능을 선택적으로 부여한다&lt;/li&gt;
  &lt;li&gt;구축 및 관리가 어렵다&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--success&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;심층 패킷분석&lt;/strong&gt;&lt;br /&gt;
심층 패킷분석(DPI, Deep Packet Inspection)은 &lt;strong&gt;패킷이 가지고 있는 컨텐츠까지 모두 검사&lt;/strong&gt;할 수 있는 기능으로 다양한 컨텐츠를 식별하고 분석할 수 있는 가장 강력한 침입차단 시스템이다. OSI 전 계층에 대해서 접근 통제를 할 수 있으며 &lt;strong&gt;상태기반 패킷검사에서 더 발전&lt;/strong&gt;된 형태이다.&lt;/p&gt;

&lt;h2 id=&quot;침입차단-시스템-구축-유형&quot;&gt;침입차단 시스템 구축 유형&lt;/h2&gt;
&lt;h3 id=&quot;스크리닝-라우터screening-router&quot;&gt;스크리닝 라우터(Screening Router)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IP, TCP, UDP 헤더 부분에 포함된 내용만 분석&lt;/strong&gt;하여 동작하며 내부 네트워크와 외부 네트워크 사이의 패킷을 perm/drop하는 라우터.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;필터링 &lt;strong&gt;속도가 빠르고 비용 적음&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;클라이언트와 서버 환경 변화 없이 설치가 가능하다&lt;/li&gt;
  &lt;li&gt;전체 네트워크에 동일한 보호 유지&lt;/li&gt;
  &lt;li&gt;OSI 3,4계층만 방어하여 필터링 규칙을 검증하기 어렵다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;패킷 내의 데이터는 차단 불가 및 로그 관리가 어렵다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;베스천-호스트bastion-host&quot;&gt;베스천 호스트(Bastion Host)&lt;/h3&gt;
&lt;p&gt;내부 네트워크 전면에서 &lt;strong&gt;내부 네트워크 전체를 보호&lt;/strong&gt;하며 외부 인터넷과 내부 네트워크를 연결하는 라우터 뒤에 위치. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lock Down&lt;/code&gt; 된 상태에 있으며 인터넷에서 접근이 가능한 서버이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스크리닝 라우터보다 &lt;strong&gt;안전&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Logging 정보 생성 관리가 편리&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;접근 제어와 인증 및 로그 기능&lt;/strong&gt; 제공&lt;/li&gt;
  &lt;li&gt;Bastion Host 손상 시 내부망 손상&lt;/li&gt;
  &lt;li&gt;로그인 정보 유출 시 내부망 침해 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;듀얼-홈드-호스트dual-homed-host&quot;&gt;듀얼 홈드 호스트(Dual-Homed Host)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2개의 네트워크 인터페이스를 가진 Bastion Host&lt;/strong&gt;로서 하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NIC&lt;/code&gt;(Network Interface Card)는 내부 네트워크와 연결하고 다른 NIC는 외부 네트워크와 연결&lt;/p&gt;

&lt;p&gt;방화벽은 하나의 네트워크에서 다른 네트워크로 IP 패킷을 라우팅하지 않기 때문에 &lt;strong&gt;Proxy 기능을 부여&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정보 지향적인 공격 방어&lt;/li&gt;
  &lt;li&gt;Logging 정보 생성 관리가 편리&lt;/li&gt;
  &lt;li&gt;설치 및 유지보수가 쉬움&lt;/li&gt;
  &lt;li&gt;방화벽에서 보안 위반 초래 가능&lt;/li&gt;
  &lt;li&gt;서비스가 증가할수록 Proxy 구성 복잡&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스크린드-호스트screened-host&quot;&gt;스크린드 호스트(Screened Host)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Packet Filtering Router&lt;/strong&gt;와 &lt;strong&gt;Bastion Host&lt;/strong&gt;로 구성되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Packet Filtering Router&lt;/strong&gt;는 외부 및 내부 네트워크에서 발생하는 &lt;strong&gt;패킷을 통과시킬 것인지를 검사&lt;/strong&gt;하고 외부에서 내부로 유입되는 패킷에 대해서는 Bastion Host로 검사된 패킷을 전달.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bastion Host&lt;/strong&gt;는 &lt;strong&gt;내부 및 외부 네트워크 시스템에 대한 인증&lt;/strong&gt;을 담당.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;네트워크 계층과 응용 계층의 2단계 방어이므로 매우 안전&lt;/li&gt;
  &lt;li&gt;가장 보편적으로 사용 및 융통성 우수&lt;/li&gt;
  &lt;li&gt;Dual-Homed의 장점 유지&lt;/li&gt;
  &lt;li&gt;스크리닝 라우터의 정보가 변경되면 방어가 불가능&lt;/li&gt;
  &lt;li&gt;구축 비용이 높다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스크린드-서브넷screened-subnet&quot;&gt;스크린드 서브넷(Screened Subnet)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;스크린드 호스트 보안상의 문제점을 보완&lt;/strong&gt;한 형태로 외부 네트워크와 내부 네트워크 사이에 하나 이상의 &lt;strong&gt;경계 네트워크&lt;/strong&gt;를 두어 내부 네트워크를 외부 내트워크로 &lt;strong&gt;분리&lt;/strong&gt;하기 위한 구조이다.&lt;/p&gt;

&lt;p&gt;일반적으로 &lt;strong&gt;두 개의 스크리닝 라우터&lt;/strong&gt;와 &lt;strong&gt;한 개의 베스천 호스트&lt;/strong&gt;를 이용하여 구축&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스크린드 호스트 구조의 장점을 유지&lt;/li&gt;
  &lt;li&gt;가장 안전한 구조&lt;/li&gt;
  &lt;li&gt;설치 및 관리가 어려움&lt;/li&gt;
  &lt;li&gt;구축 비용이 높고, 서비스 속도가 느리다&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 26 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-network-intrusion-block/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-network-intrusion-block/</guid>
        
        <category>정보보안기사</category>
        
        <category>Network</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/네트워크] 스캐닝(Scanning)</title>
        <description>&lt;h2 id=&quot;포트-스캐닝port-scanning&quot;&gt;포트 스캐닝(Port Scanning)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;서버에 열려있는 포트를 확인하기 위한 방법&lt;/strong&gt;으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NMAP&lt;/code&gt; 이라는 도구를 사용해서 스캐닝을 수행한다. 포트 스캐닝을 사용하면 서버에 열려있는 포트를 확인하고 해당 포트의 취약점을 이용하여 공격할 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;NMAP Port Scan&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;TCP connect() Scan&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-Way Handshaking&lt;/code&gt;를 수립하고 Target System에서 쉽게 탐지가 가능하다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TCP SYN Scan&lt;/td&gt;
      &lt;td&gt;SYN 패킷을 대상 포트로 발송하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN/ACK&lt;/code&gt; 패킷을 수신 받으면 &lt;strong&gt;Open&lt;/strong&gt; 상태이다&lt;br /&gt;SYN 패킷을 대상 포트로 발송하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RST/ACK&lt;/code&gt;을 수신받으면 &lt;strong&gt;Close&lt;/strong&gt; 상태이다&lt;br /&gt;&lt;strong&gt;Half Open&lt;/strong&gt; 혹은 &lt;strong&gt;Stealth Scanning&lt;/strong&gt;이라고 한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TCP FIN Scan&lt;/td&gt;
      &lt;td&gt;대상 포트로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 패킷을 전송하고 닫혀있는 포트는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RST&lt;/code&gt;를 전송한다&lt;br /&gt;포트가 개방되어 있으면 패킷을 무시한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TCP Null&lt;/td&gt;
      &lt;td&gt;모든 플래그를 지운다&lt;br /&gt;대상 포트가 닫혀있으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RST&lt;/code&gt;를 돌려보내고 개방 상태이면 패킷을 무시한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TCP X-MAS Tree Scan&lt;/td&gt;
      &lt;td&gt;대상 포트로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;URG&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PSH&lt;/code&gt; 패킷을 전송한다&lt;br /&gt;대상 시스템에서 &lt;strong&gt;포트가 닫혀있으면&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RST&lt;/code&gt;를 되돌려 보낸다&lt;br /&gt;포트가 &lt;strong&gt;개방되어 있으면 패킷을 무시&lt;/strong&gt;한다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;nmap-옵션&quot;&gt;NMAP 옵션&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;.SCAN Type&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
      &lt;th&gt;.Port Option&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-sS&lt;/td&gt;
      &lt;td&gt;TCP SYN Scan&lt;/td&gt;
      &lt;td&gt;-p #&lt;/td&gt;
      &lt;td&gt;특정 포트번호만 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sT&lt;/td&gt;
      &lt;td&gt;TCP Connection Scan&lt;/td&gt;
      &lt;td&gt;-p ssh&lt;/td&gt;
      &lt;td&gt;특정 이름의 포트만 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sU&lt;/td&gt;
      &lt;td&gt;UDP Scan&lt;/td&gt;
      &lt;td&gt;-p 1,2,3&lt;/td&gt;
      &lt;td&gt;여러 개의 특정 포트만 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sF&lt;/td&gt;
      &lt;td&gt;TCP FIN Scan&lt;/td&gt;
      &lt;td&gt;-p 1-1023&lt;/td&gt;
      &lt;td&gt;특정 범위의 포트만 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sX&lt;/td&gt;
      &lt;td&gt;TCP Xmas Scan&lt;/td&gt;
      &lt;td&gt;-p -1023&lt;/td&gt;
      &lt;td&gt;처음부터 특정 범위의 포트만 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sN&lt;/td&gt;
      &lt;td&gt;TCP NULL Scan&lt;/td&gt;
      &lt;td&gt;-p 49152-&lt;/td&gt;
      &lt;td&gt;특정 포트부터 끝까지 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sA&lt;/td&gt;
      &lt;td&gt;TCP ACK Scan&lt;/td&gt;
      &lt;td&gt;-p-&lt;/td&gt;
      &lt;td&gt;0번을 제외한 모든 포트 검색&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sW&lt;/td&gt;
      &lt;td&gt;TCP Windows Scan&lt;/td&gt;
      &lt;td&gt;-pT:1,2,U:1,2&lt;/td&gt;
      &lt;td&gt;T는 TCP포트, U는 UDP 포트를 의미&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sM&lt;/td&gt;
      &lt;td&gt;TCP Maimon Scan&lt;/td&gt;
      &lt;td&gt;-p http&lt;/td&gt;
      &lt;td&gt;http라는 이름을 가진 모든 포트를 스캔&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sI&lt;/td&gt;
      &lt;td&gt;TCP IDLE Scan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-sO&lt;/td&gt;
      &lt;td&gt;IP Protocol Scan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-b&lt;/td&gt;
      &lt;td&gt;FTP Bounce Scan&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;namp-포트-스캐닝&quot;&gt;NAMP 포트 스캐닝&lt;/h3&gt;
&lt;h4 id=&quot;udp-scan&quot;&gt;UDP SCAN&lt;/h4&gt;
&lt;p&gt;공격자는 UDP Packet을 전송해서 스캐닝하는 것으로 UDP의 특성상 신뢰성이 떨어진다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/network/udp-scan.png&quot;&gt;&lt;img src=&quot;../../assets/images/security/network/udp-scan.png&quot; alt=&quot;&quot; title=&quot;UDP SCAN&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;tcp-open-scan&quot;&gt;TCP Open SCAN&lt;/h4&gt;
&lt;p&gt;공격자는 TCP의 3-Way Handshaking 과정을 진행해서 개방된 포트를 확인한다. 서버에 로그가 기록되고 스캔 속도가 느리다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/network/tcp-open-scan.png&quot;&gt;&lt;img src=&quot;../../assets/images/security/network/tcp-open-scan.png&quot; alt=&quot;&quot; title=&quot;TCP Open SCAN&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;stealth-scan&quot;&gt;Stealth SCAN&lt;/h4&gt;
&lt;p&gt;스캔하는 대상에 로그를 남기지 않는 스캐닝 기법으로 TCP Half Open Scan, FIN Scan, Xmas Scan, Null Scan 방법이 있다. 공격 대상을 속이고 자신의 위치 또한 숨기는 스캔이다.&lt;/p&gt;

&lt;h5 id=&quot;tcp-half-open-scan&quot;&gt;TCP Half Open SCAN&lt;/h5&gt;
&lt;p&gt;TCP 연결 시에 SYN 패킷만 전송하고 응답 정보로 포트 개방을 확인한다. 완전한 세션을 성립하지 않고 포트의 활성화를 확인하므로 로그가 남지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/network/tcp-half-open-scan.png&quot;&gt;&lt;img src=&quot;../../assets/images/security/network/tcp-half-open-scan.png&quot; alt=&quot;&quot; title=&quot;TCP Half Open SCAN&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;fin-scan&quot;&gt;FIN SCAN&lt;/h5&gt;
&lt;p&gt;TCP에서 FIN은 &lt;strong&gt;연결 종료&lt;/strong&gt;를 의미하며 공격자는 &lt;strong&gt;FIN을 전송&lt;/strong&gt;하여 포트를 스캔한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/network/fin-scan.png&quot;&gt;&lt;img src=&quot;../../assets/images/security/network/fin-scan.png&quot; alt=&quot;&quot; title=&quot;FIN SCAN&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;x-mas-scan&quot;&gt;X-MAS SCAN&lt;/h5&gt;
&lt;p&gt;공격자는 &lt;strong&gt;TCP FIN, PSH, URG&lt;/strong&gt; Packet을 전송하여 포트 개방을 확인한다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/network/x-mas-scan.png&quot;&gt;&lt;img src=&quot;../../assets/images/security/network/x-mas-scan.png&quot; alt=&quot;&quot; title=&quot;X-MAS SCAN&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;null-scan&quot;&gt;NULL SCAN&lt;/h5&gt;
&lt;p&gt;공격자는 TCP &lt;strong&gt;NULL 패킷&lt;/strong&gt;을 전송하여 포트 개방을 확인한다&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/network/null-scan.png&quot;&gt;&lt;img src=&quot;../../assets/images/security/network/null-scan.png&quot; alt=&quot;&quot; title=&quot;NULL SCAN&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;tcp-fragmentation&quot;&gt;TCP Fragmentation&lt;/h4&gt;
&lt;p&gt;20Byte의 &lt;strong&gt;헤더를 2개로 분할&lt;/strong&gt;하여 보안장비의 탐지를 우회하는 방법. 첫 번째 패킷은 &lt;strong&gt;IP 주소 정보&lt;/strong&gt;가 있고 두 번째 패킷은 &lt;strong&gt;Port 정보만&lt;/strong&gt; 있게 한다.&lt;/p&gt;

</description>
        <pubDate>Tue, 25 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-network-scanning/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-network-scanning/</guid>
        
        <category>정보보안기사</category>
        
        <category>Network</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/네트워크] 분산 서비스 거부 공격(DDos)</title>
        <description>&lt;h2 id=&quot;서비스-거부-공격dos-denial-of-service&quot;&gt;서비스 거부 공격(DoS, Denial of Service)&lt;/h2&gt;
&lt;p&gt;컴퓨터의 자원을 고갈시키기 위한 공격으로 특정 서비스를 계속적으로 호출하여 CPU, Memory, Network 등의 자원을 고갈시킨다.&lt;/p&gt;

&lt;p&gt;DoS 공격은 &lt;strong&gt;소프트웨어 취약점&lt;/strong&gt;을 이용하는 공격과 IP Header를 변조하여 공격하는 &lt;strong&gt;로직 공격&lt;/strong&gt;(Logic Attack), 무작위로 패킷을 발생시키는 &lt;strong&gt;플러딩 공격&lt;/strong&gt;(Flooding Attack)으로 구분된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;도구&lt;/th&gt;
      &lt;th&gt;Trinoo&lt;/th&gt;
      &lt;th&gt;TFN&lt;/th&gt;
      &lt;th&gt;Stacheldraht&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;공격방법&lt;/td&gt;
      &lt;td&gt;UDP Flood&lt;/td&gt;
      &lt;td&gt;UDP, ICMP, SYN Flood, Smurf&lt;/td&gt;
      &lt;td&gt;UDP, ICMP, SYN Flood, Smurf&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;암호 기능&lt;/td&gt;
      &lt;td&gt;없음&lt;/td&gt;
      &lt;td&gt;없음&lt;/td&gt;
      &lt;td&gt;가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Attacker-Master&lt;/td&gt;
      &lt;td&gt;27665/tcp&lt;/td&gt;
      &lt;td&gt;Telnet 등 방법&lt;/td&gt;
      &lt;td&gt;1660/tcp(암호화)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Master-Agent&lt;/td&gt;
      &lt;td&gt;27444/udp&lt;/td&gt;
      &lt;td&gt;ICMP echo Reply&lt;/td&gt;
      &lt;td&gt;ICMP echo Reply, 65000/tcp&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Agent-Master&lt;/td&gt;
      &lt;td&gt;323335/udp&lt;/td&gt;
      &lt;td&gt;ICMP echo Reply&lt;/td&gt;
      &lt;td&gt;ICMP echo Reply&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;분산-서비스-거부-공격ddos&quot;&gt;분산 서비스 거부 공격(DDoS)&lt;/h2&gt;
&lt;h3 id=&quot;tcp-syn-flooding&quot;&gt;TCP SYN Flooding&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP&lt;/code&gt; 패킷의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt; 비트를 이용한 공격 방법으로 너무 많은 연결 요청을 전송해서 대상 시스템이 범람(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Flooding&lt;/code&gt;)하게 만들어 대상 시스템의 서비스를 중단시키는 공격&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;TCP 연결 요청. TCP SYN packet 전송 (Host A[Hacker] =&amp;gt; Host B[Victim])&lt;/li&gt;
  &lt;li&gt;Host C에게 응답. TCP SYN/ACK packet 전송&lt;/li&gt;
  &lt;li&gt;Host B는 Host C의 응답 대기 TCP ACK packet 대기&lt;/li&gt;
  &lt;li&gt;TCP 연결 대기 큐가 Overflow될 때까지 Host B에게 계속 연결 요청&lt;/li&gt;
  &lt;li&gt;Host C로부터 ACK 없음, 대기 큐는 Overflow&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;TCP 초기 연결 과정(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3-Way Handshaking&lt;/code&gt;)&lt;/strong&gt; 이용, &lt;strong&gt;SYN 패킷을 요청&lt;/strong&gt;하여 서버가 ACK 및 SYN 패킷을 보내게 한다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;전송하는 주소가 무의미한 주소이며 서버는 대기 상태이고 대량의 요청 패킷 전송으로 서버의 대기 큐가 가득차서 DoS 상태가 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;대응 방법
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;방화벽에서 대응&lt;/strong&gt;&lt;br /&gt;
IP 당 SYN 요청에 대한 PPS(Packet Per Second) 임계치를 단계적으로 조정&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;First SYN Drop(Spoofed) 설정&lt;/strong&gt;&lt;br /&gt;
SYN 패킷을 보낸 클라이언트의 존재 여부를 파악하여 차단하는 방법&lt;br /&gt;
클라이언트에서 전송된 첫 번째 SYN을 DROP하여 재요청 여부 확인 후 Spoofing 여부를 판단한다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;TCP 세션 연결 차단&lt;/strong&gt;&lt;br /&gt;
트래픽 유형별 임계치를 조정하여 TCP 세션 연결에 대한 차단&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Back Queue 증가&lt;/strong&gt;&lt;br /&gt;
임시적 방법으로 서버의 Queue 사이즈를 증가시킴
        &lt;blockquote&gt;
          &lt;p&gt;sysctl -w net.ipv4.tcp_max_syn_backlog = 1024&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;(라우터) &lt;strong&gt;Watch Mode&lt;/strong&gt;&lt;br /&gt;
SYN 패킷을 통과시키고 &lt;strong&gt;일정 시간 동안 연결이 이루어지지 않으면 라우터가 SUN 패킷을 차단&lt;/strong&gt;한다&lt;/li&gt;
      &lt;li&gt;(라우터) &lt;strong&gt;Intercept Mode&lt;/strong&gt;&lt;br /&gt;
라우터에 유입되는 SYN 패킷 요청을 &lt;strong&gt;서버로 전송하지 않고, 라우터에서 가로채어&lt;/strong&gt; SYN 패킷을 요청한 클라이언트와 서버를 대신 연결한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;DRDoS&lt;/strong&gt;&lt;br /&gt;
별도의 Agent를 설치하지 않고 TCP Half Open의 취약점을 이용하는 공격 기법&lt;br /&gt;&lt;br /&gt;
공격대상 IP로 출발지 IP를 변조하여 SYN 패킷 전송, 서버는 변조된 공격대상 IP로 SYN-ACK 패킷 전송&lt;/p&gt;

&lt;h3 id=&quot;icmp-flooding&quot;&gt;ICMP Flooding&lt;/h3&gt;
&lt;p&gt;IP 특징(Broadcast 주소 방식)과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ICMP&lt;/code&gt; 패킷을 이용한 공격 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;통신을 위해서 &lt;strong&gt;서비스 및 포트가 필요없는&lt;/strong&gt; 유일한 프로토콜이다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Smurfing Attack&lt;/strong&gt;이라고도 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다수의 호스트가 존재하는 서브 네트워크에 ICMP echo 패킷을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Broadcast&lt;/code&gt;로 전송한다. 이에 대한 다량의 응답 패킷이 공격대상 서버로 집중되게 하여 마비시키는 공격이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ICMP 공격에 사용되는 메시지&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Source Quench(Type-4)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;사용 중 전송자에게 패킷 전송 속도를 줄여 줄 것을 요구하는 메시지로 전송 속도 지연 발생&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Time to live exceeded in Transit(Type-11, Code-0)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;시간초과로 패킷이 폐기되었기 때문에 재전송한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Destination unreachable(Type-3, Code-0,1,2,3)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ICMP 트래픽 처리에 자원을 사용하게 되므로 시스템이 조금씩 느려지는 현상 발생&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응 방법
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;ACL(Access Control List)을 이용한 차단&lt;/strong&gt;&lt;br /&gt;
웹 서버 혹은 운영 장비에 대한 접근 제어 목록을 차단&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Inbound 패킷 임계치 설정&lt;/strong&gt;&lt;br /&gt;
운영 장비로 유입되는 Inbound 패킷을 기준으로 PPS 수치를 유입되는 수치보다 낮게 설정. 임계치 이상의 ICMP 및 UDP 차단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tear-drop--ip-fragmetation-ping-of-death&quot;&gt;Tear Drop : IP Fragmetation (Ping of Death)&lt;/h3&gt;
&lt;p&gt;네트워크 패킷은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTU&lt;/code&gt;(Maximum Transmission Unit)보다 큰 패킷이 오면 분할하고 분할(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fragmentation&lt;/code&gt;)된 정보를 Flag와 Offset이 가지고 있다. 이 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Offset을&lt;/code&gt; 임의로 조작하여 다시 조립될 수 없도록 하는 공격&lt;/p&gt;

&lt;p&gt;Fragment를 조작하여 패킷 필터링 장비나 IDS를 우회하여 서비스 거부를 유발시킨다&lt;/p&gt;

&lt;h4 id=&quot;공격-종류&quot;&gt;공격 종류&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Tiny Fragment&lt;/strong&gt;&lt;br /&gt;
최초의 &lt;strong&gt;Fragment를 아주 작게 만들어서&lt;/strong&gt; 네트워크 침입탐지 시스템이나 패킷 필터링 장비를 우회하는 공격&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Fragment Overlap&lt;/strong&gt;&lt;br /&gt;
Tiny Fragment 공격 기법에 비해 정교하며, IDS의 &lt;strong&gt;Fragment 처리 방법과 패킷 필터링의 재조합과 Overwrite 처리를 이용&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IP Fragmentation을 이용한 DoS&lt;/strong&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Ping of Death&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ping&lt;/code&gt;을 이용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ICMP&lt;/code&gt; 패킷을 &lt;strong&gt;규정된 길이 이상으로 큰&lt;/strong&gt; IP 패킷을 전송, 수신받은 OS에서 처리하지 못함으로써 시스템을 마비시키는 공격&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Tear Drop&lt;/strong&gt;&lt;br /&gt;
Fragment 재조합 과정의 취약점을 이용한 공격으로 목표시스템 정지나 재부팅을 유발하는 공격. &lt;strong&gt;TCP Header&lt;/strong&gt; 부분의 &lt;strong&gt;Offset Field&lt;/strong&gt; 값이 중첩되는 데이터 패킷을 대상 시스템에 전송
        &lt;ul&gt;
          &lt;li&gt;offset field : 특정 데이터 패킷이 운반 중인 데이터나 데이터 범위 내에서 운반할 byte를 지정한다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;land-attack&quot;&gt;Land Attack&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IP Header를 변조&lt;/strong&gt;하여 인위적으로 &lt;strong&gt;송신자 IP주소 및 Port주소를 수신자의 IP 주소와 Port주소로 설정&lt;/strong&gt;하여 트래픽을 전송하는 공격 기법.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;송신자와 수신자의 IP주소와 Port주소가 동일&lt;/strong&gt;하기 때문에 네트워크 장비에 부하를 유발한다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RAW Socket&lt;/strong&gt;에서 &lt;strong&gt;s_addr&lt;/strong&gt;은 송신자의 IP이고 &lt;strong&gt;daddr&lt;/strong&gt;은 수신자의 IP주소이다. 즉, s_addr과 daddr을 동일한 IP주소로 설정하고 송신하면 Land Attack을 구현할 수 있다.&lt;/p&gt;

&lt;p&gt;송신자와 수신자의 IP주소가 동일한 패킷을 삭제함으로써 대응이 가능하다&lt;/p&gt;

&lt;h3 id=&quot;http-get-flooding&quot;&gt;HTTP Get Flooding&lt;/h3&gt;
&lt;p&gt;정상적인 TCP 연결 이후에 정상적으로 보이는 HTTP Transaction 과정을 수행하는 방식으로 DoS/DDoS 공격 방법.&lt;/p&gt;

&lt;p&gt;HTTP Get을 지속적으로 요청하여 HTTP 연결 및 HTTP 처리 로직까지 과부하를 유발한다. TCP의 3-Way Handshaking 이후 공격을 수행하기 때문에 IP를 변조하지 않는다.&lt;/p&gt;

&lt;p&gt;HTTP Get Flooding은 아주 간단한 공격으로 다수의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP Request&lt;/code&gt;를 계속적으로 호출하게 만드는 방법이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응 방법
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;선별적 IP 차단&lt;/strong&gt;&lt;br /&gt;
TCP 연결요청 임계치 값과 HTTP Get의 임계치 값을 모니터링한 후 비정상적인 트래픽은 차단한다.&lt;/p&gt;

        &lt;p&gt;연결기반 공격이므로 IP를 변조할 수 없는 특성을 이용한 방법이다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;컨텐츠 요청횟수에 의한 임계치 설정&lt;br /&gt;
특정 컨텐츠를 다량으로 요청하는 것이므로 IP마다 컨텐츠 요청 횟수의 임계치를 설정&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;시간대별 웹 페이지 URL 접속 임계치 설정 차단&lt;br /&gt;
시간대별 임계치를 설정하여 임의의 시간 안에 설정한 임계치 이상의 요청이 들어온 경우 해당 IP를 탐지하여 방화벽 차단 목록에 등록한다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Web Scraping&lt;/strong&gt; 기법을 이용한 차단&lt;br /&gt;
L7 스위치를 운영하는 경우 웹 스크랩핑 기능을 사용하여 &lt;strong&gt;요청 패킷에 대한 쿠키 값이나 자바 스크립트를 보내어&lt;/strong&gt; 클라이언트로부터 원하는 값에 &lt;strong&gt;재요청 패킷이 없는 경우&lt;/strong&gt; 해당 패킷을 차단한다&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cache-control-attack&quot;&gt;Cache Control Attack&lt;/h3&gt;
&lt;p&gt;HTTP RFC 2616에 규정되어 있는 Cache-Control Header 옵션 값을 사용한다. 이 옵션은 자주 변경되는 데이터에 대해서 새롭게 HTTP 요청과 응답을 요구하는 옵션으로 &lt;strong&gt;no-cache가 설정되면 항상 최신의 페이지를 요청하여 부하를 발생&lt;/strong&gt;시킨다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응 방법
    &lt;ul&gt;
      &lt;li&gt;HTTP GET Attack과 마찬가지로 임계치 기반 대응을 실시&lt;/li&gt;
      &lt;li&gt;단, Cache-Control 사용여부에 따른 임계치를 설정하는 것이 더 효과적&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;slow-http-getpost-attack&quot;&gt;Slow HTTP Get/Post Attack&lt;/h3&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;Slow HTTP GET Flooding&lt;/strong&gt;&lt;br /&gt;
HTTP GET Flooding과 달리 HTTP Header를 변조해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Slow HTTP Get 방식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;TCP 및 UDP 기반 공격 : 변조 IP가 아닌 정상 IP 기반 공격이며, 탐지가 어렵다&lt;/li&gt;
      &lt;li&gt;소량의 트래픽을 사용한 공격 : 소량의 트래픽과 세션 연결을 통해서 공격한다&lt;/li&gt;
      &lt;li&gt;애플리케이션 대상 : 서비스의 취약점을 이용한 공격이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Slow HTTP Post 방식&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;HTTP의 Post 지시자를 이용하여 서버에게 전달할 대량의 데이터를 장시간에 걸쳐 분할 전송한다&lt;/li&gt;
      &lt;li&gt;Post 데이터가 모두 수신되지 않으면 연결을 장시간 유지하게 된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Slow HTTP Read DoS&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;공격자가 웹 서버와 TCP 연결 시 TCP 윈도우 크기 및 데이터 처리율을 감소시킨 후 HTTP 데이터를 송신하여 웹 서버가 정상적으로 응답하지 못하도록 하는 DoS/DDoS 기법&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;TCP 윈도우 크기 및 데이터 처리율을 감소&lt;/strong&gt;시키면 서버는 정상상태로 회복할 때까지 &lt;strong&gt;대기 상태&lt;/strong&gt;에 빠지게 되어 &lt;strong&gt;부하를 유발&lt;/strong&gt;한다&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;공격자는 자신의 TCP 윈도우 크기를 0바이트로 만든 후 서버로 전달&lt;/li&gt;
      &lt;li&gt;서버는 윈도우 크기가 0바이트인 것을 확인하고 데이터를 전송하지 않고 Pending 상태로 빠지게 된다&lt;/li&gt;
      &lt;li&gt;공격자는 윈도우 크기를 점검하는 Probe 패킷을 ACK로 전송하면 서버는 대기 상태로 빠지게 된다&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Slow HTTP Header DoS(Slowloris)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;HTTP Header를 비정상적으로 조작&lt;/strong&gt;해서 웹 서버가 헤더 정보를 구분할 수 없도록 하는 방법. 웹 서버에 &lt;strong&gt;HTTP Header 정보가 모두 전달되지 않은 것으로 판단&lt;/strong&gt;하여 &lt;strong&gt;연결을 장시간 유지&lt;/strong&gt;한다&lt;/li&gt;
      &lt;li&gt;웹 서버는 클라이언트로부터 요청이 끝나지 않은 것으로 판단되기 때문에 &lt;strong&gt;웹 로그에 기록하지 않는다&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;HTTP Header와 Body는 개행문자(\r\n\r\n)로 구분되는데 Slow HTTP Header DoS는 \r\n만 전송하여 불완전한 Header를 전송한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응 방법
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;접속 임계치 설정&lt;br /&gt;
특정 발신지에서 IP로 연결할 수 있는 최대값 설정&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;방화벽 설정 도구인 &lt;strong&gt;iptables로&lt;/strong&gt; 차단
        &lt;blockquote&gt;
          &lt;p&gt;iptables -A INPUT -p tcp -dport 80 -m connlimit-above 30 -j DROP&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;p&gt;30개 이상의 Concurrent Connection에 대한 차단&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Connection Timeout&lt;/strong&gt;과 &lt;strong&gt;Keepalibetime&lt;/strong&gt; 설정&lt;br /&gt;
Connection Timeout 설정으로 클라이언트와 서버 간에 데이터 전송이 없을 경우 연결 종료&lt;br /&gt;
웹 서버의 keepalivetime을 설정하여 차단&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;RequestReadTimeout&lt;/strong&gt; 설정으로 차단&lt;br /&gt;
Apache 2.2.15 버전이후에서 사용&lt;/p&gt;

        &lt;blockquote&gt;
          &lt;p&gt;RequestReadTimeout header=5 body=8 설정&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;p&gt;Slow Attack를 차단하기 위해서 5초 내에 연결이 안되면 연결 종료, POST 요청 이후 8초 내에 데이터가 오지 않으면 연결 종료&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;POST 메시지의 크기(POST_MAX_SIZE)를 제한한다&lt;/li&gt;
      &lt;li&gt;최저 데이터 전송 속도를 제한한다&lt;/li&gt;
      &lt;li&gt;TCP 상태를 모니터링한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hash-dos&quot;&gt;Hash DoS&lt;/h3&gt;
&lt;p&gt;클라이언트에서 전달되는 각종 파라미터 값을 관리하는 해시테이블의 &lt;strong&gt;인덱스 정보가 중복되도록 유도&lt;/strong&gt;하여 사전에 저장된 정보 조회 시 &lt;strong&gt;많은 CPU 자원을 소모&lt;/strong&gt;하도록 하는 공격&lt;/p&gt;

&lt;p&gt;HTTP Request 요청 시 Get, Post 방식으로 전송되는 변수를 Hash 구조로 관리한다. 많은 수의 매개변수를 전달하면 매개변수를 저장하는 해시테이블에서 &lt;strong&gt;해시 충돌이 발생&lt;/strong&gt;하여 해시테이블에 접근하는 시간이 증가한다.&lt;/p&gt;

&lt;p&gt;해시 충돌(Hash Collision) : 서로 다른 키 값이 같은 인덱스 값으로 매핑되는 현상&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응 방안
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;HTTP &lt;strong&gt;Post 파라미터 수 제한&lt;/strong&gt;&lt;br /&gt;
TOMCAT, PHP, Ruby 등의 최신 버전은 파라미터의 수를 제한할 수 있다. 즉, 개수 제한을 적용시킨다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Post 메시지 크기 제한&lt;/strong&gt;&lt;br /&gt;
POST 메시지의 사이즈를 제안하는 서비스 설정&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;PHP에서 Hash DoS 차단&lt;/strong&gt;&lt;br /&gt;
php.ini파일에서 max_input_var로 최대 HTTP POST Parameter 개수 설정&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hulk-dos&quot;&gt;Hulk DoS&lt;/h3&gt;
&lt;p&gt;웹 서버의 가용량을 모두 사용하여 정상적인 서비스가 불가능하도록 하는 Get Flooding 공격 유형&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;공격 대상 URL을 지속적으로 변경&lt;/strong&gt;하여 DDoS 차단정책을 우회하는 특징을 가진다. 특정 URL이 계속 변경되면 임계치 설정 기반 방어가 불가능해진다. 즉, 임계치는 고정된 URL에만 설정이 가능한 특성을 우회한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대응 방안
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;접속 임계치 설정&lt;/strong&gt;을 통한 차단&lt;br /&gt;
발신 IP에서 연결할 수 있는 동시 접속 수에 대한 최댓값을 설정하여 한 개의 IP에서 대량의 연결 시도를 차단
        &lt;blockquote&gt;
          &lt;p&gt;iptables -A INPUT -p tcp -dport 80 -m connlimit-above 30 -j DROP&lt;/p&gt;
        &lt;/blockquote&gt;

        &lt;p&gt;30개 이상의 Concurrent Connection에 대한 차단&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;HTTP Request HOST 필드 값&lt;/strong&gt;에 대한 임계치 설정을 통한 차단&lt;br /&gt;
Hulk DoS는 URL을 계속 변경하기 때문에 URL이 아닌 HTTP Request에 포함된 &lt;strong&gt;HOST 필드 값&lt;/strong&gt;을 카운트하여 임계치 이상인 경우 차단한다&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;302-Redirect&lt;/strong&gt;를 이용한 차단&lt;br /&gt;
대부분의 &lt;strong&gt;DDoS 공격 툴은 302-Redirect 요청&lt;/strong&gt;에 대해 반응하지 않는 것이 특징이므로, URL 중에서 공격 당하기 쉬운 웹 사이트에 대한 Redirect 처리를 통해서 자동화된 DDoS 공격 툴을 이용한 공격을 사전에 차단한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-network-ddos/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-network-ddos/</guid>
        
        <category>정보보안기사</category>
        
        <category>Network</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/윈도우] 바이러스와 악성코드</title>
        <description>&lt;h2 id=&quot;바이러스&quot;&gt;바이러스&lt;/h2&gt;
&lt;p&gt;컴퓨터 바이러스는 컴퓨터 프로그램의 한 종류로 사용자 몰래 은닉하여 정상적인 프로그램이나 사용자의 데이터를 파괴하는 악성 프로그램이다. 컴퓨터 바이러스와 악성코드는 혼동하여 많이 사용되지만, 가장 근본적인 차이점은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자기복제 여부&lt;/code&gt;이다. 즉, &lt;strong&gt;컴퓨터 바이러스는 자기 스스로를 복제하여 증식하는 자기복제 특성&lt;/strong&gt;을 가지고 있다&lt;/p&gt;

&lt;h3 id=&quot;제1세대-원시형-바이러스primitive-virus&quot;&gt;제1세대, 원시형 바이러스(Primitive Virus)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;일반적으로 아마추어 프로그래머에 의해서 개발된 바이러스&lt;/li&gt;
  &lt;li&gt;단순하여 분석이 쉽고 코드의 변형이 없이 고정된 크기를 가지고 있다&lt;/li&gt;
  &lt;li&gt;일반적으로 &lt;strong&gt;주기억 장치에 상주해서 부트 영역이나 파일을 감염&lt;/strong&gt;시키는 특성이 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;돌(Stoned) 바이러스, 예루살렘 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제2세대-암호화-바이러스encryption-virus&quot;&gt;제2세대, 암호화 바이러스(Encryption Virus)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터 프로그램의 일부 또는 전체를 &lt;strong&gt;암호화&lt;/strong&gt; 시켜서 백신으로 바이러스 감염 여부를 확인할 수 없게한다.&lt;/li&gt;
  &lt;li&gt;암호화 방식이 일정해서 복호화 방식도 일정하다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;폭포(Cascade) 바이러스, 느림보(Slow) 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제3세대-은페형-바이러스stealth-virus&quot;&gt;제3세대, 은페형 바이러스(Stealth Virus)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;자기 스스로 은폐할 수 있는 바이러스&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;다른 실행 파일에 &lt;strong&gt;기생하여 그 실행 파일의 크기를 증가&lt;/strong&gt;시킨다&lt;/li&gt;
  &lt;li&gt;파일 크기가 변경되기 때문에 백신이 발견하기 쉽다.&lt;/li&gt;
  &lt;li&gt;(단, 백신이 감염 여부를 진단할 때 이전 상태를 보여주어서 감염 여부를 확인하기 어렵게 한다)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;맥가이버(MacGyver) 바이러스, 브레인(Brain) 바이러스, 512 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제4세대-갑옷형-바이러스armor-virus&quot;&gt;제4세대, 갑옷형 바이러스(Armor Virus)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;다양한 암호화 기법을 사용&lt;/strong&gt;해서 은폐하는 기법을 사용하기 때문에 어떤 백신도 진단하기 어렵다.&lt;/li&gt;
  &lt;li&gt;바이러스가 프로그램을 변형하기 위해서 100만개가 넘는 방법을 사용한다&lt;/li&gt;
  &lt;li&gt;전문 프로그래머에 의해서 개발되었다&lt;/li&gt;
  &lt;li&gt;진단이나 치료가 불가능하지는 않다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다형성(Polymorphic) 바이러스, 자체 변형(Self-encryption) 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제5세대-매크로-바이러스&quot;&gt;제5세대, 매크로 바이러스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;엑셀이나 워드처럼 매크로 명령을 사용하는 프로그램을 감염시키는 바이러스&lt;/li&gt;
  &lt;li&gt;전문 프로그래머가 아니어도 누구나 쉽게 만들 수 있고 배포가 가능하다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;운영체제와 관계없이&lt;/strong&gt; 응용 프로그램에서 동작하는 바이러스&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Melisa, Laroux, Limda 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;부트-바이러스&quot;&gt;부트 바이러스&lt;/h3&gt;
&lt;p&gt;컴퓨터 전원을 켜면 디스크에 저장되어 있는 운영체제를 메모리로 로드한다. 이러한 과정을 부팅이라고 하며 부트 정보를 가지고 있는 디스크 영역을 부트섹터라고 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;부트 바이러스는 &lt;strong&gt;부트섹터에 영향&lt;/strong&gt;을 주는 컴퓨터 바이러스&lt;/li&gt;
  &lt;li&gt;부트섹터에 바이러스가 감염되면 컴퓨터가 &lt;strong&gt;부팅되지 않거나 부팅 시간이 오래 걸리게&lt;/strong&gt; 된다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;브레인 바이러스, 미켈란젤로(Michelangelo) 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파일-바이러스&quot;&gt;파일 바이러스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용자가 사용하는 일반 파일에 감염되는 바이러스&lt;/li&gt;
  &lt;li&gt;윈도우의 실행 파일인 &lt;strong&gt;COM 혹은 EXE 파일을 감염&lt;/strong&gt;시킨다&lt;/li&gt;
  &lt;li&gt;파일 바이러스는 기생형, 겹쳐쓰기형, 산란형, 연결형 바이러스로 분류된다
    &lt;ul&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;기생형&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;원래의 프로그램은 파괴하지 않고 바이러스가 프로그램의 앞 혹은 뒤에 붙어 &lt;strong&gt;기생&lt;/strong&gt;한다&lt;/li&gt;
          &lt;li&gt;바이러스 감염 여부 확인이 어렵다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;겹쳐쓰기형&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;파일의 앞부분을 겹쳐쓴다&lt;/li&gt;
          &lt;li&gt;원래의 프로그램이 파괴되므로 &lt;strong&gt;원래 프로그램은 복구가 안된다&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;산란형&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;EXE를 감염시키지 않고 &lt;strong&gt;같은 이름으로 COM 파일을 만든다&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;같은 디렉터리에 같은 이름의 EXE와 COM이 있는 경우 사용자가 파일이름을 입력하면 COM이 먼저 실행된다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;연결형&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;프로그램을 &lt;strong&gt;감염시키지 않는다&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;디렉터리 영역에 저장된 프로그램의 시작위치를 바이러스 위치로 변경한다&lt;/li&gt;
          &lt;li&gt;프로그램을 실행하면 &lt;strong&gt;원래 프로그램이 아닌 바이러스가 실행&lt;/strong&gt;된다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;부트-및-파일-바이러스&quot;&gt;부트 및 파일 바이러스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;부트섹터와 파일영역 모두를 감염시키는 바이러스&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;게킬라, 나타스, 침입자 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;윈도우-dde-취약점을-이용한-공격&quot;&gt;윈도우 DDE 취약점을 이용한 공격&lt;/h2&gt;
&lt;p&gt;윈도우 DDE 취약점은 DDE의 정상적인 기능을 악용한 것으로 MS Word의 경우 문서를 열 때 자동 연결 업데이트를 해제하면 방어할 수 있다&lt;/p&gt;

&lt;h3 id=&quot;윈도우-ddedynamic-data-exchange&quot;&gt;윈도우 DDE(Dynamic Data Exchange)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DDE는 &lt;strong&gt;윈도우에서 애플리케이션 간에 데이터를 전송하기 위한 프로토콜&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;윈도우 어플리케이션 간에 &lt;strong&gt;공유 메모리&lt;/strong&gt;를 사용해서 데이터를 공유한다&lt;/li&gt;
  &lt;li&gt;DDE는 윈도우 및 &lt;strong&gt;다른 운영체제 간에 데이터를 공유&lt;/strong&gt;할 수 있도록 허용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shellcode&quot;&gt;Shellcode&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;Shellcode&lt;/span&gt;는 &lt;strong&gt;작은 크기의 코드로 소프트웨어 취약점을 이용하는 짧은 기계어 코드&lt;/strong&gt;이다. 일반적으로 명령 셀을 실행시켜서 피해자의 컴퓨터를 공격자가 통제한다. Shellcode는 &lt;strong&gt;어셈블리어로 작성&lt;/strong&gt;되고 기계어로 번역되어 사용된다.&lt;/p&gt;

&lt;h2 id=&quot;heap-spray&quot;&gt;Heap Spray&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;Heap Spray&lt;/span&gt;는 짧은 기계어 코드인 Shell Code를 Heap 영역에 뿌리는 것으로 &lt;strong&gt;Heap 영역에 임의적으로 Shell Code를 삽입하여 실행시키는 공격 기법&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;생성된 Shell Code는 Visual Studio를 복사한 후 전역변수를 선언해서 대입해야 한다. 그리고 Visual Studio에서 DEP(Data Execution Prevention)을 해제하여 컴파일하면 바로 실행할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;aslraddress-space-layout-randomizaion&quot;&gt;ASLR(Address Space Layout Randomizaion)&lt;/h2&gt;
&lt;p&gt;실행 파일이 메모리에 로드될 때 기본주소는 항상 동일한 주소를 갖는다. 하지만 이렇게 동일한 메모리 주소를 가지면 공격자에게 매우 취약한 문제점이 발생한다. 즉, 주소가 동일하기 때문에 해당 주소에 악성 코드를 적재하기가 쉬워진다.&lt;/p&gt;

&lt;p&gt;프로세스가 실행될 때 메모리에 적재되는 &lt;strong&gt;기본주소가 항상 동일하면 공격자는 해당 주소를 하드코딩해서 자신의 Shellcode를 임의로 적재하여 악성코드를 실행&lt;/strong&gt;하게 할 수 있다. 이러한 문제점으로 인해서 &lt;strong&gt;윈도우 Vista 부터는 메모리의 주소를 항상 동적으로 할당&lt;/strong&gt;하게 했다. 즉, 기본주소가 동적으로 할당되는 것이다. 마찬가지로 리눅스에서도 기본주소를 동적으로 사용할 수 있는 시스템 변수가 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ASLR을 해제(고정 주소)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;sysctl -w kernel.randomize_va_space = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;ASLR을 설정(동적 주소)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;sysctl -w kernel.randomize_va_space = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;버퍼-오버플로우buffer-overflow&quot;&gt;버퍼 오버플로우(Buffer Overflow)&lt;/h2&gt;
&lt;p&gt;버퍼 오버플로우는 &lt;strong&gt;프로세스가 사용 가능한 메모리 공간을 초과해서 발생되는 공격으로 보안 취약점&lt;/strong&gt;이다. C나 C++를 사용해서 프로그램을 개발할 때 &lt;strong&gt;메모리 공간에 제한을 두지 않는 API를 사용해서 발생&lt;/strong&gt;하는 공격이다.&lt;/p&gt;

&lt;p&gt;버퍼 오버플로우 공격을 알기 위해서는 먼저 실행 중인 프로세스가 사용하는 메모리 공간의 구조를 알아야 한다. 프로세스가 사용하는 메모리 공간은 &lt;strong&gt;Stack, Heap, Text, Data&lt;/strong&gt; 로 나누어져 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Stack&lt;/strong&gt;&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램 함수 내에서 사용하는 &lt;strong&gt;지역변수&lt;/strong&gt;가 저장된다&lt;/li&gt;
      &lt;li&gt;함수를 호출하는 경우 되돌아오는 주소인 &lt;strong&gt;복귀주소&lt;/strong&gt;를 가지고 있다&lt;/li&gt;
      &lt;li&gt;함수의 인자 값을 가지고 있다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;스택 버퍼 오버플로우 공격&lt;/strong&gt; : 스택에 저장되어 있는 복귀주소가 지역변수에 의해서 침범당하는 공격&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Heap&lt;/strong&gt;&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램 실행 중 &lt;strong&gt;메모리를 동적으로 할당&lt;/strong&gt;하는 경우 힙 영역에 할당된다&lt;/li&gt;
      &lt;li&gt;동적 메모리 할당 함수를 사용해서 메모리를 할당하면 힙 영역에 할당된다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;힙 버퍼 오버플로우 공격&lt;/strong&gt; : 힙 영역은 하위주소에서 상위주소로 메모리를 할당한다. 그러므로 경계 값을 검사하지 않고 메모리를 사용하면 경계를 초과하는 취약점이 발생한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Text&lt;/strong&gt;&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;읽기만 가능한 메모리 영역&lt;/li&gt;
      &lt;li&gt;프로그램의 &lt;strong&gt;코드가 저장&lt;/strong&gt;된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;선언된 &lt;strong&gt;전역변수&lt;/strong&gt;, &lt;strong&gt;정적변수&lt;/strong&gt;가 저장된다&lt;/li&gt;
      &lt;li&gt;데이터 영역에 변수가 선언되면 자동으로 초기화된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;버퍼 오버플로우에 취약한 C언어 함수들은 다음과 같다. 이들 함수의 공통점은 &lt;strong&gt;길이제한을 두는 기능이 없다&lt;/strong&gt;는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;strcpy(char* dest, const char* src)&lt;/li&gt;
  &lt;li&gt;strcat(char* dest, const char* src)&lt;/li&gt;
  &lt;li&gt;getwd(char* buf)&lt;/li&gt;
  &lt;li&gt;gets(char* s)&lt;/li&gt;
  &lt;li&gt;fscanf(FILE* stream, const char* format, …)&lt;/li&gt;
  &lt;li&gt;scanf(const char* format, …)&lt;/li&gt;
  &lt;li&gt;sprintf(char* str, const char* format, …)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;버퍼 오버플로우를 방지하기 위해서 사용을 권고하는 C언어 함수는 다음과 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;strncat()&lt;/li&gt;
  &lt;li&gt;strncpy()&lt;/li&gt;
  &lt;li&gt;fgets()&lt;/li&gt;
  &lt;li&gt;fscanf()&lt;/li&gt;
  &lt;li&gt;vfscanf()&lt;/li&gt;
  &lt;li&gt;snprintf()&lt;/li&gt;
  &lt;li&gt;vsnprint()&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;버퍼 오버런(Buffer Overrun)&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
메모리 공간에 할당된 공간보다 더 큰 데이터를 입력하면 프로그램의 오류를 유발할 수 있다. 즉, &lt;strong&gt;공격자는 프로그램의 오류를 유발하여 시스템을 장악하거나 Shellcode를 복사하여 악성코드를 실행&lt;/strong&gt;한다.&lt;/p&gt;

&lt;h2 id=&quot;경쟁조건race-condition&quot;&gt;경쟁조건(Race Condition)&lt;/h2&gt;
&lt;p&gt;경쟁조건이란 다중 프로세스 환경에서 두 개 이상의 프로세스가 동시에 수행될 때 발생되는 비정상적인 상태를 의미한다. 즉, &lt;strong&gt;임의의 공유자원을 여러 개의 프로세스가 경쟁하기 때문에 발생&lt;/strong&gt;한다.&lt;/p&gt;

&lt;h2 id=&quot;aptadvanced-persistent-threat-공격&quot;&gt;APT(Advanced Persistent Threat) 공격&lt;/h2&gt;
&lt;p&gt;특정 기법 및 조직을 대상으로 &lt;strong&gt;다양한 공격 기법을 사용하여 지속적으로 공격을 수행하는 행위&lt;/strong&gt;를 APT 공격이라 한다.&lt;/p&gt;

&lt;p&gt;APT는 사회관계망 서비스(SNS)를 사용하여 정보수집, 악성 코드 배포를 수행하고 공격 표적을 선정하여 지속적으로 공격을 수행하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Zero Day Attack&lt;/strong&gt;&lt;/span&gt;은 &lt;strong&gt;소프트웨어 패치 전에 취약점을 이용한 공격&lt;/strong&gt;이고 &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;MAIL APT&lt;/strong&gt;&lt;/span&gt;는 &lt;strong&gt;악성 코드를 메일에 첨부하여 발송하고 이를 통해 정보를 획득하는 공격&lt;/strong&gt;이다. &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;백도어 APT&lt;/strong&gt;&lt;/span&gt;는 &lt;strong&gt;표적에 침투 후 백도어를 설치하여 재침입 시에 유입경로를 열어두는 것&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APT 공격 단계&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;침투(Incursion)&lt;/strong&gt; : Email, USB, 웹사이트를 통한 악성코드 등&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;탐색(Discovery)&lt;/strong&gt; : Network 정보, 시스템 정보, 계정 정보 및 DB/시스템 구조에 대한 정보&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수집/공격(Capture/Attack)&lt;/strong&gt; : 목표로 한 데이터 수집 혹은 시스템 공격&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유출(Exfiltration)&lt;/strong&gt; : 분석 및 추가 공격 혹은 금전적 이익을 취하기 위해 정보 유출&lt;/li&gt;
&lt;/ol&gt;

&lt;p class=&quot;notice--success&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;바이너리 디핑(Binary Diffing)&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
APT 공격이 아닌 &lt;strong&gt;Zero Attack 취약점을 찾을 수 있는 기법&lt;/strong&gt;이다. &lt;strong&gt;리버스 엔지니어링 분야&lt;/strong&gt;에서 활용되는 분야로 &lt;strong&gt;디핑 기술을 이용하여 스크립트된 바이너리 함수 정보를 획득&lt;/strong&gt;한다. 즉, 자동으로 Malware을 탐지하고 오픈소스 라이선스 준수여부를 확인할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 22 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-window-virus/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-window-virus/</guid>
        
        <category>정보보안기사</category>
        
        <category>Windows</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/윈도우] 레지스트리 /이벤트</title>
        <description>&lt;h2 id=&quot;레지스트리registry&quot;&gt;레지스트리(Registry)&lt;/h2&gt;
&lt;p&gt;윈도우 레지스트리는 마이크로소프트 윈도우 운영체제에서 운영체제 및 응용 프로그램 등에 필요한 &lt;strong&gt;정보를 저장하고 관리하기 위한 계층형 데이터베이스&lt;/strong&gt;이다. 레지스트리는 윈도우 부팅 시 로그인, 서비스 실행, 응용 프로그램 실행, 사용자의 행위에 관한 모든 활동에 참여하고 그 &lt;strong&gt;정보를 기록 및 관리&lt;/strong&gt;하는 것으로 윈도우 Me, XP, 2003, 7, 8, 10 모두 사용된다.&lt;/p&gt;

&lt;p&gt;윈도우 레지스트리 정보를 확인하는 방법은 regedit.exe 라는 레지스트리 관리 프로그램을 실행하면 된다.&lt;/p&gt;

&lt;p&gt;윈도우 레지스트리는 &lt;strong&gt;계층형 데이터베이스로 Key, Value, Data Type, Data&lt;/strong&gt;로 이루어져 있다. 키는 상위 레벨에서 하위 레벨 구조로 정의되어 있으며 레지스트리가 어떤 정보를 가지고 있는지 나타낸다.&lt;/p&gt;

&lt;p&gt;해당 키에는 Value와 Data Type, Data로 되어 있어서 Key에 대한 Value와 Value의 데이터 형태가 문자 혹은 숫자인지 등의 데이터 타입이 정의되고 마지막에는 해당 Value가 가지고 있는 데이터를 나타낸다.&lt;/p&gt;

&lt;p&gt;윈도우 레지스트리 키 중에서 가장 상위 레벨에 있는 레지스트리 키를 &lt;strong&gt;루트 키(Root Key)&lt;/strong&gt;라고 하는데 하위에 있는 레지스트리들에 어떤 정보가 있는지 알려주는 것으로 &lt;strong&gt;레지스트리 정보를 일정한 기준으로 분류&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;루트키 역할&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;HKEY_CLASSES_ROOT&lt;/strong&gt; : 파일의 각 &lt;strong&gt;확장자&lt;/strong&gt;에 대한 정보와 파일과 &lt;strong&gt;프로그램 간의 연결&lt;/strong&gt;에 대한 정보&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HKEY_LOCAL_MACHINE&lt;/strong&gt; : 설치된 &lt;strong&gt;하드웨어와 소프트웨어 설치&lt;/strong&gt; 드라이버 설정에 대한 정보&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HKEY_USERS&lt;/strong&gt; : 사용자에 대한 정보&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HKEY_CURRENT_CONFIG&lt;/strong&gt; : &lt;strong&gt;디스플레이 설정&lt;/strong&gt;과 &lt;strong&gt;프린트 설정&lt;/strong&gt;에 관한 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;주요 레지스트리 키&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;윈도우 버전 정보&lt;/strong&gt;&lt;br /&gt;
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컴퓨터 이름&lt;/strong&gt;
HKLM\SYSTEM\ControlSet00X\Control\ComputerName&lt;br /&gt;
\ActiveComputerName&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시작 프로그램 관련&lt;/strong&gt;
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows&lt;br /&gt;
\CurrentVersion\&lt;strong&gt;Run&lt;/strong&gt;,&lt;strong&gt;RunOnce&lt;/strong&gt;,&lt;strong&gt;RunServices&lt;/strong&gt;,&lt;strong&gt;RunServicesOnce&lt;/strong&gt;&lt;br /&gt;
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows&lt;br /&gt;
\CurrentVersion\&lt;strong&gt;Run&lt;/strong&gt;,&lt;strong&gt;RunOnce&lt;/strong&gt;,&lt;strong&gt;RunServices&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최근에 실행한 명령어 확인&lt;/strong&gt;&lt;br /&gt;
HKU\{USER}\SOFTWARE\Microsoft\Windows\CurrentVersion&lt;br /&gt;
\Explorer\RunMRU&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;하이브hive&quot;&gt;하이브(Hive)&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;하이브 파일&lt;/span&gt;은 &lt;strong&gt;레지스트 정보를 가지고 있는 물리적인 파일을 의미&lt;/strong&gt;한다. 윈도우 레지스트 프로그램(regedit.exe)은 하이브 파일을 읽어서 보여주거나 변경하는 것으로 &lt;strong&gt;레지스트와 관련된 모든 정보는 하이브 파일에 저장&lt;/strong&gt;되어 있다.&lt;/p&gt;

&lt;p&gt;하이브 파일은 일반적인 에디터로 변경하는 것은 불가능하고 &lt;strong&gt;커널에 의해&lt;/strong&gt;서 관리되며 &lt;strong&gt;SAM, SECURITY, SYSTEM, SOFTWARE, Default, NTUSER.DAT 등에 존재&lt;/strong&gt;한다. 이러한 하이브 파일의 목록을 하이브 셋이라고 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SYSTEM&lt;/strong&gt; : &lt;strong&gt;시스템 부팅&lt;/strong&gt;에 필요한 시스템 전역 구성정보를 가지고 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SOFTWARE&lt;/strong&gt; : 시스템 부팅에 필요없는 시스템 전역 구성정보로 소프트웨어 정보를 가지고 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SECURITY&lt;/strong&gt; : 시스템 보안정책과 권한 할당 정보로 &lt;strong&gt;시스템 계정만 접근&lt;/strong&gt;이 가능하다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SAM&lt;/strong&gt; : &lt;strong&gt;로컬 계정 정보와 그룹정보&lt;/strong&gt;로 &lt;strong&gt;시스템 계정만 접근&lt;/strong&gt; 가능&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HARDWARE&lt;/strong&gt; : 시스템 하드웨어 디스크립션과 모든 하드웨어의 장치 드라이버 매핑 정보를 가지고 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;COMPONENTS&lt;/strong&gt; : 설치된 컴포넌트와 관련된 정보 관리&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BCD00000000&lt;/strong&gt; : 부팅 환경 데이터를 관리하는 것은 과거 &lt;strong&gt;윈도우 XP의 Boot.ini가 없어지고 대체&lt;/strong&gt;되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;윈도우에서 하이브 파일은 &lt;strong&gt;C:\windows\system32\config&lt;/strong&gt; 디렉터리에 존재한다. 해당 디렉터리에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RegBack&lt;/code&gt;이라는 디렉터리가 존재하는데 이는 &lt;strong&gt;하이브 파일에 대한 백업&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h2 id=&quot;윈도우-이벤트-로그&quot;&gt;윈도우 이벤트 로그&lt;/h2&gt;
&lt;p&gt;윈도우 이벤트 로그는 &lt;strong&gt;윈도우 시스템을 사용하는 동안 발생되는 모든 내용을 발생시간 순으로 기록&lt;/strong&gt;하는 &lt;strong&gt;로그파일&lt;/strong&gt;이다. 이벤트 로그는 이벤트 뷰어라는 관리도구를 사용하여 확인할 수 있으며 이벤트 로그를 기록하고 있는 로그파일은 확장자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.evt&lt;/code&gt; 라는 이름으로 기록되어 있다.&lt;/p&gt;

&lt;p&gt;이벤트 로그는 윈도우에서 발생되는 로그파일을 계속해서 기록하여 모든 로그를 보유하고 있는 것이 아니라 &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;일정한 크기가 되면 덮어쓰는 형태&lt;/strong&gt;&lt;/span&gt;로 기록된다. 이벤트 뷰어 프로그램에서 이벤트 로그파일의 크기를 변경할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;윈도우-로그-종류&quot;&gt;윈도우 로그 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;응용 프로그램 로그&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램 개발자에 의해서 이벤트를 정의하고 분류하여 응용 프로그램에 기록할 이벤트들이 수록된 자료&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;보안 로그&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;관리자에 의해서 보안 로그에 기록된 이벤트 유형을 지정하고, 보안 로그에 기록됨&lt;/li&gt;
      &lt;li&gt;로그온 횟수, 로그인 오류 정보, 파일 생성 및 다른 개체 만들기, 파일 열기 및 삭제 등의 리소스 사용관련 이벤트 기록&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시스템 로그&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;윈도우 시스템에서 사전에 정한 윈도우 시스템 구성요소에서 기록한 이벤트 자료&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;수집된 이벤트 로그는 파일변환을 통해서 엑셀 혹은 SQLite DB에 업로드하거나 Logparse 도구를 사용해서 분석한다.&lt;/p&gt;

&lt;h2 id=&quot;웹-아티펙트-분석&quot;&gt;웹 아티펙트 분석&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;웹 아티펙트 분석&lt;/span&gt;은 사용자가 웹 사이트를 이용한 흔적을 분석하는 것이다. 웹은 웹브라우저와 웹 서버 간의 양방향 통신으로 이루어지고, &lt;strong&gt;웹에서 할당한 모든 기록을 가지고 와서 분석&lt;/strong&gt;하는 것을 웹 아티펙트 분석이라고 한다.&lt;/p&gt;

&lt;p&gt;웹 아티팩트 분석 대상으로는 웹 브라우저 &lt;span style=&quot;color:orangered&quot;&gt;캐시&lt;/span&gt;가 있는데 웹 브라우저 캐시는 캐시 데이터와 캐시 인덱스 정보로 이루어져 있다. &lt;strong&gt;캐시 데이터&lt;/strong&gt;는 &lt;strong&gt;다운로드 받은 이미지 텍스트 파일, 아이콘 등&lt;/strong&gt;을 가지고 있고 &lt;strong&gt;캐시 인덱스&lt;/strong&gt;는 &lt;strong&gt;다운로드 URL, 다운로드 시간, 데이터 크기 등&lt;/strong&gt;의 정보를 가지고 있다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;히스토리 분석&lt;/span&gt;은 사용자가 방문한 웹 사이트 접속 정보를 저장하는 것으로 월별, 일별 방문 기록을 가지고 있다. &lt;strong&gt;히스토리 정보&lt;/strong&gt;는 &lt;strong&gt;방문 사이트 URL, 방문 시간, 방문 횟수, 사이트 제목 등&lt;/strong&gt;을 가지고 있다.&lt;/p&gt;

&lt;p&gt;웹 브라우저 &lt;span style=&quot;color:orangered&quot;&gt;쿠키&lt;/span&gt;는 &lt;strong&gt;웹 사이트 방문 시 자동으로 사용자 PC에 저장되는 작은 저장 공간&lt;/strong&gt;으로 &lt;strong&gt;자동 로그인 기능, 자주 조회되는 물건 등의 값&lt;/strong&gt;이 있다. 또한 &lt;strong&gt;호스트 정보, 경로, 수정시간, 만료시간&lt;/strong&gt; 등의 값도 있다.&lt;/p&gt;

&lt;p&gt;인터넷 익스플로러에 대한 아티팩트 수집 데이터 위치&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;index.dat&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Win XP, 7&lt;/code&gt;)
    &lt;ul&gt;
      &lt;li&gt;캐시, 히스토리, 쿠키 등의 정보가 &lt;strong&gt;각각 나누어져 별도&lt;/strong&gt;의 index.dat 파일로 구성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;WebCacheV01.dat / WebCacheV24.dat&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Win 10&lt;/code&gt;)
    &lt;ul&gt;
      &lt;li&gt;웹 아티팩트 &lt;strong&gt;파일이 통합&lt;/strong&gt;되어서 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 22 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-window-registry-event/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-window-registry-event/</guid>
        
        <category>정보보안기사</category>
        
        <category>Windows</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/윈도우] 윈도우 시스템</title>
        <description>&lt;h2 id=&quot;윈도우-시스템&quot;&gt;윈도우 시스템&lt;/h2&gt;
&lt;p&gt;윈도우 운영체제는 과거 단일 사용자 운영체제인 DOS로부터 시작되어 &lt;strong&gt;GUI(Graph User Interface) 환경 및 다중 사용자, 다중 프로세스 구조를 지원&lt;/strong&gt;하는 운영체제이다. 윈도우는 손쉬운 사용자 인터페이스로 개인용 PC에서 많이 사용된다.&lt;/p&gt;

&lt;p&gt;윈도우 운영체제는 다양한 하드웨어를 자동으로 인식하여 사용할 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Plug &amp;amp; Play&lt;/code&gt; 기능을 지원한다. Plug &amp;amp; Plag 란 &lt;strong&gt;하드웨어를 표준화된 인터페이스를 통해서 개발하면 윈도우의 HAL(Hardware Abstraction Layer) 계층이 하드웨어를 인식&lt;/strong&gt;하는 기능이다. 이러한 하드웨어는 윈도우의 운영체제에 해당되는 &lt;strong&gt;Micro Kernel&lt;/strong&gt;이 관리하게 된다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;구성 내용&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;세부 내용&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;HAL&lt;br /&gt;(Hardware Abstraction Layer)&lt;/td&gt;
      &lt;td&gt;새로운 하드웨어가 개발되어 시스템에 장착되어도 드라이버 개발자가 HAL 표준을 준수하면, 파드웨어와 시스템 간 원할한 통신이 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Micro Kernel&lt;/td&gt;
      &lt;td&gt;Manager에게 작업을 분담시키고 하드웨어를 제어&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IO Manager&lt;/td&gt;
      &lt;td&gt;시스템 입출력을 제어, 장치 드라이버 사이에서 메시지 전달, 응용 프로그램이 하드웨어와 통신할 수 있는 통로를 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Object Manager&lt;/td&gt;
      &lt;td&gt;파일, 포트, 프로세스, 스레드와 같은 각 객체에 대한 정보를 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Security Reference Manager&lt;/td&gt;
      &lt;td&gt;데이터 및 시스템 자원의 제어를 허가 및 거부함으로써 강제적으로 시스템의 보안설정을 책임&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Process Manager&lt;/td&gt;
      &lt;td&gt;프로세스 및 스레드를 생성하고 요청에 따른 작업을 처리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Local Procedure Cell&lt;/td&gt;
      &lt;td&gt;프로세스는 서로의 메모리 공간을 침범하지 못하기 때문에 프로세스 간에 통신이 필요한 경우 이를 처리하는 장치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Virtual Memory Manager&lt;/td&gt;
      &lt;td&gt;응용 프로그램의 요청에 따라 RAM 메모리를 할당, 가상 메모리의 Paging을 제어&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Win 32/64 Sub System&lt;/td&gt;
      &lt;td&gt;윈도우의 기본 서버 시스템, 32비트 및 64비트 응용 프로그램이 동작할 수 있도록 지원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POSIX&lt;/td&gt;
      &lt;td&gt;유닉스 운영체계에 기반을 두고 있는 일련의 표준 운영체제 인터페이스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Security Sub System&lt;/td&gt;
      &lt;td&gt;사용자가 로그인할 때 데이터를 보호하고 운영체제가 이를 제어할 수 있도록 만든 서브 시스템&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;윈도우 파일 시스템의 경우 FAT(File Allocation Table)와 NTFS(NT File System)를 지원한다. FAT은 과거 DOS를 기반으로 하는 파일 시스템으로 작은 파일 시스템에 사용되고 NTFS는 대용량 파일과 긴 파일명, 압축, 저널링 정보를 통한 오류 처리 등을 지원&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;FAT(File Allocation Table)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;FAT16&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;DOS와 윈도우 95의 첫 버전으로 최대 디스크 지원 용량이 2GB&lt;/li&gt;
          &lt;li&gt;NTFS, FAT로 변경 및 변환 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;FAT32&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;2G 이상의 파티션 지원 및 대용량 디스크 지원 기능&lt;/li&gt;
          &lt;li&gt;NTFS로 변환 가능, FAT로 변경 변환은 불가&lt;/li&gt;
          &lt;li&gt;사용되는 운영체제 - 윈도우 95 OSR2, 윈도우 98, 윈도우 2000, 윈도우 XP&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NTFS(NT File System)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;기존 FAT 파일 시스템을 개선하고 윈도우 서버용으로 사용하기 위해서 개발된 파일 시스템&lt;/li&gt;
      &lt;li&gt;파일 암호화 및 파일 레벨 보안 지원&lt;/li&gt;
      &lt;li&gt;디스크 압축 및 파티션 단위로 쿼터&lt;/li&gt;
      &lt;li&gt;FAT16이나 FAT32로 변환 불가&lt;/li&gt;
      &lt;li&gt;사용되는 운영체제 - 윈도우 NT, 윈도우 2000, 윈도우 XP&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;USN 저널&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Update Sequence Number Journal&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;저널링 기능을 제공&lt;/strong&gt;하는 것으로 파일 시스템이 &lt;strong&gt;변경될 때 그 내용을 기록하여 복구&lt;/strong&gt;할 수 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ADS&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Alternate Data Stream&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;MAC 파일 시스템과 호환성&lt;/strong&gt;을 위해서 만든 공간으로 다중 데이터 스트림을 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Sparse 파일&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;파일 데이터가 대부분 0일 경우에 실제 데이터 기록 없이 정보를 기록하는 기능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;파일 압축&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;LZ77의 변형된 데이터 압축 알고리즘 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;VSS&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Volume Shadow Copy Service&lt;/li&gt;
          &lt;li&gt;덮어써진 파일과 디렉터리 백업을 유지하여 복구 기능을 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;EFS&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Encryting File System&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;대칭키 기법&lt;/strong&gt;으로 파일 데이터를 &lt;strong&gt;암호화&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Quotas&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;사용자별 디스크 사용 용량을 제한 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Unicode&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;다국어 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;동적 Bad 클러스터 할당&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Bad Sector가 발생한 클러스터를 자동으로 재할당&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;대용량 지원&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;2TB&lt;/strong&gt;가 넘는 대용량 볼륨 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ntfs-파일-시스템-구성&quot;&gt;NTFS 파일 시스템 구성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;VBR(Volume Boot Record)&lt;/strong&gt;&lt;br /&gt;
NTFS 파일 시스템의 제일 처음에 있는 것으로 &lt;strong&gt;부트섹터, 부트코드, NTLDR&lt;/strong&gt; 위치 등의 정보를 가지고 있다. VBR의 부트섹터는 섹터 0번에 존재한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MFT(Master File Table)&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;NTFS의 메타정보, 파일 및 디렉터리 등의 정보를 관리&lt;/strong&gt;하는 파일로 파일 위치, 속성, 시간정보, 파일명, 크기 등의 정보를 가지고 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Data Area&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;윈도우-인증-시스템&quot;&gt;윈도우 인증 시스템&lt;/h3&gt;
&lt;p&gt;winlogon은 내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;megina.dll&lt;/code&gt;이라는 GINA 프로그램을 구동시키며 검증을 위해서 아이디를 LSA에 전달한다. NTLM 값과 SAM에 저장된 NTLM 값을 비교하여 같으면 SRM에게 권한을 부여한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/windows/windows-authority.png&quot; title=&quot;https://m.blog.naver.com/PostView.naver?blogId=darkness76&amp;amp;logNo=60201244303&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F&quot;&gt;&lt;img src=&quot;../../assets/images/security/windows/windows-authority.png&quot; alt=&quot;&quot; title=&quot;윈도우 인증 프로세스&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/windows/windows-authority-role.png&quot; title=&quot;https://m.blog.naver.com/PostView.naver?blogId=darkness76&amp;amp;logNo=60201244303&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F&quot;&gt;&lt;img src=&quot;../../assets/images/security/windows/windows-authority-role.png&quot; alt=&quot;&quot; title=&quot;윈도우 인증 프로세스 역할&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;인증 프로세스 구성요소&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Winlogon&lt;/strong&gt;&lt;br /&gt;
윈도우 로그인 프로세스. 윈도우 시작 시 자동으로 초기화되어 실행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GINA(msgina.dll)&lt;/strong&gt;&lt;br /&gt;
Winlogon은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msgina.dll&lt;/code&gt;을 로딩하여 사용자가 입력한 &lt;strong&gt;계정과 암호를 LSA에게 전달&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LSA(Local Security Authority, lsass.exe에서 관리)&lt;/strong&gt;&lt;br /&gt;
모든 계정의 &lt;strong&gt;로그인에 대한 검증&lt;/strong&gt;&lt;br /&gt;
시스템 자원 및 파일 등에 대한 &lt;strong&gt;접근 권한을 검사&lt;/strong&gt;&lt;br /&gt;
계정과 암호를 검증하기 위해서 NTLM(암호화) 모듈을 로딩하고 계정을 검증&lt;br /&gt;
SRM이 작성한 감사로그를 기록&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SAM(Security Account Manager)&lt;/strong&gt;&lt;br /&gt;
사용자 계정 정보(해시 값)에 저장&lt;br /&gt;
사용자의 로그인 입력 정보와 SAM 데이터베이스 &lt;strong&gt;정보를 비교하여 인증 여부를 결정&lt;/strong&gt;하도록 해준다.&lt;/p&gt;

    &lt;p&gt;리눅스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/shadow&lt;/code&gt; 파일과 같은 역할을 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SRM(Security Reference Monitor)&lt;/strong&gt;&lt;br /&gt;
SAM이 사용자의 계정과 패스워드가 일치하는 지를 확인하여 SRM에게 알려주면 SRM은 사용자에게 고유의 SID를 부여하고 SID에 권한 부여&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;윈도우-실행-프로세스&quot;&gt;윈도우 실행 프로세스&lt;/h3&gt;
&lt;p&gt;윈도우 운영체제 관련 프로세스는 wininit.exe, services.exe, lsm.exe, winlogon.exe 등이 있으며 &lt;strong&gt;C:\windows\system32&lt;/strong&gt; 폴더에 위치한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;프로세스&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;wininit.exe&lt;/td&gt;
      &lt;td&gt;윈도우 시작 프로그램&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;services.exe&lt;/td&gt;
      &lt;td&gt;윈도우 서비스 관리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lsm.exe&lt;/td&gt;
      &lt;td&gt;Local Session Manager&lt;br /&gt;&lt;br /&gt;시스템 관리 작업, 주요 함수 실행, 호스트 컴퓨터와 서버의 연결을 관리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lsass.exe&lt;/td&gt;
      &lt;td&gt;Local Security Authority Subsystem Service&lt;br /&gt;&lt;br /&gt;사용자 로그인 검사, 비밀번호 변경 관리, 액세스 토큰 생성&lt;br /&gt;Windows Security Log를 작성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;svchost.exe&lt;/td&gt;
      &lt;td&gt;서비스를 관리하기 위한 프로세스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;conhost.exe&lt;/td&gt;
      &lt;td&gt;키보드, 마우스 입력 허용, 문자 출력, 콘솔 API 등 셀의 기본 기능 수행&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;윈도우-계정&quot;&gt;윈도우 계정&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Users&lt;/strong&gt; : 기본적인 권한은 가지고 있지 않지만 Domain Users 글로벌 그룹이 구성원으로 포함되어 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Account Operators&lt;/strong&gt; : 서버 관리자를 사용하여 컴퓨터를 도메인 추가 가능하며, 사용자 계정, 그룹의 생성 및 삭제, 수정할 수 있는 권한을 가지고 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Printer Operators&lt;/strong&gt; : 도메인 컨트롤러에 있는 프린터를 생성 및 관리&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Server Operators&lt;/strong&gt; : 도메인 컨트롤러에 있는 자원을 공유하거나 폴더를 백업하고 복구&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;유니버설 그룹&lt;/strong&gt;은 &lt;strong&gt;복수의 도메인 환경에서 상호 관련되어 있는 자원에 대한 허가를 부여할 때 주로 사용&lt;/strong&gt;한다. 도메인 내의 로컬 그룹과 유니버설 그룹의 구성원이 될 수 있다. 성능 저하를 초래할 수 있으므로 꼭 필요할 때에만 사용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;유니버설 그룹 계정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Administrators&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 컴퓨터의 모든 관리 권한과 사용 권한을 보유&lt;/li&gt;
      &lt;li&gt;기본적으로 Administrator가 사용자 계정과 Domain Admins를 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Users&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;기본적인 권한은 갖지 않음&lt;/li&gt;
      &lt;li&gt;컴퓨터에서 생성되는 로컬 사용자 계정 포함&lt;/li&gt;
      &lt;li&gt;Domain Users 글로벌 그룹이 구성원으로 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Guest&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;관리자에 의해 허락된 자원과 권한만을 사용하여 네트워크 자원에 접근 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Backup Operators&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Windows 백업을 이용하여 모든 도메인의 컨트롤러에 있는 파일과 폴더를 백업하고 복구할 수 있는 권한이 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Power Users&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;컴퓨터에서 로컬 사용자 &lt;strong&gt;계정을 생성하고 수정&lt;/strong&gt;할 수 있는 권한을 갖고 있으며 &lt;strong&gt;자원을 공유하거나 멈출 수 있다&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;시스템에 대한 전체 권한은 없지만 &lt;strong&gt;시스템을 관리할 수 있는 권한&lt;/strong&gt;이 부여된 그룹&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;공유-파일&quot;&gt;공유 파일&lt;/h3&gt;
&lt;p&gt;윈도우의 공유 폴더 기능은 자신의 컴퓨터에 잇는 폴더를 다른 컴퓨터와 공유할 수 있는 기능으로 자료를 같이 공유하면서 업무를 처리할 때 아주 유용한 기능이다. 하지만, 정보보안에서는 공유 폴더를 통해서 악성코드를 유포하거나 시스템 정보를 획득할 수 있기 때문에 삭제를 권고한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공유 폴더 목록 확인 : &lt;strong&gt;net share&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;IPC$&lt;/strong&gt; : 네트워크 프로그램 간에 통신을 위해서 파이프를 사용하고 네트워크 &lt;strong&gt;서버 원격관리를 위해서 사용&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공유 폴더 삭제 : &lt;strong&gt;/delete&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 21 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-window-system/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-window-system/</guid>
        
        <category>정보보안기사</category>
        
        <category>Windows</category>
        
        
        <category>study</category>
        
      </item>
    
  </channel>
</rss>
