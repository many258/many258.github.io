<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My LifeChronicle</title>
    <description>Be a Imagineer.</description>
    <link>https://many258.github.io/</link>
    <atom:link href="https://many258.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 23 May 2021 00:44:20 +0900</pubDate>
    <lastBuildDate>Sun, 23 May 2021 00:44:20 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>[정보보안기사/윈도우] 바이러스와 악성코드</title>
        <description>&lt;h2 id=&quot;바이러스&quot;&gt;바이러스&lt;/h2&gt;
&lt;p&gt;컴퓨터 바이러스는 컴퓨터 프로그램의 한 종류로 사용자 몰래 은닉하여 정상적인 프로그램이나 사용자의 데이터를 파괴하는 악성 프로그램이다. 컴퓨터 바이러스와 악성코드는 혼동하여 많이 사용되지만, 가장 근본적인 차이점은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자기복제 여부&lt;/code&gt;이다. 즉, &lt;strong&gt;컴퓨터 바이러스는 자기 스스로를 복제하여 증식하는 자기복제 특성&lt;/strong&gt;을 가지고 있다&lt;/p&gt;

&lt;h3 id=&quot;제1세대-원시형-바이러스primitive-virus&quot;&gt;제1세대, 원시형 바이러스(Primitive Virus)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;일반적으로 아마추어 프로그래머에 의해서 개발된 바이러스&lt;/li&gt;
  &lt;li&gt;단순하여 분석이 쉽고 코드의 변형이 없이 고정된 크기를 가지고 있다&lt;/li&gt;
  &lt;li&gt;일반적으로 &lt;strong&gt;주기억 장치에 상주해서 부트 영역이나 파일을 감염&lt;/strong&gt;시키는 특성이 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;돌(Stoned) 바이러스, 예루살렘 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제2세대-암호화-바이러스encryption-virus&quot;&gt;제2세대, 암호화 바이러스(Encryption Virus)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터 프로그램의 일부 또는 전체를 &lt;strong&gt;암호화&lt;/strong&gt; 시켜서 백신으로 바이러스 감염 여부를 확인할 수 없게한다.&lt;/li&gt;
  &lt;li&gt;암호화 방식이 일정해서 복호화 방식도 일정하다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;폭포(Cascade) 바이러스, 느림보(Slow) 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제3세대-은페형-바이러스stealth-virus&quot;&gt;제3세대, 은페형 바이러스(Stealth Virus)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;자기 스스로 은폐할 수 있는 바이러스&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;다른 실행 파일에 &lt;strong&gt;기생하여 그 실행 파일의 크기를 증가&lt;/strong&gt;시킨다&lt;/li&gt;
  &lt;li&gt;파일 크기가 변경되기 때문에 백신이 발견하기 쉽다.&lt;/li&gt;
  &lt;li&gt;(단, 백신이 감염 여부를 진단할 때 이전 상태를 보여주어서 감염 여부를 확인하기 어렵게 한다)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;맥가이버(MacGyver) 바이러스, 브레인(Brain) 바이러스, 512 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제4세대-갑옷형-바이러스armor-virus&quot;&gt;제4세대, 갑옷형 바이러스(Armor Virus)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;다양한 암호화 기법을 사용&lt;/strong&gt;해서 은폐하는 기법을 사용하기 때문에 어떤 백신도 진단하기 어렵다.&lt;/li&gt;
  &lt;li&gt;바이러스가 프로그램을 변형하기 위해서 100만개가 넘는 방법을 사용한다&lt;/li&gt;
  &lt;li&gt;전문 프로그래머에 의해서 개발되었다&lt;/li&gt;
  &lt;li&gt;진단이나 치료가 불가능하지는 않다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다형성(Polymorphic) 바이러스, 자체 변형(Self-encryption) 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;제5세대-매크로-바이러스&quot;&gt;제5세대, 매크로 바이러스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;엑셀이나 워드처럼 매크로 명령을 사용하는 프로그램을 감염시키는 바이러스&lt;/li&gt;
  &lt;li&gt;전문 프로그래머가 아니어도 누구나 쉽게 만들 수 있고 배포가 가능하다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;운영체제와 관계없이&lt;/strong&gt; 응용 프로그램에서 동작하는 바이러스&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Melisa, Laroux, Limda 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;부트-바이러스&quot;&gt;부트 바이러스&lt;/h3&gt;
&lt;p&gt;컴퓨터 전원을 켜면 디스크에 저장되어 있는 운영체제를 메모리로 로드한다. 이러한 과정을 부팅이라고 하며 부트 정보를 가지고 있는 디스크 영역을 부트섹터라고 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;부트 바이러스는 &lt;strong&gt;부트섹터에 영향&lt;/strong&gt;을 주는 컴퓨터 바이러스&lt;/li&gt;
  &lt;li&gt;부트섹터에 바이러스가 감염되면 컴퓨터가 &lt;strong&gt;부팅되지 않거나 부팅 시간이 오래 걸리게&lt;/strong&gt; 된다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;브레인 바이러스, 미켈란젤로(Michelangelo) 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파일-바이러스&quot;&gt;파일 바이러스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용자가 사용하는 일반 파일에 감염되는 바이러스&lt;/li&gt;
  &lt;li&gt;윈도우의 실행 파일인 &lt;strong&gt;COM 혹은 EXE 파일을 감염&lt;/strong&gt;시킨다&lt;/li&gt;
  &lt;li&gt;파일 바이러스는 기생형, 겹쳐쓰기형, 산란형, 연결형 바이러스로 분류된다
    &lt;ul&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;기생형&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;원래의 프로그램은 파괴하지 않고 바이러스가 프로그램의 앞 혹은 뒤에 붙어 &lt;strong&gt;기생&lt;/strong&gt;한다&lt;/li&gt;
          &lt;li&gt;바이러스 감염 여부 확인이 어렵다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;겹쳐쓰기형&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;파일의 앞부분을 겹쳐쓴다&lt;/li&gt;
          &lt;li&gt;원래의 프로그램이 파괴되므로 &lt;strong&gt;원래 프로그램은 복구가 안된다&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;산란형&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;EXE를 감염시키지 않고 &lt;strong&gt;같은 이름으로 COM 파일을 만든다&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;같은 디렉터리에 같은 이름의 EXE와 COM이 있는 경우 사용자가 파일이름을 입력하면 COM이 먼저 실행된다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;연결형&lt;/strong&gt;&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;프로그램을 &lt;strong&gt;감염시키지 않는다&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;디렉터리 영역에 저장된 프로그램의 시작위치를 바이러스 위치로 변경한다&lt;/li&gt;
          &lt;li&gt;프로그램을 실행하면 &lt;strong&gt;원래 프로그램이 아닌 바이러스가 실행&lt;/strong&gt;된다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;부트-및-파일-바이러스&quot;&gt;부트 및 파일 바이러스&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;부트섹터와 파일영역 모두를 감염시키는 바이러스&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;게킬라, 나타스, 침입자 바이러스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;윈도우-dde-취약점을-이용한-공격&quot;&gt;윈도우 DDE 취약점을 이용한 공격&lt;/h2&gt;
&lt;p&gt;윈도우 DDE 취약점은 DDE의 정상적인 기능을 악용한 것으로 MS Word의 경우 문서를 열 때 자동 연결 업데이트를 해제하면 방어할 수 있다&lt;/p&gt;

&lt;h3 id=&quot;윈도우-ddedynamic-data-exchange&quot;&gt;윈도우 DDE(Dynamic Data Exchange)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DDE는 &lt;strong&gt;윈도우에서 애플리케이션 간에 데이터를 전송하기 위한 프로토콜&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;윈도우 어플리케이션 간에 &lt;strong&gt;공유 메모리&lt;/strong&gt;를 사용해서 데이터를 공유한다&lt;/li&gt;
  &lt;li&gt;DDE는 윈도우 및 &lt;strong&gt;다른 운영체제 간에 데이터를 공유&lt;/strong&gt;할 수 있도록 허용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shellcode&quot;&gt;Shellcode&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;Shellcode&lt;/span&gt;는 &lt;strong&gt;작은 크기의 코드로 소프트웨어 취약점을 이용하는 짧은 기계어 코드&lt;/strong&gt;이다. 일반적으로 명령 셀을 실행시켜서 피해자의 컴퓨터를 공격자가 통제한다. Shellcode는 &lt;strong&gt;어셈블리어로 작성&lt;/strong&gt;되고 기계어로 번역되어 사용된다.&lt;/p&gt;

&lt;h2 id=&quot;heap-spray&quot;&gt;Heap Spray&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;Heap Spray&lt;/span&gt;는 짧은 기계어 코드인 Shell Code를 Heap 영역에 뿌리는 것으로 &lt;strong&gt;Heap 영역에 임의적으로 Shell Code를 삽입하여 실행시키는 공격 기법&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;생성된 Shell Code는 Visual Studio를 복사한 후 전역변수를 선언해서 대입해야 한다. 그리고 Visual Studio에서 DEP(Data Execution Prevention)을 해제하여 컴파일하면 바로 실행할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;aslraddress-space-layout-randomizaion&quot;&gt;ASLR(Address Space Layout Randomizaion)&lt;/h2&gt;
&lt;p&gt;실행 파일이 메모리에 로드될 때 기본주소는 항상 동일한 주소를 갖는다. 하지만 이렇게 동일한 메모리 주소를 가지면 공격자에게 매우 취약한 문제점이 발생한다. 즉, 주소가 동일하기 때문에 해당 주소에 악성 코드를 적재하기가 쉬워진다.&lt;/p&gt;

&lt;p&gt;프로세스가 실행될 때 메모리에 적재되는 &lt;strong&gt;기본주소가 항상 동일하면 공격자는 해당 주소를 하드코딩해서 자신의 Shellcode를 임의로 적재하여 악성코드를 실행&lt;/strong&gt;하게 할 수 있다. 이러한 문제점으로 인해서 &lt;strong&gt;윈도우 Vista 부터는 메모리의 주소를 항상 동적으로 할당&lt;/strong&gt;하게 했다. 즉, 기본주소가 동적으로 할당되는 것이다. 마찬가지로 리눅스에서도 기본주소를 동적으로 사용할 수 있는 시스템 변수가 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ASLR을 해제(고정 주소)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;sysctl -w kernel.randomize_va_space = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;ASLR을 설정(동적 주소)&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;sysctl -w kernel.randomize_va_space = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;버퍼-오버플로우buffer-overflow&quot;&gt;버퍼 오버플로우(Buffer Overflow)&lt;/h2&gt;
&lt;p&gt;버퍼 오버플로우는 &lt;strong&gt;프로세스가 사용 가능한 메모리 공간을 초과해서 발생되는 공격으로 보안 취약점&lt;/strong&gt;이다. C나 C++를 사용해서 프로그램을 개발할 때 &lt;strong&gt;메모리 공간에 제한을 두지 않는 API를 사용해서 발생&lt;/strong&gt;하는 공격이다.&lt;/p&gt;

&lt;p&gt;버퍼 오버플로우 공격을 알기 위해서는 먼저 실행 중인 프로세스가 사용하는 메모리 공간의 구조를 알아야 한다. 프로세스가 사용하는 메모리 공간은 &lt;strong&gt;Stack, Heap, Text, Data&lt;/strong&gt; 로 나누어져 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Stack&lt;/strong&gt;&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램 함수 내에서 사용하는 &lt;strong&gt;지역변수&lt;/strong&gt;가 저장된다&lt;/li&gt;
      &lt;li&gt;함수를 호출하는 경우 되돌아오는 주소인 &lt;strong&gt;복귀주소&lt;/strong&gt;를 가지고 있다&lt;/li&gt;
      &lt;li&gt;함수의 인자 값을 가지고 있다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;스택 버퍼 오버플로우 공격&lt;/strong&gt; : 스택에 저장되어 있는 복귀주소가 지역변수에 의해서 침범당하는 공격&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Heap&lt;/strong&gt;&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램 실행 중 &lt;strong&gt;메모리를 동적으로 할당&lt;/strong&gt;하는 경우 힙 영역에 할당된다&lt;/li&gt;
      &lt;li&gt;동적 메모리 할당 함수를 사용해서 메모리를 할당하면 힙 영역에 할당된다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;힙 버퍼 오버플로우 공격&lt;/strong&gt; : 힙 영역은 하위주소에서 상위주소로 메모리를 할당한다. 그러므로 경계 값을 검사하지 않고 메모리를 사용하면 경계를 초과하는 취약점이 발생한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Text&lt;/strong&gt;&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;읽기만 가능한 메모리 영역&lt;/li&gt;
      &lt;li&gt;프로그램의 &lt;strong&gt;코드가 저장&lt;/strong&gt;된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Data&lt;/strong&gt;&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;선언된 &lt;strong&gt;전역변수&lt;/strong&gt;, &lt;strong&gt;정적변수&lt;/strong&gt;가 저장된다&lt;/li&gt;
      &lt;li&gt;데이터 영역에 변수가 선언되면 자동으로 초기화된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;버퍼 오버플로우에 취약한 C언어 함수들은 다음과 같다. 이들 함수의 공통점은 &lt;strong&gt;길이제한을 두는 기능이 없다&lt;/strong&gt;는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;strcpy(char* dest, const char* src)&lt;/li&gt;
  &lt;li&gt;strcat(char* dest, const char* src)&lt;/li&gt;
  &lt;li&gt;getwd(char* buf)&lt;/li&gt;
  &lt;li&gt;gets(char* s)&lt;/li&gt;
  &lt;li&gt;fscanf(FILE* stream, const char* format, …)&lt;/li&gt;
  &lt;li&gt;scanf(const char* format, …)&lt;/li&gt;
  &lt;li&gt;sprintf(char* str, const char* format, …)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;버퍼 오버플로우를 방지하기 위해서 사용을 권고하는 C언어 함수는 다음과 같다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;strncat()&lt;/li&gt;
  &lt;li&gt;strncpy()&lt;/li&gt;
  &lt;li&gt;fgets()&lt;/li&gt;
  &lt;li&gt;fscanf()&lt;/li&gt;
  &lt;li&gt;vfscanf()&lt;/li&gt;
  &lt;li&gt;snprintf()&lt;/li&gt;
  &lt;li&gt;vsnprint()&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;버퍼 오버런(Buffer Overrun)&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
메모리 공간에 할당된 공간보다 더 큰 데이터를 입력하면 프로그램의 오류를 유발할 수 있다. 즉, &lt;strong&gt;공격자는 프로그램의 오류를 유발하여 시스템을 장악하거나 Shellcode를 복사하여 악성코드를 실행&lt;/strong&gt;한다.&lt;/p&gt;

&lt;h2 id=&quot;경쟁조건race-condition&quot;&gt;경쟁조건(Race Condition)&lt;/h2&gt;
&lt;p&gt;경쟁조건이란 다중 프로세스 환경에서 두 개 이상의 프로세스가 동시에 수행될 때 발생되는 비정상적인 상태를 의미한다. 즉, &lt;strong&gt;임의의 공유자원을 여러 개의 프로세스가 경쟁하기 때문에 발생&lt;/strong&gt;한다.&lt;/p&gt;

&lt;h2 id=&quot;aptadvanced-persistent-threat-공격&quot;&gt;APT(Advanced Persistent Threat) 공격&lt;/h2&gt;
&lt;p&gt;특정 기법 및 조직을 대상으로 &lt;strong&gt;다양한 공격 기법을 사용하여 지속적으로 공격을 수행하는 행위&lt;/strong&gt;를 APT 공격이라 한다.&lt;/p&gt;

&lt;p&gt;APT는 사회관계망 서비스(SNS)를 사용하여 정보수집, 악성 코드 배포를 수행하고 공격 표적을 선정하여 지속적으로 공격을 수행하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;Zero Day Attack&lt;/strong&gt;&lt;/span&gt;은 &lt;strong&gt;소프트웨어 패치 전에 취약점을 이용한 공격&lt;/strong&gt;이고 &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;MAIL APT&lt;/strong&gt;&lt;/span&gt;는 &lt;strong&gt;악성 코드를 메일에 첨부하여 발송하고 이를 통해 정보를 획득하는 공격&lt;/strong&gt;이다. &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;백도어 APT&lt;/strong&gt;&lt;/span&gt;는 &lt;strong&gt;표적에 침투 후 백도어를 설치하여 재침입 시에 유입경로를 열어두는 것&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APT 공격 단계&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;침투(Incursion)&lt;/strong&gt; : Email, USB, 웹사이트를 통한 악성코드 등&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;탐색(Discovery)&lt;/strong&gt; : Network 정보, 시스템 정보, 계정 정보 및 DB/시스템 구조에 대한 정보&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;수집/공격(Capture/Attack)&lt;/strong&gt; : 목표로 한 데이터 수집 혹은 시스템 공격&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유출(Exfiltration)&lt;/strong&gt; : 분석 및 추가 공격 혹은 금전적 이익을 취하기 위해 정보 유출&lt;/li&gt;
&lt;/ol&gt;

&lt;p class=&quot;notice--success&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;바이너리 디핑(Binary Diffing)&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
APT 공격이 아닌 &lt;strong&gt;Zero Attack 취약점을 찾을 수 있는 기법&lt;/strong&gt;이다. &lt;strong&gt;리버스 엔지니어링 분야&lt;/strong&gt;에서 활용되는 분야로 &lt;strong&gt;디핑 기술을 이용하여 스크립트된 바이너리 함수 정보를 획득&lt;/strong&gt;한다. 즉, 자동으로 Malware을 탐지하고 오픈소스 라이선스 준수여부를 확인할 수 있다.&lt;/p&gt;
</description>
        <pubDate>Sat, 22 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-window-virus/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-window-virus/</guid>
        
        <category>정보보안기사</category>
        
        <category>Windows</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/윈도우] 레지스트리 /이벤트</title>
        <description>&lt;h2 id=&quot;레지스트리registry&quot;&gt;레지스트리(Registry)&lt;/h2&gt;
&lt;p&gt;윈도우 레지스트리는 마이크로소프트 윈도우 운영체제에서 운영체제 및 응용 프로그램 등에 필요한 &lt;strong&gt;정보를 저장하고 관리하기 위한 계층형 데이터베이스&lt;/strong&gt;이다. 레지스트리는 윈도우 부팅 시 로그인, 서비스 실행, 응용 프로그램 실행, 사용자의 행위에 관한 모든 활동에 참여하고 그 &lt;strong&gt;정보를 기록 및 관리&lt;/strong&gt;하는 것으로 윈도우 Me, XP, 2003, 7, 8, 10 모두 사용된다.&lt;/p&gt;

&lt;p&gt;윈도우 레지스트리 정보를 확인하는 방법은 regedit.exe 라는 레지스트리 관리 프로그램을 실행하면 된다.&lt;/p&gt;

&lt;p&gt;윈도우 레지스트리는 &lt;strong&gt;계층형 데이터베이스로 Key, Value, Data Type, Data&lt;/strong&gt;로 이루어져 있다. 키는 상위 레벨에서 하위 레벨 구조로 정의되어 있으며 레지스트리가 어떤 정보를 가지고 있는지 나타낸다.&lt;/p&gt;

&lt;p&gt;해당 키에는 Value와 Data Type, Data로 되어 있어서 Key에 대한 Value와 Value의 데이터 형태가 문자 혹은 숫자인지 등의 데이터 타입이 정의되고 마지막에는 해당 Value가 가지고 있는 데이터를 나타낸다.&lt;/p&gt;

&lt;p&gt;윈도우 레지스트리 키 중에서 가장 상위 레벨에 있는 레지스트리 키를 &lt;strong&gt;루트 키(Root Key)&lt;/strong&gt;라고 하는데 하위에 있는 레지스트리들에 어떤 정보가 있는지 알려주는 것으로 &lt;strong&gt;레지스트리 정보를 일정한 기준으로 분류&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;루트키 역할&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;HKEY_CLASSES_ROOT&lt;/strong&gt; : 파일의 각 &lt;strong&gt;확장자&lt;/strong&gt;에 대한 정보와 파일과 &lt;strong&gt;프로그램 간의 연결&lt;/strong&gt;에 대한 정보&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HKEY_LOCAL_MACHINE&lt;/strong&gt; : 설치된 &lt;strong&gt;하드웨어와 소프트웨어 설치&lt;/strong&gt; 드라이버 설정에 대한 정보&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HKEY_USERS&lt;/strong&gt; : 사용자에 대한 정보&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HKEY_CURRENT_CONFIG&lt;/strong&gt; : &lt;strong&gt;디스플레이 설정&lt;/strong&gt;과 &lt;strong&gt;프린트 설정&lt;/strong&gt;에 관한 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;주요 레지스트리 키&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;윈도우 버전 정보&lt;/strong&gt;&lt;br /&gt;
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;컴퓨터 이름&lt;/strong&gt;
HKLM\SYSTEM\ControlSet00X\Control\ComputerName&lt;br /&gt;
\ActiveComputerName&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시작 프로그램 관련&lt;/strong&gt;
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows&lt;br /&gt;
\CurrentVersion\&lt;strong&gt;Run&lt;/strong&gt;,&lt;strong&gt;RunOnce&lt;/strong&gt;,&lt;strong&gt;RunServices&lt;/strong&gt;,&lt;strong&gt;RunServicesOnce&lt;/strong&gt;&lt;br /&gt;
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows&lt;br /&gt;
\CurrentVersion\&lt;strong&gt;Run&lt;/strong&gt;,&lt;strong&gt;RunOnce&lt;/strong&gt;,&lt;strong&gt;RunServices&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;최근에 실행한 명령어 확인&lt;/strong&gt;&lt;br /&gt;
HKU\{USER}\SOFTWARE\Microsoft\Windows\CurrentVersion&lt;br /&gt;
\Explorer\RunMRU&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;하이브hive&quot;&gt;하이브(Hive)&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;하이브 파일&lt;/span&gt;은 &lt;strong&gt;레지스트 정보를 가지고 있는 물리적인 파일을 의미&lt;/strong&gt;한다. 윈도우 레지스트 프로그램(regedit.exe)은 하이브 파일을 읽어서 보여주거나 변경하는 것으로 &lt;strong&gt;레지스트와 관련된 모든 정보는 하이브 파일에 저장&lt;/strong&gt;되어 있다.&lt;/p&gt;

&lt;p&gt;하이브 파일은 일반적인 에디터로 변경하는 것은 불가능하고 &lt;strong&gt;커널에 의해&lt;/strong&gt;서 관리되며 &lt;strong&gt;SAM, SECURITY, SYSTEM, SOFTWARE, Default, NTUSER.DAT 등에 존재&lt;/strong&gt;한다. 이러한 하이브 파일의 목록을 하이브 셋이라고 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SYSTEM&lt;/strong&gt; : &lt;strong&gt;시스템 부팅&lt;/strong&gt;에 필요한 시스템 전역 구성정보를 가지고 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SOFTWARE&lt;/strong&gt; : 시스템 부팅에 필요없는 시스템 전역 구성정보로 소프트웨어 정보를 가지고 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SECURITY&lt;/strong&gt; : 시스템 보안정책과 권한 할당 정보로 &lt;strong&gt;시스템 계정만 접근&lt;/strong&gt;이 가능하다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SAM&lt;/strong&gt; : &lt;strong&gt;로컬 계정 정보와 그룹정보&lt;/strong&gt;로 &lt;strong&gt;시스템 계정만 접근&lt;/strong&gt; 가능&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;HARDWARE&lt;/strong&gt; : 시스템 하드웨어 디스크립션과 모든 하드웨어의 장치 드라이버 매핑 정보를 가지고 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;COMPONENTS&lt;/strong&gt; : 설치된 컴포넌트와 관련된 정보 관리&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BCD00000000&lt;/strong&gt; : 부팅 환경 데이터를 관리하는 것은 과거 &lt;strong&gt;윈도우 XP의 Boot.ini가 없어지고 대체&lt;/strong&gt;되었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;윈도우에서 하이브 파일은 &lt;strong&gt;C:\windows\system32\config&lt;/strong&gt; 디렉터리에 존재한다. 해당 디렉터리에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RegBack&lt;/code&gt;이라는 디렉터리가 존재하는데 이는 &lt;strong&gt;하이브 파일에 대한 백업&lt;/strong&gt;이다.&lt;/p&gt;

&lt;h2 id=&quot;윈도우-이벤트-로그&quot;&gt;윈도우 이벤트 로그&lt;/h2&gt;
&lt;p&gt;윈도우 이벤트 로그는 &lt;strong&gt;윈도우 시스템을 사용하는 동안 발생되는 모든 내용을 발생시간 순으로 기록&lt;/strong&gt;하는 &lt;strong&gt;로그파일&lt;/strong&gt;이다. 이벤트 로그는 이벤트 뷰어라는 관리도구를 사용하여 확인할 수 있으며 이벤트 로그를 기록하고 있는 로그파일은 확장자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.evt&lt;/code&gt; 라는 이름으로 기록되어 있다.&lt;/p&gt;

&lt;p&gt;이벤트 로그는 윈도우에서 발생되는 로그파일을 계속해서 기록하여 모든 로그를 보유하고 있는 것이 아니라 &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;일정한 크기가 되면 덮어쓰는 형태&lt;/strong&gt;&lt;/span&gt;로 기록된다. 이벤트 뷰어 프로그램에서 이벤트 로그파일의 크기를 변경할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;윈도우-로그-종류&quot;&gt;윈도우 로그 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;응용 프로그램 로그&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램 개발자에 의해서 이벤트를 정의하고 분류하여 응용 프로그램에 기록할 이벤트들이 수록된 자료&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;보안 로그&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;관리자에 의해서 보안 로그에 기록된 이벤트 유형을 지정하고, 보안 로그에 기록됨&lt;/li&gt;
      &lt;li&gt;로그온 횟수, 로그인 오류 정보, 파일 생성 및 다른 개체 만들기, 파일 열기 및 삭제 등의 리소스 사용관련 이벤트 기록&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시스템 로그&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;윈도우 시스템에서 사전에 정한 윈도우 시스템 구성요소에서 기록한 이벤트 자료&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;수집된 이벤트 로그는 파일변환을 통해서 엑셀 혹은 SQLite DB에 업로드하거나 Logparse 도구를 사용해서 분석한다.&lt;/p&gt;

&lt;h2 id=&quot;웹-아티펙트-분석&quot;&gt;웹 아티펙트 분석&lt;/h2&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;웹 아티펙트 분석&lt;/span&gt;은 사용자가 웹 사이트를 이용한 흔적을 분석하는 것이다. 웹은 웹브라우저와 웹 서버 간의 양방향 통신으로 이루어지고, &lt;strong&gt;웹에서 할당한 모든 기록을 가지고 와서 분석&lt;/strong&gt;하는 것을 웹 아티펙트 분석이라고 한다.&lt;/p&gt;

&lt;p&gt;웹 아티팩트 분석 대상으로는 웹 브라우저 &lt;span style=&quot;color:orangered&quot;&gt;캐시&lt;/span&gt;가 있는데 웹 브라우저 캐시는 캐시 데이터와 캐시 인덱스 정보로 이루어져 있다. &lt;strong&gt;캐시 데이터&lt;/strong&gt;는 &lt;strong&gt;다운로드 받은 이미지 텍스트 파일, 아이콘 등&lt;/strong&gt;을 가지고 있고 &lt;strong&gt;캐시 인덱스&lt;/strong&gt;는 &lt;strong&gt;다운로드 URL, 다운로드 시간, 데이터 크기 등&lt;/strong&gt;의 정보를 가지고 있다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;히스토리 분석&lt;/span&gt;은 사용자가 방문한 웹 사이트 접속 정보를 저장하는 것으로 월별, 일별 방문 기록을 가지고 있다. &lt;strong&gt;히스토리 정보&lt;/strong&gt;는 &lt;strong&gt;방문 사이트 URL, 방문 시간, 방문 횟수, 사이트 제목 등&lt;/strong&gt;을 가지고 있다.&lt;/p&gt;

&lt;p&gt;웹 브라우저 &lt;span style=&quot;color:orangered&quot;&gt;쿠키&lt;/span&gt;는 &lt;strong&gt;웹 사이트 방문 시 자동으로 사용자 PC에 저장되는 작은 저장 공간&lt;/strong&gt;으로 &lt;strong&gt;자동 로그인 기능, 자주 조회되는 물건 등의 값&lt;/strong&gt;이 있다. 또한 &lt;strong&gt;호스트 정보, 경로, 수정시간, 만료시간&lt;/strong&gt; 등의 값도 있다.&lt;/p&gt;

&lt;p&gt;인터넷 익스플로러에 대한 아티팩트 수집 데이터 위치&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;index.dat&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Win XP, 7&lt;/code&gt;)
    &lt;ul&gt;
      &lt;li&gt;캐시, 히스토리, 쿠키 등의 정보가 &lt;strong&gt;각각 나누어져 별도&lt;/strong&gt;의 index.dat 파일로 구성&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;WebCacheV01.dat / WebCacheV24.dat&lt;/strong&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Win 10&lt;/code&gt;)
    &lt;ul&gt;
      &lt;li&gt;웹 아티팩트 &lt;strong&gt;파일이 통합&lt;/strong&gt;되어서 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 22 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-window-registry-event/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-window-registry-event/</guid>
        
        <category>정보보안기사</category>
        
        <category>Windows</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/윈도우] 윈도우 시스템</title>
        <description>&lt;h2 id=&quot;윈도우-시스템&quot;&gt;윈도우 시스템&lt;/h2&gt;
&lt;p&gt;윈도우 운영체제는 과거 단일 사용자 운영체제인 DOS로부터 시작되어 &lt;strong&gt;GUI(Graph User Interface) 환경 및 다중 사용자, 다중 프로세스 구조를 지원&lt;/strong&gt;하는 운영체제이다. 윈도우는 손쉬운 사용자 인터페이스로 개인용 PC에서 많이 사용된다.&lt;/p&gt;

&lt;p&gt;윈도우 운영체제는 다양한 하드웨어를 자동으로 인식하여 사용할 수 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Plug &amp;amp; Play&lt;/code&gt; 기능을 지원한다. Plug &amp;amp; Plag 란 &lt;strong&gt;하드웨어를 표준화된 인터페이스를 통해서 개발하면 윈도우의 HAL(Hardware Abstraction Layer) 계층이 하드웨어를 인식&lt;/strong&gt;하는 기능이다. 이러한 하드웨어는 윈도우의 운영체제에 해당되는 &lt;strong&gt;Micro Kernel&lt;/strong&gt;이 관리하게 된다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;구성 내용&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;세부 내용&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;HAL&lt;br /&gt;(Hardware Abstraction Layer)&lt;/td&gt;
      &lt;td&gt;새로운 하드웨어가 개발되어 시스템에 장착되어도 드라이버 개발자가 HAL 표준을 준수하면, 파드웨어와 시스템 간 원할한 통신이 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Micro Kernel&lt;/td&gt;
      &lt;td&gt;Manager에게 작업을 분담시키고 하드웨어를 제어&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IO Manager&lt;/td&gt;
      &lt;td&gt;시스템 입출력을 제어, 장치 드라이버 사이에서 메시지 전달, 응용 프로그램이 하드웨어와 통신할 수 있는 통로를 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Object Manager&lt;/td&gt;
      &lt;td&gt;파일, 포트, 프로세스, 스레드와 같은 각 객체에 대한 정보를 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Security Reference Manager&lt;/td&gt;
      &lt;td&gt;데이터 및 시스템 자원의 제어를 허가 및 거부함으로써 강제적으로 시스템의 보안설정을 책임&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Process Manager&lt;/td&gt;
      &lt;td&gt;프로세스 및 스레드를 생성하고 요청에 따른 작업을 처리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Local Procedure Cell&lt;/td&gt;
      &lt;td&gt;프로세스는 서로의 메모리 공간을 침범하지 못하기 때문에 프로세스 간에 통신이 필요한 경우 이를 처리하는 장치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Virtual Memory Manager&lt;/td&gt;
      &lt;td&gt;응용 프로그램의 요청에 따라 RAM 메모리를 할당, 가상 메모리의 Paging을 제어&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Win 32/64 Sub System&lt;/td&gt;
      &lt;td&gt;윈도우의 기본 서버 시스템, 32비트 및 64비트 응용 프로그램이 동작할 수 있도록 지원&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POSIX&lt;/td&gt;
      &lt;td&gt;유닉스 운영체계에 기반을 두고 있는 일련의 표준 운영체제 인터페이스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Security Sub System&lt;/td&gt;
      &lt;td&gt;사용자가 로그인할 때 데이터를 보호하고 운영체제가 이를 제어할 수 있도록 만든 서브 시스템&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;윈도우 파일 시스템의 경우 FAT(File Allocation Table)와 NTFS(NT File System)를 지원한다. FAT은 과거 DOS를 기반으로 하는 파일 시스템으로 작은 파일 시스템에 사용되고 NTFS는 대용량 파일과 긴 파일명, 압축, 저널링 정보를 통한 오류 처리 등을 지원&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;FAT(File Allocation Table)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;FAT16&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;DOS와 윈도우 95의 첫 버전으로 최대 디스크 지원 용량이 2GB&lt;/li&gt;
          &lt;li&gt;NTFS, FAT로 변경 및 변환 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;FAT32&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;2G 이상의 파티션 지원 및 대용량 디스크 지원 기능&lt;/li&gt;
          &lt;li&gt;NTFS로 변환 가능, FAT로 변경 변환은 불가&lt;/li&gt;
          &lt;li&gt;사용되는 운영체제 - 윈도우 95 OSR2, 윈도우 98, 윈도우 2000, 윈도우 XP&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NTFS(NT File System)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;기존 FAT 파일 시스템을 개선하고 윈도우 서버용으로 사용하기 위해서 개발된 파일 시스템&lt;/li&gt;
      &lt;li&gt;파일 암호화 및 파일 레벨 보안 지원&lt;/li&gt;
      &lt;li&gt;디스크 압축 및 파티션 단위로 쿼터&lt;/li&gt;
      &lt;li&gt;FAT16이나 FAT32로 변환 불가&lt;/li&gt;
      &lt;li&gt;사용되는 운영체제 - 윈도우 NT, 윈도우 2000, 윈도우 XP&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;USN 저널&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Update Sequence Number Journal&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;저널링 기능을 제공&lt;/strong&gt;하는 것으로 파일 시스템이 &lt;strong&gt;변경될 때 그 내용을 기록하여 복구&lt;/strong&gt;할 수 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ADS&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Alternate Data Stream&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;MAC 파일 시스템과 호환성&lt;/strong&gt;을 위해서 만든 공간으로 다중 데이터 스트림을 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Sparse 파일&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;파일 데이터가 대부분 0일 경우에 실제 데이터 기록 없이 정보를 기록하는 기능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;파일 압축&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;LZ77의 변형된 데이터 압축 알고리즘 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;VSS&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Volume Shadow Copy Service&lt;/li&gt;
          &lt;li&gt;덮어써진 파일과 디렉터리 백업을 유지하여 복구 기능을 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;EFS&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Encryting File System&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;대칭키 기법&lt;/strong&gt;으로 파일 데이터를 &lt;strong&gt;암호화&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Quotas&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;사용자별 디스크 사용 용량을 제한 가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Unicode&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;다국어 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;동적 Bad 클러스터 할당&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Bad Sector가 발생한 클러스터를 자동으로 재할당&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;대용량 지원&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;2TB&lt;/strong&gt;가 넘는 대용량 볼륨 지원&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ntfs-파일-시스템-구성&quot;&gt;NTFS 파일 시스템 구성&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;VBR(Volume Boot Record)&lt;/strong&gt;&lt;br /&gt;
NTFS 파일 시스템의 제일 처음에 있는 것으로 &lt;strong&gt;부트섹터, 부트코드, NTLDR&lt;/strong&gt; 위치 등의 정보를 가지고 있다. VBR의 부트섹터는 섹터 0번에 존재한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;MFT(Master File Table)&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;NTFS의 메타정보, 파일 및 디렉터리 등의 정보를 관리&lt;/strong&gt;하는 파일로 파일 위치, 속성, 시간정보, 파일명, 크기 등의 정보를 가지고 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Data Area&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;윈도우-인증-시스템&quot;&gt;윈도우 인증 시스템&lt;/h3&gt;
&lt;p&gt;winlogon은 내부적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;megina.dll&lt;/code&gt;이라는 GINA 프로그램을 구동시키며 검증을 위해서 아이디를 LSA에 전달한다. NTLM 값과 SAM에 저장된 NTLM 값을 비교하여 같으면 SRM에게 권한을 부여한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/windows/windows-authority.png&quot; title=&quot;https://m.blog.naver.com/PostView.naver?blogId=darkness76&amp;amp;logNo=60201244303&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F&quot;&gt;&lt;img src=&quot;../../assets/images/security/windows/windows-authority.png&quot; alt=&quot;&quot; title=&quot;윈도우 인증 프로세스&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/security/windows/windows-authority-role.png&quot; title=&quot;https://m.blog.naver.com/PostView.naver?blogId=darkness76&amp;amp;logNo=60201244303&amp;amp;proxyReferer=https:%2F%2Fwww.google.com%2F&quot;&gt;&lt;img src=&quot;../../assets/images/security/windows/windows-authority-role.png&quot; alt=&quot;&quot; title=&quot;윈도우 인증 프로세스 역할&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;인증 프로세스 구성요소&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Winlogon&lt;/strong&gt;&lt;br /&gt;
윈도우 로그인 프로세스. 윈도우 시작 시 자동으로 초기화되어 실행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GINA(msgina.dll)&lt;/strong&gt;&lt;br /&gt;
Winlogon은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msgina.dll&lt;/code&gt;을 로딩하여 사용자가 입력한 &lt;strong&gt;계정과 암호를 LSA에게 전달&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LSA(Local Security Authority, lsass.exe에서 관리)&lt;/strong&gt;&lt;br /&gt;
모든 계정의 &lt;strong&gt;로그인에 대한 검증&lt;/strong&gt;&lt;br /&gt;
시스템 자원 및 파일 등에 대한 &lt;strong&gt;접근 권한을 검사&lt;/strong&gt;&lt;br /&gt;
계정과 암호를 검증하기 위해서 NTLM(암호화) 모듈을 로딩하고 계정을 검증&lt;br /&gt;
SRM이 작성한 감사로그를 기록&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SAM(Security Account Manager)&lt;/strong&gt;&lt;br /&gt;
사용자 계정 정보(해시 값)에 저장&lt;br /&gt;
사용자의 로그인 입력 정보와 SAM 데이터베이스 &lt;strong&gt;정보를 비교하여 인증 여부를 결정&lt;/strong&gt;하도록 해준다.&lt;/p&gt;

    &lt;p&gt;리눅스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/shadow&lt;/code&gt; 파일과 같은 역할을 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SRM(Security Reference Monitor)&lt;/strong&gt;&lt;br /&gt;
SAM이 사용자의 계정과 패스워드가 일치하는 지를 확인하여 SRM에게 알려주면 SRM은 사용자에게 고유의 SID를 부여하고 SID에 권한 부여&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;윈도우-실행-프로세스&quot;&gt;윈도우 실행 프로세스&lt;/h3&gt;
&lt;p&gt;윈도우 운영체제 관련 프로세스는 wininit.exe, services.exe, lsm.exe, winlogon.exe 등이 있으며 &lt;strong&gt;C:\windows\system32&lt;/strong&gt; 폴더에 위치한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;프로세스&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;wininit.exe&lt;/td&gt;
      &lt;td&gt;윈도우 시작 프로그램&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;services.exe&lt;/td&gt;
      &lt;td&gt;윈도우 서비스 관리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lsm.exe&lt;/td&gt;
      &lt;td&gt;Local Session Manager&lt;br /&gt;&lt;br /&gt;시스템 관리 작업, 주요 함수 실행, 호스트 컴퓨터와 서버의 연결을 관리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lsass.exe&lt;/td&gt;
      &lt;td&gt;Local Security Authority Subsystem Service&lt;br /&gt;&lt;br /&gt;사용자 로그인 검사, 비밀번호 변경 관리, 액세스 토큰 생성&lt;br /&gt;Windows Security Log를 작성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;svchost.exe&lt;/td&gt;
      &lt;td&gt;서비스를 관리하기 위한 프로세스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;conhost.exe&lt;/td&gt;
      &lt;td&gt;키보드, 마우스 입력 허용, 문자 출력, 콘솔 API 등 셀의 기본 기능 수행&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;윈도우-계정&quot;&gt;윈도우 계정&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Users&lt;/strong&gt; : 기본적인 권한은 가지고 있지 않지만 Domain Users 글로벌 그룹이 구성원으로 포함되어 있음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Account Operators&lt;/strong&gt; : 서버 관리자를 사용하여 컴퓨터를 도메인 추가 가능하며, 사용자 계정, 그룹의 생성 및 삭제, 수정할 수 있는 권한을 가지고 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Printer Operators&lt;/strong&gt; : 도메인 컨트롤러에 있는 프린터를 생성 및 관리&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Server Operators&lt;/strong&gt; : 도메인 컨트롤러에 있는 자원을 공유하거나 폴더를 백업하고 복구&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;유니버설 그룹&lt;/strong&gt;은 &lt;strong&gt;복수의 도메인 환경에서 상호 관련되어 있는 자원에 대한 허가를 부여할 때 주로 사용&lt;/strong&gt;한다. 도메인 내의 로컬 그룹과 유니버설 그룹의 구성원이 될 수 있다. 성능 저하를 초래할 수 있으므로 꼭 필요할 때에만 사용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;유니버설 그룹 계정&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Administrators&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 컴퓨터의 모든 관리 권한과 사용 권한을 보유&lt;/li&gt;
      &lt;li&gt;기본적으로 Administrator가 사용자 계정과 Domain Admins를 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Users&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;기본적인 권한은 갖지 않음&lt;/li&gt;
      &lt;li&gt;컴퓨터에서 생성되는 로컬 사용자 계정 포함&lt;/li&gt;
      &lt;li&gt;Domain Users 글로벌 그룹이 구성원으로 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Guest&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;관리자에 의해 허락된 자원과 권한만을 사용하여 네트워크 자원에 접근 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Backup Operators&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Windows 백업을 이용하여 모든 도메인의 컨트롤러에 있는 파일과 폴더를 백업하고 복구할 수 있는 권한이 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Power Users&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;컴퓨터에서 로컬 사용자 &lt;strong&gt;계정을 생성하고 수정&lt;/strong&gt;할 수 있는 권한을 갖고 있으며 &lt;strong&gt;자원을 공유하거나 멈출 수 있다&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;시스템에 대한 전체 권한은 없지만 &lt;strong&gt;시스템을 관리할 수 있는 권한&lt;/strong&gt;이 부여된 그룹&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;공유-파일&quot;&gt;공유 파일&lt;/h3&gt;
&lt;p&gt;윈도우의 공유 폴더 기능은 자신의 컴퓨터에 잇는 폴더를 다른 컴퓨터와 공유할 수 있는 기능으로 자료를 같이 공유하면서 업무를 처리할 때 아주 유용한 기능이다. 하지만, 정보보안에서는 공유 폴더를 통해서 악성코드를 유포하거나 시스템 정보를 획득할 수 있기 때문에 삭제를 권고한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공유 폴더 목록 확인 : &lt;strong&gt;net share&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;IPC$&lt;/strong&gt; : 네트워크 프로그램 간에 통신을 위해서 파이프를 사용하고 네트워크 &lt;strong&gt;서버 원격관리를 위해서 사용&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;공유 폴더 삭제 : &lt;strong&gt;/delete&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 21 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-window-system/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-window-system/</guid>
        
        <category>정보보안기사</category>
        
        <category>Windows</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/리눅스] 로그 파일 및 주요 명령어</title>
        <description>&lt;h2 id=&quot;로그-파일&quot;&gt;로그 파일&lt;/h2&gt;
&lt;p&gt;사용자가 네트워크를 경유해서 리눅스 운영체제에 접속하고 로그인 후 어떤 명령 등을 실행하면 리눅스 운영체제는 &lt;strong&gt;사용자의 터미널 정보, 실행한 명령어, 로그인과 로그아웃 정보 등을 모두 로그파일에 기록&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;로그파일은 공격자가 임의적으로 시스템에 접근하여 어떤 작업을 수행했는지 알 수 있는 것으로 침해사고 발생 시 누가 무엇을 수행했는지 증명하는 책임추적성 역할을 수행한다.&lt;/p&gt;

&lt;p&gt;로그 파일이라는 것은 &lt;strong&gt;파일에 불과하기 때문에 어떤 로그 파일도 공격자에 의해서 조작될 수 있으므로&lt;/strong&gt; 하나의 로그 파일을 보고 침해 사고를 분석하는 것이 아니라 여러 개의 로그 파일을 종합적으로 분석해서 판단해야 한다.&lt;/p&gt;

&lt;p&gt;리눅스의 로그파일은 기본적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/log&lt;/code&gt; 라는 디렉터리에 존재한다.&lt;/p&gt;

&lt;h3 id=&quot;현재-로그인-사용자-확인&quot;&gt;현재 로그인 사용자 확인&lt;/h3&gt;
&lt;p&gt;리눅스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w&lt;/code&gt; 혹은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;who&lt;/code&gt; 명령을 실행하면 현재 로그인 한 사용자 정보를 확인할 수 있다. 즉, 리눅스에서 &lt;strong&gt;로그인 사용자 ID, 사용 터미널, 로그인 시간 등을 확인&lt;/strong&gt;할 수 있다.&lt;/p&gt;

&lt;p&gt;현재 로그인한 사용자 정보는 로그인을 수행할 때 &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;utmp&lt;/strong&gt;&lt;/span&gt; 라는 파일에 로그인 정보가 기록된다. utmp 파일은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/run/utmp&lt;/code&gt;에 존재한다.&lt;/p&gt;

&lt;p&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;who&lt;/code&gt; 명령은 &lt;strong&gt;utmp 파일을 읽어서 터미널에 출력&lt;/strong&gt;해주는 역할을 수행하는 것이고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;utmp&lt;/code&gt; 파일은 &lt;strong&gt;현재 로그인 한 사용자의 정보&lt;/strong&gt;를 가지고 있는 것이다.&lt;/p&gt;

&lt;p&gt;utmp 파일에 대한 정보는 &lt;strong&gt;stat 명령을 실행&lt;/strong&gt;해서 확인할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;사용자의-로그인-및-로그아웃-정보-확인&quot;&gt;사용자의 로그인 및 로그아웃 정보 확인&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;wtmp&lt;/strong&gt;&lt;/span&gt; 로그 파일은 &lt;strong&gt;사용자의 로그인과 로그아웃 정보를 가지고 있는 로그 파일&lt;/strong&gt;로 접속 정보를 &lt;strong&gt;계속 기록&lt;/strong&gt;하는 파일이다. wtmp 파일은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/log&lt;/code&gt; 디렉터리에 존재하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last&lt;/code&gt; 명령을 사용하여 wtmp 파일을 읽을 수 있다.&lt;/p&gt;

&lt;p&gt;또한 wtmp 파일은 로그인과 로그아웃 정보 이외에도 시스템 관련 정보를 포함하고 있기 때문에 침해사고 분석 시 중요한 로그파일 중 하나이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 로그인 및 로그아웃 정보&lt;/li&gt;
  &lt;li&gt;시스템 관련 정보&lt;/li&gt;
  &lt;li&gt;시스템 종료 및 부팅 정보&lt;/li&gt;
  &lt;li&gt;재부팅 정보&lt;/li&gt;
  &lt;li&gt;telnet 및 ftp 등을 통한 로그인 정보&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;로그인-실패-정보-확인&quot;&gt;로그인 실패 정보 확인&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;btmp&lt;/strong&gt;&lt;/span&gt; 로그 파일은 리눅스 &lt;strong&gt;로그인 시 실패한 정보를 가지고 있는 로그 파일&lt;/strong&gt;이다. 해당 로그 파일은 바이너리로 되어 있기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lastb&lt;/code&gt; 명령어를 실행하여 확인해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;syslog-사용하기&quot;&gt;syslog 사용하기&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;syslog&lt;/strong&gt;&lt;/span&gt;는 리눅스 &lt;strong&gt;운영체제에 대한 로그를 기록하는 데몬 프로세스&lt;/strong&gt;로 syslogd라는 프로그램에 의해서 로그를 기록한다. syslogd 프로세스가 실행되면 syslogd의 설정 파일인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/syslogd.conf&lt;/code&gt; 파일을 읽어서 로그를 기록할 수준을 결정한다.&lt;/p&gt;

&lt;p&gt;즉, 로그를 기록하는 수준이라는 것은 위험성에 따라 분류하여 어디까지 로그파일을 기록할 것인지를 결정하는 것이다.&lt;/p&gt;

&lt;p&gt;syslogd 프로세스에 의해서 &lt;strong&gt;기록되는 로그파일은 /var/log&lt;/strong&gt; 디렉터리에 존재하며 &lt;strong&gt;syslogd.conf 파일&lt;/strong&gt;은 syslogd 데몬 프로세스가 어떤 로그를 기록하고 각각의 로그파일은 어느 디렉터리에 기록할 것인지를 정의하는 &lt;strong&gt;설정파일&lt;/strong&gt;이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;syslog 주체별 분류(Facility)&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;종류&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;내용&lt;/strong&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;kern&lt;/td&gt;
          &lt;td&gt;kernel에서 요청하는 경우 로그를 기록&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;mail&lt;/td&gt;
          &lt;td&gt;mail subsystem 요청하는 경우 로그를 기록&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;lpr&lt;/td&gt;
          &lt;td&gt;Pringing subsystem에서 요청하는 경우 로그를 기록&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;daemon&lt;/td&gt;
          &lt;td&gt;System server processes에서 요청하는 경우 로그를 기록&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;auth&lt;/td&gt;
          &lt;td&gt;Login authentication system에서 요청하는 경우 로그를 기록&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;시스템 위험성에 따른 syslog 유형&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;위험성 강도 순서&lt;/strong&gt; : emerg &amp;gt; alert &amp;gt; crit &amp;gt; err &amp;gt; warn &amp;gt; notice &amp;gt; info &amp;gt; debug&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;위험강도&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;내용&lt;/strong&gt;&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;emerg&lt;/td&gt;
          &lt;td&gt;가장 위험성이 높고 긴급하며 심각한 상황을 모든 사용자에게 경보하는 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;alert&lt;/td&gt;
          &lt;td&gt;변조된 시스템 데이터베이스 등과 같이 곧바로 정정해야만 하는 것으로 즉시 주의를 요하는 심각한 에러가 발생한 경우의 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;crit&lt;/td&gt;
          &lt;td&gt;H/W나 디바이스와 관련하여 심각한 오류 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;err&lt;/td&gt;
          &lt;td&gt;일상적으로 발생할 수 있는 에러 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;warn&lt;/td&gt;
          &lt;td&gt;시스템 수행 시 주의사항 및 경고 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;notice&lt;/td&gt;
          &lt;td&gt;에러 상태는 아니나, 특수한 방법으로 수행해야 할 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;info&lt;/td&gt;
          &lt;td&gt;도움말 등의 정보가 있는 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;debug&lt;/td&gt;
          &lt;td&gt;오류를 검출하거나 해결 시 도움이 될 만한 외부 정보들을 표시하는 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;none&lt;/td&gt;
          &lt;td&gt;로깅 주체에서 무시하는 정보 메시지&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;mark&lt;/td&gt;
          &lt;td&gt;메시지 생성 시간을 결정하는 메시지(기본값 = 15분)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주요-명령어&quot;&gt;주요 명령어&lt;/h2&gt;
&lt;h3 id=&quot;작업-스케줄-관리&quot;&gt;작업 스케줄 관리&lt;/h3&gt;
&lt;h4 id=&quot;cron&quot;&gt;cron&lt;/h4&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;cron&lt;/strong&gt;&lt;/span&gt;은 &lt;strong&gt;일정한 날짜와 시간에 지정된 작업을 실행하는 프로세스로 반복적인 작업을 수행&lt;/strong&gt;할 때 사용한다. cron 프로세스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/crontab&lt;/code&gt; 파일에 설정된 것을 읽어서 작업을 수행한다.&lt;/p&gt;

&lt;p&gt;정보보안에서 cron이 중요한 이유는 두 가지가 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;보안 취약점 검사를 수행할 때 매일 반복적으로 점검이 가능하다&lt;/li&gt;
  &lt;li&gt;공격자가 악성코드를 실행하는 명령을 crontab에 설정해서 반복적으로 악성코드를 실행할 수 있다&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;crontab 파일구조&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;분(m)&lt;/strong&gt; : 0 ~ 59&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;시(h)&lt;/strong&gt; : 0 ~ 23&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;일(dom)&lt;/strong&gt; : 1 ~ 31&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;월(mon)&lt;/strong&gt; : 1 ~ 12&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;요일(dow)&lt;/strong&gt; : 일요일(0) ~ 토요일(6)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;사용자(user)&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;실행명령(command)&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;crontab 옵션&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-l&lt;/td&gt;
      &lt;td&gt;현재 로그인 된 계정에 잡혀있는 작업 스케쥴 확인&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-e&lt;/td&gt;
      &lt;td&gt;현재 로그인 중인 계정에 작업을 등록&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r&lt;/td&gt;
      &lt;td&gt;현재 crontab에 등록된 작업을 삭제&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u [유저명]&lt;/td&gt;
      &lt;td&gt;작업을 실행시킬 유저명 설정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;at&quot;&gt;at&lt;/h4&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;at&lt;/strong&gt;&lt;/span&gt;은 cron과 다르게 예약한 명령어를 정해진 시간에 한 번만 실행할 때 사용하는 명령어이다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;at 옵션&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-l&lt;/td&gt;
      &lt;td&gt;현재 실행 대기 중인 명령의 목록을 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r&lt;/td&gt;
      &lt;td&gt;실행 대기 중인 명령에서 해당 작업번호를 삭제&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-f&lt;/td&gt;
      &lt;td&gt;표준 입력 대신 실행할 명령을 파일로 저장&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;악성코드-탐지&quot;&gt;악성코드 탐지&lt;/h3&gt;
&lt;h4 id=&quot;리다이렉션redirection&quot;&gt;리다이렉션(Redirection)&lt;/h4&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;리다이렉션&lt;/strong&gt;&lt;/span&gt;은 &lt;strong&gt;표준 스트림으로 사용자가 지정한 곳을 변경&lt;/strong&gt;할 수 있는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어 명령어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 파일로 입력하면 &lt;strong&gt;명령어의 결과가 파일에 저장&lt;/strong&gt;된다. 즉 ps &amp;gt; A.txt 를 실행하면 ps 정보로 출력되는 프로세스 정보가 A.txt 라는 파일에 기록된다. 만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&lt;/code&gt; 로 입력한다면 &lt;strong&gt;파일에 추가&lt;/strong&gt;하라는 의미이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;종류&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;=1&amp;gt;와 같은 것으로 1의 의미는 표준출력. 출력 방향 전환으로 파일이 존재하면 덮어쓴다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;=1»와 같은 의미로 표준출력에 추가한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;lt;&lt;/td&gt;
      &lt;td&gt;출력 방향 전환으로 파일이 존재하면 덮어쓴다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;«&lt;/td&gt;
      &lt;td&gt;표준 출력에 추가한다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;파이프pipe&quot;&gt;파이프(Pipe)&lt;/h4&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;파이프&lt;/strong&gt;&lt;/span&gt;는 어떤 명령어의 실행 결과를 다른 명령어의 입력으로 전달하는 것으로 명령어 1 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; 명령어 2 형태로 사용한다&lt;/p&gt;

&lt;h3 id=&quot;find-명령어&quot;&gt;find 명령어&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;find&lt;/strong&gt;&lt;/span&gt; 명령은 특정 파일명이나 특정 권한이 부여된 파일을 찾을 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;파일명&lt;/strong&gt;으로 파일을 검색한다. 알려진 공격 파일을 찾을 수도 있으며 특히, Web Shell 중에서 알려진 파일 등을 확인할 수 있다
    &lt;blockquote&gt;
      &lt;p&gt;EX1) find . -name “[A-Z]&lt;em&gt;” : 현재 디렉터리에서 파일명의 첫 글자가 영문자 대문자인 것을 검색&lt;br /&gt;
EX2) find . -name “&lt;/em&gt; *” -exec rm -f {}\; : 현재 디렉터리에서 파일 이름에 공백이 들어간 모든 문자를 삭제&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;특정 권한이 부여된 파일을 검색&lt;/strong&gt;하여 파일에 특수 권한이 부여되어 있거나, 실행권한을 가지고 있는 파일을 찾을 수 있다
    &lt;ul&gt;
      &lt;li&gt;권한을 가질 파일을 찾을 때는 가장 먼저 setuid, setgid 등의 &lt;strong&gt;특수 권한이 부여된 것을 찾아야&lt;/strong&gt; 한다. setuid(4000), setgid(2000), sticky bit(1000)의 권한이 부여되었으며 만약, setuid와 setgid 모두가 부여된 것을 찾기 위해서는 6000(4000+2000)으로 검색하면 된다.
        &lt;blockquote&gt;
          &lt;p&gt;EX) find / &lt;strong&gt;-perm&lt;/strong&gt; +6000&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특정 &lt;strong&gt;시간 이후에 변경된 파일을 찾아서&lt;/strong&gt; 침입 이후에 변경된 파일 리스트를 확인할 수 있다
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;-atime&lt;/strong&gt; : Access Time으로 파일을 열거나 접근한 시간을 기준으로 검색&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;-mtime&lt;/strong&gt; : Modify Time으로 파일이 변경된 시간으로 검색&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;-ctime&lt;/strong&gt; : Change Time으로 파일 속성이 변경된 시간을 기준으로 검색
        &lt;blockquote&gt;
          &lt;p&gt;EX1) find / -mtime +5 : 최근 5일 동안 변경되지 않은 파일 검색&lt;br /&gt;
EX2) find / -mtime -1 : 24시간 동안 변경된 파일 검색&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;특정 사용자가 소유자인 파일 검색&lt;/strong&gt;. 파일의 &lt;strong&gt;소유자를 기준으로 파일&lt;/strong&gt;을 찾기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 옵션을 사용하면 된다. &lt;strong&gt;소유자가 없는 파일&lt;/strong&gt;을 찾을 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nouser&lt;/code&gt; 옵션을 이용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;파일-무결성integrity-검사&quot;&gt;파일 무결성(Integrity) 검사&lt;/h3&gt;
&lt;p&gt;단순하게 시간을 기준으로 파일이 변경되었는지 확인하기는 어렵다. 파일 시간은 얼마든지 변조가 가능하기 때문에 시간만으로 파일 변경 여부를 확인할 수 없다.&lt;/p&gt;

&lt;p&gt;파일의 무결성 검사를 위해서는 &lt;strong&gt;초기 상태의 파일 정보에 대해서 해시 값을 저장&lt;/strong&gt;하고 원하는 시점에 초기의 해시 값과 &lt;strong&gt;비교해서 변경 여부를 확인&lt;/strong&gt;한다. 해시 값을 사용해서 파일의 무결성을 검사하는 도구로는 &lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;tripwire&lt;/strong&gt;&lt;/span&gt;가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;tripwire –&lt;strong&gt;init&lt;/strong&gt; : 해시 값을 저장한 데이터베이스 초기화&lt;/li&gt;
  &lt;li&gt;tripwire –&lt;strong&gt;check&lt;/strong&gt; : 무결성 검사를 실행&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 21 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-linux-log/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-linux-log/</guid>
        
        <category>정보보안기사</category>
        
        <category>Linux</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/리눅스] 방화벽</title>
        <description>&lt;h2 id=&quot;방화벽&quot;&gt;방화벽&lt;/h2&gt;
&lt;h3 id=&quot;iptables&quot;&gt;iptables&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;iptables&lt;/span&gt;는 리눅스에서 &lt;strong&gt;방화벽 정책을 수립할 수 있는 도구&lt;/strong&gt;로 iptables를 사용하는 경우 다음과 같은 방화벽 정책을 수립해서 패킷 필터링을 할 수 있다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;모든 것을 허용한 후에 일부 패킷을 제한한다&lt;/li&gt;
  &lt;li&gt;모든 것을 거부한 후에 일부 패킷을 허용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;iptables의 체인은 외부에서 리눅스 시스템으로 유입되는 패킷과 리눅스 내부에서 외부로 전송되는 패킷에 대해서 접근 제어를 생성할 수 있다&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;iptables 체인 종류&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;INPUT&lt;/strong&gt; : 리눅스로 들어오는 패킷(입력 패킷)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FORWARD&lt;/strong&gt; : INPUT과 OUTPUT 역할, 라우터에 방화벽을 적용할 때 사용한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OUTPUT&lt;/strong&gt; : 외부로 나가는 패킷(출력 패킷)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;iptables 사용법&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;iptables [-t table] command [match] [target\jump]&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;A&lt;/strong&gt;(–append) : 규칙을 추가&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;D&lt;/strong&gt;(–delete) : 규칙을 삭제&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;N&lt;/strong&gt;(–new-chain) : 새로운 체인 생성&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;X&lt;/strong&gt;(–delete-chain) : 체인 제거&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;P&lt;/strong&gt;(–policy) : 체인 기본정책 변경&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;L&lt;/strong&gt;(–list) : 체인의 규칙 상태 보기&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;F&lt;/strong&gt;(–flush) : 체인 내의 모든 규칙 제거(&lt;strong&gt;방화벽 초기화&lt;/strong&gt;)&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;Z&lt;/strong&gt;(–zero) : 체인 내의 모든 규칙의 패킷과 바이트의 카운트를 0으로 초기화&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;R&lt;/strong&gt;(–replace) : 새로운 규칙으로 대체&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;I&lt;/strong&gt;(–insert) : 체인의 가장 처음에 규칙을 추가&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;E&lt;/strong&gt;(–rename-chain) : 체인의 이름을 변경&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;iptables에 등록된 정보는 &lt;strong&gt;INPUT, FORWARD, OUTPUT 체인 별&lt;/strong&gt;로 확인할 수 있는데 이 때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iptables -L&lt;/code&gt;을 사용하면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용 예제
    &lt;ul&gt;
      &lt;li&gt;loopback 패킷 차단
        &lt;blockquote&gt;
          &lt;p&gt;iptables -A OUTPUT -o lo -j DROP&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;등록된 체인 삭제
        &lt;blockquote&gt;
          &lt;p&gt;iptables -F OUTPUT&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ifconfig&quot;&gt;ifconfig&lt;/h3&gt;
&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;ifconfig&lt;/span&gt; 명령어는 &lt;strong&gt;네트워크 인터페이스 정보를 확인하거나 네트워크 인터페이스를 시작, 종료&lt;/strong&gt;할 수 있다. 리눅스에서 ifconfig 명령어를 입력하면 네트워크 인터페이스를 확인할 수 있는데, 일반적으로 &lt;strong&gt;eth0, lo&lt;/strong&gt; 두 개의 인터페이스가 확인된다. 여기서 &lt;strong&gt;lo 인터페이스는 Loopback 주소&lt;/strong&gt;로 자기 자신의 주소로 사용되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt;의 주소가 할당되어 있다&lt;/p&gt;

</description>
        <pubDate>Fri, 21 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-linux-firewall/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-linux-firewall/</guid>
        
        <category>정보보안기사</category>
        
        <category>Linux</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[에픽게임즈/Epic Games] 시작되는 2021 에픽스토어 메가세일과 무료 배포 게임(5/21)</title>
        <description>&lt;p&gt;생각보다는 일찍 이번 상반기에도 에픽에서 메가 세일을 진행하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/hobby/games/epic-mega-sale.png&quot;&gt;&lt;img src=&quot;../../assets/images/hobby/games/epic-mega-sale.png&quot; alt=&quot;&quot; title=&quot;에픽 메가 세일&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;메가 세일 기간은 글을 작성하는 오늘(&lt;strong&gt;5/21&lt;/strong&gt;)일자부터 &lt;strong&gt;6/17&lt;/strong&gt;(목요일)까지 입니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/hobby/games/epic-mega-sale-coupon.png&quot;&gt;&lt;img src=&quot;../../assets/images/hobby/games/epic-mega-sale-coupon.png&quot; alt=&quot;&quot; title=&quot;크레딧 지급&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11,000&lt;/code&gt;원의 상당한 쿠폰을 같이 배포하는데 신작, 별도 할인과 구분없이 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;15,000&lt;/code&gt;원 이상의 게임을 구매할 때 사용&lt;/strong&gt;할 수 있으며 구매 즉시 해당 상품권을 다시 자동으로 회수하여 사용할 수 있습니다(이론 상 무한정!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;몇 달 전에는 GTA5를 비롯하여 명작게임들을 무료로 배포한 전적이 있죠.&lt;/p&gt;

&lt;p&gt;지금까지 그래왔듯이 &lt;strong&gt;금요일 매주 미스터리 게임이 무료&lt;/strong&gt;로 제공됩니다.&lt;/p&gt;

&lt;p&gt;기존과 다른점이 있다면 저번 겨울때처럼 미리 공개를 하지 않는다는 거네요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;5/21일자의 무료 게임은 [&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NBA 2K21&lt;/code&gt;&lt;/strong&gt;] 이며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5/28&lt;/code&gt;(다음주 금요일) 자정전까지 무료로 받을 수 있습니다.&lt;/p&gt;

&lt;p&gt;스포츠 게임을 그리 좋아하지 않는 저로서는 아마 하지는 않을 것 같지만 무료로 배포하는 거니까 일단 라이브러리에 담아 놓았습니다.&lt;/p&gt;

&lt;p&gt;다음 주에는 어떤 게임을 배포할 지 매우 궁금하네요 :)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/hobby/games/05-21-epic-free-game.png&quot;&gt;&lt;img src=&quot;../../assets/images/hobby/games/05-21-epic-free-game.png&quot; alt=&quot;&quot; title=&quot;2021/05/21 에픽 무료 배포 게임 - NBA2K21&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;다음 주에도 무료 배포 게임과 함께 포스팅하겠습니다&lt;/p&gt;

&lt;p&gt;모두 라이브러리 채워놓을 준비합시다!&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;이 글은 순전히 정보 전달 목적으로 작성되었으며 일절 비용을 받지 않았습니다.&lt;/p&gt;
</description>
        <pubDate>Fri, 21 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/hobby/games-epic-free-week-0521/</link>
        <guid isPermaLink="true">https://many258.github.io/hobby/games-epic-free-week-0521/</guid>
        
        <category>Games</category>
        
        
        <category>hobby</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/리눅스] 리눅스 부팅(Booting)</title>
        <description>&lt;h2 id=&quot;boot-master&quot;&gt;Boot Master&lt;/h2&gt;
&lt;p&gt;컴퓨터 시스템에 전원이 들어왔을 때 가장 처음 하는 것은 &lt;strong&gt;보조 기억 장치에 있는 운영체제의 커널을 주기억 장치에 적재&lt;/strong&gt;하는 작업이다. 이렇게 보조 기억 장치에 있는 커널을 주기억 장치에 올리는 것은 &lt;strong&gt;로더&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Loader&lt;/code&gt;)라는 프로그램이 수행한다&lt;/p&gt;

&lt;p&gt;리눅스에서 이러한 로더의 역할을 수행하는 것이 &lt;span style=&quot;color:orangered&quot;&gt;LILO(LInux LOader)&lt;/span&gt;이다. 즉, LILO는 리눅스의 부트로더이다. LILO는 실행 시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/lilo.conf&lt;/code&gt; 라는 파일을 읽어 들여서 실행된다&lt;/p&gt;

&lt;p&gt;최근에는 리눅스 부팅에 LILO보다는 &lt;span style=&quot;color:orangered&quot;&gt;GRUB&lt;/span&gt; 이라는 부트로드를 사용한다. GRUB은 로더의 역할을 수행하는 것으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/boot/grub/grub.conf&lt;/code&gt; 설정파일을 읽어서 가동된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GRUB&lt;/code&gt;의 특징&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;부트정보를 사용자가 임의로 변경할 수 있음&lt;/li&gt;
      &lt;li&gt;여러 운영체제를 사용할 수 있는 멀티부팅 지원&lt;/li&gt;
      &lt;li&gt;커널 경로 및 파일명만 알고 있다면 부팅이 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;/boot/grub/grub.conf 설정 값&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;default=0&lt;/td&gt;
      &lt;td&gt;부트 순서를 지정하는 번호로 멀티부트의 경우 운영체제 레이블 번호를 선택&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;timeout=0&lt;/td&gt;
      &lt;td&gt;지정된 시간이 경과되면 default로 지정된 운영체제로 부팅&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;splashimg=(hd0,0)&lt;br /&gt;/grub/splash.xpm.gz&lt;/td&gt;
      &lt;td&gt;부팅 이미지를 지정하는 부분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hiddenmenu&lt;/td&gt;
      &lt;td&gt;부트로더를 보여주지 않음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;title Fedora&lt;/td&gt;
      &lt;td&gt;부팅되는 부트 엔트리를 의미&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;부팅-순서&quot;&gt;부팅 순서&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;리눅스의 서버 전원을 켜면 &lt;strong&gt;ROM BIOS를 읽고 디스크의 MBR(Master Boot Record)에 있는 부트로더가 실행&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;부트로더는 보조 기억 장치에 저장되어 있는 &lt;strong&gt;리눅스 커널을 찾고 실행&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;리눅스 커널은 하드웨어를 확인하고 &lt;strong&gt;root의 읽기 전용&lt;/strong&gt;으로 마운트를 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디스크 검사&lt;/strong&gt;하고 &lt;strong&gt;root의 쓰기 전용&lt;/strong&gt;으로 다시 마운트 수행&lt;/li&gt;
  &lt;li&gt;리눅스 커널은 &lt;strong&gt;init 프로세스를 실행하고 PID 1번&lt;/strong&gt;을 할당&lt;/li&gt;
  &lt;li&gt;init 프로세스는 자신의 설정파일인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/initab&lt;/code&gt; 파일을 읽어서 디바이스 및 프로세스를 활성화&lt;/li&gt;
  &lt;li&gt;init 프로세스의 작업 수행은 리눅스의 &lt;strong&gt;Run 레벨에 따라 다르게 부팅&lt;/strong&gt;된다&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;run-level&quot;&gt;Run Level&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;0&lt;/strong&gt; : &lt;strong&gt;PROM&lt;/strong&gt; 감사 단계&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;1&lt;/strong&gt; : 관리상태의 단계. 사용자 로그인의 접근이 불가능한 단일 사용자 단계로 여러 개의 파일 시스템이 로드되어 있음. &lt;strong&gt;암호를 변경할 때 사용&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;2&lt;/strong&gt; : &lt;strong&gt;공유된 자원을 갖지 않은 다중 사용자&lt;/strong&gt; 단계&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;3&lt;/strong&gt; : 기본 실행 단계로 &lt;strong&gt;공유 자원을 가진 다중 사용자 단계&lt;/strong&gt;, 텍스트 유저 모드&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;4&lt;/strong&gt; : &lt;strong&gt;현재 사용되지 않음&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;5&lt;/strong&gt; : Level3 으로 기동 후에 그래픽 모드인 &lt;strong&gt;X-Windows 실행&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;6&lt;/strong&gt; : &lt;strong&gt;재부팅 단계&lt;/strong&gt;로 실행단계 3의 상태로 재부팅&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;디렉터리-구조&quot;&gt;디렉터리 구조&lt;/h2&gt;
&lt;p&gt;디렉터리는 운영체제의 파일 관리 구조로 사용자는 디렉터리를 만들어서 파일을 저장하고 사용할 수 있다. 디렉터리는 리눅스를 설치하면 기본적으로 생성되는 것이 있으며 해당 디렉터리는 그 용도가 정해져 있다&lt;/p&gt;

&lt;p&gt;리눅스 디렉터리는 &lt;strong&gt;계층형 파일 시스템&lt;/strong&gt;으로 이루어져 있으며 사용자별로 자신의 디렉터리를 생성하여 사용할 수 있다. 특히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bin&lt;/code&gt;은 &lt;strong&gt;기본적인 실행파일&lt;/strong&gt;을 가지고 있고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;boot&lt;/code&gt;는 &lt;strong&gt;리눅스 부트 프로그램인 LILO 파일&lt;/strong&gt;을 가지고 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;etc&lt;/code&gt; 디렉터리는 환경설정에 관련된 파일&lt;/strong&gt;을 가지고 있어서 사용자 패스워드 정보를 가지고 있는 &lt;strong&gt;passwd 파일, shadow 파일&lt;/strong&gt;과 프로토콜 및 서비스 정보를 보유를 &lt;strong&gt;protocol, services 파일&lt;/strong&gt; 등을 가지고 있다&lt;/p&gt;

&lt;p&gt;리눅스는 다중 사용자를 제공하고 있으므로 각 사용자별로 디렉터리를 생성한다. &lt;strong&gt;사용자 디렉터리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;home&lt;/code&gt; 디렉터리 하위&lt;/strong&gt;에 생성된다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;디렉터리 구조&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;/&lt;/td&gt;
      &lt;td&gt;루트 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/bin&lt;/td&gt;
      &lt;td&gt;기본적인 실행 명령&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/boot&lt;/td&gt;
      &lt;td&gt;LILO 등 부팅에 관련된 파일&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev&lt;/td&gt;
      &lt;td&gt;장치 파일 모음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/fd&lt;/td&gt;
      &lt;td&gt;플로디 디스크&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/hda&lt;/td&gt;
      &lt;td&gt;마스트 IDE 하드 디스크&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/sda&lt;/td&gt;
      &lt;td&gt;SCSI 및 SATA 하드 디스크&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/cdrom&lt;/td&gt;
      &lt;td&gt;CD ROM 드라이버&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/mouse&lt;/td&gt;
      &lt;td&gt;마우스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/hdb&lt;/td&gt;
      &lt;td&gt;슬레이브 IDE 하드 디스크&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/dev/hd&lt;/td&gt;
      &lt;td&gt;하드 디스크&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/etc&lt;/td&gt;
      &lt;td&gt;시스템 설정 파일&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/home&lt;/td&gt;
      &lt;td&gt;사용자 홈 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/lib&lt;/td&gt;
      &lt;td&gt;C 라이브러리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/mnt&lt;/td&gt;
      &lt;td&gt;임시 마운트용 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc&lt;/td&gt;
      &lt;td&gt;시스템 정보를 가진 가상 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/buddyinfo&lt;/td&gt;
      &lt;td&gt;버디 할당자 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/cmdline&lt;/td&gt;
      &lt;td&gt;시스템 부팅 중 커널에 제출된 명령 내용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/cpuinfo&lt;/td&gt;
      &lt;td&gt;시스템 CPU 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/devices&lt;/td&gt;
      &lt;td&gt;디바이스들의 목록&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/diskstats&lt;/td&gt;
      &lt;td&gt;디스크의 상태 및 파티션 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/dma&lt;/td&gt;
      &lt;td&gt;DMA 채널&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/filesystems&lt;/td&gt;
      &lt;td&gt;파일 시스템의 목록&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/interrupts&lt;/td&gt;
      &lt;td&gt;인터럽트에 대한 통계&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/iomem&lt;/td&gt;
      &lt;td&gt;할당된 메모리 영역&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/ioport&lt;/td&gt;
      &lt;td&gt;입출력 포트 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/kallsyms&lt;/td&gt;
      &lt;td&gt;심볼들의 목록&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/loadavg&lt;/td&gt;
      &lt;td&gt;CPU 부하와 관련된 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/locks&lt;/td&gt;
      &lt;td&gt;잠금 파일&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/mdstat&lt;/td&gt;
      &lt;td&gt;RAID 시스템의 정보를 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/meminfo&lt;/td&gt;
      &lt;td&gt;시스템 메모리 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/modules&lt;/td&gt;
      &lt;td&gt;사용중인 모듈들&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/partitions&lt;/td&gt;
      &lt;td&gt;파티션 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/slabinfo&lt;/td&gt;
      &lt;td&gt;슬랩 할당기 통계 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/swaps&lt;/td&gt;
      &lt;td&gt;스왑 파티션에 대한 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/uptime&lt;/td&gt;
      &lt;td&gt;시스템이 부팅된 이후의 시간&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/root&lt;/td&gt;
      &lt;td&gt;루트 사용자의 홈 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/sbin&lt;/td&gt;
      &lt;td&gt;시스템 관리용 실행 파일&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/tmp&lt;/td&gt;
      &lt;td&gt;임시파일 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/usr&lt;/td&gt;
      &lt;td&gt;애플리케이션이 설치되는 디렉터리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/var&lt;/td&gt;
      &lt;td&gt;시스템에서 운영되는 임시파일 및 로그파일&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Thu, 20 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-linux-boot/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-linux-boot/</guid>
        
        <category>정보보안기사</category>
        
        <category>Linux</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/리눅스] 권한 관리</title>
        <description>&lt;h2 id=&quot;패스워드-권한&quot;&gt;패스워드 권한&lt;/h2&gt;

&lt;p&gt;일반적으로 패스워드 파일의 소유자는 root 이고 root만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rw-&lt;/code&gt;로 되어 있다. 이것은 root 사용자만 읽고 쓰기가 가능하다는 의미이다.&lt;/p&gt;

&lt;p&gt;만약, 일반 사용자가 패스워드를 변경하면 /etc/passwd 파일이 수정되어야 하는데 사용자는 root가 아니므로 /etc/passwd 파일을 수정할 수 없다.&lt;/p&gt;

&lt;p&gt;패스워드를 변경하려면 passwd 프로그램을 실행해야 하고 passwd 프로그램은 /usr/bin/passwd에 있는 실행 파일이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 라는 필드 때문에 파일의 소유자는 root 이며 root, 같은 그룹, 다른 사용자 모두 실행할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;그런데&lt;/strong&gt;, 권한 부분을 자세히 살펴보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt; 를 확인할 수 있는데 &lt;strong&gt;특수 권한&lt;/strong&gt;이라고 하여 &lt;strong&gt;실행 시 소유자의 권한으로 실행된다는 것을 의미&lt;/strong&gt;한다. passwd 실행 파일의 소유자는 root 이므로 passwd 실행 파일을 실행시키는 &lt;strong&gt;일반 사용자도 순간적으로 소유자인 root의 권한을 획득&lt;/strong&gt;한다. 이 과정을 리눅스에서는 특수 권한인 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setuid&lt;/code&gt;&lt;/strong&gt;라고 한다. 그렇기 때문에 일반 사용자는 /usr/bin/passwd 라는 파일을 실행해서 패스워드를 변경하고 /usr/bin/passwd 파일은 /etc/passwd 파일을 수정하게 되는 것이다.&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;/bin/false&lt;/strong&gt;&lt;br /&gt;
설정하면 로그인할 때 셀(Shell)을 실행하지 않는다.&lt;/p&gt;

&lt;h2 id=&quot;권한-관리&quot;&gt;권한 관리&lt;/h2&gt;
&lt;h3 id=&quot;디폴트-권한-umask&quot;&gt;디폴트 권한 umask&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;리눅스의 권한 관리&lt;/strong&gt;는 &lt;strong&gt;소유자/그룹/다른 사용자&lt;/strong&gt;로 이루어진다. 그리고 각각은 &lt;strong&gt;읽기(r)/쓰기(w)/실행(x) 권한&lt;/strong&gt;을 가질 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들어, rw-rw-rwx 식으로 조회가 된다면 맨 왼쪽은 파일을 만든 소유자로 읽고 쓸수가 있고 그 다음은 같은 그룹의 사용자로 읽고 쓸 수 있다는 의미를 가지며 마지막으로 다른 사용자는 읽고, 쓰고, 실행이 가능하다.&lt;/p&gt;

&lt;p&gt;하지만, 파일을 만들 때마다 사용자가 매번 권한을 부여하는 것은 귀찮은 일이기에 &lt;strong&gt;Default 권한&lt;/strong&gt;이라는 것이 존재한다. Default 권한 값을 가지고 있는 것은 &lt;strong&gt;umask 값&lt;/strong&gt;인데 만약 값이 0022라면 두 번째 자리부터 0은 소유자, 2는 그룹, 마지막 2는 다른 사용자를 의미하며 이것을 6에서 빼서 그 권한을 확인할 수 있다. 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;666&lt;/code&gt; - 022 = 644가 되고 여기서 644의 6이라는 것은 r = 4, w = 2, x =0의 의미로 4+2+0=6이 된다. 소유자는 읽기, 쓰기, 권한을 가지고 있다는 의미이며 4 값을 가지는 그룹과 다른 사용자는 읽기만 가능하다는 것이다. 단, 디렉터리를 mkdir 명령을 통해서 생성하면 Default 권한이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;777&lt;/code&gt;-022=755가 된다.&lt;/p&gt;

&lt;p&gt;umask 값을 확인하기 위해서는 umask 명령을 실행하여 확인할 수 있으며 일반적으로 권한 백 단위라고 생각해도 좋지만, 리눅스는 특수 권한이라고 하여 천 단위 권한이 존재한다. &lt;strong&gt;setuid(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4000&lt;/code&gt;), setgid(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2000&lt;/code&gt;), sticky(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1000&lt;/code&gt;) 비트&lt;/strong&gt;를 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;권한-부여-및-변경&quot;&gt;권한 부여 및 변경&lt;/h3&gt;
&lt;p&gt;chmod 명령으로 사용자에게 권한을 부여하려면 u 옵션에 &lt;strong&gt;rwx(읽기[4], 쓰기[2], 실행[1]) 권한&lt;/strong&gt;을 부여하고 그룹에게 권한을 부여할 때는 g 옵션, 다른 사용자에게 부여할 때는 o 옵션을 사용한다. 최대 권한은 777이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;chmod [옵션] [파일명]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;chmod 명령은 숫자를 사용해서 권한을 부여할 수도 있지만 문자를 써더 권한을 부여하거나 삭제가 가능하다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;명령기호&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;u&lt;/td&gt;
      &lt;td&gt;user&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;g&lt;/td&gt;
      &lt;td&gt;group&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;o&lt;/td&gt;
      &lt;td&gt;other&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;a&lt;/td&gt;
      &lt;td&gt;all&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;+&lt;/td&gt;
      &lt;td&gt;추가&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;삭제&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;r&lt;/td&gt;
      &lt;td&gt;읽기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;쓰기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;x&lt;/td&gt;
      &lt;td&gt;실행&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;chown&lt;/strong&gt;&lt;/span&gt; 명령어는 &lt;strong&gt;파일에 대한 사용자와 그룹을 변경&lt;/strong&gt;할 수 있는 명령어로 다음과 같은 형식으로 사용한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;chown [Option] [UID:GID] [디렉터리명 / 파일명]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;chown 명령어 옵션&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-R&lt;/td&gt;
      &lt;td&gt;하위 디렉터리의 모든 권한 변경&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-c&lt;/td&gt;
      &lt;td&gt;권한 변경 파일 내용 출력&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;chgrp&lt;/strong&gt;&lt;/span&gt; 명령은 &lt;strong&gt;파일이나 디렉터리의 소유 그룹을 변경&lt;/strong&gt;하는 명령어로 다음 형식으로 사용한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;chgrp [Option] [그룹 파일]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;chgrp 옵션&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-c&lt;/td&gt;
      &lt;td&gt;실제 변경된 것을 보여준다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-h&lt;/td&gt;
      &lt;td&gt;심볼릭 링크 자체의 그룹을 변경&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-f&lt;/td&gt;
      &lt;td&gt;그룹이 변경되지 않는 파일에 대해서 오류 메시지를 보여주지 않는다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-v&lt;/td&gt;
      &lt;td&gt;작업 진행 상태를 설명&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-R&lt;/td&gt;
      &lt;td&gt;하위 모든 파일도 지정한 그룹으로 변경&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;특수-권한-관리&quot;&gt;특수 권한 관리&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;특수 권한 파일 검색&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;#find / -perm [4000/2000/1000] -print&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;setuid&quot;&gt;setuid&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setuid&lt;/code&gt; 권한이 설정된 파일을 &lt;strong&gt;다른 사용자가 실행하게 되면, 실행될 때 그 파일의 소유자 권한으로 실행&lt;/strong&gt;되는 파일이다.&lt;/p&gt;

&lt;p&gt;setuid의 설정은 chmod 명령으로 8진수 &lt;strong&gt;4000&lt;/strong&gt;이나, &lt;strong&gt;u+s&lt;/strong&gt;를 사용해서 설정할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;실행파일&lt;/strong&gt;에 setuid를 설정하면 소문자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt;가 되고 정상적으로 실행할 수 있으나, &lt;strong&gt;실행파일이 아닌 파일&lt;/strong&gt;에 setuid를 설정하면 대문자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt;가 되고 &lt;strong&gt;실행은 불가능&lt;/strong&gt;하다.&lt;/p&gt;

&lt;h4 id=&quot;setgid&quot;&gt;setgid&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setgid&lt;/code&gt;는 &lt;strong&gt;파일 생성자의 그룹 소유권을 얻는 것&lt;/strong&gt;으로 &lt;strong&gt;동일한 프로젝트에 실행 권한을 부여&lt;/strong&gt;하기 위하여 사용한다.&lt;/p&gt;

&lt;p&gt;예를 들어, A라는 사용자는 B의 디렉터리에 디렉터리 생성 및 파일 생성을 할 수 없다. 하지만 root가 chmod 2777 B 디렉터리에 setgid를 부여하면 A 사용자가 B 디렉터리에 하위 디렉터리를 만들거나 파일을 생성할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;setgid의 설정은 chmod 명령으로 8진수 &lt;strong&gt;2000&lt;/strong&gt;으로 설정이 가능하다.&lt;/p&gt;

&lt;h4 id=&quot;sticky-bit&quot;&gt;sticky bit&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sticky bit&lt;/code&gt;는 &lt;strong&gt;공용 디렉터리를 만들어 누구나 자유롭게 사용&lt;/strong&gt;할 수 있도록 한 것으로 권한부여는 &lt;strong&gt;1000&lt;/strong&gt;으로 설정한다.&lt;/p&gt;

&lt;p&gt;sticky bit가 부여된 디렉터리는 누구나 자유롭게 사용할 수 있지만, 해당 디렉터리의 &lt;strong&gt;삭제는 소유자만 가능&lt;/strong&gt;하다.&lt;/p&gt;
</description>
        <pubDate>Thu, 20 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-linux-authority/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-linux-authority/</guid>
        
        <category>정보보안기사</category>
        
        <category>Linux</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/리눅스] 리눅스 파일 시스템</title>
        <description>&lt;h2 id=&quot;파일-시스템&quot;&gt;파일 시스템&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;여러 가지 정보를 저장하는 기본적인 구조&lt;/li&gt;
  &lt;li&gt;시스템 관리를 위한 기본 환경을 제공&lt;/li&gt;
  &lt;li&gt;계층적인 트리 구조 형태&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리눅스에 설치되어 있는 운영체제 관련 파일, 사용자 패키지, 사용자가 만든 파일 등을 관리하는 것이다. 리눅스의 파일은 가장 최상위 루트부터 그 하위로 만들어지며 &lt;strong&gt;루트 파일 시스템은 오직 한 개&lt;/strong&gt;만 존재한다&lt;/p&gt;

&lt;p&gt;사용자가 vi, vim과 같은 에디터 프로그램을 사용해서 파일을 만드는 &lt;strong&gt;텍스트 파일&lt;/strong&gt;과 gcc(C언어 컴파일러)를 사용해서 만든 실행파일이 있으므로 실행파일은 &lt;strong&gt;바이너리 파일&lt;/strong&gt;로 분류된다.&lt;/p&gt;

&lt;p&gt;파일들을 저장하기 위한 디렉터리가 있고 USB, CDROM, CPU, Memory와 같은 하드웨어 장치를 관리하기 위한 특수파일이 있으며 &lt;strong&gt;특수파일&lt;/strong&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/dev&lt;/code&gt; 디렉터리에 위치한다. 특수파일에는 문자단위로 기록된 &lt;strong&gt;문자단위 특수파일&lt;/strong&gt;과 동일한 크기로 기록되는 &lt;strong&gt;블록단위 특수파일&lt;/strong&gt;로 분류된다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;종류&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;루트 파일 시스템&lt;/td&gt;
      &lt;td&gt;하드디스크 상에서 적어도 하나의 파일 시스템이 존재&lt;br /&gt;시스템 프로그램과 디렉터리들이 포함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;일반 파일&lt;/td&gt;
      &lt;td&gt;컴퓨터가 수행 가능한 프로그램 파일이나 원시 프로그램 파일, 텍스트 파일, 데이터 파일 등이 존재&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;디렉터리 파일&lt;/td&gt;
      &lt;td&gt;다른 파일과 디렉터리들에 관한 정보를 저장하는 논리적인 단위&lt;br /&gt;파일명인 문자열과 inode 번호를 연결하는 부분&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;특수 파일&lt;/td&gt;
      &lt;td&gt;주변 장치에 연결된 파일로 하나 이상의 특수 파일을 가지고 있어야 한다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;파일시스템-구조&quot;&gt;파일시스템 구조&lt;/h3&gt;
&lt;p&gt;리눅스 파일 시스템의 구조는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;부트블록&lt;/code&gt;으로 시작되며 부트블록은 &lt;strong&gt;컴퓨터 시스템을 부팅하기 위한 부팅에 관련&lt;/strong&gt;된 이미지를 가지고 있다. 이것은 리눅스 &lt;strong&gt;운영체제가 시작되면 제일 처음 읽음&lt;/strong&gt;으로써 리눅스를 기동하게 된다. 부트블록이 주기억 장치에 모두 올라가면 리눅스 운영체제는 제일 처음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;init&lt;/code&gt; &lt;strong&gt;프로세스를 기동&lt;/strong&gt;하게 되고, init 프로세스의 &lt;strong&gt;프로세스 ID는 1번&lt;/strong&gt;이 부여된다&lt;/p&gt;

&lt;p&gt;부트블록 다음에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;슈퍼블록&lt;/code&gt;이 나오며 슈퍼블록은 파일 시스템의 크기, 여유 공간, 파일 시스템 이름, 디스크의 이름 등의 정보를 가지고 있다&lt;/p&gt;

&lt;h4 id=&quot;부트-블록boot-block&quot;&gt;부트 블록(Boot Block)&lt;/h4&gt;
&lt;p&gt;파일 시스템으로부터 리눅스 커널을 적재시키기 위한 프로그램&lt;/p&gt;

&lt;h4 id=&quot;슈퍼-블록super-block&quot;&gt;슈퍼 블록(Super Block)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;파일 시스템의 크기, 블록 수 등 이용 가능한 빈 블록 리스트&lt;/li&gt;
  &lt;li&gt;빈 블록 리스트에서 그 다음의 빈 블록을 가리키는 인덱스&lt;/li&gt;
  &lt;li&gt;inode 목록의 크기, 파일 시스템에 있는 빈 inode의 수와 목록&lt;/li&gt;
  &lt;li&gt;빈 node 목록에서 그 다음의 빈 inode의 수와 목록&lt;/li&gt;
  &lt;li&gt;빈 블록과 빈 inode 목록들에 대한 lock 필드&lt;/li&gt;
  &lt;li&gt;슈퍼 블록들이 수정되었는지 나타내는 플래그&lt;/li&gt;
  &lt;li&gt;파일 시스템 이름과 파일 시스템 디스크의 이름&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;inode&quot;&gt;inode&lt;/h4&gt;
&lt;p&gt;리눅스 커널이 현재 사용하는 자료구조를 유지하는 구조체&lt;/p&gt;

&lt;p&gt;리눅스는 파일에 접근 시 아이노드를 통해서 파일을 참조한다. inode는 리눅스만 가지고 있는 정보로 파일과 관련된 정보를 가지고 있고, 파일은 영문이름, 한글이름등으로 나타내지만 리눅스는 &lt;strong&gt;inode number라는 일련의 숫자를 부여하여 파일을 관리&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;inode는 파일 링크 정보를 가지고 있는데 파일링크는 심볼릭 링크와 하드 링크로 나누어진다&lt;br /&gt;
&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;심볼릭 링크&lt;/strong&gt;&lt;/span&gt;는 마치 &lt;strong&gt;윈도우의 바로가기와 비슷한 기능&lt;/strong&gt;으로 파일명이 너무 길면 심볼릭 링크를 만들어서 짧은 파일명으로 사용할 수 있다.&lt;br /&gt;
즉, 긴 파일명과 긴 디렉터리 명을 대신해서 사용할 때 &lt;strong&gt;링크정보만 가지고 있는 새로운 inode가 만들어지고(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ln -s&lt;/code&gt;)&lt;/strong&gt; inode는 &lt;strong&gt;원래 파일의 포인터 정보만을 가지고 있다&lt;/strong&gt;. 만약 &lt;strong&gt;원본 파일이나 디렉터리를 삭제하게 되면 심볼릭 링크는 삭제&lt;/strong&gt;된다&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;하드 링크&lt;/strong&gt;&lt;/span&gt;는 원본 파일을 복사해서 동일한 inode를 만드는 것(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ln&lt;/code&gt;)으로 원본 파일을 삭제하거나 이동해도 하드 링크는 존재한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;구성요소&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;파일 소유자의 사용자 ID&lt;/li&gt;
      &lt;li&gt;파일 소유자의 그룹 ID&lt;/li&gt;
      &lt;li&gt;파일 크기&lt;/li&gt;
      &lt;li&gt;파일이 생성된 시간&lt;/li&gt;
      &lt;li&gt;최근 파일이 사용된 시간&lt;/li&gt;
      &lt;li&gt;최근 파일이 변경된 시간&lt;/li&gt;
      &lt;li&gt;파일이 링크된 수&lt;/li&gt;
      &lt;li&gt;데이터 블록 주소&lt;/li&gt;
      &lt;li&gt;접근 모드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;기능&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;할당 및 적용&lt;/strong&gt;&lt;/span&gt; : 파일 구성 블록에 대한 물리적 위치 정보&lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;파일생성&lt;/strong&gt;&lt;/span&gt; : 파일이 생성되면 해당하는 inode가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i-list&lt;/code&gt;에 만들어지며 그 inode의 inode Number와 파일 이름, 디렉터리가 등록됨&lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;파일링크&lt;/strong&gt;&lt;/span&gt; : 기존 파일과 링크할 경우 디렉터리에 그 파일에 대한 새로운 이름이 등록되고 inode Number는 본래 있던 파일의 inode Number가 복사된다&lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:orangered&quot;&gt;&lt;strong&gt;파일삭제&lt;/strong&gt;&lt;/span&gt; : 파일에 대한 inode의 파일 링크 수가 하나 감소되고 디렉터리 엔트리에서 해당 파일의 &lt;strong&gt;inode Number가 0으로 변경&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;블록관리-방법&quot;&gt;블록관리 방법&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;단일 간접블록(Single Indirect Block)&lt;/strong&gt;&lt;br /&gt;
inode block을 가리키며 실제 데이터 블록을 가리키는 포인터들로 구성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이중 간접블록(Double Indirect Block)&lt;/strong&gt;&lt;br /&gt;
인덱스 블록이 2개의 레이어로 구성되면 첫 번째 인덱스 블록은 두 번째 인덱스 블록을 가리키는 포인터로, 두 번째 인덱스 블록은 실제 데이터 블록을 가리키는 포인터로 구성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;삼중 간접블록(Triple Indirect Block)&lt;/strong&gt;&lt;br /&gt;
인덱스 블록이 3개의 레이어로 구성되면 첫 번째와 두 번째 인덱스 블록은 다른 인덱스 블록을 가리키는 포인터, 세 번째 층 인덱스 블록은 실제데이터 블록을 가리키는 포인터들로 구성&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;데이터-블록data-block&quot;&gt;데이터 블록(Data Block)&lt;/h4&gt;
&lt;p&gt;실제 데이터가 저장되어 있는 파일 형태&lt;/p&gt;

&lt;h2 id=&quot;파일-시스템-생성&quot;&gt;파일 시스템 생성&lt;/h2&gt;
&lt;h3 id=&quot;디스크-파티션&quot;&gt;디스크 파티션&lt;/h3&gt;
&lt;p&gt;파일 시스템을 생성하기 위해서는 하드 디스크를 초기화하고 필요하면 파티션을 수행하여 하드 디스크를 분할해야 한다. 그 때 파티션을 수행하는 리눅스 명령어가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fdisk&lt;/code&gt;이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;fdisk [-l][-v][-s 파티션][장치명]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;fdisk 옵션&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-l&lt;/td&gt;
      &lt;td&gt;현재 파일 시스템 목록 확인&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-v&lt;/td&gt;
      &lt;td&gt;버전 정보 확인&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-s 장치명&lt;/td&gt;
      &lt;td&gt;입력 장치 크기를 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-d&lt;/td&gt;
      &lt;td&gt;파티션 삭제&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-n&lt;/td&gt;
      &lt;td&gt;새로운 파티션 생성&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;현재 파티션 설정 상태 확인&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;파일-시스템-생성-1&quot;&gt;파일 시스템 생성&lt;/h3&gt;
&lt;p&gt;하드 디스크를 파티션했으면 해당 파티션에 &lt;strong&gt;파일 시스템을 생성&lt;/strong&gt;해야 한다. 하드 디스크를 생성하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mkfs&lt;/code&gt; 명령어를 실행한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;mkfs[옵션][장치이름]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;mkfs 옵션&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-V&lt;/td&gt;
      &lt;td&gt;실행되는 파일 시스템의 특정 명령어 등 &lt;strong&gt;모든 정보를 출력&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-t&lt;/td&gt;
      &lt;td&gt;파일 시스템 형식 선택&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-c&lt;/td&gt;
      &lt;td&gt;Bad Block 검사, Bad Block 리스트 초기화&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-l&lt;/td&gt;
      &lt;td&gt;파일로부터 초기 Bad Block을 읽음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-v&lt;/td&gt;
      &lt;td&gt;현재 진행사항 출력&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;파일-시스템-무결성-검사&quot;&gt;파일 시스템 무결성 검사&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsck&lt;/code&gt;는 &lt;strong&gt;파일 시스템의 무결성을 검사&lt;/strong&gt;하는 명령어로 파일 시스템에는 상위 디렉터리, 하위 디렉터리 그리고 파일 간의 링크 정보 등을 가지고 있어야 한다. 이러한 정보에 오류가 발생되면 파일 시스템의 구조를 파악할 수 없다. 그럴 때 리눅스는 fsck를 통해서 파일 시스템의 무결성을 검사하고 오류가 발생하면 수정할 수 있다. fsck는 &lt;strong&gt;기본적으로 부팅단계에서 자동적으로 실행&lt;/strong&gt;하게 되고 필요에 따라서 직접 실행할 수도 있다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;fsck 옵션&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-s&lt;/td&gt;
      &lt;td&gt;대화형 모드에서 여러 파일 시스템을 점검할 때 fsck 동작을 시리얼화 한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-t&lt;/td&gt;
      &lt;td&gt;검사를 수행할 파일 시스템을 지정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-A&lt;/td&gt;
      &lt;td&gt;/etc/fstab 파일에 기술된 파일 시스템을 모두 검사&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-N&lt;/td&gt;
      &lt;td&gt;검사는 수행하지 않고 수행될 내용을 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-P&lt;/td&gt;
      &lt;td&gt;병렬처리를 수행하여 루트 파일 시스템 점검&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-R&lt;/td&gt;
      &lt;td&gt;루트 파일 시스템은 제외&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-V&lt;/td&gt;
      &lt;td&gt;명령을 포함하여 세부 내역을 출력&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;파일 시스템 옵션&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-a&lt;/td&gt;
      &lt;td&gt;무결성 검사 후에 자동검사 수행&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r&lt;/td&gt;
      &lt;td&gt;대화형 모드를 수행하며 오류를 수정&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-n&lt;/td&gt;
      &lt;td&gt;오류를 수정하지 않고 표준 출력으로 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-y&lt;/td&gt;
      &lt;td&gt;특정 파일 시스템에 대해서 오류를 자동 수정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;파일-시스템-마운트&quot;&gt;파일 시스템 마운트&lt;/h3&gt;
&lt;p&gt;디렉터리, CDROM, USB 등과 같은 장치를 연결하여 사용하는 것이 마운트(Mount)이다. 리눅스에서는 특정 디렉터리를 연결할 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mount&lt;/code&gt; 명령을 사용한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;mount [-hV]&lt;br /&gt;
mount -a [-fnrvw] [-t 파일 시스템 유형]&lt;br /&gt;
mount [-fnrvw] [-o 옵션[…]] 장치/디렉터리&lt;br /&gt;
mount [-fnrvw] [-t 파일 시스템 유형] [-o 옵션] 장치 디렉터리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;mount 옵션&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-v&lt;/td&gt;
      &lt;td&gt;자세한 정보 출력모드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-f&lt;/td&gt;
      &lt;td&gt;마운트 를 할 수 있는지 점검&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-n&lt;/td&gt;
      &lt;td&gt;/etc/mtab 파일에 쓰기 작업을 하지 않고 마운트&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r&lt;/td&gt;
      &lt;td&gt;읽기만 가능하도록 마운트 수행&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-w&lt;/td&gt;
      &lt;td&gt;읽기 및 쓰기 모드로 마운트 수행&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-t vfstype&lt;/td&gt;
      &lt;td&gt;-t 다음에 쓰이는 인수로 파일 시스템 유형 지정&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fstab&lt;/code&gt; 파일은 mount를 수행할 때 참조하는 파일로 파일 시스템 마운트에 관한 정보를 가지고 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;fstab 파일의 필드&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;파일 시스템 장치(레이블 명)&lt;/li&gt;
      &lt;li&gt;마운트 포인터(디렉터리 명)&lt;/li&gt;
      &lt;li&gt;파일 시스템 형식(ext2, ext3…)&lt;/li&gt;
      &lt;li&gt;옵션(Read Only / Read Write)&lt;/li&gt;
      &lt;li&gt;덤프&lt;/li&gt;
      &lt;li&gt;파일 점검 옵션(0,1)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;fstab 옵션&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;defalut&lt;/td&gt;
      &lt;td&gt;일반적인 팡리 시스템&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;auto&lt;/td&gt;
      &lt;td&gt;부팅 시 자동으로 마운트&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;exec&lt;/td&gt;
      &lt;td&gt;실행 파일이 실행되도록 허용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;suid&lt;/td&gt;
      &lt;td&gt;setuid와 setid를 허용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ro&lt;/td&gt;
      &lt;td&gt;읽기전용 파일 시스템&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;rw&lt;/td&gt;
      &lt;td&gt;읽고 쓰기가 가능한 파일 시스템&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;user&lt;/td&gt;
      &lt;td&gt;일반 사용자도 마운트 할 수 있는 파일 시스템&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;nouser&lt;/td&gt;
      &lt;td&gt;root만 마운트 할 수 있는 파일 시스템&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;noauto&lt;/td&gt;
      &lt;td&gt;부팅 시 자동으로 마운트하지 않음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;noexec&lt;/td&gt;
      &lt;td&gt;실행 파일이 실행되지 못함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;nosuid&lt;/td&gt;
      &lt;td&gt;setuid와 setgid를 허용하지 않음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;usrquota&lt;/td&gt;
      &lt;td&gt;개별 사용자의 쿼터 설정이 가능한 파일 시스템을 의미&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;grpquota&lt;/td&gt;
      &lt;td&gt;그룹별 쿼터 설정이 가능한 파일 시스템&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;마운트를 해제할 때는 umount 명령어를 사용한다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;umount [-nv] 장치/디렉터리&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;umount 옵션&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;설명&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-n&lt;/td&gt;
      &lt;td&gt;/etc/mtab 파일을 변경하지 않고 마운트를 해제&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-v&lt;/td&gt;
      &lt;td&gt;정보출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-a&lt;/td&gt;
      &lt;td&gt;/etc/mtab 파일에 지정된 파일 시스템을 모두 해제&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-t 파일시스템 명&lt;/td&gt;
      &lt;td&gt;지정된 파일 시스템을 해제&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;CDROM과 같은 하드웨어는 마운트를 수행하여 사용할 수 있다. 만약 CDROM에서 CD를 빼내려면 마운트를 해제하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eject&lt;/code&gt; 명령을 실행한다.&lt;/p&gt;

&lt;h2 id=&quot;파일-시스템-종류&quot;&gt;파일 시스템 종류&lt;/h2&gt;
&lt;p&gt;리눅스 파일 시스템은 ext2, ext3, ext4가 있으며 현재 대부분의 리눅스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ext4&lt;/code&gt;를 지원한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ext2 파일 시스템&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;단일 파일의 크기 : 최대 2GB&lt;/li&gt;
      &lt;li&gt;파일명 : 최대 256Byte&lt;/li&gt;
      &lt;li&gt;최대 지원 파일 시스템 크기 : 4TB&lt;/li&gt;
      &lt;li&gt;디렉터리 당 저장 가능한 최대 파일 수 : 약 25,000개&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ext3 파일 시스템&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;단일 단일의 크기 : 4GB&lt;/li&gt;
      &lt;li&gt;파일명 : 256Byte&lt;/li&gt;
      &lt;li&gt;최대 파일 시스템 크기 : 16TB&lt;/li&gt;
      &lt;li&gt;디렉터리 당 저장 가능한 최대 파일 수 : 65,565개&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;저널링 파일 시스템&lt;/strong&gt; 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ext4 파일 시스템&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;1EB(엑사바이트) 블록 지원, 단일 파일 크기 16TB 지원&lt;/li&gt;
      &lt;li&gt;ext2, ext3 &lt;strong&gt;호환성&lt;/strong&gt; 및 마운트 가능&lt;/li&gt;
      &lt;li&gt;파일 무결성 오류 시 실행되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fsck&lt;/code&gt; 성능 향상&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Extends&lt;/code&gt; 지원 : 큰 사이즈 파일을 삭제할 때 시간을 단축함&lt;/li&gt;
      &lt;li&gt;하위 디렉터리 수 제한이 32,000개에서 2배 확대&lt;/li&gt;
      &lt;li&gt;ext3 저널링 파일 시스템에서 발생되는 단편화를 조각모음으로 개선&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 19 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-linux-file-system/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-linux-file-system/</guid>
        
        <category>정보보안기사</category>
        
        <category>Linux</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[정보보안기사/리눅스] 리눅스(Linux)</title>
        <description>&lt;h2 id=&quot;리눅스&quot;&gt;리눅스&lt;/h2&gt;
&lt;p&gt;윈도우, 유닉스, iOS와 같은 운영체제의 한 종류로 컴퓨터 시스템의 하드웨어를 효율적으로 관리하기 위한 시스템 소프트웨어.&lt;/p&gt;

&lt;p&gt;1989년 핀란드 헬싱키 대학에 재학 중이던 리누스 토르발스가 개발한 것으로 유닉스를 기반으로 하였으며 공개용 운영체제이다. 리눅스는 기존 유닉스와 다르게 대형 서버를 위해서 개발된 운영체제가 아니라 개인용 컴퓨터나 워크스테이션을 위해서 개발되었으므로 소스코드부터 운영체제 사용까지 GPL(General Public License) 라이센스가 적용된 운영체제이다. 그러므로 리눅스를 설치하고 사용자가 자신의 운영체제를 수정하여 사용할 수 있다&lt;/p&gt;

&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;다중 사용자&lt;/strong&gt;&lt;br /&gt;
리눅스는 여러 명의 사용자가 네트워크를 통해서 접속하여 컴퓨터 시스템을 사용할 수 있는 다중 사용자 환경을 지원하기 때문에 사용자별 권한관리와 자원관리가 가능&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;다중작업&lt;/strong&gt;&lt;br /&gt;
운영체제 내에서 &lt;strong&gt;여러 개의 프로세스를 동시에 실행&lt;/strong&gt;시켜 CPU를 스케줄링하여 사용할 수 있다.&lt;/p&gt;

    &lt;p&gt;여러 개의 프로세스가 동시에 실행되기 때문에 각 프로세스 간 작업순서 조정과 같은 스케줄링 기능을 가지고 있다. 이러한 스케줄링은 기본적으로 시간(Time Slice) 사용량만큼 자원을 할당하여 사용할 수 있게 하는 &lt;strong&gt;시분할 시스템&lt;/strong&gt;을 지원&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;다중 처리기&lt;/strong&gt;&lt;br /&gt;
컴퓨터 시스템에 한 개 이상의 CPU가 탑재되어 있는 경우 &lt;strong&gt;여러 개의 CPU를 지원해 주는 다중 처리기를 지원&lt;/strong&gt;하며 작업을 &lt;strong&gt;병렬적&lt;/strong&gt;으로 처리하여 시스템을 효율적으로 사용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;다중 플랫폼&lt;/strong&gt;&lt;br /&gt;
여러 종류의 CPU를 지원하여 대부분의 플랫폼을 지원하고 성능을 낼 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;계층형 파일 시스템&lt;/strong&gt;&lt;br /&gt;
리눅스 파일 시스템은 &lt;strong&gt;루트를 기반으로 하위 디렉터리를 이루는 계층형 파일 시스템&lt;/strong&gt;으로 이루어져 있어서 디렉터리를 쉽게 추가하고 관리할 수 있으며 파일 시스템을 효율적으로 관리할 수 있다.&lt;/p&gt;

    &lt;p&gt;계층형 파일 시스템은 리눅스 뿐만 아니라 윈도우, 유닉스 모두 계층형 파일 시스템으로 되어 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;POSIX와 호환&lt;/strong&gt;&lt;br /&gt;
POSIX는 유닉스 시스템의 표준 인터페이스를 정의한 것으로 리눅스는 POSIX 표준을 따른다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;우수한 네트워킹&lt;/strong&gt;&lt;br /&gt;
TCP/IP, IPX/SPC, Appletalk, Bluetooth 등 다양한 프로토콜을 지원하며 리눅스 설치 이후에 IP주소, 게이트웨이, 서브넷 등을 설정하면 바로 네트워크를 사용할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;가상콘솔&lt;/strong&gt;&lt;br /&gt;
기본적으로 6개의 가상콘솔이 있어서 각 창마다 서로 다른 작업을 수행할 수 있으므로 물리적 모니터의 한계를 극복&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;가상 기억장치&lt;/strong&gt;&lt;br /&gt;
주기억 장치의 한계를 극복하기 위해서 보조 기억장치를 마치 주기억 장치처럼 사용할 수 있도록 하여 주기억 장치의 공간을 증대하는 방법이 가상 기억장치이다.&lt;/p&gt;

    &lt;p&gt;가상 기억 장치는 기억공간을 확대하여 기억장치를 효율적으로 사용할 수 있으므로 시스템을 안정적으로 사용할 수 있다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기능&quot;&gt;기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;작업 관리자&lt;/strong&gt;&lt;br /&gt;
작업의 생성, 실행, 상태관리, 스케줄링, 시그널 처리, 프로세스 간 통신 등의 서비스 제공&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;메모리 관리자&lt;/strong&gt;&lt;br /&gt;
세그먼테이션, 페이징, Swap 서비스를 통한 물리 메모리와 가상 메모리 관리&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;파일 시스템 관리자&lt;/strong&gt;&lt;br /&gt;
파일 생성, 삭제, 접근 제어, 디렉터리 관리, 슈퍼블록 관리 등의 서비스 제공&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;네트워크 관리자&lt;/strong&gt;&lt;br /&gt;
소켓, TCP/IP, 프로토콜 스택 관리 등의 서비스&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;장치 관리자&lt;/strong&gt;&lt;br /&gt;
디스크, 각종 카드, 외부 인터페이스 등을 제어하는 드라이버 관리 서비스 제공&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;구성요소&quot;&gt;구성요소&lt;/h3&gt;
&lt;h4 id=&quot;커널kernel&quot;&gt;&lt;span style=&quot;color:orangered&quot;&gt;커널(Kernel)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;주기억 장치에 상주&lt;/strong&gt;하면서 &lt;strong&gt;사용자 프로그램을 관리&lt;/strong&gt;하는 운영체제의 핵심 역할&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;프로세스, 메모리, 입출력, 파일 관리&lt;/strong&gt; 등을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;셀shell&quot;&gt;&lt;span style=&quot;color:orangered&quot;&gt;셀(Shell)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;명령어 해석기, 번역기&lt;/strong&gt;로 &lt;strong&gt;사용자 명령의 입출력을 수행&lt;/strong&gt;하며 프로그램을 실행&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기능
    &lt;ul&gt;
      &lt;li&gt;시그널을 처리&lt;/li&gt;
      &lt;li&gt;프로그램을 실행&lt;/li&gt;
      &lt;li&gt;파이프, 리다이렉션, 백그라운드 프로세스 설정&lt;/li&gt;
      &lt;li&gt;입력된 내용을 파악해서 명령 줄을 분석&lt;/li&gt;
      &lt;li&gt;와일드 카드, 히스토리 문자, 특수문자 분석&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;전역 설정파일 : 환경파일이 /etc 디렉터리에 존재하는 것으로 리눅스를 사용하는 모든 사용자에게 적용되는 환경 파일&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;환경변수&quot;&gt;환경변수&lt;/h5&gt;
&lt;p&gt;유용하게 사용될 변수 및 설정해야 하는 값을 설정해두는 것&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;환경변수&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;SHELL&lt;/td&gt;
      &lt;td&gt;사용자의 로그인 셀의 절대경로&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HOME&lt;/td&gt;
      &lt;td&gt;홈 디렉터리에 대한 경로 이름&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PATH&lt;/td&gt;
      &lt;td&gt;실행할 명령어를 찾을 경로&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;USER&lt;/td&gt;
      &lt;td&gt;사용자 이름&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LOGNAME&lt;/td&gt;
      &lt;td&gt;로그인할 때 사용할 이름&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TERM&lt;/td&gt;
      &lt;td&gt;사용 중인 단말기 설명&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MAIL&lt;/td&gt;
      &lt;td&gt;전자메일 우편함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HOSTNAME&lt;/td&gt;
      &lt;td&gt;호스트 명을 의미&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TMOUT&lt;/td&gt;
      &lt;td&gt;이 시간동안 명령 등의 입력이 없으면 연결 종료&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;c-셀&quot;&gt;C 셀&lt;/h5&gt;
&lt;p&gt;사용자의 작업 환경을 편리하게 하기 위하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.cshrc&lt;/code&gt; 파일에 필요한 환경 변수를 저장하여 사용자가 로그인했을 때 지정 명령들을 자동으로 수행&lt;/p&gt;

&lt;h5 id=&quot;tc-셀tcsh&quot;&gt;TC 셀(tcsh)&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;C 셀의 기능을 강화한 것으로 명령 편집 기능을 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;bourne-셀&quot;&gt;bourne 셀&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;사용자의 편의성을 위하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.profile&lt;/code&gt; 파일에 환경 변수를 저장&lt;/li&gt;
  &lt;li&gt;.profile은 C 셀의 .&lt;strong&gt;cshrc 파일과 동일한 역할&lt;/strong&gt; 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;korn-셀&quot;&gt;korn 셀&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;.kshrc 또는 .profile 파일에 환경 변수 저장&lt;/li&gt;
  &lt;li&gt;C 셀과 TC 셀의 기능을 모두 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;bash-셀&quot;&gt;bash 셀&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;C 셀과 korn 셀의 특징을 결합한 것으로 GNU 프로젝트에 의해서 개발된 셀&lt;/li&gt;
  &lt;li&gt;리눅스에서 가장 많이 사용&lt;/li&gt;
  &lt;li&gt;명령 편집 기능을 제공&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;.bash_profile&lt;/strong&gt; : 사용자 홈 디렉터리에 있는 파일. 개별적인 셀 환경을 설정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;.bashrc&lt;/strong&gt; : 사용자 정의 변수, 함수 alias를 정의&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;.bash_logout&lt;/strong&gt; : 사용자가 로그아웃할 때 실행되는 파일을 정의&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 18 May 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/security-linux-concept/</link>
        <guid isPermaLink="true">https://many258.github.io/study/security-linux-concept/</guid>
        
        <category>정보보안기사</category>
        
        <category>Linux</category>
        
        
        <category>study</category>
        
      </item>
    
  </channel>
</rss>
