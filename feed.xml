<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My LifeChronicle</title>
    <description>Be a Imagineer.</description>
    <link>https://many258.github.io/</link>
    <atom:link href="https://many258.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 16 Apr 2021 20:35:47 +0900</pubDate>
    <lastBuildDate>Fri, 16 Apr 2021 20:35:47 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>[운영체제/OS] 병행 프로세스 동기화 유형</title>
        <description>&lt;h1 id=&quot;임계-구역critical-section&quot;&gt;임계 구역(Critical Section)&lt;/h1&gt;
&lt;p&gt;다중 프로그래밍 운영체제에서 한순간에 여러 개의 프로세스에 의하여 공유되는 데이터 및 자원에 대하여 &lt;strong&gt;반드시 하나의 프로세스에 의해서만 자원 또는 데이터가 사용되도록&lt;/strong&gt;하는 것으로 자원이 프로세스에 의하여 반납된 후, 비로소 다른 프로세스에서 자원을 이용하거나 데이터를 접근할 수 있도록 지정된 영역이다.&lt;/p&gt;

&lt;p&gt;하나의 컴퓨터 시스템에서 여러 개의 프로세스가 운영되고 있을 때 각 프로세스는 &lt;strong&gt;동시에 접근해서는 안 되는 공유 자원&lt;/strong&gt;을 임계 구역이라 할 수 있으며 여기에는 메모리, 프린터, 디스크, CD-ROM이 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;두 개 이상의 프로세스가 동시에 사용할 수 없다&lt;/li&gt;
  &lt;li&gt;순서를 지키면서 신속하게 사용&lt;/li&gt;
  &lt;li&gt;하나의 프로세스가 독점하게 해서는 안된다&lt;/li&gt;
  &lt;li&gt;사용 중에 중단, 무한 반복되어서는 안된다&lt;/li&gt;
  &lt;li&gt;인터럽트가 불가능한 상태로 만들어야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;상호-배제mutual-exclusion&quot;&gt;상호 배제(Mutual Exclusion)&lt;/h1&gt;
&lt;p&gt;임계 구역을 어느 시점에서 단지 &lt;strong&gt;한 개의 프로세스만이 사용할 수 있도록&lt;/strong&gt; 하며, 다른 프로세스가 현재 사용 중인 임계 구역에 대하여 &lt;strong&gt;접근하려고 할 때 금지하는 행위&lt;/strong&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상호배제&lt;/code&gt;라고 한다. 상호배제 알고리즘은 인터럽트 불능 처리, 잠금, 엄격한 교대, TSL, 세마포어 등이 있다&lt;/p&gt;

&lt;h2 id=&quot;상호-배제-알고리즘&quot;&gt;상호 배제 알고리즘&lt;/h2&gt;
&lt;h3 id=&quot;인터럽트-불능-처리&quot;&gt;인터럽트 불능 처리&lt;/h3&gt;
&lt;p&gt;하나의 프로세스가 하나의 공유 자원을 점유하게 되면 &lt;strong&gt;인터럽트를 발생하지 않도록 봉쇄&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;인터럽트를 봉쇄한다는 것은 현시점에서 어떠한 프로세스도 새롭게 &lt;strong&gt;자원을 점유하기 위한 시도를 할 수 없게 된다&lt;/strong&gt;는 의미히며 즉, 현재 공유 자원을 점유한 프로세스는 아무런 제약 없이 공유 자원을 사용하게 되므로 완벽한 상호배제를 할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 하나의 프로세스가 공유 자원을 점유하고 있는 동안 다른 프로세스는 아무런 작업을 할수 없는 상태이므로 &lt;strong&gt;시스템 효율이 매우 낮아진다&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;잠금lock&quot;&gt;잠금(Lock)&lt;/h3&gt;
&lt;p&gt;공유 자원을 점유하게 되는 경우 그 자원을 어떠한 프로세스도 접근하지 못하도록 하는 방법&lt;/p&gt;

&lt;p&gt;공유 자원을 점유하는 프로세스는 사용을 시작하면서 공유 자원에 접근하려는 모든 프로세스가 사용할 수 없도록 표시를 하게 된다. 이 때 이미 점유되어 있는 공유자원을 사용하기 위해 접근하고 있는 임의의 프로세스들은 표시를 계속 확인하게 되는데 이를 바쁜 대기(Busy Wait) 상태라고 한다&lt;/p&gt;

&lt;h3 id=&quot;엄격한-교대dekker-알고리즘&quot;&gt;엄격한 교대(Dekker 알고리즘)&lt;/h3&gt;
&lt;p&gt;두 개 이상의 프로세스가 &lt;strong&gt;교대로 공유 자원을 점유&lt;/strong&gt;하는 방식&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/dekker-algorithm.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/dekker-algorithm.png&quot; alt=&quot;&quot; title=&quot;데커 알고리즘&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;프로세스 A가 공유 자원을 점유하고 나면 프로세스 B는 프로세스 A가 사용 해제를 통보하길 기다렸다가 사용한다&lt;/p&gt;

&lt;p&gt;한쪽 프로세스가 점유 시간이 길어지면 나머지 프로세스는 사용 가능한가를 계속 감지하는 작업을 반복해야한다. 즉, &lt;strong&gt;바쁜 대기 현상은 계속 발생&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;하나의 프로세스가 &lt;strong&gt;우선권&lt;/strong&gt;을 갖게 해야 하며, 한쪽이 작업량이 많아서 빈번해져도 반드시 교대로 점유해야한다(하나의 프로세스를 &lt;strong&gt;연속적으로 재사용 불가&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;하나의 프로세스가 사용 중에 중단되면 다른 프로세스는 영원히 사용할 수 없는 &lt;strong&gt;교착상태&lt;/strong&gt;에 빠지게 된다&lt;/p&gt;

&lt;h3 id=&quot;tsltest--set-lock-명령어-기법&quot;&gt;TSL(Test &amp;amp; Set Lock) 명령어 기법&lt;/h3&gt;
&lt;p&gt;엄격한 교대의 문제점을 해결하는 방법으로 특수한 하드웨어 자원을 필요로 하지만, 바쁜 대기 상태는 완벽히 해결하지는 못한다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로세스 A,B 모두 각자의 변수 x,y를 갖게 되며 각 프로세스는 x,y값이 모두 0일 때 공유 자원을 사용할 수 있다&lt;/li&gt;
  &lt;li&gt;프로세스 A가 공유 자원을 사용하기 위해서는 y값이 0인가를 확인한다. y값이 1이라면 프로세스 B가 사용 중이다&lt;/li&gt;
  &lt;li&gt;프로세스 B가 공유 자원을 사용하기 위해서는 x값이 0인가를 확인한다. x값이 1이라면 프로세스 A가 사용 중이다&lt;/li&gt;
  &lt;li&gt;상대 프로세스가 가진 변수 값이 0인 경우에만 공유 자원을 점유할 수 있게 되고 점유하자마자 변수를 1로 변경하고 사용 후에는 0으로 변경한다&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Sleep() / Wakeup()&lt;/strong&gt;&lt;br /&gt;
TSL의 교착 상태와 바쁜 대기 현상의 단점 중 &lt;strong&gt;바쁜 대기의 문제점을 보완&lt;/strong&gt;한 방법&lt;/p&gt;

    &lt;p&gt;하나의 공유 자원을 점유하기 위한 시도를 반복하지 않고 사용하려는 공유 자원이 이미 &lt;strong&gt;사용 중이라면 프로세스를 잠시 중단하게 한다&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sleep&lt;/code&gt;, Wait, P, Down), 이후 어느 정도의 시간이 지나서 공유 자원이 사용 가능하다면 잠시 &lt;strong&gt;중단하고 있던 프로세스를 활성화&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Wakeup&lt;/code&gt;, Signal, V, Up)하여 바쁜 대기 현상을 방지하는 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;세마포어semaphore&quot;&gt;세마포어(Semaphore)&lt;/h1&gt;
&lt;p&gt;프로세스 간의 상호배제 및 동기화 문제 해결 방법&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P(S)&lt;/strong&gt;, &lt;strong&gt;V(S)&lt;/strong&gt; 연산을 통해서 프로세스 사이의 동기를 유지하고 상호배제의 원리 보장&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;이진 세마포어&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;세마포어 변수가 오직 &lt;strong&gt;0과 1값&lt;/strong&gt;을 가지며 하나의 임계 구역만을 상호배제하기 위한 알고리즘&lt;/li&gt;
      &lt;li&gt;잠금, 엄격한 교대, TSL&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;산술(계수형 세마포어)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;세마포어 변수가 &lt;strong&gt;0과 양의 정수&lt;/strong&gt;를 값으로 가지며 임계 구역을 여러 개 관리하기 위한 상호배제 알고리즘&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 개의 프로세스가 동시에 그값을 수정하지 못한다&lt;/li&gt;
  &lt;li&gt;세마포어에 대한 연산은 처리 중에 인터럽트 되어서는 안된다&lt;/li&gt;
  &lt;li&gt;세마포어데 대한 연산은 소프트웨어나 하드웨어로 구현 가능&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt; 조작은 블록 큐에 &lt;strong&gt;대기 중인 프로세스를 깨우는 신호&lt;/strong&gt;로서, 흔히 &lt;strong&gt;Signal&lt;/strong&gt; 동작이라 한다&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; 조작은 임계 영역을 사용하려는 프로세서들의 &lt;strong&gt;진입 여부를 결정&lt;/strong&gt;하는 것으로, 흔히 &lt;strong&gt;Wait&lt;/strong&gt; 동작이라 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모니터monitor&quot;&gt;모니터(Monitor)&lt;/h1&gt;
&lt;p&gt;상호배제를 위한 데이터 및 프로그램 모듈로 운영체제 내부의 프로그램을 모니터라고 한다. 공유 자원을 사용하기 위해 기다리는 프로세스들은 모니터에 진입해도 좋다는 허가를 기다리며 모니터에서는 &lt;strong&gt;프로세스들의 공유 자원 점유 순서를 제어&lt;/strong&gt;한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;두 개 이상의 프로세스가 특정 공유 자원을 순차적으로 할당하는 데 필요한 데이터 및 프로시저를 포함하는 &lt;strong&gt;병행성 구조&lt;/strong&gt;(Concurrency Construct)이다&lt;/li&gt;
  &lt;li&gt;모니터 내의 자원을 원하는 프로세스는 반드시 해당 &lt;strong&gt;모니터의 진입부를 호출&lt;/strong&gt;해야 한다&lt;/li&gt;
  &lt;li&gt;모니터 외부의 프로세스는 모니터 &lt;strong&gt;내부의 데이터를 직접 접근 불가&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자료 추상화&lt;/strong&gt;와 &lt;strong&gt;정보 은폐&lt;/strong&gt;의 개념을 기초적으로 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;스위치 개념&lt;/strong&gt;을 사용하여 한순간에 하나의 프로세스만이 모니터에 진입 가능&lt;/li&gt;
  &lt;li&gt;모니터에서 사용되는 &lt;strong&gt;연산은 Wait와 Signal&lt;/strong&gt;이 있다&lt;/li&gt;
  &lt;li&gt;모니터의 &lt;strong&gt;경계&lt;/strong&gt;에서 상호배제가 시행&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;교착상태dead-lock&quot;&gt;교착상태(Dead-Lock)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/deadlock.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/deadlock.png&quot; alt=&quot;&quot; title=&quot;교착상태(Deadlock)&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;두 개 이상의 프로세스가 하나의 자원을 공유하여 사용하고 있을 때 &lt;strong&gt;서로가 사용 중인 자원을 요구&lt;/strong&gt;하지만 &lt;strong&gt;요구를 영원히 들어줄 수 없는&lt;/strong&gt; 상태를 의미&lt;/p&gt;

&lt;h2 id=&quot;교착상태-발생-필수-4대-요소&quot;&gt;교착상태 발생 필수 4대 요소&lt;/h2&gt;
&lt;h3 id=&quot;상호배제mutual-exclusion&quot;&gt;상호배제(Mutual Exclusion)&lt;/h3&gt;
&lt;p&gt;여러 개의 프로세스를 동시에 운영하는 다중 프로그래밍 방식에서는 &lt;strong&gt;제한된 자원을 서로 공유&lt;/strong&gt;하면서 효율적으로 사용해야 하기 때문에 상호배제를 해야 한다. 이러한 상호배제는 여러 개의 프로세스를 동시에 처리하기 위하여 공유 자원을 &lt;strong&gt;순차적 처리하면서, 동시에 접근하지 못하도록&lt;/strong&gt; 해야 한다.&lt;/p&gt;

&lt;p&gt;하지만, 이러한 상호배제가 실패하게 되면 교착상태가 발생할 수 있기 때문에 상호배제는 교착상태 발생의 필수 조건 중 하나가 된다&lt;/p&gt;

&lt;h3 id=&quot;점유와-대기hold--wait&quot;&gt;점유와 대기(Hold &amp;amp; Wait)&lt;/h3&gt;
&lt;p&gt;시스템의 성능을 높이기 위해서는 여러 개의 프로세스를 동시에 운영하면서 사용 중이거나 사용 중이 아닌 공유 자원들을 순차적으로 배분해 주어야 시스템 성능이 향상될 것이다&lt;/p&gt;

&lt;p&gt;따라서 점유와 대기는 존재할 수 밖에 없고 이는 교착상태 발생의 필수 조건 중 하나가 된다&lt;/p&gt;

&lt;h3 id=&quot;비선점non-preemption&quot;&gt;비선점(Non-Preemption)&lt;/h3&gt;
&lt;p&gt;비선점이란, 이미 사용 중인 공유 자원들을 빼앗을 수 없다는 의미&lt;/p&gt;

&lt;p&gt;하나의 프로세스가 특정 공유 자원을 사용하다가 프로그램 루틴의 문제로 임계 구역 내부에서 중단되었을 때 만약 이 자원을 빼앗을 수 없다면 이 자원을 사용하기 위해 대기 중이던 프로세스는 영원히 원하는 자원을 빼앗을 수 없다는 것은 비선점이고 이는 교착상태 발생의 필수 조건 중에 하나가 된다&lt;/p&gt;

&lt;h3 id=&quot;순환-대기circular-wait-환형-대기&quot;&gt;순환 대기(Circular Wait, 환형 대기)&lt;/h3&gt;
&lt;p&gt;공유 자원들을 프로세스에게 분배할 때 입력 순으로 순차적으로 분배한다면 시간이 오래 걸려 성능이 떨어질 뿐 교착상태는 발생하지 않을 것이다. 순차적으로 분배하지 않고 당장 사용하지 않는 자원은 다른 프로세스가 사용하게 한다면 자원을 효율적으로 사용하게 될 것이다.&lt;/p&gt;

&lt;p&gt;이처럼 모든 프로세스와 자원을 순차적으로 사용하지 않고 사용 시기와 순서를 융통성있게 조절하게 될 때 프로세스의 자원의 점유와 대기 상태는 환형 상태가 될 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;교착상태-해결-방안&quot;&gt;교착상태 해결 방안&lt;/h2&gt;
&lt;h3 id=&quot;예방prevention&quot;&gt;예방(Prevention)&lt;/h3&gt;
&lt;p&gt;교착상태가 &lt;strong&gt;절대 발생하지 않도록 사전에 조치를 취하는 방안이지만&lt;/strong&gt;, &lt;strong&gt;성능은 낮아&lt;/strong&gt;질 수 밖에 없다. 교착상태 발생의 &lt;strong&gt;네 가지 조건 중에서 하나를 제거&lt;/strong&gt;함으로서 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;상호배제 부정
&lt;strong&gt;단일 프로그램을 운영&lt;/strong&gt;하거나, &lt;strong&gt;자원을 독립적&lt;/strong&gt;으로 사용하여 임계 구역을 없애고 상호배제를 하지 않는다면 교착상태는 절대 발생하지 않는다. 하지만 &lt;strong&gt;자원의 낭비나 신뢰성이 낮아&lt;/strong&gt;지기 때문에 사용하기에 적절하지 않은 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;점유와 대기 부정
각 프로세스는 &lt;strong&gt;한 번에 자신에게 필요한 모든 자원을 요구&lt;/strong&gt;해야 하며, 이 요구가 &lt;strong&gt;만족되지 않으면 작업을 진행할 수 없다&lt;/strong&gt;. 또한 어떤 자원을 갖고 있는 프로세스가 더 이상 요구가 수용되지 않으면 원래 갖고 있던 자원을 일단 반납하고 필요하다면 다시 그 자원이나 다른 자원을 요구해야 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;비선점 부정
프로세스가 점유하고 있는 자원들을 언제든 빼앗을 수 있도록 한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;순환 대기 부정
한 프로세스가 주어진 유형의 자원을 할당받았으면 그 프로세스는 순서에 따라 나중에 위치하는 유형의 자원말을 요구할 수 있게 한다&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;모든 자원을 선형 순서로 분류&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;회피avoidance&quot;&gt;회피(Avoidance)&lt;/h3&gt;
&lt;p&gt;프로세스가 자원을 요구할 때 시스템이 안전(교착상태가 발생하지 않는 범위 내) 상태를 유지할 수 있는 프로세스의 자원 요구만을 할당해주는 방안&lt;/p&gt;

&lt;h4 id=&quot;은행원-알고리즘bankers-algorithm&quot;&gt;은행원 알고리즘(Banker’s Algorithm)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/banker-algorithm.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/banker-algorithm.png&quot; alt=&quot;&quot; title=&quot;은행원 알고리즘&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Dijkstra가 제안한 방식으로 &lt;strong&gt;불안전 상태&lt;/strong&gt;와 &lt;strong&gt;안전 상태&lt;/strong&gt;로 구분한다. &lt;strong&gt;안전 상태에서는 교착상태가 발생하지 않으며&lt;/strong&gt;, 은행원 알고리즘을 적용하기 위해서는 &lt;strong&gt;자원의 양&lt;/strong&gt;과 &lt;strong&gt;사용자의 수&lt;/strong&gt;가 &lt;strong&gt;일정&lt;/strong&gt;해야 한다. 또한 모든 요구를 &lt;strong&gt;정해진 시간 안에 할당하는 것을 보장&lt;/strong&gt;해야 한다.&lt;/p&gt;

&lt;p&gt;하지만, 은행원 알고리즘은 응답 시간이 보장되어야 하는 &lt;strong&gt;대화식 시스템에 적용하기 어렵다&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;은행원 : 운영체제&lt;/li&gt;
  &lt;li&gt;대출자 : 프로세스&lt;/li&gt;
  &lt;li&gt;은행 보유 금액 : 자원 수&lt;/li&gt;
  &lt;li&gt;현재 대출 금액 : 각 프로세스가 점유하고 잇는 자원 수&lt;/li&gt;
  &lt;li&gt;대출 한도 금액 : 프로세스가 완료할 때까지 필요한 총 자원 수&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;발견detection&quot;&gt;발견(Detection)&lt;/h3&gt;
&lt;p&gt;자원 할당 그래프는 시스템이 주된 이유가 교착상태인가를 발견하는 기법. 교착상태임이 발견되면 해당 프로세스와 자원을 선점하거나 중단 시켜 교착상태 해결&lt;/p&gt;

&lt;h3 id=&quot;회복recovery&quot;&gt;회복(Recovery)&lt;/h3&gt;
&lt;p&gt;실행 중인 모든 프로세스가 정상적으로 작업을 완료할 수 없기 때문에 발생한 교착상태이므로 어느 정도의 &lt;strong&gt;희생은 감수&lt;/strong&gt;해야 한다. 즉, 실행을 중단하거나 점유 중인 자원을 빼앗을 프로세스를 찾는 일로 가능한 손실이 적은 쪽을 선택해야 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;선점을 통한 회복&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;보유하고 있는 &lt;strong&gt;자원을 빼앗아&lt;/strong&gt; 교착상태를 해결하고 시스템을 정상으로 회복하는 방법&lt;/li&gt;
      &lt;li&gt;우선순위가 낮은, 진행 상태가 적은, 자원을 적게 사용하고 있는 프로세스의 자원을 선점하여 프로세스를 일시 중단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;복귀(Rollback)를 통한 회복&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;교착상태가 발생하기 이전 상태로 복귀하여 다시 실행하는 방법&lt;/li&gt;
      &lt;li&gt;현재 실행 중인 전체 프로세스를 대상으로 할 수 있지만 더욱 효과적인 방법은 &lt;strong&gt;교착상태를 해결할 만큼의 프로세스들만을 선택하여 처음부터 다시 실행&lt;/strong&gt;하는 것&lt;/li&gt;
      &lt;li&gt;현재까지 실행되고 있는 프로세스와 중단된 프로세스의 정보를 &lt;strong&gt;재구성해야하는 어려움&lt;/strong&gt;이 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;제거(Kill)를 통한 회복&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;우선순위가 낮은, 진행 상태가 적은, 자원을 적게 사용하고 있는 프로세스를 선택하여 제거&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;기아 상태&lt;/strong&gt;나 문제가 있는 프로세스 제거&lt;/li&gt;
      &lt;li&gt;정상 수행이 불가능한 모든 프로세스를 제거하고 다시 시작&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;사용자의 조치 경로(Routing) 선택&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Window OS : Ctrl + Alt + Delete를 입력하면 현재 작동 중인 프로세스 리스트가 나오게 되는데 이 때 문제가 있는 프로세스를 선택하여 제거&lt;/li&gt;
      &lt;li&gt;Unix OS : ps 명령을 입력하면 현재 프로세스들의 리스트가 출력되는데 이 때 문제가 있는 프로세스들을 kill/killall 명령으로 제거&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 16 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-concurrent-process-synchronization/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-concurrent-process-synchronization/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] CPU 스케줄링</title>
        <description>&lt;h1 id=&quot;cpu-스케줄링&quot;&gt;CPU 스케줄링&lt;/h1&gt;
&lt;p&gt;다중 프로그래밍 방식의 운영체제는 하나의 주기억 장소에 여러 개의 프로세스가 실행된다. 여러 개의 프로세스가 실행되지만, 컴퓨터 시스템에서 보유하고 있는 자원들은 극히 &lt;strong&gt;제한적&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;　
이러한 제한된 환경 아래서 최적의 효과를 보기 위해서는 &lt;strong&gt;프로세스의 계획적인 실행 순서&lt;/strong&gt;가 필요하다. 이러한 계획적인 실행 순서를 CPU 스케줄링 혹은 프로세스 스케줄링이라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;스케줄링-목적&quot;&gt;스케줄링 목적&lt;/h2&gt;
&lt;p&gt;CPU나 자원을 효과적이며 생산성 있게 사용하기 위한 소프트웨어적 계획을 의미. 이러한 프로세스 스케줄링은 필요한 하드웨어 레지스터를 설정함으로써 프로세스에게 CPU를 할당하고 &lt;a href=&quot;/study/os-interrupt/#문맥-교환context-switching&quot;&gt;문맥 교환&lt;/a&gt;을 하는 프로세스 관리 기능이다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 프로세스들에게 공정하게 배정해야 한다(&lt;strong&gt;공정성&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;단위 시간당 가능한 &lt;strong&gt;최대한 많은 양이 처리&lt;/strong&gt;될 수 있도록 해야 한다&lt;/li&gt;
  &lt;li&gt;응답 시간이 &lt;strong&gt;신속&lt;/strong&gt;해야 한다&lt;/li&gt;
  &lt;li&gt;같은 종류의 작업은 거의 같은 시간과 비용으로 실행될 수 있어야 한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;오버헤드를 최소화&lt;/strong&gt;해야 한다&lt;/li&gt;
  &lt;li&gt;시스템 내 &lt;strong&gt;자원을 사용하지 않는 시간이 없도록 유지&lt;/strong&gt;해야 한다&lt;/li&gt;
  &lt;li&gt;응답 시간과 자원의 활용 간 적절한 균형이 유지되도록 해야 한다&lt;/li&gt;
  &lt;li&gt;프로세스가 무한정 기다리게 하는 것을 피해야 한다&lt;/li&gt;
  &lt;li&gt;프로세스의 상태를 파악하여 우선순위를 부여하는 것이 좋다&lt;/li&gt;
  &lt;li&gt;중요 자원을 차지하고 있는 프로세스에 우선권을 부여해야 한다&lt;/li&gt;
  &lt;li&gt;문제로 인해 불안하지 않은 프로세스에 서비스를 많이 제공하도록 한다&lt;/li&gt;
  &lt;li&gt;부하가 많은 경우 갑자기 체증이 발생하지 않도록 조절해야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스케줄링-평가-기준&quot;&gt;스케줄링 평가 기준&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;시스템 관점
    &lt;ul&gt;
      &lt;li&gt;CPU 이용률 : &lt;i class=&quot;fas fa-search-plus&quot;&gt;&lt;/i&gt;&lt;strong&gt;최대화&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;처리 능력(Throughput) : 단위 시간당 처리할 수 있는 CPU의 작업량 &lt;i class=&quot;fas fa-search-plus&quot;&gt;&lt;/i&gt;&lt;strong&gt;최대화&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스 관점
    &lt;ul&gt;
      &lt;li&gt;대기(Waiting) 시간 : 준비 상태에서 대기하는 시간 &lt;i class=&quot;fas fa-search-minus&quot;&gt;&lt;/i&gt;&lt;strong&gt;최소화&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;응답(Response) 시간 : 입력에 대해 처음 반응하는 시간 &lt;i class=&quot;fas fa-search-minus&quot;&gt;&lt;/i&gt;&lt;strong&gt;최소화&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;반환(Turn-around) 시간 : 작업을 지시하고 결과가 되돌아오는 시간 &lt;i class=&quot;fas fa-search-minus&quot;&gt;&lt;/i&gt;&lt;strong&gt;최소화&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;스케줄링-알고리즘&quot;&gt;스케줄링 알고리즘&lt;/h2&gt;
&lt;p&gt;다중 프로그래밍 방식은 메모리에 여러 개의 프로그램을 적재함으로써 CPU와 I/O 장치들의 유휴 시간을 줄여 사용 효율을 높이는 방식이다. 이러한 다중 프로그래밍 방식에서 &lt;strong&gt;CPU의 사용률과 처리율을 최대화 하기 위한 방법&lt;/strong&gt;들을 프로세스 스케줄링 알고리즘이라고 한다&lt;/p&gt;

&lt;h3 id=&quot;비선점형-방식non-preemptive&quot;&gt;비선점형 방식(Non-Preemptive)&lt;/h3&gt;
&lt;p&gt;현재 실행 중인 프로세스가 자발적으로 CPU를 중단하는 경우에만 CPU 스케줄링을 수행하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일괄처리 방식에 적당&lt;/li&gt;
  &lt;li&gt;대화형/시간 분할/실시간 시스템 부적합&lt;/li&gt;
  &lt;li&gt;응답 시간 예측이 어렵다&lt;/li&gt;
  &lt;li&gt;문맥 교환이 적어 오버헤드가 적다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;fcfsfirst-come-first-served-fifo-first-input-first-out&quot;&gt;FCFS(First Come First Served, FIFO: First Input First Out)&lt;/h4&gt;
&lt;p&gt;먼저 입력된 작업을 먼저 처리하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가장 대표적인 비선점형 방식&lt;/li&gt;
  &lt;li&gt;공평하고 구현이 간단하나, 평균 반환 시간이 길다&lt;/li&gt;
  &lt;li&gt;짧은 작업이나 중요한 작업이 지연될 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;sjfshortest-job-first-최단-작업-우선&quot;&gt;SJF(Shortest Job First, 최단 작업 우선)&lt;/h4&gt;
&lt;p&gt;작업이 끝나기까지의 실행 시간 추정치가 가장 작은 작업을 먼저 실행시키는 방식. 비선점형이기 때문에 긴 작업일지라도 이미 CPU를 점유하고 있다면 뒤로 밀려나지 않고 처리되고 다음 작업들을 대상으로 재정리를 수행한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;평균 대기 시간을 최소화한다&lt;/li&gt;
  &lt;li&gt;프로세스의 다음 CPU 사용시간을 예측해야하는 어려움이 있다&lt;/li&gt;
  &lt;li&gt;긴 작업의 경우 계속해서 입력되는 짧은 작업들 때문에 우선순위가 계속 밀려나게 되고 &lt;strong&gt;무한 연기 상태&lt;/strong&gt;가 발생하기도 한다&lt;/li&gt;
  &lt;li&gt;위 무한 연기 현상을 방지하기 위해 &lt;strong&gt;에이징(Aging)&lt;/strong&gt;&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt; 기법을 사용하여 해결&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;strong&gt;에이징 기법&lt;/strong&gt; : 자원이 할당되기를 오랜 시간 동안 기다린 프로세스는 기다린 시간에 비례하는 높은 우선순위를 부여하여 가까운 시간 안에 자원이 할당되도록 하는 기법&lt;/p&gt;

&lt;h4 id=&quot;hrnhighest-response-ratio-next&quot;&gt;HRN(Highest Response-ratio Next)&lt;/h4&gt;
&lt;p&gt;실행 시간 추정과 선점 기능 때문에 스케줄러가 복잡해지고 남은 계산 시간들을 저장해 놓아야 한다는 단점을 보완, 서비스 시간(실행 시간 추정치)과 대기 시간의 비율을 고려한 스케줄링 방식&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;우선순위 = $\frac{대기 시간 + 서비스 시간}{서비스 시간}$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;SJF를 개선한 방식&lt;/li&gt;
  &lt;li&gt;우선 순위 계산 공식을 이용하며, 계산된 값이 가장 큰 작업에게 우선권을 부여&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;우선순위priority&quot;&gt;우선순위(Priority)&lt;/h4&gt;
&lt;p&gt;대기 리스트에 있는 프로세스들에게 작업의 우선순위를 부여하여 CPU를 할당하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;고정적 우선순위와 동적 우선순위 방식이 존재&lt;/li&gt;
  &lt;li&gt;기아 현상, 무한 봉쇄 현상 발생 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;기한부deadline&quot;&gt;기한부(Deadline)&lt;/h4&gt;
&lt;p&gt;제한된 시간 내에 반드시 작업이 완료되도록 스케줄링하는 방식. 제한된 시간을 정확히 추정하여 그 시간 만큼에 CPU 사용 시간을 제한한다. 작업이 제한 시간 내에 처리되지 않으면 다시는 해당 작업이 CPU 사용 시간을 합당받을 수 없다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스들이 마감 시간 내에 처리되지 않으면 폐기되거나 처음부터 다시 실행 필요&lt;/li&gt;
  &lt;li&gt;기한부 스케줄링에 필요한 집약적 자원 관리는 많은 오버헤드를 일으킬 수 있다&lt;/li&gt;
  &lt;li&gt;동시에 다수의 기한부 작업이 수행되면 스케줄링은 매우 어려워질 수 있다&lt;/li&gt;
  &lt;li&gt;사용자는 작업에 필요한 자원의 정확한 정보를 시스템에 제시하여야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;선점형-방식preemtive&quot;&gt;선점형 방식(Preemtive)&lt;/h3&gt;
&lt;p&gt;하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;대화형, 시간 분할, 실시간 시스템에 적합&lt;/li&gt;
  &lt;li&gt;응답 시간 예측이 용이하다&lt;/li&gt;
  &lt;li&gt;문맥 교환이 많아 오버헤드가 많다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;라운드-로빈rr-round-robin&quot;&gt;라운드 로빈(RR, Round-Robin)&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;/study/os-development-process/#시분할-처리time-sharing-processing-시스템&quot;&gt;시분할 시스템&lt;/a&gt;을 위해 고안되었으며 여러 개의 프로세스가 10 ~ 100msec 정도의 시간 할당량(Quantum, Time Slice)이라는 작은 단위 시간이 정의되어 시간 할당량만큼씩 CPU를 사용하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FIFO 스케줄링을 선점형으로 변환한 방식&lt;/li&gt;
  &lt;li&gt;적절한 응답 시간을 보장해주는 대화식 사용자에게 효과적&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시간 할당량이 클 때, &lt;i class=&quot;fas fa-search-plus&quot;&gt;&lt;/i&gt;
    &lt;ul&gt;
      &lt;li&gt;FIFO 방식과 거의 같은 형태가 된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시간 할당량이 작을 때, &lt;i class=&quot;fas fa-search-minus&quot;&gt;&lt;/i&gt;
    &lt;ul&gt;
      &lt;li&gt;프로세스 간의 전이가 많아지므로 프로세스가 전이되는 과정에서 필요한 문맥 교환 수 증가&lt;/li&gt;
      &lt;li&gt;실행 시간보다 문맥 교환의 교체에 사용되는 부가적인 시간이 증가하게 되므로 오버헤드가 증가&lt;/li&gt;
      &lt;li&gt;프로세서의 교환에서 시간을 소비하고 실제 사용자들의 연산은 거의 못하는 결과를 초래&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;srtshortest-remaining-time&quot;&gt;SRT(Shortest Remaining Time)&lt;/h4&gt;
&lt;p&gt;작업이 끝나기까지 &lt;strong&gt;남아 있는&lt;/strong&gt; 실행 시간의 추정치가 가장 작은 프로세스를 먼저 실행하는 방식으로 &lt;strong&gt;새로 입력되는 작업까지도 포함&lt;/strong&gt;된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실행 시간 추적과 서비스 받은 시간을 기록해야 하므로 오버헤드가 증가&lt;/li&gt;
  &lt;li&gt;임계치(Threshold Value)&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt;를 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;strong&gt;임계치&lt;/strong&gt; : CPU를 사용 중인 프로세스가 거의 마지막에 이르렀을 때 남아 있는 시간보다 조금 작은 프로세스가 입력된다면 &lt;strong&gt;순수 SRT는 조금 작은 프로세스에게 CPU 사용 권한을 넘겨주어야&lt;/strong&gt; 한다. 하지만 이럴 경우 &lt;strong&gt;문맥 교환 횟수나 전체 정황으로 보았을 때&lt;/strong&gt; 현재 현재 작업 중인 프로세스를 모두 마치고 조금 &lt;strong&gt;작은 프로세스를 다음에 처리하는 것이 더 효율적&lt;/strong&gt;일 것이다. 이러한 경우를 &lt;strong&gt;추정해서 공식에 적용시켜 얻어진 수치&lt;/strong&gt;를 의미한다&lt;/p&gt;

&lt;h4 id=&quot;다단계-큐mq-multi-level-queue&quot;&gt;다단계 큐(MQ, Multi-level Queue)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/mulitlevel-queue.png&quot; title=&quot;https://www.includehelp.com/operating-systems/multilevel-queue-scheduling-in-operating-system.aspx&quot;&gt;&lt;img src=&quot;../../assets/images/os/mulitlevel-queue.png&quot; alt=&quot;&quot; title=&quot;다단계(멀티레벨) 큐&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;준비 큐를 여러 종류의 그룹으로 나누고 여러 개의 큐에 다양한 알고리즘을 적용하는 스케줄링 기법. 일반적으로 멀티레벨 큐에서 준비 큐는 대화형 작업을 담기 위한 &lt;strong&gt;전위 큐(Foreground Queue)&lt;/strong&gt;와 계산 위주의 작업을 담기 위한 &lt;strong&gt;후위 큐(Background Queue)&lt;/strong&gt;로 분할되어 프로세스들은 자신의 우선순위 값에 해당하는 큐에 들어가며 우선순위가 낮은 하위 단계 큐의 작업은 실행중이더라도 상위 단계 큐에 프로세스가 도착하면 CPU를 뺏기는 선점 방식이다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선점, 비선점 방식&lt;/li&gt;
  &lt;li&gt;정적 우선순위를 사용하는 스케줄링을 구현 할 때 가장 적합&lt;/li&gt;
  &lt;li&gt;서로 다른 우선순위의 프로세스들을 구별하고 관리하기 위해 우선순위의 개수만큼 큐가 필요&lt;/li&gt;
  &lt;li&gt;큐를 특성별로 여러 개 가지며, 각 독립적인 스케줄링을 가진다&lt;/li&gt;
  &lt;li&gt;큐 간에 &lt;strong&gt;프로세스가 이동이 안된다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;우선순위가 가장 높은 큐에서는 비선점형으로 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;다단계-피드백-큐mfq-multi-level-feedback-queue&quot;&gt;다단계 피드백 큐(MFQ, Multi level Feedback Queue)&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/os/multilevel-feedback-queue.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/multilevel-feedback-queue.png&quot; alt=&quot;&quot; title=&quot;다단계(멀티레벨) 피드백 큐&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;짧은 작업이나 입출력 위주의 작업에 우선권을 부여하기 위해 개발된 방식으로 적응 기법의 개념을 적용. 큐 간에 프로세스가 이동이 불가한 다단계 큐(MQ)의 단점을 보완&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;큐마다 시간 할당량이 존재하며 &lt;strong&gt;낮은 큐일수록 시간 할당량은 커진다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;각각의 큐들은 종속적으로 연결되어 있다&lt;/li&gt;
  &lt;li&gt;CPU를 시간 할당량만큼 사용한 프로세스는 낮은 큐로 이동&lt;/li&gt;
  &lt;li&gt;맨 위에 큐는 &lt;strong&gt;RR방식&lt;/strong&gt;을 사용, 맨 마지막 큐는 &lt;strong&gt;FCFS방식&lt;/strong&gt; 사용&lt;/li&gt;
  &lt;li&gt;우선순위가 낮은 프로세스는 계속 지연되는 &lt;strong&gt;기아(Starvation) 현상&lt;/strong&gt;이 발생할 수 있다 &lt;i class=&quot;far fa-hand-point-right&quot;&gt;&lt;/i&gt; &lt;strong&gt;Aging 기법&lt;/strong&gt; 사용으로 해결&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 15 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-cpu-scheduling/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-cpu-scheduling/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 프로세스</title>
        <description>&lt;h1 id=&quot;프로세스process&quot;&gt;프로세스(Process)&lt;/h1&gt;
&lt;p&gt;파일로 작성된 프로그램은 &lt;a href=&quot;/study/os-system-software/#로더loader&quot;&gt;로더&lt;/a&gt;에 의해 주기억 장치에 상주되어 CPU에 의해서 처리된다. 이 때, &lt;strong&gt;주기억 장치&lt;/strong&gt;에 상주된 &lt;strong&gt;프로그램&lt;/strong&gt;이 &lt;strong&gt;CPU에 의해서 처리&lt;/strong&gt;되는 상태를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스&lt;/code&gt;라고 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU에 의해서 현재 &lt;strong&gt;실행되고 있는 프로그램&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PCB&lt;/code&gt;(&lt;strong&gt;Process Control Block&lt;/strong&gt;, 프로세스 제어 블록)의 존재로서 명시되는 것&lt;/li&gt;
  &lt;li&gt;프로세서가 할당되는 개체로서 디스패치가 가능한 단위&lt;/li&gt;
  &lt;li&gt;지정된 결과를 얻기 위한 일련의 &lt;strong&gt;계통적 동작&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;목적 또는 결과에 따라 발생하는 사건들의 과정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비동기적 행위&lt;/strong&gt;&lt;sup&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;/sup&gt;를 일으키는 주체&lt;/li&gt;
  &lt;li&gt;프로시저가 활동 중인 상태를 의미&lt;/li&gt;
  &lt;li&gt;실행 중인 프로시저의 제어 궤적&lt;/li&gt;
  &lt;li&gt;CPU가 할당되는 실체&lt;/li&gt;
  &lt;li&gt;운영체제가 관리하는 &lt;strong&gt;최소 단위의 작업&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--warning&quot;&gt;&lt;strong&gt;비동기적 행위&lt;/strong&gt; : 다중 프로그래밍 방식에서 CPU가 하나의 프로그램만을 연속적으로 처리하지 않고, 여러 프로그램의 일부분을 반복적으로 실행하고 중단하는 행위&lt;/p&gt;

&lt;h2 id=&quot;프로세스의-상태전이도&quot;&gt;프로세스의 상태전이도&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/process-state-diagram.png&quot; title=&quot;https://afteracademy.com/blog/what-is-long-term-short-term-and-medium-term-scheduler&quot;&gt;&lt;img src=&quot;../../assets/images/OS/process-state-diagram.png&quot; alt=&quot;&quot; title=&quot;프로세스의 상태 전이도&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-상태&quot;&gt;프로세스 상태&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;New(생성)&lt;/strong&gt;&lt;br /&gt;
프로세스가 막 생성된 상태&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ready(준비)&lt;/strong&gt;&lt;br /&gt;
프로세스가 처리기를 사용하고 있지는 않지만 언제든 사용할 수 있는 상태를 의미
    &lt;ul&gt;
      &lt;li&gt;프로세스가 처리기의 배정을 기다리고 있는 상태&lt;/li&gt;
      &lt;li&gt;다른 프로세스 실행을 위해서 일시적으로 정지해있는 상태&lt;/li&gt;
      &lt;li&gt;CPU에 의해 처리되기 위해 주기억 장치에 존재하는 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Running(실행)&lt;/strong&gt;&lt;br /&gt;
프로세스가 CPU를 차지하고 있는 상태 또는 프로세스의 명령이 실행되고 있는 상태를 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Block(Wait, 대기/보류)&lt;/strong&gt;&lt;br /&gt;
프로세스가 어떤 사건이 일어나기를 기다리고 있는 상태
    &lt;ul&gt;
      &lt;li&gt;처리 속도가 느린 I/O 작업 중인 상태&lt;/li&gt;
      &lt;li&gt;외부적인 사건이 생길 때까지 실행할 수 없는 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Blocked Suspended&lt;/strong&gt;&lt;br /&gt;
프로세스가 대기 상태에서 기억 장치를 잃은 상태&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Suspended Ready&lt;/strong&gt;&lt;br /&gt;
프로세스가 기억장치를 제외한 다른 모든 필요한 자원을 보유한 상태&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Exit(Terminated)&lt;/strong&gt;&lt;br /&gt;
프로세스의 실행을 완료되고 할당된 CPU를 반납한 상태&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로세스-상태-변화&quot;&gt;프로세스 상태 변화&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Dispatch&lt;/strong&gt;(디스패치, 준비&lt;i class=&quot;fas fa-arrow-alt-circle-right&quot;&gt;&lt;/i&gt;실행)&lt;br /&gt;
준비 상태에 있는 여러 프로세스 중 프로세스를 선정하여 CPU를 할당하는 시점&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Timer Run Out&lt;/strong&gt;(할당 시간 종료, 실행&lt;i class=&quot;fas fa-arrow-alt-circle-right&quot;&gt;&lt;/i&gt;준비)&lt;br /&gt;
할당된 시간만큼 CPU를 사용하고 준비 상태로 변하는 시점. 상태 변이 원인이 외부에 있어 외부 인터럽트에 의해 할당 시간이 종료&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;I/O 발생&lt;/strong&gt;(Block, 실행&lt;i class=&quot;fas fa-arrow-alt-circle-right&quot;&gt;&lt;/i&gt;대기)&lt;br /&gt;
프로세스가 CPU 사용 중에 I/O 행위가 필요하여 대기 상태로 이동하는 시점&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Wake up&lt;/strong&gt;(대기&lt;i class=&quot;fas fa-arrow-alt-circle-right&quot;&gt;&lt;/i&gt;준비)&lt;br /&gt;
I/O 작업이 완료되거나 자원이 할당되어 다시 준비 상태로 이동하는 시점&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Suspended&lt;/strong&gt;(&lt;strong&gt;Swap-Out&lt;/strong&gt;, 대기&lt;i class=&quot;fas fa-arrow-alt-circle-right&quot;&gt;&lt;/i&gt;지연준비)&lt;br /&gt;
준비/대기 상태에서 기억 장치를 반납하고 지연 준비 상태로 전이&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Resume&lt;/strong&gt;(&lt;strong&gt;Swap-In&lt;/strong&gt;, 지연 준비&lt;i class=&quot;fas fa-arrow-alt-circle-right&quot;&gt;&lt;/i&gt;대기)&lt;br /&gt;
지연 준비/지연 대기 상태에서 기억 장치를 할당받아 준비(대기) 상태로 전이&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;프로세스-스케줄링&quot;&gt;프로세스 스케줄링&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Long-Term&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;장기&lt;/code&gt; 스케줄러, &lt;strong&gt;Job Scheduler&lt;/strong&gt;)&lt;br /&gt;
디스크에서 하나의 프로그램을 가져와 커널에 등록하면 프로세스가 되는데 이 때, 보조기억장치에서 &lt;strong&gt;어떤 프로그램을 가져와(Load) 커널(Job Queue)에 등록할 지 결정&lt;/strong&gt;하는 역할을 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Middle-Term&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중기&lt;/code&gt; 스케줄러)&lt;br /&gt;
&lt;strong&gt;메모리에 적재된 프로세스의 수를 동적으로 조절&lt;/strong&gt;하기 위해 추가된 스케줄러&lt;/p&gt;

    &lt;p&gt;만약 메모리에 많은 수의 프로세스가 적재되어 프로세스 당 보유하고 있는 메모리량이 극도로 적어지게 되면 CPU 수행에 당장 필요한 프로세스의 주소 공간 조차도 메모리에 올려놓기 힘든 상황이 발생할 수 있다. 이 때, 디스크 I/O가 수시로 발생하게 되어 시스템의 성능이 심각하게 저하될 수 있다&lt;/p&gt;

    &lt;p&gt;이런 경우에, 메모리를 올라와 있는 프로세스 중 일부로부터 메모리를 &lt;strong&gt;여유공간을 마련&lt;/strong&gt;하기 위해 &lt;strong&gt;프로세스를 통째로 빼앗아&lt;/strong&gt; 그 내용을 디스크의 &lt;strong&gt;스왑 영역에 저장&lt;/strong&gt;한다(&lt;strong&gt;Swap-Out&lt;/strong&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Short-Term&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단기&lt;/code&gt; 스케줄러, &lt;strong&gt;CPU scheduler&lt;/strong&gt;)&lt;br /&gt;
&lt;strong&gt;준비 상태&lt;/strong&gt;의 프로세스 중에서 어떤 프로세스를 다음 번에 &lt;strong&gt;실행 상태&lt;/strong&gt;로 만들 것인지를 결정하는 역할을 수행(메모리에 있는 프로그램들 중 어떤 프로세스를 CPU에 할당할 지 결정)&lt;/p&gt;

    &lt;p&gt;시분할 시스템에서 &lt;strong&gt;타이머 인터럽트가 발생&lt;/strong&gt;하면 단기 스케줄러가 &lt;strong&gt;호출&lt;/strong&gt;된다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;스풀spool-simultaneous-peripheral-operation-on-line&quot;&gt;스풀(Spool, Simultaneous Peripheral Operation On​-Line)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;프로그램&lt;/strong&gt;과 이를 이용하는 &lt;strong&gt;I/O 장치와의 속도 차를 극복&lt;/strong&gt;하기 위한 장치로 대부분의 &lt;strong&gt;하드 디스크가 중재&lt;/strong&gt;(프린트 작업에서도 사용)&lt;/p&gt;

&lt;h3 id=&quot;버퍼링buffering&quot;&gt;버퍼링(Buffering)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;CPU&lt;/strong&gt;와 &lt;strong&gt;I/O 장치&lt;/strong&gt;와의 속도 차이를 줄이기 위해 &lt;strong&gt;메모리가 중재&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;버퍼링은 &lt;strong&gt;한 레코드를 미리 읽어&lt;/strong&gt; CPU에 저장해 두고 CPU가 필요한 레코드를 일기 위해 기다리는 일이 없도록 한다&lt;/p&gt;
</description>
        <pubDate>Tue, 13 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-process/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-process/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 인터럽트(Interrupt)</title>
        <description>&lt;h1 id=&quot;인터럽트&quot;&gt;인터럽트&lt;/h1&gt;
&lt;p&gt;프로세스가 수행 중에 다른 프로세스를 수행하기 위하여 현재 수행 중인 프로세스를 중단하거나 외부 입력 장치에 의해 프로세스가 중단되는 상태&lt;/p&gt;

&lt;h2 id=&quot;인터럽트-작업-순서&quot;&gt;인터럽트 작업 순서&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;../../assets/images/os/interrupt-processing-routine.png&quot;&gt;&lt;img src=&quot;../../assets/images/os/interrupt-processing-routine.png&quot; alt=&quot;&quot; title=&quot;인터럽트 처리 흐름&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;인터럽트가 발생하면 &lt;strong&gt;운영체제가 제어권&lt;/strong&gt;을 받는다&lt;/li&gt;
  &lt;li&gt;운영체제는 인터럽트 받은 &lt;strong&gt;현재의 프로세스 상태를 저장&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;운영체제는 인터럽트의 정보를 분석하여 지정되어 있는 루틴으로 제어권을 넘겨준다&lt;/li&gt;
  &lt;li&gt;인터럽트 &lt;strong&gt;처리 루틴이 인터럽트 처리&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;인터럽트가 걸렸던 &lt;strong&gt;이전 프로세스의 상태로 복구&lt;/strong&gt;된다&lt;/li&gt;
  &lt;li&gt;인터럽트가 걸렸던 시점 &lt;strong&gt;이후부터 프로세스 실행&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;인터럽트-서비스-루틴isr-interrupt-service-routine&quot;&gt;인터럽트 서비스 루틴(ISR, Interrupt Service Routine)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;인터럽트 핸들러&lt;/strong&gt;라고도 부르며, 인터럽트 접수에 의해 발생되는 인터럽트에 대응하여 &lt;strong&gt;특정 기능을 처리하는 기계어 코드 루틴&lt;/strong&gt;이다&lt;/p&gt;

&lt;p&gt;인터럽트 핸들러는 인터럽트 원인에 따라 각각 존재하고 인터럽트 핸들러가 작업을 마치는 데 걸리는 시간도 다양하다.&lt;/p&gt;

&lt;p&gt;인터럽트 핸들러는 커널에 존재하고 응용 프로그램에는 넣지 않는다. 초기의 DOS는 인터럽트 핸들러를 응용 프로그램과 결합하여 작성하였지만, 윈도우가 본격적인 운영체제를 갖추면서 &lt;strong&gt;커널&lt;/strong&gt;에서 처리하게 되었다&lt;/p&gt;

&lt;h2 id=&quot;인터럽트-벡터-테이블ivt-interrupt-vector-table&quot;&gt;인터럽트 벡터 테이블(IVT, Interrupt Vector Table)&lt;/h2&gt;
&lt;p&gt;여러가지 인터럽트에 대해 해당 인터럽트 발생시 &lt;strong&gt;처리해야 할 루틴의 주소를 보관하고 있는 공간&lt;/strong&gt;을 의미&lt;/p&gt;

&lt;h2 id=&quot;인터럽트-종류&quot;&gt;인터럽트 종류&lt;/h2&gt;
&lt;h3 id=&quot;소프트웨어-인터럽트&quot;&gt;소프트웨어 인터럽트&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;인터럽트 이름&lt;/th&gt;
      &lt;th&gt;내용&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;SVC(SuperVisor Call) 인터럽트&lt;/td&gt;
      &lt;td&gt;- 운영체제의 제어 프로그램인 &lt;a href=&quot;/study/os-development-process/#제어-프로그램&quot;&gt;감시 프로그램&lt;/a&gt;을 호출하면 SVC 인터럽트가 발생. &lt;br /&gt;- 운영체제에서 중추적인 역할을 하는 감시 프로그램의 호출은 사용자로부터 운영체제를 보호하거나 입출력 수행 루틴 호출, 기억 장치 할당 루틴, 오퍼레이터와의 대화 등을 위해 발생하는 인터럽트&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;외부-인터럽트&quot;&gt;외부 인터럽트&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;인터럽트 이름&lt;/th&gt;
      &lt;th&gt;내용&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;전원 이상(Power Fail) 인터럽트&lt;/td&gt;
      &lt;td&gt;- 정전, 파워 이상&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;기계 착오(Machine Check) 인터럽트&lt;/td&gt;
      &lt;td&gt;- CPU의 기능적인 오류&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;외부(External) 인터럽트&lt;/td&gt;
      &lt;td&gt;- 현재 운영 중인 운영체제 소속이 아닌 외적인 요인으로부터 발생&lt;br /&gt;- &lt;strong&gt;인터럽트 시계&lt;/strong&gt;에 의해 프로세스가 시간 할당량이 종료된 경우&lt;br /&gt;- 웹 서버나 프린트 서버를 운영하고 있는 상태에서 외부로부터 인터럽트 처리 신호가 왔을 경우&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;입출력(I/O) 인터럽트&lt;/td&gt;
      &lt;td&gt;- 하드웨어적 인터럽트로 &lt;strong&gt;입출력 채널 확인, 준비, 할당, 완료&lt;/strong&gt; 시에 발생&lt;br /&gt;- 프로세스 실행 상태에서 I/O를 처리하기 위해 대기 상태로 전이되고 필요한 I/O를 요구할 때 발생(키 입력 및 프린터 출력하는 경우 등)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;내부-인터럽트&quot;&gt;내부 인터럽트&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;인터럽트 이름&lt;/th&gt;
      &lt;th&gt;내용&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;프로그램 검사(Program Check) 인터럽트( =&lt;strong&gt;Trap&lt;/strong&gt;)&lt;/td&gt;
      &lt;td&gt;- 프로그램 명령어를 수행하는 과정에서 부분적으로 발생하는 문제들에 의해 발생&lt;br /&gt;- 데이터 연산 과정에서 Overflow나 Underflow 상태 시&lt;br /&gt;- 나눗셈에서 분모가 0인 경우&lt;br /&gt;- 기억 장치의 제한된 영역을 사용하는 명령 등&lt;br /&gt;- 프로그램이 정상 수행되지 않고 시스템이 중지하거나 오류메시지를 출력하고 운영체제로 복귀하는 경우&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;인터럽트-우선순위&quot;&gt;인터럽트 우선순위&lt;/h2&gt;
&lt;p&gt;여러 장치에서 인터럽트가 동시에 발생하거나 인터럽트 서비스 루틴 수행 중 인터럽트가 발생한 경우 우선순위 판별이 필요&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;전원 이상&lt;/li&gt;
  &lt;li&gt;기계 착오&lt;/li&gt;
  &lt;li&gt;외부 신호&lt;/li&gt;
  &lt;li&gt;입출력&lt;/li&gt;
  &lt;li&gt;프로그램 검사&lt;/li&gt;
  &lt;li&gt;SVC&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;일반적으로 소프트웨어 인터럽트보다 &lt;strong&gt;하드웨어 인터럽트&lt;/strong&gt;가,
내부 인터럽트 보다 &lt;strong&gt;외부 인터럽트&lt;/strong&gt;가 우선 순위가 높다&lt;/p&gt;

&lt;h2 id=&quot;우선순위-판별-방법&quot;&gt;우선순위 판별 방법&lt;/h2&gt;
&lt;h3 id=&quot;polling폴링-소프트웨어적-방법&quot;&gt;Polling(폴링, 소프트웨어적 방법)&lt;/h3&gt;
&lt;p&gt;CPU가 모든 제어기에 연결된 TEST I/O 선을 이용해 요청한 장치를 검사하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;회로가 간단, 우선순위의 변경이 용이&lt;/li&gt;
  &lt;li&gt;검사할 때의 CPU의 자원이 필요해 반응 시간이 느리다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vectored-interrupt하드웨어적-방법&quot;&gt;Vectored Interrupt(하드웨어적 방법)&lt;/h3&gt;
&lt;p&gt;인터럽트를 요청할 수 있는 장치에 버스를 직렬 또는 병렬로 연결해 인터럽트 요청 자치의 번호를 CPU에게 알리는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;데이지 체인&lt;/strong&gt;(Daisy Chain)&lt;br /&gt;
어디에 인터럽트가 발생했는지 확인하는 회로를 &lt;strong&gt;직렬로 연결&lt;/strong&gt;하는 하드웨어적 방법으로 INTR, INTA 선에 장치들을 우선순위에 따라 &lt;strong&gt;순서대로 연결&lt;/strong&gt;하는 방식.&lt;/p&gt;

    &lt;p&gt;다른 방법에 비해 구성이 간단하나, 단순한 구조 때문에 CPU 가까이 연결된 장치에 비해 멀리있는 장치는 인터럽트 요청이 지연될 가능성이 존재&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;병렬 연결 방식&lt;/strong&gt;&lt;br /&gt;
I/O 제어기 마다 별도의 버스 선을 이용하여 INTR, INTA선을 이용해서 확인하는 방법.&lt;/p&gt;

    &lt;p&gt;이 방법은 인터럽트를 요청한 장치를 쉽게 찾을 수 있는 장점이 있으나 하드웨어 구성이 매우 복잡하며, CPU가 가지고 있는 인터럽트 포트 수에 의해서 연결할 수 있는 장치의 수가 제한된다는 단점이 존재&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문맥-교환context-switching&quot;&gt;문맥 교환(Context Switching)&lt;/h2&gt;
&lt;p&gt;다중 프로그래밍 시스템에서 CPU가 할당되는 &lt;strong&gt;프로세스를 변경&lt;/strong&gt;하기 위하여 현재 CPU를 사용하여 실행되고 있는 프로세서의 &lt;strong&gt;상태 정보를 저장&lt;/strong&gt;하고 제어권을 &lt;strong&gt;인터럽트 서비스 루틴(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ISR&lt;/code&gt;)&lt;/strong&gt;에게 넘기는 작업을 의미&lt;/p&gt;

&lt;p&gt;　
CPU는 하나의 프로세스 정보만을 기억한다. 여러 개의 프로세스가 실행되는 다중 프로그래밍 환경에서 &lt;strong&gt;CPU는 각각의 프로세스의 정보를 저장했다 복귀하는 일을 반복&lt;/strong&gt;한다. 프로세스의 저장과 복귀는 프로세스의 중단과 실행을 의미한다. 프로세스의 &lt;strong&gt;중단과 실행 시 인터럽트가 발생&lt;/strong&gt;하므로, 문맥 교환이 많이 일어난다는 것은 인터럽트가 많이 발생한다는 의미이다.&lt;/p&gt;

&lt;p&gt;　
프로세스들 시간 할당량은 시스템 성능의 중요한 역할을 한다. 시간 할당량이 적을수록 사용자 입장에서는 여러 개의 프로세스가 거의 동시에 수행되는 느낌을 갖지만 인터럽트의 수와 문맥 교환의 수가 증가한다. 프로세스의 실행을 위한 부가적인 활동을 오버헤드라고 하는데, 이 또한 문맥 교환 수가 같이 늘어나게 된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;시간 할당량 감소&lt;/strong&gt; :
    &lt;ul&gt;
      &lt;li&gt;문맥 교환 수, 인터럽트 횟수, 오버헤드 &lt;i class=&quot;fas fa-arrow-circle-right&quot;&gt;&lt;/i&gt; &lt;strong&gt;증가&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;여러 개의 프로세스가 동시에 수행되는 느낌을 받는다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시간 할당량 증가&lt;/strong&gt; :
    &lt;ul&gt;
      &lt;li&gt;문맥 교환 수, 인터럽트 횟수, 오버헤드 &lt;i class=&quot;fas fa-arrow-circle-right&quot;&gt;&lt;/i&gt; &lt;strong&gt;감소&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;여러 개의 프로세스가 동시에 수행되는 느낌을 갖지 못한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;프로세스-제어-블록pcb-process-control-block&quot;&gt;프로세스 제어 블록(PCB, Process Control Block)&lt;/h2&gt;
&lt;p&gt;여러 개의 프로세스를 수행하는 다중 프로그래밍 환경 하에서 &lt;strong&gt;각 프로세스를 구분&lt;/strong&gt;하기 위한 프로세스 정보 블록&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;항목&lt;/th&gt;
      &lt;th&gt;상세 내용&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;① 프로세스 식별자&lt;/td&gt;
      &lt;td&gt;프로세스들을 구분할 수 있는 태그/명칭/고유 이름&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;② 프로세스 현재 상태&lt;/td&gt;
      &lt;td&gt;프로세스의 현재 상태&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;③ 프로그램 카운터(PC,계수기)&lt;/td&gt;
      &lt;td&gt;다음에 실행되는 명령어의 주소&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;④ 프로세스 우선순위&lt;/td&gt;
      &lt;td&gt;프로세스의 우선순위에 대한 정보 기억&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⑤ 프로세스가 적재된 기억 장치 부분을 가리키는 포인터&lt;/td&gt;
      &lt;td&gt;프로세스가 시작되는 기억 장치의 시작 번지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⑥ 프로세스에 할당된 자원을 가리키는 포인터&lt;/td&gt;
      &lt;td&gt;프로세스 처리 중에 필요한 자원의 정보를 갖고 있는 기억 장소의 시작 번지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⑦ 처리기(CPU) 레지스터 정보&lt;/td&gt;
      &lt;td&gt;CPU 내 범용 레지스터(AX/BX/CX/DX), 데이터 레지스터(SP/BP/SI/DI), 세그먼트 레지스터(CS/DS/ES/SS) 등이 갖고 있는 값&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⑧ CPU의 각종 레지스터 상태를 가리키는 포인터&lt;/td&gt;
      &lt;td&gt;CPU에 1비트로 구성된 상태 레지스터의 비트열 값&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⑨ 계정 정보&lt;/td&gt;
      &lt;td&gt;CPU 사용 시간의 정보, 각종 스케줄러에 필요한 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⑩ 기억 장치 관리 정보&lt;/td&gt;
      &lt;td&gt;프로그램이 적재될 기억 장치의 상한치/하한치/페이지 테이블 등의 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⑪ 입출력 정보&lt;/td&gt;
      &lt;td&gt;프로세스 수행 시 필요한 주변 장치, 파일들의 정보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⑫ 부모 프로세스를 가리키는 포인터&lt;/td&gt;
      &lt;td&gt;자신을 생성한 상위 프로세스의 번지&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;⑬ 자식 프로세스를 가리키는 포인터&lt;/td&gt;
      &lt;td&gt;자신이 생성한 하위 프로세스의 번지&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 13 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-interrupt/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-interrupt/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 운영체제 발달 과정</title>
        <description>&lt;h1 id=&quot;운영체제-시스템의-발달-과정&quot;&gt;운영체제 시스템의 발달 과정&lt;/h1&gt;
&lt;h2 id=&quot;일괄-처리batch-processing-시스템&quot;&gt;일괄 처리(Batch Processing) 시스템&lt;/h2&gt;
&lt;p&gt;운영체제 형태 중 시대적으로 가장 먼저 생겨난 시스템으로 시스템의 효율 향상을 위하여 작업량이 &lt;strong&gt;일정한 수준&lt;/strong&gt;이 될 때까지 모아두었다가 &lt;strong&gt;한꺼번에 처리&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주기억 장치에 어셈블리어로 작성한 프로그램을 적재해 컴퓨터 시스템을 운영&lt;/li&gt;
  &lt;li&gt;컴퓨터 시스템을 중단 없이 효율적으로 사용 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;다중-프로그래밍multiprogramming-시스템&quot;&gt;다중 프로그래밍(Multiprogramming) 시스템&lt;/h2&gt;
&lt;p&gt;하나의 컴퓨터 시스템에서 &lt;strong&gt;여러 프로그램&lt;/strong&gt;이 같이 컴퓨터 시스템에 입력되어 주기억 장치에 적재되고, 이들이 처&lt;strong&gt;리 장치를 번갈아 사용하며 실행&lt;/strong&gt;하도록 하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하나뿐인 자원을 &lt;strong&gt;여러 개의 프로그램이 공동&lt;/strong&gt;으로 사용&lt;/li&gt;
  &lt;li&gt;동일한 기억 장소를 둘 이상의 프로그램들이 사용하는 시스템&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;처리량의 극대화&lt;/strong&gt;를 꾀한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;온라인on-line-processing-시스템&quot;&gt;온라인(On-Line Processing) 시스템&lt;/h2&gt;
&lt;p&gt;통신 회선으로 각 시스템을 연결하여 처리하며 장소를 이동하지 않아도 처리 결과를 받아볼 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다중 프로그램밍 방식, 일괄 처리 방식으로 처리된 결과를 원격지에서 받아볼 수 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;대화식(Interactive)&lt;/strong&gt; 처리로 운영체제에 적당&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시분할-처리time-sharing-processing-시스템&quot;&gt;시분할 처리(Time-Sharing Processing) 시스템&lt;/h2&gt;
&lt;p&gt;사용자는 단말 장치를 이용하여 운영체제와 상호작용하며, 시스템은 &lt;strong&gt;일정 시간 단위(Time Slice / Quantum)&lt;/strong&gt;로 CPU를 한 사용자에서 다음 사용자로 신속하게 전환함으로써, 각각의 사용자들은 실제로 자신만의 컴퓨터를 사용하고 있는 것처럼 사용할 수 있는 처리 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다중 프로그래밍 방식과 결합하여 모든 작업이 동시에 진행되는 것과 같은 대화식 처리를 진행&lt;/li&gt;
  &lt;li&gt;하나의 CPU를 여러 개의 작업이 정해진 시간 동안 번갈아 사용&lt;/li&gt;
  &lt;li&gt;라운드 로빈(Round-Robin) 방식이라고도 한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;응답 시간의 최소화&lt;/strong&gt;를 꾀한다&lt;/li&gt;
  &lt;li&gt;컴퓨터 시스템의 전체 효율은 좋아지나 개인 사용자 입장에서는 반응 속도가 느려질 수 있다&lt;/li&gt;
  &lt;li&gt;다중 프로그램밍을 전제로 하기 때문에 다중 프로그래밍보다 복잡&lt;/li&gt;
  &lt;li&gt;H/W를 보다 능률적으로 사용할 수 있는 시스템&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;실시간-처리real-time-processing-시스템&quot;&gt;실시간 처리(Real Time Processing) 시스템&lt;/h2&gt;
&lt;p&gt;우주 왕복선이나 레이더 추적기 등 정해진 시간에 반드시 수행되어야 하는 작업들에 적당한 방식으로 &lt;strong&gt;한정된 시간 제약 조건&lt;/strong&gt;에서 자료를 분석하여 처리하는 시스템&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실행 결과를 즉시 받아볼 수 있어 응답 시간이 짧다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;다중-모드multi-mode-처리-시스템&quot;&gt;다중 모드(Multi Mode) 처리 시스템&lt;/h2&gt;
&lt;p&gt;일괄 처리, 시간 분할 처리, 실시간 처리를 모두 수행할 수 있는 운영 방식&lt;/p&gt;

&lt;h2 id=&quot;분산-처리distributed-시스템&quot;&gt;분산 처리(Distributed) 시스템&lt;/h2&gt;
&lt;p&gt;하나의 작업을 여러 개의 컴퓨터 시스템이 공동으로 작업할 수 있는 운영 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 컴퓨터 시스템은 &lt;strong&gt;독립&lt;/strong&gt;적인 CPU와 메모리를 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;약 결합&lt;/strong&gt;(Loosely Coupled) 형태의 시스템 운영에 적합&lt;/li&gt;
  &lt;li&gt;통신 회선을 통하여 각 시스템에서 처리된 작업들을 모아 중앙 컴퓨터에서 처리&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;클라이언트 / 서버&lt;/strong&gt; 운영체제&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;전송 지연이 길고 데이터 처리율이 낮다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;약 결합 시스템&lt;/strong&gt; :&lt;br /&gt;
각 프로세스마다 &lt;strong&gt;독립된 메모리&lt;/strong&gt;를 가진 시스템으로 분산 처리 시스템이라고도 한다. 둘 이상의 독립된 컴퓨터 시스템을 통신망을 통해 연결한 시스템.&lt;/p&gt;

    &lt;p&gt;각 시스템마다 &lt;strong&gt;독자적인 운영체제&lt;/strong&gt;를 가지고 있으며, 독립적으로 작동할 수 있고 필요한 경우 &lt;strong&gt;메시지 전달&lt;/strong&gt;이나 &lt;strong&gt;원격 프로시저 호출&lt;/strong&gt;을 통해 프로세스 간 &lt;strong&gt;상호통신&lt;/strong&gt;이 가능하다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;병렬-처리parallel-시스템&quot;&gt;병렬 처리(Parallel) 시스템&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;하나의 메모리&lt;/strong&gt;를 &lt;strong&gt;여러 개의 CPU&lt;/strong&gt;가 사용하는 컴퓨터 시스템&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;강 결합 형태의 시스템에 적합&lt;/li&gt;
  &lt;li&gt;복잡한 수치 연산, 과학 기술 처리에 적합한 방식&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;strong&gt;강 결합 시스템&lt;/strong&gt; :&lt;br /&gt;
동일 운영체제 하에서 여러 개의 프로세스가 하나의 메모리를 공유하여 사용하는 시스템으로 다중(병렬)처리 시스템이라고도 한다.&lt;/p&gt;

    &lt;p&gt;하나의 운영체제가 모든 프로세스와 시스템 하드웨어를 제어하며, 프로세스 간 &lt;strong&gt;통신은 공유메모리&lt;/strong&gt;를 통해 이루어지기에 공유 메모리를 차지하려는 프로세스 간의 &lt;strong&gt;경쟁을 최소화&lt;/strong&gt;하여야 한다. 하나의 메모리를 사용하므로 &lt;strong&gt;프로세스 간의 결합력은 강&lt;/strong&gt;하다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;운영체제-성능-평가-기준&quot;&gt;운영체제 성능 평가 기준&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;처리량&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Throughput&lt;/code&gt;)&lt;br /&gt;
일정한 시간 내에서 얼마나 많은 작업량을 처리할 수 있는가의 척도&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;반환 시간&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Turn-around Time&lt;/code&gt;)&lt;br /&gt;
요청한 작업에 대하여 그 결과를 사용자에게 되돌려 줄 때까지 소요되는 시간
    &lt;blockquote&gt;
      &lt;p&gt;대기 시간(Waiting Time) + 실행 시간(Running Time) + 응답 시간(Response Time)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;신뢰도&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reliability&lt;/code&gt;)&lt;br /&gt;
작업의 결과가 얼마나 정확하고 믿을 수 있는가의 기준.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;사용 가능도&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Availability&lt;/code&gt;)&lt;br /&gt;
컴퓨터 시스템 내의 한정된 각종 자원을 여러 사용자가 요구할 때, 어느 정도 신속하고 충분하게 지원해 줄 수 있는지의 정도&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;운영체제의-구성&quot;&gt;운영체제의 구성&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/os-configure.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/os-configure.png&quot; alt=&quot;&quot; title=&quot;운영체제의 구성&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;제어-프로그램&quot;&gt;제어 프로그램&lt;/h2&gt;
&lt;p&gt;운영체제에서 가장 기초적인 시스템의 기능을 담당하는 프로그램으로 프로세스 관리, CPU 스케줄링, 입출력 제어, 기억 장치 관리 등의 기능을 수행.&lt;/p&gt;

&lt;p&gt;이러한 제어 프로그램이 항상 작동 중이라면 이를 &lt;strong&gt;커널(Kernel)&lt;/strong&gt;이라고 한다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;종류&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;감시 프로그램(Supervisor Program)&lt;/td&gt;
      &lt;td&gt;- 제어 프로그램의 중추적인 역할을 담당하는 프로그램으로 각종 운영체제 제어 루틴의 호출을 인식하여 해당 제어 루틴을 지시하고 루틴의 동작을 감시/감독하는 프로그램. &lt;br /&gt;- 운영체제 초기에는 감시 프로그램을 모니터라는 용어로 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;데이터 관리 프로그램(Data Management)&lt;/td&gt;
      &lt;td&gt;- 주기억 장치와 보조 기억 장치 사이의 자료 전송, 파일의 조작 및 처리, 입출력 자료와 프로그램의 논리적인 연결 등 운영체제 시스템에서 취급하는 파일과 데이터를 표준적인 방법으로 처리할 수 있도록 관리. &lt;br /&gt;- IOCS(Input Ouput Control System)이라고도 한다. &lt;br /&gt;- 세부적으로 구분하여 정리하면 다음과 같다. &lt;br /&gt;　　Open/Close : 파일의 조작 및 처리, 입출력 자료와 프로그램을 논리적으로 연결 &lt;br /&gt;　　Read/Write : 주기억 장치와 보조 기억 장치 사이의 자료 전송 &lt;br /&gt;　　Blocking/Deblocking : OS에서 취급하는 파일과 데이터를 표준적인 방법으로 처리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;작업 제어 프로그램(Job Control Program)&lt;/td&gt;
      &lt;td&gt;- 어떤 업무를 처리한 후 다른 업무로의 이행을 자동적으로 수행하기 위한 준비 및 처리 완료를 담당하는 기능을 수행. &lt;br /&gt;- 작업의 연속 처리를 위한 스케줄 및 시스템 자원 할당 등을 담당 &lt;br /&gt;- 운영체제의 각종 제어 루틴(프로세스 관리, CPU 스케줄링 등)의 수행 순서를 관리하며 사용자의 명령어 및 프로그램에 따라 제어 루틴들의 작업 시기를 조절해주는 기능 수행 &lt;br /&gt;&lt;br /&gt;&lt;i class=&quot;fa fa-info-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;작업 제어 스케줄러&lt;br /&gt;　Master Scheduler : 사용자와 운영체제 사이의 통신을 담당&lt;br /&gt;　Job Scheduler : 작업과 작업 사이에 존재하며 작업의 순서를 결정하는 행위를 담당&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;처리-프로그램&quot;&gt;처리 프로그램&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;종류&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;언어 번역 프로그램(Language Translator Program)&lt;/td&gt;
      &lt;td&gt;- 사용자가 저급이나 고급 언어를 사용하여 원시 프로그램을 작성하면, 목적 프로그램으로 번역해주는 프로그램&lt;br /&gt;- 제어 프로그램들의 일부를 사용자에 의해 처리될 수 있게 서비스를 제공해주는 것으로 &lt;a href=&quot;/study/os-system-software/#어셈블러assembler&quot;&gt;어셈블러, 컴파일러, 인터프리터&lt;/a&gt;, 프리프로세서가 존재&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;서비스 프로그램(Service Program)&lt;/td&gt;
      &lt;td&gt;- 사용 빈도수가 높은 모듈이나 프로그램들을 사용자가 사용할 수 있도록 제공되는 프로그램&lt;br /&gt;- 시스템 서비스에는 연계 편집기/라이브러리 등이 있고 사용자 서비스에는 정렬/병합/유틸리티 등과 같은 프로그램이 존재&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;문제 프로그램(Problem Program)&lt;/td&gt;
      &lt;td&gt;- 편집기, 데이터베이스, 통신용 프로그램, 그래픽 프로그램 등 사용자의 응용 처리를 위해 사용되는 프로그램&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Tue, 13 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-development-process/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-development-process/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 시스템 소프트웨어</title>
        <description>&lt;h1 id=&quot;시스템-소프트웨어&quot;&gt;시스템 소프트웨어&lt;/h1&gt;
&lt;p&gt;응용 프로그램들을 지원하기 위해서 개발된 소프트웨어로 사용자보다는 &lt;strong&gt;하드웨어 위주의 소프트웨어&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;시스템 소프트웨어에는 &lt;strong&gt;운영체제&lt;/strong&gt;(UNIX, MS-DOS, Windows 등)나 &lt;strong&gt;유틸리티&lt;/strong&gt;(컴파일러, 링커, 로더, 매크로 프로세서, 탐색기) 등이 있으며, 규모나 복잡도가 매우 커서 일반 사용자들이 개발하기에는 어렵다&lt;/p&gt;

&lt;p&gt;시스템 소프트웨어를 개발하는 도구들에는 시스템 언어(어셈블리어, C언어) 및 번역 프로그램(어셈블러, 매크로 프로세서, 컴파일러 등)이 있으며 링커, 로더 등도 포함된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램을 기억 장치에 상주시킨다&lt;/li&gt;
  &lt;li&gt;인터럽트를 관리한다&lt;/li&gt;
  &lt;li&gt;기억/주변 장치 관리&lt;/li&gt;
  &lt;li&gt;파일 관리&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시스템-소프트웨어-개발-도구&quot;&gt;시스템 소프트웨어 개발 도구&lt;/h2&gt;
&lt;h3 id=&quot;어셈블러assembler&quot;&gt;어셈블러(Assembler)&lt;/h3&gt;
&lt;p&gt;어셈블리어로 작성된 소스 프로그램을 &lt;strong&gt;기계어&lt;/strong&gt;(0과 1로 구성된 언어)로 번역하고 로더(실행 가능한 파일로 만드는 프로그램)에 필요한 정보를 생성한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래머가 기계어로 작성하지 않아도 어셈블리어로 작성한 원시 프로그램을 기계어로 번역&lt;/li&gt;
  &lt;li&gt;어셈블리어로 작성된 원시 프로그램은 기계어보다 읽고 이해가 쉽다&lt;/li&gt;
  &lt;li&gt;프로그램의 주소가 기호 번지이다&lt;/li&gt;
  &lt;li&gt;프로그램에 데이터를 사용하기 쉽다&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;어셈블러-기능&quot;&gt;어셈블러 기능&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;기능&lt;/th&gt;
      &lt;th&gt;상세&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;명령어 생성&lt;/td&gt;
      &lt;td&gt;원시 프로그램에 있는 기호 명령어를 분서갛여 기계어 명령어로 변경&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;기계 주소를 할당&lt;/td&gt;
      &lt;td&gt;원시 프로그램에 있는 기호 번지나 상수의 기억 장소를 할당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;의사 명령어 처리&lt;/td&gt;
      &lt;td&gt;프로그램의 시작과 종료, 재배치 정보 등 프로그램의 안내자 역할을 하는 명령어들을 처리&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;어셈블러-종류&quot;&gt;어셈블러 종류&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;단일 패스 어셈블러&lt;/strong&gt;(1-Pass)&lt;br /&gt;
원시 프로그램을 &lt;strong&gt;한 번에 검색하여 일괄적&lt;/strong&gt;으로 기계어 코드로 변경&lt;br /&gt;
잘못된 명령어를 사용하는 경우에는 실행할 수 없는 파일을 만든다. 따라서, &lt;strong&gt;정확한 명령어나 기호번지를 사용&lt;/strong&gt;해야 하는 어려움이 존재&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;기호 테이블을 정의&lt;/li&gt;
      &lt;li&gt;한 번에 번역하기 때문에 속도가 빠르다&lt;/li&gt;
      &lt;li&gt;프로그램 크기가 작으며 작성이 어렵다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이중 패스 어셈블러&lt;/strong&gt;(2-Pass)&lt;br /&gt;
원시 프로그램을 &lt;strong&gt;1차 검색&lt;/strong&gt;하여 명령어 및 기호 번지들을 데이터 베이스 &lt;strong&gt;테이블에 저장&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;잘못 사용한 명령어나 기호 번지는 &lt;strong&gt;프로그래머가 수정&lt;/strong&gt;할 수 있도록 오류 메시지를 출력하기도 한다. 이후에는 각 &lt;strong&gt;테이블에 저장된 정보들을 이용&lt;/strong&gt;하여 기게어 코드나 기억 장소를 변환한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;매크로-프로세서macro-processor&quot;&gt;매크로 프로세서(Macro Processor)&lt;/h3&gt;
&lt;p&gt;어셈블리어를 사용하기 쉽도록 명령어들을 문자로 치환하여 확장해준다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;매크로는 일종의 문자열 치환과 같이 사용된 횟수만큼 명령어를 생성, 삽입해서 실행&lt;/li&gt;
  &lt;li&gt;매크로 정의 내에 또 다른 매크로 정의 가능&lt;/li&gt;
  &lt;li&gt;파스칼 언어는 매크로 프로세서의 기능이 없다&lt;/li&gt;
  &lt;li&gt;매크로 라이브러리 : 여러 프로그램에서 공통적으로 자주 사용되는 매크로를 모아 놓은 라이브러리&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;매크로-프로세서-기능&quot;&gt;매크로 프로세서 기능&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;기본 기능&lt;/th&gt;
      &lt;th&gt;-&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;매크로 &lt;strong&gt;정의 인식&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;원시 프로그램 내에 존재하는 매크로를 파악하여 매크로를 정의한 부분의 시작과 종료를 파악&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;매크로 &lt;strong&gt;정의 저장&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;매크로 프로세서는 매크로 명과 정의된 내용을 매크로 호출 시 확장하기 위해 저장&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;매크로 &lt;strong&gt;호출 인식&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;원시 프로그램 내에 매크로가 확장하기 위한 준비가 되어 있는 지 확인&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;매크로 &lt;strong&gt;확장 및 인수&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;치환 매크로를 호출하면 매크로 명이 있는 원시 프로그램 위치에 저장된 내용과 인수를 치환&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;컴파일러compiler&quot;&gt;컴파일러(Compiler)&lt;/h3&gt;
&lt;p&gt;고급 언어로 작성된 프로그램을 기계에 적합한 프로그램으로 번역해주는 프로그램&lt;/p&gt;

&lt;p&gt;원시 프로그램에 번역 프로그램을 수행하면 번역 프로그램은 기계가 이해할 수 있는 이진수로 구성된 &lt;strong&gt;목적 프로그램을 출력&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;COBOL, C, FORTRAN, PASCAL, ALGOL, Ada…&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;인터프리터interpreter&quot;&gt;인터프리터(Interpreter)&lt;/h3&gt;
&lt;p&gt;고급 언어로 작성된 원시코드 &lt;strong&gt;명령어들을 한번에 한 줄&lt;/strong&gt;씩 읽어들여서 실행하는 프로그램&lt;/p&gt;

&lt;p&gt;인터프리터 과정에서는 최적화 단계를 거쳐 &lt;strong&gt;목적 프로그램을 출력하지 않는&lt;/strong&gt; 것이 컴파일러와 크게 구분되는 점이다(기계어 명령어들이 만들어지는 컴파일 단계를 거칠 필요가 없다)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BASIC, LISP, Python, APL&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;링커linker&quot;&gt;링커(Linker)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/linker.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/linker.png&quot; alt=&quot;&quot; title=&quot;링커&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;컴파일러가 만들어낸 하나 이상의 목적 파일을 가져와 이를 &lt;strong&gt;단일 실행 프로그램으로 병합&lt;/strong&gt;하는 프로그램&lt;/p&gt;

&lt;h3 id=&quot;로더loader&quot;&gt;로더(Loader)&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/loader.png&quot;&gt;&lt;img src=&quot;../../assets/images/OS/loader.png&quot; alt=&quot;&quot; title=&quot;로더&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;목적 프로그램을 실행 가능한 파일로 변환하기 위해 &lt;strong&gt;주기억 장소를 할당&lt;/strong&gt;하거나, 여러 개의 목적 프로그램을 연계 편집하여 CPU가 처리될 수 있는 프로그램으로 변환&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;좁은 의미&lt;/strong&gt;의 로더 :&lt;br /&gt;
프로그램을 실행하기 위하여 프로그램을 보조 기억 장치로부터 컴퓨터의 주기억 장치에 올려놓는 로더&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;넓은 의미&lt;/strong&gt;의 로더 :&lt;br /&gt;
적재뿐만이 아닌 목적 프로그램들끼리 연결시키거나 주기억 장치를 재배치하는 등의 포괄적인 작업을 수행하는 로더&lt;/p&gt;

&lt;h4 id=&quot;로더의-기능&quot;&gt;로더의 기능&lt;/h4&gt;
&lt;p&gt;일반적으로 로더는 프로그램을 실행하기 위하여 프로그램을 보조 기억 장치로부터 컴퓨터의 주기억 장치에 올려놓는 기능을 가진 프로그램으로 &lt;strong&gt;할당, 연결, 재배치, 적재&lt;/strong&gt; 순서로 진행&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;기능&lt;/th&gt;
      &lt;th&gt;내용&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;할당(Allocation)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;- 목적 프로그램이 실행된 주기억 장치 공간을 확보&lt;br /&gt;- 단일 프로그램은 프로그램 전체를 적재하여 실행할 수 있는 주기억 장치 공간을 확보 &lt;br /&gt;- 다중 프로그램은 프로그램의 일부를 적재한 후 실행 도중에 필요한 부분을 적재할 수 있는 주기억 장치 공간을 확보&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;연결(Linking)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;- 여러 개의 독립적인 모듈을 연결 &lt;br /&gt;- 독립적인 주기억 장치의 일부 공간을 논리적인 주소 공간으로 연결 &lt;br /&gt;- 링키지 에디터는 프로그램 적재 시 필요한 프로그램들을 결합하여 주기억 장치에 적재함은 물론 보조 기억 장치에 로드 이미지를 보관해두는 역할을 수행&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;재배치(Relocation)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;- 프로그램이 주기억 장치 공간 안에서 위치를 변경할 수 있게 한다 &lt;br /&gt;- &lt;strong&gt;베이스 레지스터&lt;/strong&gt;를 관리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;적재(Loading)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;프로그램 전체를 주기억 장치에 한 번에 적재하게 하거나 실행 시 필요한 일부분만을 차례로 적재하게 한다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;로더의-종류&quot;&gt;로더의 종류&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;로더의 종류&lt;/th&gt;
      &lt;th&gt;내용&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Compile and Go 로더&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;- &lt;strong&gt;번역 프로그램과 로더가 하나로&lt;/strong&gt; 구성되어 번역 프로그램이 로더의 역할(연결 기능은 수행하지 않는다)까지 담당하는 방식 &lt;br /&gt;- 매우 단순하여 프로그램하기가 용이하며 주기억 장소의 제한이 없다면 가장 이상적이라 할 수 있다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;절대 로더(Absolute Loader)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;- 로더의 역할이 축수되어 가장 간단한 프로그램으로 구성된 것으로 기억 장소 &lt;strong&gt;할당이나 연결&lt;/strong&gt;을 프로그래머가 직접 지정하는 방식(&lt;strong&gt;재배치&lt;/strong&gt;: 번역 프로그램 / &lt;strong&gt;적재&lt;/strong&gt; : 로더) &lt;br /&gt;- 프로그래머 입장에서는 매우 어렵고 한 번 &lt;strong&gt;지정한 주기억 장소&lt;/strong&gt;의 위치는 &lt;strong&gt;변경이 힘들다&lt;/strong&gt;는 단점 존재&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;직접 연결 로더&lt;/td&gt;
      &lt;td&gt;- 로더가 할당, 연결, 재배치, 적재를 &lt;strong&gt;모두 수행&lt;/strong&gt;하는 일반적인 형태 &lt;br /&gt;- 기억 장소를 자동으로 재배치하고, 독립적으로 프로그래밍된 프로그램들을 연결하여 수행하기 때문에 &lt;strong&gt;재배치 로더 혹은 상대적 로더&lt;/strong&gt;라고도 한다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Binding 로더&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;- &lt;strong&gt;할당, 연결, 재배치만&lt;/strong&gt; 하는 로더로 프로그램을 실행하기 전 모든 준비만을 담당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;Module 로더&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;- &lt;strong&gt;적재만&lt;/strong&gt;을 담당하는 로더를 의미&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;동적 적재 로더(Direct Linking Loader)&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;- CPU가 현재 사용 중인 부분만 전재하고 &lt;strong&gt;미사용 중인 프로그램&lt;/strong&gt;은 보조 기억 장치에 &lt;strong&gt;저장&lt;/strong&gt;해두는 방식으로 &lt;strong&gt;Load-On-Call&lt;/strong&gt;이라고도 한다 &lt;br /&gt;- &lt;strong&gt;오버레이(Overlay)&lt;/strong&gt; : 프로그램 파일을 분할하여 순차적으로 적재하는 운영 방식&lt;br /&gt;- &lt;strong&gt;스와핑(Swapping)&lt;/strong&gt; : 프로그램 파일을 분할하여 교체하면서 적재하는 운영 방식&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-system-software/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-system-software/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[운영체제/OS] 운영체제의 기본 개념</title>
        <description>&lt;h1 id=&quot;운영체제os-operating-system&quot;&gt;운영체제(OS: Operating System)&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;하드웨어를 제어하는 소프트웨어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;하드웨어를 활용&lt;/strong&gt;할 수 있도록 펌웨어나 소프트웨어로 만들어진 프로그램&lt;/li&gt;
  &lt;li&gt;컴퓨터 본체 및 각 주변 장치를 가장 &lt;strong&gt;능률적이고 경제적&lt;/strong&gt;으로 사용할 수 있도록 하는 프로그램&lt;/li&gt;
  &lt;li&gt;컴퓨터를 &lt;strong&gt;편리&lt;/strong&gt;하게 사용하고 하드웨어를 효율적으로 사용할 수 있도록 하는 프로그램&lt;/li&gt;
  &lt;li&gt;컴퓨터 자원들인 프로세서, 기억 장치, 파일 및 정보, 네트워크 및 보호 등을 &lt;strong&gt;효율적&lt;/strong&gt;으로 관리할 수 있는 프로그램의 집합&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;운영체제의-목적&quot;&gt;운영체제의 목적&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;컴퓨터 시스템의 처리량, 신뢰성을 최대화&lt;/li&gt;
  &lt;li&gt;컴퓨터 시스템의 반환 시간, 응답 시간, 처리 시간, 대기 시간, 경과 시간을 &lt;strong&gt;최소화&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;컴퓨터를 구성하고 있는 자원을 효율적으로 운영하고 제어&lt;/li&gt;
  &lt;li&gt;사용자와 컴퓨터 시스템과의 &lt;strong&gt;인터페이스&lt;/strong&gt; 제공&lt;/li&gt;
  &lt;li&gt;제한된 자원을 &lt;strong&gt;효율적으로 공유&lt;/strong&gt;하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스케줄링&lt;/code&gt; 수행&lt;/li&gt;
  &lt;li&gt;데이터를 공유&lt;/li&gt;
  &lt;li&gt;주변 장치를 관리&lt;/li&gt;
  &lt;li&gt;시스템의 &lt;strong&gt;이식성/호환성&lt;/strong&gt; 증대&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;운영체제의-역할&quot;&gt;운영체제의 역할&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;운영체제는 &lt;strong&gt;스스로 어떤 기능도 수행하지 않고&lt;/strong&gt; 다른 응용 프로그램이 유용한 작업을 할 수 있도록 &lt;strong&gt;환경을 제공&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;하드웨어와 사용자 사이에 내부 및 외부 인터페이스 제공&lt;/li&gt;
  &lt;li&gt;컴퓨터 자원을 여러 사용자가 효율적으로 나누어 사용할 수 있도록 자원을 관리&lt;/li&gt;
  &lt;li&gt;프로세서, 프로세스, 기억 장치, 입출력 장치를 관리&lt;/li&gt;
  &lt;li&gt;컴퓨터를 초기화시켜 작업을 수행할 수 있는 상태로 유지시키는 역할 수행&lt;/li&gt;
  &lt;li&gt;소프트웨어나 하드웨어에 오류가 발생하면 운영체제는 &lt;strong&gt;회복&lt;/strong&gt;을 위해 활동&lt;/li&gt;
  &lt;li&gt;시스템 사용 도중 발생하는 내/외부적인 오류로부터 시스템을 &lt;strong&gt;보호&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;응용 프로그램들이 컴퓨터의 제한된 자원들을 공유할 수 있도록 자원을 관리&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;운영체제-계층-구조&quot;&gt;운영체제 계층 구조&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;../../assets/images/OS/operation-system-layer.png&quot; title=&quot;운영체제 계층 구조&quot;&gt;&lt;img src=&quot;../../assets/images/OS/operation-system-layer.png&quot; alt=&quot;&quot; title=&quot;운영체제 계층 구조&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;명령어 해석기&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shell&lt;/code&gt;)&lt;br /&gt;
사용자 명령을 입력받아 시스템 기능을 수행하는 명령 해석기&lt;br /&gt;
사용자와 시스템 간의 &lt;strong&gt;인터페이스를 담당&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제어 프로그램&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kernel&lt;/code&gt;)&lt;br /&gt;
하드웨어를 제어하는 프로그램으로 메모리, CPU, 단말기, 프린터 등 시스템의 자원 활용도를 높이기 위해 스케줄링과 자료 관리를 하는 핵심 요소&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;기계어&lt;/strong&gt;(Machine Language)&lt;br /&gt;
0과 1로 표시되며 실행할 명령, 데이터, 기억 장소의 주소 등을 포함한다. 하드웨어를 직접 실행시킬 수 있는 형태로 구성되며 컴퓨터의 모든 &lt;strong&gt;하드웨어를 제어하기 위한 다양한 비트 형식&lt;/strong&gt;의 명령어가 존재&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;마이크로프로그램&lt;/strong&gt;(Micro-Program)&lt;br /&gt;
ROM이나 PROM에 영구히 기록되는 프로그램을 말하는 것으로 보통 &lt;strong&gt;펌웨어&lt;/strong&gt;를 의미하며 마이크로코드(Microcode)라고도 한다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 11 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/os-base-concept/</link>
        <guid isPermaLink="true">https://many258.github.io/study/os-base-concept/</guid>
        
        <category>OS</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[데이터통신] OSI 참조 모델</title>
        <description>&lt;h1 id=&quot;osi-참조-모델&quot;&gt;OSI 참조 모델&lt;/h1&gt;
&lt;p&gt;각 업체의 독자적인 기술은 통신의 유용성 및 타사 제품 간 통신 네트워크 문제가 대두되면서 이를 위해 국제 표준화 기구(ISO)에서는 단말기로부터 컴퓨터, 네트워크, 프로세스, 사용자 간의 표준화된 절차를 규정하도록 한 &lt;strong&gt;표준 프로토콜(OSI: Open System Interconnection)&lt;/strong&gt;을 발표하였다&lt;/p&gt;

&lt;h2 id=&quot;설계-원칙&quot;&gt;설계 원칙&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;적절한 수의 계층을 두어 시스템의 복잡도를 최소화&lt;/li&gt;
  &lt;li&gt;서비스 접점의 경계를 두어 되도록 적은 상호 작용이 되도록 하였다&lt;/li&gt;
  &lt;li&gt;비슷한 층은 하나의 계층으로 묶어서 효율성을 증진시켰다&lt;/li&gt;
  &lt;li&gt;인접 층의 서비스를 변형시키지 않는 범위에서 계층에 서비스를 개발할 수 있도록 하였다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;osi-7계층의-구조와-기능&quot;&gt;OSI 7계층의 구조와 기능&lt;/h2&gt;

&lt;p class=&quot;align-center&quot;&gt;&lt;a href=&quot;../../assets/images/network/data-communication/osi-7-layer.png&quot; title=&quot;OSI 계층 구조&quot;&gt;&lt;img src=&quot;../../assets/images/network/data-communication/osi-7-layer.png&quot; alt=&quot;&quot; title=&quot;OSI 계층 구조&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;물리-계층physical-layer&quot;&gt;물리 계층(Physical Layer)&lt;/h3&gt;
&lt;p&gt;전송 매체와 전송 신호를 액세스하기 위한 기계적, 전기적, 기능적, 절차적 특성을 규정짓는 최하위 계층&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;통신 케이블, 전송 신호 방식, 물리적 정비를 정의&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#계층-간-데이터-단위&quot;&gt;PDU&lt;/a&gt; : 비트(스트림)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;데이터-링크-계층data-link-layer&quot;&gt;데이터 링크 계층(Data Link Layer)&lt;/h3&gt;
&lt;p&gt;인접한 장치 간에 원활한 데이터의 전송을 하도록 하며, 물리적 연결 간의 신뢰성 있는 정보를 전송하는 계층&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;동기화&lt;/strong&gt;, 오류, 흐름 제어로 프레임을 효과적으로 전송&lt;/li&gt;
  &lt;li&gt;전화를 이용한 인터넷 접속 프로토콜(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PPP&lt;/code&gt;) 기능을 담당&lt;/li&gt;
  &lt;li&gt;프레임 동기화(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BASIC&lt;/code&gt; 동기, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HDLC&lt;/code&gt; 동기, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SDLC&lt;/code&gt; 동기)&lt;/li&gt;
  &lt;li&gt;신뢰성 있고 효율적인 데이터 전송&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;매체 액세스 제어&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CSMA/CD&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Token-Bus&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Token-Ring&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;전송 제어 기능 담당&lt;/li&gt;
  &lt;li&gt;논리적 연결인 &lt;strong&gt;링크를 확립하거나 해제&lt;/strong&gt; 수행&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#계층-간-데이터-단위&quot;&gt;PDU&lt;/a&gt; : 프레임&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;네트워크-계층network-layer&quot;&gt;네트워크 계층(Network Layer)&lt;/h3&gt;
&lt;p&gt;통신 시스템 간의 경로를 선택하는 기능, 통신 트래픽의 흐름을 제어하는 기능 및 통신 중에 패킷의 분실로 재전송을 요청할 수 있는 오류 제어 기능을 수행&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;패킷 정보를 목적지까지 전송&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;논리적 어드레싱&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;정보 교환 및 중계 기능을 담당&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;경로 선택&lt;/strong&gt;, &lt;strong&gt;트래픽 제어&lt;/strong&gt;, &lt;strong&gt;체증 제어&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;네트워크 연결을 관리&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#계층-간-데이터-단위&quot;&gt;PDU&lt;/a&gt; : 패킷 or 데이터그램&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;전송-계층transport-layer&quot;&gt;전송 계층(Transport Layer)&lt;/h3&gt;
&lt;p&gt;네트워크 종단 시스템 간의 데이터를 일관성 있고 &lt;strong&gt;투명한 데이터 전송&lt;/strong&gt;을 제공할 수 있도록 종단 간에 통신을 지원&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;종단 사용자 간&lt;/strong&gt;에 에러 복구와 흐름 제어를 제공&lt;/li&gt;
  &lt;li&gt;공유 회선을 &lt;strong&gt;다중화, 집중화&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;주소를 지정&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#계층-간-데이터-단위&quot;&gt;PDU&lt;/a&gt; : TCP 세그먼트&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;세션-계층session-layer&quot;&gt;세션 계층(Session Layer)&lt;/h3&gt;
&lt;p&gt;응용 프로그램 간의 대화를 구성하고, 동기를 취하며 데이터 교환을 관리하기 위한 수단을 지원&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;데이터가 전달되었으나 오류가 있는 데이터를 &lt;strong&gt;회복&lt;/strong&gt;하기 위해 사용&lt;/li&gt;
  &lt;li&gt;전송 방향 결정(&lt;strong&gt;전이중/반이중/단방향&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;데이터 교환, &lt;strong&gt;대화&lt;/strong&gt;를 관리&lt;/li&gt;
  &lt;li&gt;전자 사서함 기능을 제공&lt;/li&gt;
  &lt;li&gt;통신 시스템 간의 &lt;strong&gt;회화 기능&lt;/strong&gt;을 관리&lt;/li&gt;
  &lt;li&gt;대동기점은 데이터 교환을 대화 단위로 분할하여 오류를 확인한다&lt;/li&gt;
  &lt;li&gt;소동기점은 대화의 중간에 삽입되며, 응용 프로그램에 따라 오류 확인이 요구되지 않을 수도 있다&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#계층-간-데이터-단위&quot;&gt;PDU&lt;/a&gt; : 메시지/데이터&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;표현-계층presentation-layer&quot;&gt;표현 계층(Presentation Layer)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 코드 &lt;strong&gt;변환, 압축, 번역, 암호화/해독&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;표현 형식을 제어&lt;/li&gt;
  &lt;li&gt;정보 형식을 지정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;구문&lt;/strong&gt; 검색, &lt;strong&gt;문맥&lt;/strong&gt; 관리&lt;/li&gt;
  &lt;li&gt;PDU : 메시지/데이터&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;응용-계층application-layer&quot;&gt;응용 계층(Application Layer)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;사용자가 OSI 환경에 접근이 가능하도록 한다&lt;/li&gt;
  &lt;li&gt;OSI 네트워크 환경에서 사용자에게 서비스를 제공하는 계층&lt;/li&gt;
  &lt;li&gt;PDU : 메시지/데이터&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;계층-간-데이터-단위&quot;&gt;계층 간 데이터 단위&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/network/data-communication/osi-layer-data-unit.png&quot; title=&quot;계층 간 데이터 단위&quot;&gt;&lt;img src=&quot;../../assets/images/network/data-communication/osi-layer-data-unit.png&quot; alt=&quot;&quot; title=&quot;계층 간 데이터 단위&quot; class=&quot;align-center&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PCI&lt;/strong&gt;(Protocol Control Information)&lt;br /&gt;
각 계층에서 처리되는 프로토콜 제어 정보로 &lt;strong&gt;하위 계층으로 전달&lt;/strong&gt;되는 PDU에 추가되는 블록. 일반적으로 각 계층의 기능 및 프로그램이라 할 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PDU&lt;/strong&gt;(Protocol Data Unit)&lt;br /&gt;
아래 계층으로 전달되는 데이터 단위로 &lt;strong&gt;PCI와 결합&lt;/strong&gt;되어 전달&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SDU&lt;/strong&gt;(Service Data Unit)&lt;br /&gt;
상위 계층에서 전달받은 데이터 단위로 SDU는 &lt;strong&gt;PCI와 결합&lt;/strong&gt;되어 하위 계층에 PDU 데이터 단위로 전달&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SAP&lt;/strong&gt;(Service Access Point)&lt;br /&gt;
&lt;strong&gt;(N)층이 (N+1)층에 제공하는 서비스&lt;/strong&gt;를 의미. (N)계층에서 (N+1)계층으로 전달되는 서비스를 (N)-SAP라고 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 09 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/data-communication-osi-7-layer/</link>
        <guid isPermaLink="true">https://many258.github.io/study/data-communication-osi-7-layer/</guid>
        
        <category>데이터통신</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[데이터통신] 통신 프로토콜</title>
        <description>&lt;h1 id=&quot;통신-프로토콜&quot;&gt;통신 프로토콜&lt;/h1&gt;
&lt;p&gt;서로 다른 시스템에 존재하는 개체 간의 원활한 통신을 위한 소프트웨어적 하드웨어적 약속이나 규칙 및 규약을 의미&lt;/p&gt;

&lt;h2 id=&quot;통신-프로토콜-기본-구성-요소&quot;&gt;통신 프로토콜 기본 구성 요소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;구문&lt;/strong&gt;(Syntax) : 데이터 형식, 부호화, 신호 레벨 등의 요소&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;의미&lt;/strong&gt;(Semantics) : 전송 제어 및 오류 처리를 위한 정보 등을 규정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시간&lt;/strong&gt;(Timing) : 두 개체 간의 통신 속도를 조정하거나 메시지의 전송 및 순서에 대한 특성을 가리킨다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;통신-프로토콜-주요-기능&quot;&gt;통신 프로토콜 주요 기능&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;기능&lt;/th&gt;
      &lt;th&gt;내용&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;단편화와 재결합&lt;br /&gt;(Fragmentation &amp;amp; Reassembly)&lt;/td&gt;
      &lt;td&gt;많은 양의 데이터 블록을 효율적인 전송이 되도록 작은 단위의 블록으로 단편화하여 전송하며, 수신된 작은 단위 블록은 다시 원래의 데이터가 될 수 있도록 재결합되어야 한다&lt;br /&gt;효과적으로 오류 제어를 할 수 있고 응답 시간이 빠르다&lt;br /&gt;재결합 시 프레임에 순서 번호 부여를 하는 등 부수적인 데이터의 증가와 처리 시간이 길어져서 비효율적이다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;캡슐화&lt;br /&gt;(Encapsulation)&lt;/td&gt;
      &lt;td&gt;데이터의 플래그, 주소, 제어 정보 등 정보 데이터와 정보   데이터를 오류 없이 전송하기 위한 구조적인 묶음을 의미&lt;br /&gt;HDSL, BASIC, DDCMP, TCP&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;캡슐의 주요 제어 정보&lt;/td&gt;
      &lt;td&gt;주소, 에러 검출 코드, 프로토콜 제어&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;연결 제어&lt;br /&gt;(Connection Control)&lt;/td&gt;
      &lt;td&gt;회선 접속 → 링크 확립 → 데이터 전송 → 링크 해제 → 회선 절단에서 링크 확립과 링크 해제 단계를 제어하는 기능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;흐름 제어&lt;br /&gt;(Flow Control)&lt;/td&gt;
      &lt;td&gt;두 개체 사이에 데이터의 개수나 속도의 조절하는   기능&lt;br /&gt;Sliding Window&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;오류 제어&lt;br /&gt;(Error Control)&lt;/td&gt;
      &lt;td&gt;수신된 오류를 검출하고 재전송을 요구하는 기능&lt;br /&gt;ARQ, Hamming Code, Parity&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;동기화&lt;br /&gt;(Synchronization)&lt;/td&gt;
      &lt;td&gt;데이터 전송은 직렬 전송으로 이루어진다. 따라서 송신측의 정보를 수신측에서 정확하게 수신하려면 직렬 입력 파형으로부터 비트와 문자를 정확하게 시간에 맞추어 수신해야 한다. 이처럼 송신측과 수신측이   같은 시간으로 동작하게 하는 기능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;순서 제어&lt;br /&gt;(Sequencing)&lt;/td&gt;
      &lt;td&gt;연결 제어의 순서적 절차 기능으로 데이터 조각에 순서를 부여하여 전송하거나 수신된 데이터 조각을 순서에 맞게 조립하는 기능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;주소 지정&lt;br /&gt;(Addressing)&lt;/td&gt;
      &lt;td&gt;데이터를 목적지까지 전송할 수 있도록 데이터에 목적지 위치를 추가하고 관리하는 기능&lt;br /&gt;IP주소, 서브넷 마스크, NIC 주소, ARP, RARP&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;다중화&lt;br /&gt;(Multiplexing)&lt;/td&gt;
      &lt;td&gt;여러 개의 회선에서 데이터를 받아 한 개의 고속 회선으로 송신하거나 반대로 고속 회선에서 데이터를 입력받아 여러 개의 회선으로 분할하는 기능&lt;br /&gt;FDM, TDM, CDM&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;경로   선택&lt;br /&gt;(Routing)&lt;/td&gt;
      &lt;td&gt;송/수신 간에 중간 서브넷을 거쳐 최적의 경로를 선택하는 기술로 서브넷 자원의 이용을 최대화하여 평균 패킷 전송 시간을 최소화하는 기능&lt;br /&gt;Fixed, Flooding, RIP, ERP, BGP, EGP&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;통신-프로토콜의-종류&quot;&gt;통신 프로토콜의 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ARPANET&lt;/strong&gt;(Advanced Research Projects Agency Network)&lt;br /&gt;
현재 사용 중인 인터넷의 모체가 된 네트워크.&lt;/p&gt;

    &lt;p&gt;패킷 교환 기술을 이용하여 전용 회선으로 연결된 여러 대의 컴퓨터로 구성되었으며, 미 국방성의 지원으로 개발된 &lt;strong&gt;최초의 유선형 패킷 교환&lt;/strong&gt; 시스템&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SNA&lt;/strong&gt;(System Network Architecture)&lt;br /&gt;
특정한 시스템이나 프로그램이 아닌 &lt;strong&gt;네트워크상의 통신 규약&lt;/strong&gt;.&lt;/p&gt;

    &lt;p&gt;사용자와 하드웨어, 각 세부적인 기술들을 분리시켜 네트워크의 모든 구성 요소가 다른 네트워크와 통신이 원활할 수 있도록 제시한 네트워크 구조&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;X.25&lt;/strong&gt;&lt;br /&gt;
패킷 교환망에 광범위하게 사용되는 네트워크 프로토콜로서 CCITT에 의해 표준으로 채택되었다.&lt;/p&gt;

    &lt;p&gt;패킷형으로 동작하는 데이터 단말 장치(DTE)와 데이터 회선 종단 장치(DCE) 간의 인터페이스로, 사용자 단말 장치와 패킷 교환망(PSDN) 간의 데이터 교환 절차를 정의&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;공중 패킷 교환망에 대한 &lt;strong&gt;ITU-T&lt;/strong&gt;의 권고안&lt;/li&gt;
      &lt;li&gt;물리 계층, 데이터 링크 계층, 패킷 계층들에 대한 기능으로 구성&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;연결형&lt;/strong&gt; 네트워크 프로토콜&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;흐름 및 오류 제어&lt;/strong&gt; 기능을 제공&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OSI&lt;/strong&gt;(Open Systems Interconnection, 개방형 시스템 간 상호 접속)&lt;br /&gt;
국제 표준화 기구인 ISO에서 개발된 OSI는 통신 네트워크 간에 어떻게 데이터를 전송할 것인가에 대한 표준 규약 또는 참조 모델&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ISDN&lt;/strong&gt;(Integrated Services Digital Network)&lt;br /&gt;
발신 가입자로부터 수신자까지의 모든 전송, 교환 과정이 디지털 방식으로 처리되며 음성과 비음성, 영상 등 서비스를 종합적으로 처리하는 종합 정보 통신망&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IN&lt;/strong&gt;(Intelligent Network, 지능망)&lt;br /&gt;
기존의 &lt;strong&gt;통신망에 컴퓨터를 연결&lt;/strong&gt;하여 새로운 기술을 쉽게 접목할 수 있게 한 지능화된 네트워크를 의미.&lt;/p&gt;

    &lt;p&gt;기존의 공중 전화망(PSTN)에 컴퓨터를 연결하고, 서비스 교환 시스템(SSP), 서비스 제어 시스템(SCP), 서비스 관리 시스템(SMS) 등의 소프트웨어를 설치한 것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PPP&lt;/strong&gt;(Point to Point Protocol)&lt;br /&gt;
전화선과 모뎀을 이용하여 인터넷을 접속하기 위한 프레임 프로토콜로 이전에 사용했던 방식인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SLIP&lt;/code&gt;을 개선하여 에러 검출 기능과 복구 기능을 추가한 프로토콜.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;문자&lt;/strong&gt; 위주 프레임&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IETF&lt;/code&gt;의 표준 프로토콜&lt;/li&gt;
      &lt;li&gt;주로 두 개의 라우터를 접속할 때 사용&lt;/li&gt;
      &lt;li&gt;다중 프로토콜 지원&lt;/li&gt;
      &lt;li&gt;오류 &lt;strong&gt;검출만 제공&lt;/strong&gt;되며, 재전송을 통한 오류 복구와 흐름 제어은 제공 되지 않음&lt;/li&gt;
      &lt;li&gt;비동기식 링크도 지원해야 하기 때문에 프레임은 반드시 바이트의 정수배가 되어야 한다&lt;/li&gt;
      &lt;li&gt;동기/비동기 회선 모두를 통하여 전송&lt;/li&gt;
      &lt;li&gt;압축 기능 제공&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;구조&lt;/strong&gt; : [Flag][Address][Control][&lt;strong&gt;Protocol&lt;/strong&gt;][Data][FCS][Flag]
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;PAP&lt;/strong&gt;(Password Authentication Protocol)&lt;br /&gt;
초기 접속 시 아이디와 비밀번호를 미리 입력해 놓으면 자동으로 접속할 수 있는 프로토콜&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;CHAP&lt;/strong&gt;(Challenge Handshake Authentication Protocol)&lt;br /&gt;
초기 접속이 이루어질 때 매번 3단계의 핸드세이크 인증을 수행하는 방법&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;통신-프로토콜-계층-간-관계도&quot;&gt;통신 프로토콜 계층 간 관계도&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;../../assets/images/network/data-communication/network-layer-compare.png&quot; title=&quot;통신 프로토콜 계층 간 관계도&quot; class=&quot;align-center&quot;&gt;&lt;img src=&quot;../../assets/images/network/data-communication/network-layer-compare.png&quot; alt=&quot;&quot; title=&quot;통신 프로토콜 계층 간 관계도&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;통신-제어-프로그램&quot;&gt;통신 제어 프로그램&lt;/h2&gt;
&lt;p&gt;데이터 전송 회선과 통신 제어 장치를 이용하여 컴퓨터와 단말기 간, 단말기와 단말기 간, 컴퓨터와 컴퓨터 간에 정보를 송/수신하기 위한 프로그램을 총칭하여 통신 제어 프로그램 혹은 통신 소프트웨어라 한다&lt;/p&gt;

&lt;h3 id=&quot;통신-제어-프로그램의-3가지-기능&quot;&gt;통신 제어 프로그램의 3가지 기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;데이터 송/수신 기능&lt;/strong&gt;&lt;br /&gt;
두 노드 간에 정보 교환을 위해서는 사전에 송/수신측 간 통신제어 프로그램의 명령이나 응답에 관한 신호의 제어 및 전달방식을 약속하여야 한다. 이러한 약속을 프로토콜이라고 하며 통신소프트웨어가 지원&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;통신 하드웨어 제어 기능&lt;/strong&gt;
통신에 필요한 하드웨어와의 신호 및 데이터 송/수신을 행하는 모든 통신 제어를 소프트웨어가 지원&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;이용자 인터페이스 제어 기능&lt;/strong&gt;
이용자가 통신 시스템을 쉽게 지시하고 통신 기능을 원만히 수행할 수 있도록 하는 기본 명령을 소프트웨어가 지원&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 08 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/data-communication-protocol/</link>
        <guid isPermaLink="true">https://many258.github.io/study/data-communication-protocol/</guid>
        
        <category>데이터통신</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[데이터통신] 인터네트워킹</title>
        <description>&lt;h1 id=&quot;인터네트워킹&quot;&gt;인터네트워킹&lt;/h1&gt;
&lt;p&gt;근거리 네트워크망 혹은 광역망 간에 상호 접속시키는 제반 기법으로 인터네트워킹의 전체 구성을 &lt;strong&gt;인터넷&lt;/strong&gt;이라고 하며 그 구성 요소를 &lt;strong&gt;서브넷&lt;/strong&gt;이라고 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TCP/IP를 기본 프로토콜로 한다&lt;/li&gt;
  &lt;li&gt;X.25 네트워크를 통한 가상 회선, 데이터그램 서비스를 제공&lt;/li&gt;
  &lt;li&gt;로컬 네트워크 상호 간 연결에는 &lt;strong&gt;브리지&lt;/strong&gt;가 사용&lt;/li&gt;
  &lt;li&gt;외부 네트워크와 연결할 경우에는 게이트웨이와 라우터가 필수적&lt;/li&gt;
  &lt;li&gt;IP는 여러 개의 패킷 교환망들의 상호 연결을 위한 범용 &lt;strong&gt;비연결성 프로토콜&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;TCP는 데이터 &lt;strong&gt;전송 프로토콜&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;HTTP, FTP, Telnet, Mail, IRC가 주요 서비스&lt;/li&gt;
  &lt;li&gt;다른 네트워크 또는 같은 네트워크를 연결하여 그 중추 역할을 하는 네트워크로 보통 &lt;strong&gt;인터넷의 주가 되는 기간망&lt;/strong&gt;을 &lt;strong&gt;백본&lt;/strong&gt;이라고 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;인터네트워킹의-4계층&quot;&gt;인터네트워킹의 4계층&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;링크 계층&lt;/strong&gt;(물리 계층, 데이터 링크 계층)
    &lt;ul&gt;
      &lt;li&gt;통신망을 액세스할 수 있는 프로토콜로 흐름제어나 에러 제어의 서비스를 제공&lt;/li&gt;
      &lt;li&gt;Ethernet, IEEE802, X.25&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인터넷 계층&lt;/strong&gt;(네트워크 계층)
    &lt;ul&gt;
      &lt;li&gt;데이터를 전송하기 위한 절차, 순서 제어 등의 서비스 제공&lt;/li&gt;
      &lt;li&gt;IP&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;전송 계층&lt;/strong&gt;(세션 계층, 전송 계층)
    &lt;ul&gt;
      &lt;li&gt;호스트들 간의 신뢰성 있는 통신 제공&lt;/li&gt;
      &lt;li&gt;연결 위주의 데이터 프로토콜, 데이터그램 프로토콜, 음성 프로토콜, 실시간 데이터 프로토콜&lt;/li&gt;
      &lt;li&gt;TCP&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;응용 계층&lt;/strong&gt;(표현 계층, 응용 계층)
    &lt;ul&gt;
      &lt;li&gt;응용 프로그램 간의 데이터 송수신을 제공&lt;/li&gt;
      &lt;li&gt;FTP, SMTP, Telnet 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;인터넷-프로토콜-스위트internet-protocol-suite&quot;&gt;인터넷 프로토콜 스위트(Internet Protocol Suite)&lt;/h2&gt;
&lt;p&gt;인터넷에서 컴퓨터들이 서로 정보를 주고받는 데 쓰이는 통신규약 모음이다. 인터넷 프로토콜 슈트 중 TCP와 IP가 가장 많이 쓰이기 때문에 TCP/IP 프로토콜 슈트라고도 불린다&lt;/p&gt;

&lt;h3 id=&quot;링크-계층&quot;&gt;링크 계층&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;프토토콜&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;OSPF&lt;/td&gt;
      &lt;td&gt;- Open Shortest Path First, 최단 경로 우선 프로토콜&lt;br /&gt;- 인터넷 프로토콜 네트워크를 위한 링크 스테이트 라우팅 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SLIP&lt;/td&gt;
      &lt;td&gt;- Serial Line Internet Protocol, 직렬 회선 인터넷 프로토콜&lt;br /&gt;- 대부분의 컴퓨터에 내장된 직렬 포트에서 인터넷 등의 TCP/IP 네트워크에 전화선 등 직렬 통신 회선을 통해 일시적으로 접속하기 위한 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PPP&lt;/td&gt;
      &lt;td&gt;- Point-to-Point  Protocol, 점 대 점 프로토콜&lt;br /&gt;- 두 통신 노드 간의 직접적인 연결을 위해 일반적으로 사용되는 데이터 링크 프로토콜&lt;br /&gt;- 인증, 암호화를 통한 전송 및 데이터 압축 기능 제공&lt;br /&gt;- SLIP, LAPB와 같은 프로토콜에 대한 대안으로 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MAC&lt;/td&gt;
      &lt;td&gt;- Media Access Control, 매체 접근 제어&lt;br /&gt;- 자료 전송 프로토콜의 하부 계층이며 OSI 모델에 규정된 데이터 링크 계층의 일부&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Ethernet&lt;/td&gt;
      &lt;td&gt;- OSI 모델의 물리 계층에서 신호와 배선, 데이터 링크 계층에서 MAC 패킷과 프로토콜의 형식을 정의&lt;br /&gt;- 현재 가장 널리 사용되고 있으며, 토큰 링, FDDI 등의 다른 표준을 대부분 대체&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DSL&lt;/td&gt;
      &lt;td&gt;- Digital Subscriver Line, 디지털 가입자 회선&lt;br /&gt;- 지역 전화망을 통해 디지털 데이터 전송을 제공하는 기술의 계열&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ISDN&lt;/td&gt;
      &lt;td&gt;- Integrated Service Digital Network, 광대역 종합 통신망&lt;br /&gt;- 모든 정보를 디지털 신호로 만들어 하나의 네트워크를 통하여 문자, 그림, 음성, 화상, 비디오, 팩시밀리 등과 같은 모든 종류의   서비스를 제공하는 통신망&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FDDI&lt;/td&gt;
      &lt;td&gt;- Fiber Distributed Data Interface, 파이버 분산형 데이터 인터페이스&lt;br /&gt;- 근거리 통신망의 데이터 전송을 위한 100Mbit/sec의 광 표준을 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RARP&lt;/td&gt;
      &lt;td&gt;- Reverse Address Resolution Protocol, 역순 주소 결정 프로토콜&lt;br /&gt;- IP호스트가 자신의 물리 네트워크 주소(MAC)는 알지만 IP주소를 모르는 경우에 서버로부터 IP주소를 요청하기 위해 사용&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;인터넷-계층&quot;&gt;인터넷 계층&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;프로토콜&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;IP&lt;/td&gt;
      &lt;td&gt;- Internet Protocol, 인터넷 프로토콜&lt;br /&gt;- 송신 호스트와 수신 호스트가 패킷 교환 네트워크에서 정보를 주고받는 데 사용하는 정보 위주의 규약&lt;br /&gt;- 호스트의 주소 지정과 패킷 분할 및 재조립 기능 담당&lt;br /&gt;- 비신뢰성(Unreliability), 비연결성(Connectionlessness)&lt;br /&gt;- IPv4, IPv6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ARP&lt;/td&gt;
      &lt;td&gt;- Address Resolution Protocol, 주소 결정 프로토콜&lt;br /&gt;- 네트워크 상에서 IP주소를 물리적 네트워크 주소로 대응시키기 위해 사용되는 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ICMP&lt;/td&gt;
      &lt;td&gt;- Internet Control Message Protocol, 인터넷 제어 메시지 프로토콜&lt;br /&gt;- 네트워크 컴퓨터 위에서 돌아가는 운영체제에서 오류메시지를 전송하는 데 주로 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IGMP&lt;/td&gt;
      &lt;td&gt;- Internet Group Management Protocol, 인터넷 그룹 관리 프로토콜&lt;br /&gt;- 호스트 컴퓨터와 인접 라우터가 멀티캐스트 그룹 멤버십을 구성하는 데 사용하는 통신 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IPSec&lt;/td&gt;
      &lt;td&gt;- Internet Protocol Security&lt;br /&gt;- 통신 세션의 각 IP패킷을 암호화하고 인증하는 안전한 인터넷 프로토콜 통신을 위한 인터넷 프로토콜 스위트&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;전송-계층&quot;&gt;전송 계층&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;프로토콜&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;TCP&lt;/td&gt;
      &lt;td&gt;- Transmission Control Protocol, 전송 제어 프로토콜&lt;br /&gt;- 네트워크의 정보 전달을 통제하는 프로토콜이자 인터넷을 이루는 핵심 프로토콜&lt;br /&gt;- 연결형, 신뢰성 확보, 복구 기능 제공, 순서 재조정 기능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;QUIC&lt;/td&gt;
      &lt;td&gt;- 범용 목적의 전송 계층 통신 프로토콜&lt;br /&gt;- TCP를 사용하는 연결 지향 웹 애플리케이션의 성능을 개선&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UDP&lt;/td&gt;
      &lt;td&gt;- User/Universal Datagram Protocol, 사용자 데이터그램 프로토콜&lt;br /&gt;- 인터넷 프로토콜 스위트의 주요 프로토콜&lt;br /&gt;- 주로 DNS, IPTV, VoIP, TFTP, IP터널에서 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DCCP&lt;/td&gt;
      &lt;td&gt;- Datagram Congestion Control Protocol, 데이터그램 혼잡 제어 프로토콜&lt;br /&gt;- 메시지 지향적인 전송 계층 통신 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SCTP&lt;/td&gt;
      &lt;td&gt;- Stream Control Transmission Protocol, 스트림 제어 전송 프로토콜&lt;br /&gt;- 컴퓨터 네트워킹에서 프로토콜 번호 132를 사용하는 전송 계층 프로토콜&lt;br /&gt;- TCP와 UDP의 동일한 서비스 기능들 가운데 일부를 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RSVP&lt;/td&gt;
      &lt;td&gt;- Resource ReSerVation Protocol, 자원 예약 프로토콜&lt;br /&gt;- RFC 2205에 기술된 전송 계층 프로토콜&lt;br /&gt;- 네트워크 상에서 자원을 예약할 수 있도록 디자인된 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;응용-계층&quot;&gt;응용 계층&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;프로토콜&lt;/th&gt;
      &lt;th&gt;기능&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;BGP&lt;/td&gt;
      &lt;td&gt;- Border Gateway Protocol, 경계 경로 프로토콜&lt;br /&gt;- 인터넷에서 자율시스템(AS) 중 라우팅 및 도달 가능성 정보를 교환하기 위해 설계된, 표준화된 외부 게이트웨이 프로토콜의 하나&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NSP&lt;/td&gt;
      &lt;td&gt;- Name Service Protocol&lt;br /&gt;- DNS가 발표되기 전 사용되던 호스크와 IP 어드레스의 매핑 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DNS&lt;/td&gt;
      &lt;td&gt;- Domain Name System, 도메인 네임 시스템&lt;br /&gt;- 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 하기 위해 개발&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LLMNR&lt;/td&gt;
      &lt;td&gt;- Link-Local Multicast Name Resolution&lt;br /&gt;- DNS을 기반으로 고완된 프로토콜&lt;br /&gt;- 패킷 포맷 IPv4, IPv6 호스트 상에서 모두 사용 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Archie&lt;/td&gt;
      &lt;td&gt;FTP 지원 프로토콜로 전 세계의 FTP Host를 검색하는 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FTP&lt;/td&gt;
      &lt;td&gt;- File Transfer Protocol, 파일 전송 프로토콜&lt;br /&gt;- TCP/IP 프로토콜을 가지고 서버와 클라이언트 사이의 파일 전송을 하기 위한 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TFTP&lt;/td&gt;
      &lt;td&gt;- Trivial File Transfer Protocol&lt;br /&gt;- FTP보다 더 단순한 방식으로 파일을 전송(불안정하다는 단점이 존재)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SFTP&lt;/td&gt;
      &lt;td&gt;- SSH/Secure File Transfer Protocol&lt;br /&gt;- 신뢰할 수 있는 데이터 스트림을 통해 파일 접근, 파일 전송, 파일 관리를 제공하는 네트워크 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HTTP&lt;/td&gt;
      &lt;td&gt;- Hyper Text Transfer Protocol(80 Port)&lt;br /&gt;- 인터넷에서 고급화된 파일(텍스트, 그래픽, 사운드, 오디오 등)을 송수신하는 서비스&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POP3&lt;/td&gt;
      &lt;td&gt;- Post Office Protocol&lt;br /&gt;- 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오는데 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IMAP&lt;/td&gt;
      &lt;td&gt;- Internet Message Access Protocol, 인터넷 메시지 접속 프로토콜&lt;br /&gt;- 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오는데 사용&lt;br /&gt;- 온라인/오프라인을 지원하므로 POP3와 달리 이메일 메시지를 서버에 남겨 두었다가 나중에 삭제 가능&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LDAP&lt;/td&gt;
      &lt;td&gt;- Lightweight Directory Access Protocol, 경량 디렉토리 접근 프로토콜&lt;br /&gt;- TCP/IP위에서 디렉터리 서비스를 조회하고 수정하는 응용 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MQTT&lt;/td&gt;
      &lt;td&gt;- Message Queuing Telemetry Transport&lt;br /&gt;- ISO 표준 발생-구독 기반의 메시징 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NNTP&lt;/td&gt;
      &lt;td&gt;- Network News Transfer Protocol&lt;br /&gt;- 뉴스 서버 간에 유즈넷 뉴스 기사를 전송하고 최종 사용자 클라이언트 애플리케이션에 의해 기사를 구독, 게시할 수 있게 하기 위한 애플리케이션 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NTP&lt;/td&gt;
      &lt;td&gt;- Network Time Protocol&lt;br /&gt;- 패킷 교환, 가변 레이턴시 데이터 네트워크를 통해 컴퓨터 시스템 간 시간 동기화를 위한 네트워크 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RTP&lt;/td&gt;
      &lt;td&gt;- Real-Time Transport Protocol&lt;br /&gt;- 네트워크상에서 음성이나 영상 또는 시뮬레이션 데이터 등 실시간 전송이 필요한 응용에 대하여 편리한 전송 기능을 제공&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RTCP&lt;/td&gt;
      &lt;td&gt;- Real-Time Control Protocol&lt;br /&gt;- 세션의 모든 참여자에게 컨트롤 패킷을 주기적으로 전송&lt;br /&gt;- 데이터 전송을 모니터링하고 최소한의 제어와 인증 기능을 제공&lt;br /&gt;- RTP 세션의 대역 외 통계 및 제어 정보를 제공&lt;br /&gt;- RTCP가 직접 미디어 데이터를 전송하지는 않는다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RTSP&lt;/td&gt;
      &lt;td&gt;- Real Time Streaming Protocol&lt;br /&gt;- 스트리밍 미디어 서버를 제어할 목적으로 엔터테인먼트, 통신 시스템에 사용하도록 설계된 네트워크 제어 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RIP&lt;/td&gt;
      &lt;td&gt;- Routing Information Protocol&lt;br /&gt;- UDP/IP 상에서 동작하는 라우팅 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SIP&lt;/td&gt;
      &lt;td&gt;- Session Initiation Protocol&lt;br /&gt;- IETE에서 정의한 시그널링 프로토콜로 음성과 화상통화같은 멀티미디어 세션을 제어하기 위해 널리 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SMTP&lt;/td&gt;
      &lt;td&gt;- Simple Mail Transfer Protocol(25 Port)&lt;br /&gt;- 인터넷에서 이메일을 보내기 위해 이용되는 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SNMP&lt;/td&gt;
      &lt;td&gt;- Simple Network Management Protocol, 간이 망 관리 프로토콜&lt;br /&gt;- IP 네트워크상의 장치로부터 정보를 수집 및 관리하며, 또한 정보를 수정하여 장치의 동작을 변경하는 데 사용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SSH&lt;/td&gt;
      &lt;td&gt;- Secure SHell, 시큐어 셸 (22 Port)&lt;br /&gt;- 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있도록 해주는 응용 프로그램 또는 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Telnet&lt;/td&gt;
      &lt;td&gt;- 멀리 떨어진 호스트에 원격 접속하여 사용할 수 있는 가상 터미널(VT) 서비스 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TLS/SSL&lt;/td&gt;
      &lt;td&gt;- Transport Layer Security/Secure Sockets Layer&lt;br /&gt;- 컴퓨터 네트워크에 통신 보안을 제공하기 위해 설계된 암호 규약&lt;br /&gt;- TCP/IP 네트워크를 사용하는 통신에 적용되며 통신 과정에서 전송 계층 종단간 보안과 데이터 무결성을 확보해준다&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;XMPP&lt;/td&gt;
      &lt;td&gt;- eXtensible Messaging and Presense Protocol&lt;br /&gt;- XML에 기반한 메시지 지향 미들웨어용 통신 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Gopher&lt;/td&gt;
      &lt;td&gt;- 인터넷을 위해 고안된 문서 검색 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IRC&lt;/td&gt;
      &lt;td&gt;- Internet Relay Chat&lt;br /&gt;- 인터넷 채팅 서비스 프로토콜&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DHCP&lt;/td&gt;
      &lt;td&gt;- Dynamic Host Configuration Protocol&lt;br /&gt;- 호스트 IP 구성 관리를 단순화하는 IP 표준&lt;br /&gt;- 네트워크에 연결되어 있는 컴퓨터가 시동될 때 DHCP 서버로부터 IP 주소와 구성 매개 변수를 동적으로 할당받아 자동으로 TCP/IP 설정이 이루어진다&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;프로토콜-구조&quot;&gt;프로토콜 구조&lt;/h2&gt;
&lt;h3 id=&quot;tcp-header&quot;&gt;TCP Header&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SRC&lt;/strong&gt;(Source Port) : 송신측의 포트 주소 기록&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DEST&lt;/strong&gt;(Destination) : 수신측의 포트 주소 기록&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SEQ&lt;/strong&gt;(Sequence Number) : 전체 데이터의 세그먼트 위치 기록(상위)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt;(Acknowledgment) : 전체 데이터 세그먼트 위치를 기록(하위)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DO&lt;/strong&gt;(Data Offset) : TCP 헤더 길이 기록&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;RES&lt;/strong&gt;(Reserved) : 확장될 때 사용할 예비 영역&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CF&lt;/strong&gt;(Control Flags) : 패킷의 종류를 표시하는 플래그&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;WINDOW&lt;/strong&gt; : 수신 가능한 최대 세그먼트 길이를 기록&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CS&lt;/strong&gt;(Checksum) : 오류를 체크하는 알고리즘 기록&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;URGPTR&lt;/strong&gt;(Urgent Pointer) : 긴급 데이터 포인트 기록&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;udp-header-8byte&quot;&gt;UDP Header (8Byte)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Source&lt;/strong&gt; Port Number : 송신 포트번호&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Destination&lt;/strong&gt; Port Number : 수신 포트번호&lt;/li&gt;
  &lt;li&gt;UDP Total &lt;strong&gt;length&lt;/strong&gt; : UDP 헤더와 데이터를 합친 길이&lt;/li&gt;
  &lt;li&gt;UDP &lt;strong&gt;Checksum&lt;/strong&gt; : UDP 헤더와 데이터를 모두 포함하여 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;rtp-header&quot;&gt;RTP Header&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Padding&lt;/strong&gt;(P)&lt;br /&gt;
세팅되어 있는 경우는 그 패킷의 끝에 전송하려는 데이터 외에 &lt;strong&gt;추가적인 데이터&lt;/strong&gt;들이 포함되어 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Marker&lt;/strong&gt;(M)&lt;br /&gt;
패킷 스트림에서 프레임 간의 &lt;strong&gt;경계에 존재&lt;/strong&gt;하는 특별한 경우를 표시&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Extension&lt;/strong&gt;(X)&lt;br /&gt;
세팅되어 있는 경우는 RTP 헤더 마지막에 &lt;strong&gt;확장 헤더가 있음을&lt;/strong&gt; 의미&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Payload Type&lt;/strong&gt;(PT)&lt;br /&gt;
데이터가 어떤 형식인지를 지정&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Timestamp&lt;/strong&gt;&lt;br /&gt;
데이터그램에 포함된 &lt;strong&gt;데이터의 생성 시기&lt;/strong&gt;를 나타낸다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;rtcp-패킷-유형&quot;&gt;RTCP 패킷 유형&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SR(Sender Report) : 세션의 품질에 대한 정보를 포함&lt;/li&gt;
  &lt;li&gt;RR(Receiver Report) : 세션의 품질에 대한 정보를 포함&lt;/li&gt;
  &lt;li&gt;SDES(Source Description) : 세션에 속한 각 참가자의 ID에 대한 정보를 포함&lt;/li&gt;
  &lt;li&gt;BYE(Goodbye) : 세션에서 하나 이상의 소스가 더 이상 활성화 상태가 아님을 나타낸다&lt;/li&gt;
  &lt;li&gt;APP(APPlication-defined) : 새 응용 프로그램에서 실험적으로 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RR/SR Header
    &lt;ul&gt;
      &lt;li&gt;버전&lt;/li&gt;
      &lt;li&gt;패딩 : 1로 설정된 경우, 추가 패딩 옥텟의 개수&lt;/li&gt;
      &lt;li&gt;수신 보고서 개수 : RTCP 패킷에 포함된 수신 블록의 개수&lt;/li&gt;
      &lt;li&gt;패킷 유형 : RR(201), SR(200)&lt;/li&gt;
      &lt;li&gt;길이 : 1을 뺀 32비트 단어에 RTCP 패킷의 길이를 포함&lt;/li&gt;
      &lt;li&gt;식별자 : 패킷의 동기화 소스 식별자를 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip-header&quot;&gt;IP Header&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;VER(Version, 4bit)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IHL(Internet Header Length, 4bit)&lt;br /&gt;
IP 헤더 길이로 보통 24바이트 정도이다. 4비트로 표현된 길이에 4바이트를 곱하면 IP 헤더의 길이&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TOS(Type Source, 8bit)&lt;br /&gt;
IP 서비스 형태로 상위층에 의해 결정&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TL(Total Length, 16bit)&lt;br /&gt;
IP 헤더 길이와 TCP 헤더와 TCP 데이터의 길이를 더한 길이&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ID(IDentification, 16bit)&lt;br /&gt;
참고 정보들이 기록&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FL(Flags, 3bit)&lt;br /&gt;
패킷 분할의 정보로 첫 번째 비트는 사용하지 않고, 2번째 비트가 ‘1’이면 분할 가능, ‘0’이면 분할 불가를 의미하고 3번째 비트가 ‘0’이면 분할된 패킷의 최후 패킷을 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TTL(Time To Live, 8bit)&lt;br /&gt;
패킷을 처리하는 데 필요한 시간으로 데이터그램 패킷의 최대 수명 시간은 255초. 범람 라우팅에서는 Hop Count로 사용하는 블록&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PROT(PROTocol, 8bit)&lt;br /&gt;
IP 계층에서 서비스를 받을 상위 계층의 프로토콜 번호로 TCP 계층의 TCP(6)/UDP(17)을 기입하는 블록&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HC(Header Checksum, 16bit)&lt;br /&gt;
IP헤더의 오류 체크 블록&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SOURCE(Source address, 32bit)&lt;br /&gt;
송신측의 IP 어드레스&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DEST(DESTination, 32bit)&lt;br /&gt;
수신측의 IP 어드레스&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;OPT(OPTion)&lt;br /&gt;
표준 IP헤더에는 없는 정보를 송신할 때 사용하는 블록&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 08 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://many258.github.io/study/data-communication-internetworking/</link>
        <guid isPermaLink="true">https://many258.github.io/study/data-communication-internetworking/</guid>
        
        <category>데이터통신</category>
        
        
        <category>study</category>
        
      </item>
    
  </channel>
</rss>
