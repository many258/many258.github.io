<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://many258.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://many258.github.io/" rel="alternate" type="text/html" /><updated>2021-03-28T01:39:58+09:00</updated><id>https://many258.github.io/feed.xml</id><title type="html">My LifeChronicle</title><subtitle>Be a Imagineer.</subtitle><author><name>SG Yoo.</name></author><entry><title type="html">[데이터통신] 데이터 전송 제어</title><link href="https://many258.github.io/study/data-communication-transmission-control/" rel="alternate" type="text/html" title="[데이터통신] 데이터 전송 제어" /><published>2021-03-28T00:00:00+09:00</published><updated>2021-03-28T02:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdata-communication-transmission-control%7D</id><content type="html" xml:base="https://many258.github.io/study/data-communication-transmission-control/">&lt;h1 id=&quot;데이터-링크-제어&quot;&gt;데이터 링크 제어&lt;/h1&gt;
&lt;p&gt;데이터 통신망에 접속된 컴퓨터나 단말 장치가 오류 없이 투명한 정보를 효율적이고 원할하게 송/수신하기 위하여 데이터 통신 시스템이 갖추어야 할 제어 기술로 데이터 입출력, 동기 제어, 오류 제어 등을 포함한다&lt;/p&gt;

&lt;h1 id=&quot;데이터-전송-제어-절차&quot;&gt;데이터 전송 제어 절차&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;회선접속&lt;br /&gt;
  일반 교환망에서의 물리적인 접속 단계&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;데이터 링크의 확립&lt;br /&gt;
  데이터 송수신을 위한 논리적인 경로를 구성하는 단계&lt;br /&gt;
  (링크 확립 방법 : &lt;strong&gt;Selection&lt;/strong&gt;, &lt;strong&gt;Polling&lt;/strong&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;데이터 전송&lt;br /&gt;
  송수신측 간의 메시지 전송 단계&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;데이터 링크의 해제 통보 &lt;br /&gt;
  링크 확립을 종료하는 단계로 논리적인 경로를 해제하는 단계&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;회선 절단&lt;br /&gt;
  교환망에 연결된 회선 접속 단계로 물리적인 접속을 해제하는 단계&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;데이터-전송-프레임&quot;&gt;데이터 전송 프레임&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;전송 프레임&lt;/strong&gt; : 수신측의 입장에서 보면 전송되는 모든 정보가 ‘1’과 ‘0’으로 수신되는데, 이 때 수신된 비트열이 어디서부터 제어 영역이고 어디서부터 정보 영역인지를 미리 &lt;strong&gt;약속&lt;/strong&gt;하지 않는다면 정상적으로 수신된 비트 열일지라도 다른 의미를 갖는 정보로 해석될 수 있다.&lt;/p&gt;

&lt;p&gt;따라서, 7비트(&lt;strong&gt;문자 지향 프레임&lt;/strong&gt;), 8비트(&lt;strong&gt;바이트 지향 프레임&lt;/strong&gt;, DEC사의 DDCMP), &lt;strong&gt;비트 지향 프레임&lt;/strong&gt;을 부여하여 송수신하도록 해야 한다. 이처럼 송신측에서 발생된 정보의 정확한 전송을 위해 사용자 정보에 헤더와 트레일러를 부과하는 과정을 &lt;strong&gt;캡슐화&lt;/strong&gt;라고 하며, 이러한 형식화된 데이터 블록을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프레임&lt;/code&gt;이라고 한다&lt;/p&gt;

&lt;h2 id=&quot;문자-지향-프레임&quot;&gt;문자 지향 프레임&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;IBM사의 &lt;strong&gt;BASIC&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;전송 방향은 &lt;strong&gt;반이중&lt;/strong&gt; 방식으로만 사용&lt;/li&gt;
  &lt;li&gt;회선 연결은 점 대 점 방식뿐만 아니라 멀티 포인트 링크에서도 사용될 수 있다&lt;/li&gt;
  &lt;li&gt;같은 전송 회선만 가능(&lt;strong&gt;종속적&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;오류 제어 방식은 &lt;strong&gt;Stop-And-Wait&lt;/strong&gt; ARQ를 사용&lt;/li&gt;
  &lt;li&gt;오류 검출이 어렵고, 전송 효율이 나쁘다&lt;/li&gt;
  &lt;li&gt;주로 동기 전송 방식을 사용하나 &lt;strong&gt;비동기 전송 방식&lt;/strong&gt;을 사용하기도 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;../../assets/images/network/data-communication/character-oriented-frame.png&quot; alt=&quot;&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;BCC(Block Check Character) 검사 범위 : &lt;strong&gt;[Heading - STX - Text - ETX]&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;source : http://egloos.zum.com/nooriry/v/1598115&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;비트-지향-프레임&quot;&gt;비트 지향 프레임&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;ISO의 HDLC, IBM사의 SDLC, 미 국방성 TCP&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;../../assets/images/network/data-communication/bit-oriented-frame.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;source : http://www.rhyshaden.com/hdlc.htm&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;flag&quot;&gt;FLAG&lt;/h3&gt;
&lt;p&gt;프레임 구조의 앞과 뒤를 구분하는 비트 열(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'01111110'&lt;/code&gt;, ‘7E’)&lt;/p&gt;

&lt;p&gt;통신 회선을 공유하는 모든 다른 프레임들과 구분하는 비트 열로 송신측에서는 송신하기 전에 송신 메시지 앞과 뒤에 추가하여 전송
FLAG 비트를 제외한 모든 비트는 연속된 ‘1’의 비트가 6개 이상이 되지 않도록 강제적으로 ‘0’을 추가하여 송신.&lt;/p&gt;

&lt;p&gt;수신측은 FLAG 비트를 제외한 비트 열에 ‘1’의 문자가 연속적으로 5개가 입력되면 5개 다음에 입력된 ‘0’ 비트를 제거한다. 이처럼 ‘0’을 삽입하고 ‘0’을 제거하여 기본적인 오류를 검출하고 신뢰성 있는 송수신이 되도록 하는 기능을 &lt;strong&gt;비트 투과성&lt;/strong&gt;(Bit Transparency) 또는 &lt;strong&gt;비트 스터핑&lt;/strong&gt;(Bit Stuffing)이라고 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프레임의 앞과 뒤를 구분&lt;/li&gt;
  &lt;li&gt;동기를 유지&lt;/li&gt;
  &lt;li&gt;비트 투과성으로 기본적인 오류를 검출&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;address&quot;&gt;ADDRESS&lt;/h3&gt;
&lt;p&gt;상대국이나 복합국의 주소를 지정할 때 사용하는 블록으로 기본적으로 &lt;strong&gt;8비트를 사용하며 8바이트&lt;/strong&gt;까지 확장 가능&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1바이트를 사용할 시, 방송용 주소(11111111)와 시험용(00000000)을 제외하면 실제 주소는 254개 부여 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;control&quot;&gt;CONTROL&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;I(Information)&lt;/strong&gt; 프레임
    &lt;ul&gt;
      &lt;li&gt;순수한 정보만을 전송하는 프레임&lt;/li&gt;
      &lt;li&gt;첫 번째 비트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'0'&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;사용자 데이터를 전달하거나 피기백킹 기법을 통해 데이터에 대한 확인 응답을 보낼 때 사용&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;피기백킹&lt;/strong&gt; : 데이터 프레임에 확인응답을 포함시켜 전송하는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;S(Supervisor)&lt;/strong&gt; 프레임
    &lt;ul&gt;
      &lt;li&gt;정보 전송 프레임을 감시/감독하는 프레임으로 흐름제어, 에러 제어를 담당하는 프레임&lt;/li&gt;
      &lt;li&gt;상위 두 비트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'10'&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;RR(00, 수신 완료), REJ(01, 수신 거부), RNR(10, 수신 준비 안 됨)등의 제어 명령이 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;U(Unnumbered)&lt;/strong&gt; 프레임
    &lt;ul&gt;
      &lt;li&gt;통신하기 위한 초기 설정 및 링크 확립과 해제 등의 명령이 있는 프레임&lt;/li&gt;
      &lt;li&gt;상위 두 비트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'11'&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;SMD(Set Mode)의 기능
        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;NRM&lt;/strong&gt;(Normal Response Mode, UNC, &lt;strong&gt;표준 응답 모드&lt;/strong&gt;)&lt;br /&gt;
주 스테이션이 링크 제어를 담당하며, 부 스테이션은 주 스테이션으로부터 메시지를 수신한 경우에만 데이터를 전송할 수 있다(&lt;strong&gt;반이중 통신&lt;/strong&gt;)&lt;br /&gt;
점 대 점이나 멀티 포인트 불균형 링크 구성에 사용&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;ARM&lt;/strong&gt;(Asynchronous Response Mode, UAC, &lt;strong&gt;비동기 응답 모드&lt;/strong&gt;)&lt;br /&gt;
주 스테이션이 링크 제어를 담당하며, 부 스테이션은 주 스테이션으로부터 메시지가 없어도 데이터를 전송할 수 있다(&lt;strong&gt;전이중 통신&lt;/strong&gt;)&lt;br /&gt;
점 대 점이나 멀티포인트 불균형 링크 구성에 사용&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;ABM&lt;/strong&gt;(Asynchronous Balance Mode, BAC, &lt;strong&gt;비동기 균형 모드&lt;/strong&gt;)&lt;br /&gt;
주 스테이션과 부 스테이션의 구분이 없이 동등하다&lt;br /&gt;
링형이나 망형 구조의 균형 링크 구성에 사용(&lt;strong&gt;전이중 통신&lt;/strong&gt;)&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;&lt;strong&gt;SIM&lt;/strong&gt;(Set Initial Mode, 모드 설정 초기화)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;정보부&quot;&gt;정보부&lt;/h3&gt;
&lt;p&gt;사용자 사이에서 교환되는 정보 메시지 블록의 길이, 구성과 관계없이 송수신 간 협의에 따른다&lt;/p&gt;

&lt;h3 id=&quot;fcsframe-check-sequence-프레임-검사-순서부&quot;&gt;FCS(Frame Check Sequence, 프레임 검사 순서부)&lt;/h3&gt;
&lt;p&gt;주소부/제어부/정보부 블록의 오류를 검사하는 블록으로 오류 검사 방법은 주로 &lt;strong&gt;CRC 방식&lt;/strong&gt;을 사용&lt;/p&gt;

&lt;h3 id=&quot;hdlc-특징&quot;&gt;HDLC 특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;전송 방향 : 단방향/반이중/전이중 방식 모두 사용 가능&lt;/li&gt;
  &lt;li&gt;회선 연결 : 점 대 점, 멀티포인트, 루프 방식 모두 사용 가능&lt;/li&gt;
  &lt;li&gt;오류 제어 방식 : ARQ(&lt;strong&gt;Go-Back-N&lt;/strong&gt;, &lt;strong&gt;Seletive-repeat&lt;/strong&gt;) 사용&lt;/li&gt;
  &lt;li&gt;다른 전송 회선도 가능(&lt;strong&gt;독립적&lt;/strong&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;동기식 전송&lt;/strong&gt;으로 전송 효율과 신뢰성이 높다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;기타-프레임&quot;&gt;기타 프레임&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SDLC&lt;/strong&gt;(Synchronous Data Link Control)
    &lt;ul&gt;
      &lt;li&gt;HDLC를 기반으로 하는 비트 위주 데이터 링크 제어 프로토콜&lt;/li&gt;
      &lt;li&gt;X.25 패킷 교환망 표준의 한 부분으로 &lt;strong&gt;ITU-T&lt;/strong&gt;에 의해 제정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LAP-B&lt;/strong&gt;(Link Access Procedure Balanced)
    &lt;ul&gt;
      &lt;li&gt;X.25 패킷 교환망의 표준으로 &lt;strong&gt;ITU-T&lt;/strong&gt;에서 제정한 HDLC 기반으로 하는 비트 위주 프레임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LAP-D&lt;/strong&gt;(Link Access Procedure D channel)
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;ISDN&lt;/strong&gt;의 D채널을 위한 프레임 혹은 데이터 링크 제어 프로토콜&lt;/li&gt;
      &lt;li&gt;LAP-B와는 달리 &lt;strong&gt;다중화된 채널을 성립&lt;/strong&gt;시킬 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LLC&lt;/strong&gt;(Logical Link Control)
    &lt;ul&gt;
      &lt;li&gt;LAN에서 사용되는 대표적인 프레임.(IEEE802 표준 계열)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SLIP&lt;/strong&gt;(Serial Line Internet Protocol)
    &lt;ul&gt;
      &lt;li&gt;전화선과 모뎀을 이용하여 인터넷에 접속하기 위한 프레임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PPP&lt;/strong&gt;(Point-to-Point Protocol)
    &lt;ul&gt;
      &lt;li&gt;전화선과 모뎀을 이용하여 인터넷에 접속하기 위한 프레임&lt;/li&gt;
      &lt;li&gt;SLIP을 개선하여 &lt;strong&gt;에러를 검출하고 복구&lt;/strong&gt;하는 기능 존재&lt;/li&gt;
      &lt;li&gt;HDLC와 유사한 점이 있으나 &lt;strong&gt;문자 위주 프레임&lt;/strong&gt;이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="데이터통신" /><summary type="html">데이터 링크 제어 데이터 통신망에 접속된 컴퓨터나 단말 장치가 오류 없이 투명한 정보를 효율적이고 원할하게 송/수신하기 위하여 데이터 통신 시스템이 갖추어야 할 제어 기술로 데이터 입출력, 동기 제어, 오류 제어 등을 포함한다</summary></entry><entry><title type="html">[데이터통신] 데이터 통신 시스템의 기본</title><link href="https://many258.github.io/study/data-communication-base/" rel="alternate" type="text/html" title="[데이터통신] 데이터 통신 시스템의 기본" /><published>2021-03-27T00:00:00+09:00</published><updated>2021-03-27T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdata-communication-base%7D</id><content type="html" xml:base="https://many258.github.io/study/data-communication-base/">&lt;h1 id=&quot;통신의-3요소&quot;&gt;통신의 3요소&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;정보원(Source)&lt;/li&gt;
  &lt;li&gt;수신원(Destination)&lt;/li&gt;
  &lt;li&gt;전송매체(Transmission Media)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-통신-시스템의-발달-과정&quot;&gt;데이터 통신 시스템의 발달 과정&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SAGE&lt;/strong&gt;(Semi-Automatic Ground Enviroment)
    &lt;ul&gt;
      &lt;li&gt;미국의 군사용 반자동 방공 시스테믕로 사용된 &lt;strong&gt;최초의 데이터 통신&lt;/strong&gt; 시스템&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SABRE&lt;/strong&gt;(Semi-Automatic Business Research Enviroment)
    &lt;ul&gt;
      &lt;li&gt;항공기 좌석 예약 시스템으로 &lt;strong&gt;최초의 상업용&lt;/strong&gt; 통신 시스템&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CTSS&lt;/strong&gt;(Compatible Time Sharing System)
    &lt;ul&gt;
      &lt;li&gt;대학 내 대형컴퓨터 공동 이용을 목적으로 시행한 &lt;strong&gt;최초의 시분할&lt;/strong&gt; 시스템&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ARPANET&lt;/strong&gt;(Advanced Research Project Agency Network)
    &lt;ul&gt;
      &lt;li&gt;최소의 &lt;strong&gt;유선 패킷 시스템&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;인터넷 기술의 모체&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ALOHA&lt;/strong&gt;(Additive Links On-line Hawaii Area)
    &lt;ul&gt;
      &lt;li&gt;최초의 &lt;strong&gt;무선 패킷&lt;/strong&gt; 네트워크 시스템&lt;/li&gt;
      &lt;li&gt;공유 회선 점유방식 중 &lt;strong&gt;경쟁방식(CSMA, CSMA/CD)의 모체&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;SNA&lt;/strong&gt;(System Network Architecture)
    &lt;ul&gt;
      &lt;li&gt;IBM 사에서 발표한 컴퓨터 간 접속 &lt;strong&gt;네트워크 시스템 표준&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-통신-시스템&quot;&gt;데이터 통신 시스템&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 전송계
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;단말장치&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTE&lt;/code&gt;: Data Terminal Equipment)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;데이터 전송 회선&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;신호 변환기&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DCE&lt;/code&gt;: Data Circuit Equipment)&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;통신 회선&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;통신 제어 장치&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CCU&lt;/code&gt;: Communication Control Unit)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 처리계
    &lt;ul&gt;
      &lt;li&gt;컴퓨터
        &lt;ul&gt;
          &lt;li&gt;하드웨어&lt;/li&gt;
          &lt;li&gt;통신 소프트웨어&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;통신&lt;/code&gt; 시스템의 3대 구성요소
    &lt;ul&gt;
      &lt;li&gt;단말장치&lt;/li&gt;
      &lt;li&gt;통신 제어 장치&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;전송 장치&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전송&lt;/code&gt; 시스템의 3대 구성요소
    &lt;ul&gt;
      &lt;li&gt;단말장치&lt;/li&gt;
      &lt;li&gt;통신 제어 장치&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;데이터 전송 회선&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;단말장치dte-data-terminal-equipment&quot;&gt;단말장치(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DTE&lt;/code&gt;: Data Terminal Equipment)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;통신 시스템과 사용자의 접점에 위치하여 데이터를 입력하거나 처리된 결과를 출력하는 기능 담당&lt;/li&gt;
  &lt;li&gt;전송 제어 기능(입출력 제어, 오류 제어, 송수신 제어) 수행&lt;/li&gt;
  &lt;li&gt;통신 회선을 통하여 송수신될 때 속도의 차이를 극복시켜 주는 임시 기억 장치의 역할&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;데이터-전송-회선&quot;&gt;데이터 전송 회선&lt;/h2&gt;
&lt;p&gt;전송 신호를 송/수신하기 위한 통로&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전송로에 적합한 신호로 변경&lt;/li&gt;
  &lt;li&gt;데이터 송수신 시에 동기(시간 맞춤 행위)를 제어&lt;/li&gt;
  &lt;li&gt;오류를 검출하거나 정정&lt;/li&gt;
  &lt;li&gt;전송 조작 절차를 제어&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;신호-변환기dce-data-circuit-equipment&quot;&gt;신호 변환기(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DCE&lt;/code&gt;: Data Circuit Equipment)&lt;/h3&gt;
&lt;p&gt;단말장치와 통신 회선 사이에서 적합한 신호나 데이터로 변환시켜주는 장치로서 데이터 회선 종단 장치라고도 한다.&lt;br /&gt;
&lt;strong&gt;MODEM, CODEC, DSU&lt;/strong&gt;가 존재&lt;/p&gt;

&lt;h3 id=&quot;통신-회선&quot;&gt;통신 회선&lt;/h3&gt;
&lt;p&gt;데이터가 실질적으로 전송되는 선로.&lt;br /&gt;
&lt;strong&gt;꼬임선/동축케이블/광섬유 케이블&lt;/strong&gt; 등 전송 매체 존재&lt;/p&gt;

&lt;h2 id=&quot;통신-제어-장치ccu-communication-control-unit&quot;&gt;통신 제어 장치(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CCU&lt;/code&gt;: Communication Control Unit)&lt;/h2&gt;
&lt;p&gt;데이터 전송회선과 컴퓨터를 연결하는 장치. 컴퓨터가 데이터 처리에 전념할 수 있도록 컴퓨터를 대신해 데이터 전송에 관한 전반적인 제어 기능을 수행&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;통신 회선을 통하여 송수신되는 자료를 제어하고 감시&lt;/li&gt;
  &lt;li&gt;통신 회선의 전송 속도와 CPU의 처리 속도 사이에서 조정을 수행&lt;/li&gt;
  &lt;li&gt;통신 회선과 전기적으로 결합&lt;/li&gt;
  &lt;li&gt;통신 방식과 다중 접속을 제어&lt;/li&gt;
  &lt;li&gt;전송 문자 및 메시지를 조립 또는 분해&lt;/li&gt;
  &lt;li&gt;동기 제어 : 컴퓨터의 처리 속도와 통신 회선 상의 전송 속도 차이 조정&lt;/li&gt;
  &lt;li&gt;오류 제어 : 통신 회선과 단말장치에서 발생하는 오류 제어&lt;/li&gt;
  &lt;li&gt;흐름 제어 : 수신 가능한 데이터의 양을 송신측에 알려 원할한 정보 전송이 가능하도록 조정&lt;/li&gt;
  &lt;li&gt;응답 제어 : 수신 정보 확인&lt;/li&gt;
  &lt;li&gt;투과성 : 전송할 실제 데이터에 대한 비트 열에 확장 비트를 부가 또는 소거&lt;/li&gt;
  &lt;li&gt;우선권 제어&lt;/li&gt;
  &lt;li&gt;제어 정보 식별 : 일반 데이터와 제어 정보 구분&lt;/li&gt;
  &lt;li&gt;기밀 보호 : 암호화 등 제어&lt;/li&gt;
  &lt;li&gt;관리 기능 : 통신에 관한 통계 정보 수집&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="데이터통신" /><summary type="html">통신의 3요소 정보원(Source) 수신원(Destination) 전송매체(Transmission Media)</summary></entry><entry><title type="html">[데이터통신] 데이터 전송</title><link href="https://many258.github.io/study/data-communication-transmission/" rel="alternate" type="text/html" title="[데이터통신] 데이터 전송" /><published>2021-03-27T00:00:00+09:00</published><updated>2021-03-09T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdata-communication-transmission%7D</id><content type="html" xml:base="https://many258.github.io/study/data-communication-transmission/">&lt;h1 id=&quot;데이터-전송-방식&quot;&gt;데이터 전송 방식&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;아날로그 전송&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;전송 매체를 통해 전달되는 신호가 아날로그 형태인 것(사람의 음성, 화상)&lt;/li&gt;
      &lt;li&gt;신호의 감쇠 현상이 심하기 때문에 증폭기에 의해 신호를 중간에 다시 증폭하여 전송해야 하는데 신호에 포함된 잡음까지 같이 증폭&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디지털 전송&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;전송 매체를 통해 전달되는 신호가 디지털 형태인 것&lt;/li&gt;
      &lt;li&gt;신호에 포함된 잡음은 제거하고 0과 1만을 추출하여 증폭되므로 왜곡 현상이 없다&lt;/li&gt;
      &lt;li&gt;아날로그 전송과 비교하여 유지 비용이 적다&lt;/li&gt;
      &lt;li&gt;디지털 신호 변환에 의해 아날로그나 디지털 정보의 암호화가 쉽게 구현 가능&lt;/li&gt;
      &lt;li&gt;전송 용량을 다중화함으로써 효율성이 높음&lt;/li&gt;
      &lt;li&gt;아날로그 전송보다 훨씬 &lt;strong&gt;많은 대역폭을 필요&lt;/strong&gt;로 하고, 전송 거리가 짧기 때문에 증폭기가 많이 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-비트의-전송-방법&quot;&gt;데이터 비트의 전송 방법&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;직렬 전송
    &lt;ul&gt;
      &lt;li&gt;정보를 구성하는 각 비트들이 하나의 전송 매체를 통해 한 비트씩 순서적으로 전송되는 형태&lt;/li&gt;
      &lt;li&gt;하나의 전송 매체만 사용하므로 &lt;strong&gt;속도는 느리지만&lt;/strong&gt; 구성 비용이 적다&lt;/li&gt;
      &lt;li&gt;원거리 전송에 적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;병렬 전송
    &lt;ul&gt;
      &lt;li&gt;정보를 구성하는 각 비트들이 여러 개의 전송 매체를 통해 동시에 전송되는 형태&lt;/li&gt;
      &lt;li&gt;여러 개의 전송 매체를 사용하므로 전송 속도는 &lt;strong&gt;빠르지만&lt;/strong&gt; 구성 비용이 많이 소요&lt;/li&gt;
      &lt;li&gt;근거리 전송에 적합하며 주로 컴퓨터와 주변장치 사이의 데이터 전송에 사용&lt;/li&gt;
      &lt;li&gt;흐름 제어 필요 :
        &lt;ul&gt;
          &lt;li&gt;수신측이 현재 데이터 수신중임을 알리기 위해 Busy 신호 사용&lt;/li&gt;
          &lt;li&gt;문자와 문자 단위를 식별하기 위해 Strobe 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-전송-방향&quot;&gt;데이터 전송 방향&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;단방향 전송(Simplex)&lt;br /&gt;
한쪽 방향으로만 데이터 전송이 이루어지는 방식&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;양방향 전송(Duplex)&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;반이중 전송(Half-Duplex)
        &lt;ul&gt;
          &lt;li&gt;한쪽에서 데이터 전송이 되면 다른 한쪽에서는 전송이 끝나기를 기다리는 방식&lt;/li&gt;
          &lt;li&gt;전송 &lt;strong&gt;방향을 바꾸는 시간&lt;/strong&gt;이 필요&lt;/li&gt;
          &lt;li&gt;통신 회선이 비교적 적을 때 사용&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;2선식 선로&lt;/strong&gt;를 두어 송신과 수신을 번갈아 전송&lt;/li&gt;
          &lt;li&gt;전송 지연에 문제가 있으며 &lt;strong&gt;반환 시간(Turn-Around Time)이 길다&lt;/strong&gt;.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;전이중 전송(Full-Duplex)
        &lt;ul&gt;
          &lt;li&gt;전송 시간에 구애를 받지 않는다&lt;/li&gt;
          &lt;li&gt;전송량이 많고 통신 회선의 용량이 클 때 사용&lt;/li&gt;
          &lt;li&gt;통신 회선의 &lt;strong&gt;효율이 높다&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;4선식 선로&lt;/strong&gt;를 두어 송신과 수신을 별도로 전송&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;동기화&quot;&gt;동기화&lt;/h1&gt;
&lt;p&gt;송신 측과 수신 측이 정확히 데이터를 주고 받을 수 있도록 양측에 시간을 맞추는 것을 의미. 이 때 양측의 &lt;strong&gt;시간을 일치&lt;/strong&gt;시키는 것을 &lt;strong&gt;동기식 전송&lt;/strong&gt;, 송신 측에 관계없이 수신 측에서 &lt;strong&gt;수신 신호로 시간을 식별&lt;/strong&gt;하는 것을 &lt;strong&gt;비동기식 전송&lt;/strong&gt;이라고 한다.&lt;/p&gt;

&lt;h2 id=&quot;비동기식-전송&quot;&gt;비동기식 전송&lt;/h2&gt;
&lt;p&gt;시작 비트, 전송 문자(정보 비트), 정지 비트로 구성된 한 문자를 단위로 전송하며, 오류 검출을 위한 패리티 비트를 추가하기도 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;간헐적으로 시간을 맞춘다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;독립적, 문자 단위&lt;/strong&gt; 전송&lt;/li&gt;
  &lt;li&gt;문자와 문자 사이의 &lt;strong&gt;휴지 기간&lt;/strong&gt;이 존재&lt;/li&gt;
  &lt;li&gt;한꺼번에 많은 데이터를 보내면 프레이밍 에러의 가능성이 높아진다&lt;/li&gt;
  &lt;li&gt;약 2Kbps 이하의 &lt;strong&gt;저속&lt;/strong&gt;, &lt;strong&gt;단거리&lt;/strong&gt; 전송에 사용&lt;/li&gt;
  &lt;li&gt;대화용 전송에 적당&lt;/li&gt;
  &lt;li&gt;버퍼를 적게 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ASK, FSK&lt;/strong&gt; 방식에 적합&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;전송 효율 = $\frac{정보 비트}{전송 비트} \times 100\%$&lt;br /&gt;
&lt;sub&gt;전송 비트 = 정보 비트 + 제어 비트(동기 문자, 오류 검출 비트)&lt;/sub&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;프레이밍 에러&lt;/strong&gt;(Framing Error) : 송신 측과 수신 측의 샘플링 시점이 달라서 발생하는 오류. 비동기 전송에서 start bit 와 stop bit 사이에 더 많은 비트들을 전송함으로써 오버헤드 비율을 줄일 수 있으나 비트들이 많을 수록 프레이밍 에러가 발생할 가능성이 높아진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;동기식-전송&quot;&gt;동기식 전송&lt;/h2&gt;
&lt;p&gt;미리 정해진 수만큼의 문자열을 한 블록(프레임)으로 만들어 일시에 전송하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;연속적&lt;/strong&gt;으로 시간을 맞춘다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;종속적, 블록(프레임) 단위&lt;/strong&gt; 전송&lt;/li&gt;
  &lt;li&gt;송신, 수신 양쪽의 동기를 유지하기 위해 타이밍 신호를 계속적으로 공급하거나 동기 문자를 전송&lt;/li&gt;
  &lt;li&gt;프레임 단위로 전송하므로 속도가 빠르다&lt;/li&gt;
  &lt;li&gt;시작/종료 비트로 인한 오버헤드가 없고, 휴지 기간이 없으므로 &lt;strong&gt;전송 효율이 좋다&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;단말기는 반드시 버퍼 기억장치에 내장하여야 한다&lt;/li&gt;
  &lt;li&gt;PSK, QAM 방식에 적당&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;문자 동기 방식&lt;/strong&gt; : SYN 등의 전송 제어 문자에 의해 동기를 맞추는 방식으로 BSC 프로토콜에서 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비트 동기 방식&lt;/strong&gt; : 데이터 블록의 처음과 끝에 8비트의 플래그 비트를 표시하여 동기를 맞추는 방식으로, HDLC/SDLC/ADCCP 프로토콜에서 사용(전송 에러 검출을 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FSC&lt;/code&gt;(Frame Check Sequence) 이용)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-전송-형태&quot;&gt;데이터 전송 형태&lt;/h1&gt;
&lt;h2 id=&quot;베이스밴드-전송기저-대역-전송-baseband-transmission&quot;&gt;베이스밴드 전송(기저 대역 전송, Baseband Transmission)&lt;/h2&gt;
&lt;p&gt;원래의 신호를 다른 주파수 대역으로 변조하지 않고 전송하거나 정보를 0과 1로 표시하고 이것을 직류의 전기 신호로 전송하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;보통 하나의 회선에 하나의 채널을 사용&lt;/li&gt;
  &lt;li&gt;10Mbps 이하의 전송 속도&lt;/li&gt;
  &lt;li&gt;소규모 데이터 전송에 적합&lt;/li&gt;
  &lt;li&gt;신호는 양방향으로 진행&lt;/li&gt;
  &lt;li&gt;모뎀이 필요 없어 비용이 저렴하나 전송거리가 짧음&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단극 RZ, 양극 NRZ-L, NRZ-M, Bipolar, Manchester&lt;/strong&gt; 등이 있다&lt;/li&gt;
  &lt;li&gt;CSMA/CD 방식, Token Ring 방식에서 채택&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;브로드밴드-전송반송-대역-전송-broadband-transmission&quot;&gt;브로드밴드 전송(반송 대역 전송, Broadband Transmission)&lt;/h2&gt;
&lt;p&gt;디지털 신호를 반송파의 진폭, 주파수, 위상 등으로 변환하여 아날로그를 전송하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;회선당 20 ~ 30개의 채널을 사용&lt;/li&gt;
  &lt;li&gt;150Mbps 이하의 전송속도&lt;/li&gt;
  &lt;li&gt;대규모의 멀티미디어에 적합한 방식&lt;/li&gt;
  &lt;li&gt;신호는 단방향으로 진행&lt;/li&gt;
  &lt;li&gt;Token Bus 방식에서 채택&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-전송-속도&quot;&gt;데이터 전송 속도&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;데이터 신호 속도(bps)&lt;br /&gt;
부호를 구성하는 데이터의 비트 수가 1초 동안에 얼마나 전송되었는가를 나타내는 단위
    &lt;blockquote&gt;
      &lt;p&gt;데이터 신호 속도(bps) = 변조 속도(Baud) X 변조 시 상태 변화 수&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;변조 속도(Baud)&lt;br /&gt;
신호의 변조 과정에서 1초 동안 몇 회의 변조가 행해졌는가를 나타내는 것을 의미.
    &lt;blockquote&gt;
      &lt;p&gt;B = $\frac{1}{T}$ &lt;sub&gt;T: 단위 시간당 펄스의 수&lt;/sub&gt;&lt;br /&gt;
$= \frac{bps}{변조 시 상태 변화 수}$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;베어러 속도&lt;br /&gt;
보통 베어러 속도를 반송 속도라고 하며 데이터 신호에 동기 신호와 상태 신호를 합한 속도(단위 bps = bit/sec)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Nyquist의 공식&lt;br /&gt;
잡음이 없는 채널의 전송 속도(bps)와 주파수(W)의 관계식
    &lt;blockquote&gt;
      &lt;p&gt;$C = 2W\log_2L$&lt;br /&gt;
&lt;sub&gt;C : bps / W : 대역폭 / L : 신호 레벨&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Shannon의 공식&lt;br /&gt;
잡음이 있는 채널의 전송 속도(bps)와 주파수(W)의 관계식
    &lt;blockquote&gt;
      &lt;p&gt;$C=W\log_2(1+S/N)$&lt;br /&gt;
&lt;sub&gt;C : bps / W : 대역폭 / S/N : 신호 대 잡음비&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;데이터-전송-코드&quot;&gt;데이터 전송 코드&lt;/h1&gt;
&lt;h2 id=&quot;baudot-코드&quot;&gt;Baudot 코드&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;초기의 전송용 코드로 5비트로 구성&lt;/li&gt;
  &lt;li&gt;오류 검출 코드가 없다&lt;/li&gt;
  &lt;li&gt;코드의 확장 기능이 있다&lt;/li&gt;
  &lt;li&gt;텔렉스(최초의 문자 전송 시스템으로 문자 정보를 텔렉스 교환기를 사용해서 전송하는 시스템) 코드로 이용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ascii-code&quot;&gt;ASCII Code&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;(American Standard Code for Information Interchange)&lt;/li&gt;
  &lt;li&gt;ISO에서 제정한 코드이며 7비트(패리티 비트 추가 시 8비트)로 구성된 데이터 통신용 코드&lt;/li&gt;
  &lt;li&gt;순차적인 코드(알파벳이나 숫자가 순서적 코드로 되어 있다)&lt;/li&gt;
  &lt;li&gt;정보 문자와 제어 문자로 구분&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ascii-코드-제어-문자&quot;&gt;ASCII 코드 제어 문자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;전송 제어 : 통신 선로의 데이터 흐름을 제어
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;SOH&lt;/strong&gt;(Start Of Head) : 머리말의 시작&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;STX&lt;/strong&gt;(Start of TeXt) : 본문의 시작 혹은 머리말의 종료&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ETX&lt;/strong&gt;(End of TeXt) : 본문을 종료&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;EOT&lt;/strong&gt;(End Of Transmission) : 전송의 종료, 링크 해제를 요청&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ENQ&lt;/strong&gt;(ENQuire) : 링크 설정 요청, 상대국의 응답을 요청한다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ACK&lt;/strong&gt;(ACKnowledge) : 긍정적인 응답, 다음 프레임을 요청&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;DLE&lt;/strong&gt;(Data Link Escape) : 보조적인 제어 문자, 통신망에서 전송 제어 문자를 구분&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;NAK&lt;/strong&gt;(Negative AcKnowledge) : 부정적인 응답 및 재전송 요구&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;SYN&lt;/strong&gt;(SYNchronous) : 시간 맞춤 행위를 위한 동기 문자&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ETB&lt;/strong&gt;(End of Transmission Block) : 블록의 종료를 표시&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;포멧 제어 : 데이터의 출력 및 정보의 레이아웃을 제어
    &lt;ul&gt;
      &lt;li&gt;BS(Back Space)&lt;/li&gt;
      &lt;li&gt;HT(Horizontal Tabulation)&lt;/li&gt;
      &lt;li&gt;LF(Line Feed)&lt;/li&gt;
      &lt;li&gt;VT(Vertical Tab)&lt;/li&gt;
      &lt;li&gt;FF(Form Feed)&lt;/li&gt;
      &lt;li&gt;CR(Carriage Return)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장치 제어 : 단말기의 보조 장치를 제어&lt;/li&gt;
  &lt;li&gt;정보 분리 : 데이터의 논리적 요소를 분리
    &lt;ul&gt;
      &lt;li&gt;US(Unit Separator)&lt;/li&gt;
      &lt;li&gt;RS(Record Separator)&lt;/li&gt;
      &lt;li&gt;GS(Group Separator)&lt;/li&gt;
      &lt;li&gt;FS(File Separator)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bcdbinary-coded-decimal&quot;&gt;BCD(Binary Coded Decimal)&lt;/h2&gt;
&lt;p&gt;컴퓨터 내부 코드로 10진수를 표현하기 위하여 주로 사용&lt;br /&gt;
데이터 비트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6비트&lt;/code&gt;로 구성되므로 총 64개의 문자 표현이 가능&lt;/p&gt;

&lt;h2 id=&quot;ebcdicextended-binary-coded-decimal-interchange-code&quot;&gt;EBCDIC(Extended Binary Coded Decimal Interchange Code)&lt;/h2&gt;
&lt;p&gt;IBM 컴퓨터의 내부 코드로 사용되며 컴퓨터와 컴퓨터 사이에 데이터 전송 코드로 사용&lt;/p&gt;

&lt;p&gt;8비트로 구성되며 총 256문자 표현이 가능&lt;/p&gt;

&lt;h2 id=&quot;unicode&quot;&gt;UNICODE&lt;/h2&gt;
&lt;p&gt;서로 다른 언어를 사용하는 컴퓨터들이 문제없이 통신하도록 모든 문자 체계를 하나의 문자 집합으로 만든 것. 숫자와 글자(키와 값)가 1:1 매핑된 형태의 코드&lt;/p&gt;

&lt;p&gt;Character set = UTF(Unicode Transformation Format) : 포함시키고자 하는 문자 집합을 정의&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UTF-8
    &lt;ul&gt;
      &lt;li&gt;하나의 문자를 1 ~ 4바이트의 가변 길이로 표현&lt;/li&gt;
      &lt;li&gt;현재 인터넷에서 가장 많이 쓰이면 인코딩이며 뛰어난 크로스 플랫폼 호환성을 지님&lt;/li&gt;
      &lt;li&gt;웹, 데이터베이스에서 주로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UTF-16
    &lt;ul&gt;
      &lt;li&gt;모든 문자를 2바이트의 고정 길이로 표현&lt;/li&gt;
      &lt;li&gt;바이트 순서가 정해지지 않아 리틀/빅 에디안 문제가 발생하기 때문에 인터넷 상에서의 사용을 권고하지 않음&lt;/li&gt;
      &lt;li&gt;윈도우 계열에서 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UTF-32
    &lt;ul&gt;
      &lt;li&gt;모든 문자를 4바이트의 고정 길이로 표현&lt;/li&gt;
      &lt;li&gt;저장 공간의 낭비가 심하다는 단점이 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="데이터통신" /><summary type="html">데이터 전송 방식 아날로그 전송 전송 매체를 통해 전달되는 신호가 아날로그 형태인 것(사람의 음성, 화상) 신호의 감쇠 현상이 심하기 때문에 증폭기에 의해 신호를 중간에 다시 증폭하여 전송해야 하는데 신호에 포함된 잡음까지 같이 증폭 디지털 전송 전송 매체를 통해 전달되는 신호가 디지털 형태인 것 신호에 포함된 잡음은 제거하고 0과 1만을 추출하여 증폭되므로 왜곡 현상이 없다 아날로그 전송과 비교하여 유지 비용이 적다 디지털 신호 변환에 의해 아날로그나 디지털 정보의 암호화가 쉽게 구현 가능 전송 용량을 다중화함으로써 효율성이 높음 아날로그 전송보다 훨씬 많은 대역폭을 필요로 하고, 전송 거리가 짧기 때문에 증폭기가 많이 사용</summary></entry><entry><title type="html">[데이터통신] 신호 변환기</title><link href="https://many258.github.io/study/data-communication-signal-converter/" rel="alternate" type="text/html" title="[데이터통신] 신호 변환기" /><published>2021-03-27T00:00:00+09:00</published><updated>2021-03-27T20:37:34+09:00</updated><id>https://many258.github.io/study/%7Bdata-communication-signal-converter%7D</id><content type="html" xml:base="https://many258.github.io/study/data-communication-signal-converter/">&lt;h1 id=&quot;신호-변환기의-종류&quot;&gt;신호 변환기의 종류&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;MODEM&lt;/strong&gt;&lt;br /&gt;
 &lt;strong&gt;디지털 데이터를 아날로그 신호&lt;/strong&gt;로 변환시키는 장비로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PSTN&lt;/code&gt;(공중 전화망)에 접속되는 장비&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DSU&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;디지털 데이터를 전송망에 적합한 디지털 신호&lt;/strong&gt;로 변환시키는 장비로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PSDN&lt;/code&gt;(공중 데이터망)에 접속되는 장비&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CODEC&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;아날로그 데이터를 디지털 신호&lt;/strong&gt;로 변환시키는 장비로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PCM&lt;/code&gt;이 대표적인 예&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Telephone&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;아날로그 데이터를 아날로그 신호&lt;/strong&gt;로 변환시키는 장비로 빠르고 멀리 전송하기 위해 음성 대역 의 낮은 주파수를 &lt;strong&gt;높은 주파수로 변환&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;modemmodulator--demodulator&quot;&gt;MODEM(Modulator / Demodulator)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기존의 공중 통신망을 이용하여 데이터 전송을 하기 위해 사용&lt;/li&gt;
  &lt;li&gt;음성 통신 회선은 사람의 음성 신호와 같은 아날로그 신호를 전송하기에 적합&lt;/li&gt;
  &lt;li&gt;공중 전화망을 음성 정보뿐만 아니라 디지털 전송으로 재사용하기 위해 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기능&quot;&gt;기능&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;변/복조 기능이 존재&lt;/li&gt;
  &lt;li&gt;펄스를 전송 신호로 변환&lt;/li&gt;
  &lt;li&gt;자동 호출 / 자동 응답 기능 존재&lt;/li&gt;
  &lt;li&gt;고장 장애 시험이 가능&lt;/li&gt;
  &lt;li&gt;데이터 통신 및 속도를 제어할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;분류&quot;&gt;분류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;동기&lt;/strong&gt; 방식에 의한 분류
    &lt;ul&gt;
      &lt;li&gt;비동기식 모뎀 방식 : 진폭 편이 변조(ASK), 주파수 편이 변조(FSK)&lt;/li&gt;
      &lt;li&gt;동기식 모뎀 방식 : 위상 편이 변조(PSK), 진폭 위상 편이 변조(QAM)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;포트&lt;/strong&gt; 수에 의한 분류
    &lt;ul&gt;
      &lt;li&gt;단 포트 모뎀&lt;br /&gt;
중속도(2,400bps 이하)에 사용되는 모뎀으로 하나의 포트에 연결&lt;/li&gt;
      &lt;li&gt;멀티 포트 모뎀&lt;br /&gt;
포트의 수가 2/4/6개 등 여러 개의 포트가 내장되어 있는 모뎀&lt;/li&gt;
      &lt;li&gt;널 모뎀&lt;br /&gt;
중간에 모뎀 또는 기타 데이터 통신 기기(DCE)를 사용하지 않고 터미널과 컴퓨터 사이에 RS-232C를 이용하여 직접 접속하는 모뎀&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;속도&lt;/strong&gt;에 의한 분류
    &lt;ul&gt;
      &lt;li&gt;저속도 모뎀(300bps 이하) : ASK&lt;/li&gt;
      &lt;li&gt;중속도 모뎀(1200 ~ 4800bps) : FSK, PSK&lt;/li&gt;
      &lt;li&gt;고속 모뎀(4800 ~ ) : QAM&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;모뎀의-신호-변환-방식&quot;&gt;모뎀의 신호 변환 방식&lt;/h3&gt;
&lt;h4 id=&quot;askamplitutde-shift-keying--진폭-편이-변조&quot;&gt;ASK(Amplitutde Shift Keying : 진폭 편이 변조)&lt;/h4&gt;
&lt;p&gt;디지털 데이터의 ‘1’과 ‘0’을 진폭의 크기만 다르게 하여 전송하는 방식&lt;/p&gt;

&lt;h4 id=&quot;fskfrequency-shift-keying--주파수-편이-변조&quot;&gt;FSK(Frequency Shift Keying : 주파수 편이 변조)&lt;/h4&gt;
&lt;p&gt;디지털 데이터의 ‘1’과 ‘0’을 주파수의 주기 수를 다르게 하여 전송하는 방식&lt;/p&gt;

&lt;h4 id=&quot;pskphase-shift-keying--위상-편이-변조&quot;&gt;PSK(Phase Shift Keying : 위상 편이 변조)&lt;/h4&gt;
&lt;p&gt;디지털 데이터의 ‘1’과 ‘0’을 위상(각도, 위치)을 다르게 하여 전송하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DPSK&lt;/strong&gt;(Differential PSK)&lt;br /&gt;
차등 인코딩을 사용하는 2위상 PSK&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;QDPSK&lt;/strong&gt;(Quadrature DPSK)&lt;br /&gt;
차등 인코딩을 사용하는 4위상 PSK&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;M위상(M진) PSK&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;$M=2^{전송\ 비트}, 전송\ 비트 = \log_2M$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;qskquadrature-amplitude-modulation--진폭-위상-변조-직교-위상-변조&quot;&gt;QSK(Quadrature Amplitude Modulation : 진폭 위상 변조, 직교 위상 변조)&lt;/h4&gt;
&lt;p&gt;디지털 데이터의 진폭과 위상을 변조하여 전송하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Coherent 방식&lt;br /&gt;
단일 주파수, 같은 모양의 위상. 동기와 유사&lt;/li&gt;
  &lt;li&gt;Non-Coherent 방식&lt;br /&gt;
다양한 주파수와 진폭, 다양한 모양의 위상. 비동기와 유사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dsudigital-service-unit&quot;&gt;DSU(Digital Service Unit)&lt;/h2&gt;
&lt;p&gt;네트워크 간에 서로 다른 디지털 신호를 사용하기 때문에 필요한 네트워크 연결 장비(네트워크 간의 상호 보안 문제가 있기 때문)&lt;/p&gt;

&lt;p&gt;하나의 통합된 디지털 신호(Bipolar)를 사용하자는 취지에서 등장한 ISDN이 계속 발전하지 못한 이유 또한 보안 문제가 발생했기 때문이다&lt;/p&gt;

&lt;h3 id=&quot;특징&quot;&gt;특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;디지털 신호를 변조하지 않고 DTE를 데이터 교환망에 접속하기 위한 장비&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;먼 거리&lt;/strong&gt;까지 디지털 데이터를 전송하기 위해 사용&lt;/li&gt;
  &lt;li&gt;모뎀의 회로 구성보다 간단하고 &lt;strong&gt;속도가 빠르다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dsu의-신호-변환-방식&quot;&gt;DSU의 신호 변환 방식&lt;/h3&gt;
&lt;h4 id=&quot;단극-rzreturn-to-zero&quot;&gt;단극 RZ(Return to Zero)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;전압을 양극이나 음극 하나만 사용&lt;/strong&gt;하므로 단극이라고 하며 입력 데이터가 ‘1’이면 양극이나 음극 중에서 전압을 주고 ‘0’이면 전압을 주지 않는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;송수신 회로 구성이 간단하지만 &lt;strong&gt;잡음이 많아 단거리 구간&lt;/strong&gt;에 사용되며 ‘1’과 ‘0’이 &lt;strong&gt;연속되면 동기가 용이하지 않다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;양극-nrznon-return-to-zero&quot;&gt;양극 NRZ(Non Return to Zero)&lt;/h4&gt;
&lt;p&gt;전압을 양극과 음극 모두 사용하므로 양극이라고 하며 입력 데이터가 ‘1’이면 양극, ‘0’이면 음극의 전압을 주는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;NRZ-L(Level)&lt;/strong&gt;&lt;br /&gt;
‘1’인 경우에는 양극, ‘0’인 경우에는 음극을 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NRZ-M(Mark=’1’)&lt;/strong&gt;&lt;br /&gt;
비트 간격의 시점에서는 항상 천이(변화)가 발생하며&lt;br /&gt;
‘&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;‘의 경우에는 비트 간격의 중간에서 &lt;strong&gt;천이가 발생&lt;/strong&gt;하고,&lt;br /&gt;
‘0’의 경우에는 비트 간격의 중간에서 천이가 없는 방식&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NRZ-S(Space=’0’)&lt;/strong&gt;&lt;br /&gt;
비트 간격의 시점에서는 항상 천이(변화)가 발생하며&lt;br /&gt;
‘&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;‘의 경우에는 비트 간격의 중간에서 &lt;strong&gt;천이가 발생&lt;/strong&gt;하고,&lt;br /&gt;
‘1’의 경우에는 비트 간격의 중간에서 천이가 없는 방식&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NRZ-I(Inversion)&lt;/strong&gt;&lt;br /&gt;
‘0’에서 ‘1’로, ‘1’에서’ 1’로 비트가 &lt;strong&gt;변할 때만 Interval 중간&lt;/strong&gt;에서 변화가 있고,&lt;br /&gt;
‘1’에서 ‘0’으로 변하거나 ‘0’이 지속될 때는 ‘0’의 상태 &lt;strong&gt;변화 없이&lt;/strong&gt; 같은 신호 레벨로 지속&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;bipolar&quot;&gt;Bipolar&lt;/h4&gt;
&lt;p&gt;AMI(교호 반전 부호), 3원 부호, ISDN 신호 방식이며 양극, 음극, Zero를 모두 사용한다.&lt;/p&gt;

&lt;p&gt;‘0’은 Zero로 ‘1’은 양극과 음극을 &lt;strong&gt;교대로 변환&lt;/strong&gt;시키는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;직류 성분이 포함되지 않는 장점이 있지만 &lt;strong&gt;동기화의 어려움&lt;/strong&gt; 존재&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;manchester&quot;&gt;Manchester&lt;/h4&gt;
&lt;p&gt;하나의 펄스폭을 2개로 나누어 ‘1’과 ‘0’을 &lt;strong&gt;반대로 구성&lt;/strong&gt;하여 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;IEEE 802.3의 CSMA/CD LAN에서의 전송 부호로 사용&lt;/li&gt;
  &lt;li&gt;매 비트 구간에서는 반드시 &lt;strong&gt;한 번 이상의 신호 준위 천이가 발생&lt;/strong&gt;하므로 이를 이용하여 &lt;strong&gt;클록 신호를 추출&lt;/strong&gt;할 수 있어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동기화&lt;/code&gt; 능력을 가지게 된다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;codec&quot;&gt;CODEC&lt;/h2&gt;
&lt;p&gt;아날로그 데이터를 전송하기 위해서 디지털 신호로 변환시키고, 다시 디지털 신호를 아날로그로 복귀시키는 장비&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;펄스 코드 변조(PCM)&lt;/li&gt;
  &lt;li&gt;델타 변조(DM)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pcmpulse-code-modulation&quot;&gt;PCM(Pulse Code Modulation)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;점유 주파수 대역이 넓은 단점이 존재&lt;/li&gt;
  &lt;li&gt;잡음과 누화에 강하다&lt;/li&gt;
  &lt;li&gt;저질의 전송으로도 사용이 가능&lt;/li&gt;
  &lt;li&gt;광통신의 실현으로 대용량 전송 가능&lt;/li&gt;
  &lt;li&gt;IC의 저가격화에 의해 경제적&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;표본화sampling&quot;&gt;표본화(Sampling)&lt;/h3&gt;
&lt;p&gt;연속적으로 변하는 아날로그 신호를 주기적인 간격으로 표본 값을 구하는 과정(&lt;strong&gt;PAM신호를 얻는 과정&lt;/strong&gt;)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;표본화 정리(Nyquist-Shannon Sampling Theorem)&lt;br /&gt;
어떤 신호 f(t)가 의미를 지니는 최고의 주파수보다 &lt;strong&gt;2배 이상의 속도의 균일한 시간 간격으로 채집&lt;/strong&gt;된다면 이 채집된 데이터는 원래의 신호가 가진 모든 정보를 포함한다는 이론&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;양자화quantization&quot;&gt;양자화(Quantization)&lt;/h3&gt;
&lt;p&gt;표본화한 표본 값을 정수화하는 단계로 실수형의 표본 값을 &lt;strong&gt;정수가 되도록&lt;/strong&gt; 반올림을 수행한다. 이 때 발생하는 오차를 &lt;strong&gt;양자화 잡음&lt;/strong&gt;이라고 하는데, &lt;strong&gt;PCM극 장치&lt;/strong&gt;에서 발생한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;양자화 스텝&lt;/strong&gt; : 표본화 된 하나의 PAM(Pulse Amplitude Modulation) 신호를 부호화 할 때, 다음과 같은 공식이 성립한다
    &lt;blockquote&gt;
      &lt;p&gt;$M = 2^n$&lt;br /&gt;
&lt;sub&gt;M : 양자화 스탭 / n : 표본당 전송 비트 수&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Companding : 압축과 신장의 합성어로 전송될 일부분의 신호가 일정한 범위 내에 있지 않고 급격한 차이가 있을 경우 급격한 일부분의 신호에 의하여 많은 스탭 수가 필요하게 된다. 이 때 사용하는 방법으로 급격한 신호를 압축하여 압축 정보와 함께 전송하면 수신측에서는 압축된 정보를 참조하여 원래로 신호로 신장하는 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;부호화encoding&quot;&gt;부호화(Encoding)&lt;/h3&gt;
&lt;p&gt;양자화된 표본 펄스의 진폭 값을 디지털 신호 ‘1’과 ‘0’의 조합으로 변환하는 단계&lt;/p&gt;

&lt;p&gt;인접 부호 간 1bit만 변화시키는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gray Code&lt;/code&gt;를 가장 많이 사용&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;원천 부호화&lt;/strong&gt;(Source Coding)&lt;br /&gt;
정보 신호를 전송하기에 적합하도록 효율적으로 부호화하는 방식으로 정보 신호를 디지털 신호로 바꾸고 데이터를 압축하여 제한된 대역폭에서 고속으로 전송되도록 한다
    &lt;ul&gt;
      &lt;li&gt;DM(Delta Modulation), PCM(Pulse Code Modulation), 허프만 코딩(Huffiman Coding), LPC(Linear Predictive Coding), PNM(펄스 수 변조)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;채널 부호화&lt;/strong&gt;(Channel Coding)&lt;br /&gt;
원천 부호화된 원래의 정보에 에러 검출 및 정정을 위한 비트들을 추가하여 전송하는 방법으로 수신측에서 에러를 검사하여 데이터의 재전송을 요청하거나 자체적으로 에러를 검출하여 정정하도록 하는 목적
    &lt;ul&gt;
      &lt;li&gt;ARQ(Automatic Repeat Request), FEC(Forward Error Correction)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;복호화decoding&quot;&gt;복호화(Decoding)&lt;/h3&gt;
&lt;p&gt;수신된 디지털 신호를 &lt;strong&gt;원래의 신호로 복원&lt;/strong&gt;하는 단계. 부호를 PAM 신호로 변환&lt;/p&gt;

&lt;h3 id=&quot;여파화filtering&quot;&gt;여파화(Filtering)&lt;/h3&gt;
&lt;p&gt;인접한 PAM 신호의 정점을 연결하여 &lt;strong&gt;계단 모양의 파형으로 만들고&lt;/strong&gt; 저역 필터기를 통과시킨다. 약간의 일그러짐이 있지만 표본화되기 전 원래의 신호와 비슷하게 복원된다.&lt;/p&gt;

&lt;h2 id=&quot;pcmtdmtime-division-multiplexing&quot;&gt;PCM/TDM(Time Division Multiplexing)&lt;/h2&gt;
&lt;p&gt;PCM화된 다수의 음성 채널을 하나의 전송로를 이용하여 전송하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;T1(DS-1) 방식 : 북미 표준&lt;/li&gt;
  &lt;li&gt;E1(DE-1) 방식 : 유럽 표준&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;아이-패턴&quot;&gt;아이 패턴&lt;/h2&gt;
&lt;p&gt;디지털 신호는 시간이 흐름에 따라 단계적인 레벨을 이동하면서 파형을 그리게 되는데 이러한 단계적인 레벨 이동의 흐름을 &lt;strong&gt;특정 시간단위 내에서 중첩하여 보여준 파형&lt;/strong&gt;이 바로 눈 패턴(Eye Pattern)이다.&lt;/p&gt;

&lt;p&gt;채널을 통과하면 아이 패턴의 모양이 변하게 되는데, 변화는 위치와 특성에 따라 여러 가지 통신 특성의 변화를 가늠해볼 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Optimum Sampling Time&lt;/strong&gt;&lt;br /&gt;
아이 패턴이 열린 최대 높이가 최적의 샘플링 순간&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Sensitivity to Timing Error&lt;/strong&gt;&lt;br /&gt;
아이 패턴의 기울기를 통해 시간 오차에 대한 민감도를 평가&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Noise Margin&lt;/strong&gt;&lt;br /&gt;
아이 패턴이 눈이 열린 높이 만큼을 잡음에 대한 여분으로 잡을 수 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Maximum Distortion&lt;/strong&gt;&lt;br /&gt;
아이 패턴의 맨 위와 맨 아래의 파형들의 진동폭은 신호가 샘플링되는 순간 왜곡되는 최대값을 나타낸다&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;../../assets/images/network/data-communication/eye-pattern.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;출처 : http://www.rfdh.com/bas_com/1-8.htm&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="데이터통신" /><summary type="html">신호 변환기의 종류 MODEM 디지털 데이터를 아날로그 신호로 변환시키는 장비로 PSTN(공중 전화망)에 접속되는 장비 DSU 디지털 데이터를 전송망에 적합한 디지털 신호로 변환시키는 장비로 PSDN(공중 데이터망)에 접속되는 장비 CODEC 아날로그 데이터를 디지털 신호로 변환시키는 장비로 PCM이 대표적인 예 Telephone 아날로그 데이터를 아날로그 신호로 변환시키는 장비로 빠르고 멀리 전송하기 위해 음성 대역 의 낮은 주파수를 높은 주파수로 변환</summary></entry><entry><title type="html">[소프트웨어공학] 미들웨어(Middleware)</title><link href="https://many258.github.io/study/software-engineering-middleware/" rel="alternate" type="text/html" title="[소프트웨어공학] 미들웨어(Middleware)" /><published>2021-03-26T00:00:00+09:00</published><updated>2021-03-26T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-middleware%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-middleware/">&lt;h1 id=&quot;미들웨어middleware&quot;&gt;미들웨어(Middleware)&lt;/h1&gt;
&lt;p&gt;운영체제와 사용자 응용 프로그램 사이에 또는 다른 종류의 사용자 응용프로그램 사이에서 조정 및 &lt;strong&gt;중개 역할&lt;/strong&gt;을 하는 프로그램&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;두 개 이상의 응용 프로그램 간 데이터를 공유시킨다&lt;/li&gt;
  &lt;li&gt;표준화된 인터페이스 제공 가능&lt;/li&gt;
  &lt;li&gt;서버와 클라이언트 사이에서 작업량의 감소, 부하 분산, 트랜잭션 처리, 보안 등 역할을 담당&lt;/li&gt;
  &lt;li&gt;분산된 업무를 동시에 처리 가능하여 자료의 일관성 유지&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;종류&quot;&gt;종류&lt;/h2&gt;
&lt;h3 id=&quot;rpcremote-procedure-call--원격-프로시져-호출&quot;&gt;RPC(Remote Procedure Call) : 원격 프로시져 호출&lt;/h3&gt;
&lt;p&gt;원격 프로시져를 마치 로컬 프로시져처럼 호출하는 방식의 미들웨어&lt;/p&gt;

&lt;p&gt;한 프로그램이 네트워크 상의 다른 컴퓨터에 위치하고 있는 프로그램에 서비스를 요청하는데 사용되는 프로토콜로서, 이때 서비스를 요청하는 프로그램은 네트워크에 대한 상세 내용을 알 필요가 없다&lt;/p&gt;

&lt;p&gt;제품 종류 : Entera(이큐브시스템), ONC/RPC(OSF)&lt;/p&gt;

&lt;h3 id=&quot;mommessage-oriented-middleware--메시지-지향-미들웨어&quot;&gt;MOM(Message Oriented Middleware) : 메시지 지향 미들웨어&lt;/h3&gt;
&lt;p&gt;주로 &lt;strong&gt;비동기형 메시지 처리를 전달&lt;/strong&gt;하는 미들웨어.&lt;br /&gt;
이 기종 분산 데이터 시스템의 데이터 동기를 위해 주로 사용&lt;br /&gt;
제품 종류 : MQ(IBM), Message Q(Oracle), JMS(JCP)&lt;/p&gt;

&lt;h3 id=&quot;tp-모니터&quot;&gt;TP-모니터&lt;/h3&gt;
&lt;p&gt;온라인 트랜잭션 업무에서 트랜잭션을 처리, 감시하는 미들웨어.&lt;br /&gt;
사용자 수가 증가하여도 빠른 응답속도를 유지해야 하는 OLTP성의 업무에 적합
제품 종류 : Tuxedo(Oracle), Tmax(Tmax Soft)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;OLTP&lt;/strong&gt;(Online Transaction Processing)&lt;br /&gt;
네트워크 상의 여러 이용자가 실시간으로 데이터베이스의 데이터를 갱신하거나 조회하는 등의 단위 작업을 처리하는 방식&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OLAP&lt;/strong&gt;(Online Analytical Processing)&lt;br /&gt;
사용자가 다양한 각도에서 직접 대화식으로 정보를 분석하는 과정.&lt;br /&gt;
데이터웨어하우스 등의 시스템과 연관되어 자료를 분석하고 의미있는 정보로 치환하거나, 복잡한 모델링을 가능하게끔 하는 분석 방법&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;corbacommon-object-request-broker-architecture&quot;&gt;CORBA(Common Object Request Broker Architecture)&lt;/h3&gt;
&lt;p&gt;네트워크에서 분산 프로그램 객체를 생성, 배포, 관리하기 위한 규격으로 네트워크 상의 서로 다른 장소에 있는 프로그램들이 “인터페이스 브로커”를 통해 통신이 가능하도록 해준다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OMG&lt;/strong&gt;(Object Management Group)&lt;br /&gt;
여러 대의 컴퓨터를 연결하여 사용하는 환경하에서 응용 프로그램 간에 기술적인 문제를 지원하고 표준을 위해 설립된 비영리 단체.&lt;br /&gt;
분산 네트워크 시스템에서 하드웨어나 운영체제에 영향을 받지 않고 응용 프로그램을 통합할 수 있는 공통된 작업 환경을 제공한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;OMA&lt;/strong&gt;(Object Management Architecture)&lt;br /&gt;
OMG의 활동 방향과 목적에 부합되는 모델로서 ORB, 객체 서비스, 공통 기능, 응용 인터페이스, 도메인 인터페이스 등으로 구성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ORB&lt;/strong&gt;(Object Request Broker)&lt;br /&gt;
객체지향 시스템에서 객체 및 서비스를 요청하고 전송할 수 있도록 지원하는 미들웨어로 CORBA 표준 스펙을 구현한 미들웨어&lt;br /&gt;
제품 종류 : Orbix(Micro Focus), CORBA(OMG)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;comcomponent-object-model&quot;&gt;COM(Component Object Model)&lt;/h3&gt;
&lt;p&gt;MS사가 개발한 객체 응용 프로그램 간의 통신 방식으로 응용 프로그램의 컴포넌트 객체들을 개발하고 지원하기 위한 미들웨어.&lt;/p&gt;

&lt;p&gt;모든 기능을 여러 개의 &lt;strong&gt;단위 프로그램으로 분할&lt;/strong&gt;함으로써
코드의 재사용성을 극대화하고 효율적인 유지보수를 보장한다. 단위 소프트웨어, 컴포넌트들을 재사용하기 위해서는 &lt;strong&gt;표준화된 방법&lt;/strong&gt;이 필요했는데 단위 소프트웨어,컴포넌트들이 서로 통신할 수 있게 마이크로소프트가 표준화를 규정하였다.&lt;/p&gt;

&lt;p&gt;객체를 재사용하는 개념이 없기 때문에 객체지향의 이점은 누릴 수 없지만 다양한 응용 프로그램을 관리하는 면에서는 CORBA보다 우월&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IPC&lt;/strong&gt;(Inter Process Communication)&lt;br /&gt;
두 프로세스가 상호 통신하며 정보를 교환하는 방법&lt;/p&gt;

    &lt;p&gt;멀티태스킹 환경에서는 여러가지 프로그램들이 동시에 실행된다. 각 프로세스들은 메모리와 CPU를 공유하고 있을 뿐, 독립된 일을 하며 상호 간섭하지 않고 간섭할 수도 없다. 하지만 필요에 따라 프로세스간의 정보를 교환해야 하는 경우가 생기는데 이 때 사용한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dcomdistributed-component-object-model&quot;&gt;DCOM(Distributed Component Object Model)&lt;/h3&gt;
&lt;p&gt;인터넷이나 LAN환경에서 서로 다른 컴퓨터끼리의 통신을 지원하는 분산확장형 COM&lt;/p&gt;

&lt;p&gt;사용자 응용 프로그램 객체는 파일 이름 대신에 URL을 사용하여 서버 객체를 사용할 수 있으므로 인터넷에서 분산 처리를 실현할 수 있다&lt;/p&gt;

&lt;h3 id=&quot;comcomponent-object-model-1&quot;&gt;COM+(Component Object Model+)&lt;/h3&gt;
&lt;p&gt;분산형 트랜잭션을 동시 처리할 목적으로 출현&lt;/p&gt;

&lt;p&gt;COM/DCOM과 약간 다른 개념으로 MTS라고 불리는 일종에 서비스.&lt;br /&gt;
쉽게 말하자면 COM을 네트워크에서 사용가능하도록 해주는 서비스&lt;/p&gt;

&lt;h3 id=&quot;wasweb-application-server--웹-애플리케이션-서버&quot;&gt;WAS(Web Application Server) : 웹 애플리케이션 서버&lt;/h3&gt;
&lt;p&gt;정적인 콘텐츠를 처리하는 웹 서버와 달리 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어&lt;br /&gt;
종류 : 아파치 톰캣(Apache Tomcat), JBoss, Jetty, WebLogic, JRun, Jeus, WebSphere&lt;/p&gt;

&lt;h3 id=&quot;esbenterprise-service-bus--엔터프라이즈-서비스-버스&quot;&gt;ESB(Enterprise Service Bus) : 엔터프라이즈 서비스 버스&lt;/h3&gt;
&lt;p&gt;메시지 기반으로 느슨한 결합형태의 표준 인터페이스 통신을 통해 전사 시스템 환경을 연동하는 미들웨어&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SOA에서 사용되는 개념&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;EAI와 유사하게 사용된다. 기관 간, 서비스 간 연계가 이루어진다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SOA&lt;/strong&gt;(서비스 지향 아키텍쳐 : Service Oritented Architecture)&lt;br /&gt;
대규모 컴퓨터 시스템을 구축할 때의 개념으로 업무상에 일 처리에 해당하는 소프트웨어 기능을 서비스로 판단하여 그 서비스를 네트워크 상에 연동하여 시스템 전체를 구축해 나가는 방법론&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;EAI&lt;/strong&gt;(기업 응용 프로그램 통합 : Enterprise Application Integration)&lt;br /&gt;
DW, ERP, CRM, SCM, B2B 등 기업에서 운영하는 서로 다른 어플리케이션 및 시스템을 통합시키는 것을 의미.&lt;br /&gt;
업무의 효율성, 확장성 향상, 유지보수 및 비용 절감, 편의성 증대시키는 솔루션&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">미들웨어(Middleware) 운영체제와 사용자 응용 프로그램 사이에 또는 다른 종류의 사용자 응용프로그램 사이에서 조정 및 중개 역할을 하는 프로그램</summary></entry><entry><title type="html">[소프트웨어공학] 소프트웨어 검사</title><link href="https://many258.github.io/study/software-engineering-testing/" rel="alternate" type="text/html" title="[소프트웨어공학] 소프트웨어 검사" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-09T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-testing%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-testing/">&lt;h1 id=&quot;검사-관련-용어정의&quot;&gt;검사 관련 용어정의&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;검사&lt;/strong&gt;(Testing)&lt;br /&gt;
오류를 찾는 작업&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;검증&lt;/strong&gt;(Verification)&lt;br /&gt;
개발된 소프트웨어와 사용자의 요구분석 명세서와의 차이를 확인하는 작업&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디버깅&lt;/strong&gt;(Debugging)&lt;br /&gt;
검사로 찾아낸 오류를 수정하는 작업&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;검토 회의&lt;/strong&gt;(Walk-through)&lt;br /&gt;
소프트웨어 생명주기의 단계마다 산출된 명세서를 가지고 다음 단계로 넘어가기 전에 오류를 찾아내는 작업&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;정형 기술 검토&lt;/strong&gt;(FTR)&lt;br /&gt;
소프트웨어에 관련된 여러 사람이 모여 회의하는 정형화된 오류 검토 회의&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;검사방법&quot;&gt;검사방법&lt;/h1&gt;
&lt;h2 id=&quot;화이트-박스-검사&quot;&gt;화이트 박스 검사&lt;/h2&gt;
&lt;p&gt;상자 안을 들여다 볼 수 있다는 뜻으로 &lt;strong&gt;원시 프로그램을 직접 보면서&lt;/strong&gt; 프로그램 상 허용되는 논리적인 모든 경로를 직접 검사하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 모듈의 논리적 구조를 체계적으로 점검하는 구조 검사&lt;/li&gt;
  &lt;li&gt;원시 코드의 모든 문장을 &lt;strong&gt;한 번 이상 수행함&lt;/strong&gt;으로써 진행되는 구조 검사&lt;/li&gt;
  &lt;li&gt;검사 대상의 가능한 경로를 어느 정도 통과하는 지의 적용 범위성을 측정 기준으로 한다&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프로그램의 제어 구조에 따라 &lt;strong&gt;선택, 반복 등의 부분들을 수행&lt;/strong&gt;함으로써 논리적인 경로를 검사&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;기초 경로 검사&lt;/strong&gt;(Basic Path Testing)&lt;br /&gt;
모든 논리적인 경로를 복잡도로 계산하여 구한 후 경로를 수행할 수 있는 검사 경우를 직접 입력하여 오류를 검출하는 방법
        &lt;blockquote&gt;
          &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;오일러의 공식&lt;/code&gt; : V - E + R = 2&lt;br /&gt;
&lt;sub&gt;V: 노드의 수, E: 간선의 수, R:영역의 수&lt;/sub&gt;&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;루프 검사&lt;/strong&gt;(Loop Testing)&lt;br /&gt;
반복문 관련 오류 검출&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;데이터 흐름 검사&lt;/strong&gt;(Data Flow Testing)&lt;br /&gt;
제어 흐름 그래프에 데이터 사용 현황(정의, 소멸, 사용)을 테스트&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;조건 검사&lt;/strong&gt;(Condition Testing)&lt;br /&gt;
조건문 관련 오류 검출&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;찾을 수 있는 오류
    &lt;ul&gt;
      &lt;li&gt;자세하고 세부적 오류 검출 가능&lt;/li&gt;
      &lt;li&gt;반복문, 참거짓을 판단할 수 있는 논리 구조 상의 오류 검출 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;블랙-박스-검사&quot;&gt;블랙 박스 검사&lt;/h2&gt;
&lt;p&gt;상자 안을 볼 수 없다는 뜻으로 원시 프로그램은 보지 않고 프로그램만 실행시켜 데이터 입력에 대한 결과만을 보고 오류를 판단하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;균등 분할&lt;/strong&gt;(Equivalence Partitioning)&lt;br /&gt;
입력 자료에 초점을 맞춰 검사 사례를 만드는 방법.&lt;br /&gt;
타당한 자료와 타당하지 않은 자료의 개수를 균등하게 하여 정함&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;한계값 분석&lt;/strong&gt;(Boundary Value Analysis)&lt;br /&gt;
입력조건의 중간값에서 보다 &lt;strong&gt;경계값에서 에러가 발생될 확률이 높다&lt;/strong&gt;는 점을 이용하여 이를 실행하는 테스크 케이스를 만드는 방법&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;원인-결과 그래프&lt;/strong&gt;(Cause-Effect Graphing)&lt;br /&gt;
입력 데이터 간의 관계가 출력에 미치는 영향을 그래프로 표현하여 오류 검출&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;오류 예측&lt;/strong&gt;(Error Guessing)&lt;br /&gt;
각 시험기법들이 놓치기 쉬운 오류들을 감각 및 경험으로 찾아보는 것&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;비교 검사&lt;/strong&gt;(Comparison Testing)&lt;br /&gt;
여러 버전의 프로그램에 동일한 검사 자료를 제공하여 동일한 결과가 출력되는 지 비교 및 확인하는 검사&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;페어 와이즈 조합 테스트&lt;/strong&gt;&lt;br /&gt;
모든 가능한 입력 값들의 조합들을 테스트하는 대신에 모든 Pair의 조합을 테스트하는 방법&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;상태 전이 검사&lt;/strong&gt;&lt;br /&gt;
시스템의 상태가 변화함에 따른 검사&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비정상적인 자료를 입력해도 오류 처리를 수행하지 않은 경우의 오류 검출 가능&lt;/li&gt;
  &lt;li&gt;정상적인 자료를 입력해도 요구된 기능이 제대로 수행되지 않는 경우의 오류를 검출 가능&lt;/li&gt;
  &lt;li&gt;성능 오류, 자료 구조 상의 오류, 인터페이스, 시작과 종결 상의 오류를 찾을 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;검사-순서&quot;&gt;검사 순서&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;단위(코드) 검사&lt;/li&gt;
  &lt;li&gt;통합(설계) 검사&lt;/li&gt;
  &lt;li&gt;검증(요구사항) 검사&lt;/li&gt;
  &lt;li&gt;시스템 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;단위-검사&quot;&gt;단위 검사&lt;/h2&gt;
&lt;p&gt;원시 프로그램의 모듈을 대상으로 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;화이트 검사&lt;/code&gt;를 실시&lt;/strong&gt;하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인터페이스 검사&lt;/li&gt;
  &lt;li&gt;자료 구조 검사&lt;/li&gt;
  &lt;li&gt;경로 검사&lt;/li&gt;
  &lt;li&gt;오류 처리 검사&lt;/li&gt;
  &lt;li&gt;한계값 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;통합-검사&quot;&gt;통합 검사&lt;/h2&gt;
&lt;p&gt;단위 검사를 성공적으로 실시한 후에 단위별로 &lt;strong&gt;결합하면서 오류를 검출&lt;/strong&gt;하는 방법&lt;/p&gt;

&lt;h3 id=&quot;하향식top-down-통합-검사&quot;&gt;하향식(Top-Down) 통합 검사&lt;/h3&gt;
&lt;p&gt;상위 모듈에서 하위 모듈로 결합하면서 오류를 찾는 방법으로 가짜 모듈(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stub&lt;/code&gt;)이 필요하다&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;전체 프로그램을 매번 실행하고 종속적인 모듈은 &lt;strong&gt;가짜 모듈(Stub)로 대치&lt;/strong&gt;한다&lt;/li&gt;
  &lt;li&gt;통합 방법에 따라 가짜 모듈을 &lt;strong&gt;실제 모듈로 대치&lt;/strong&gt;한다&lt;/li&gt;
  &lt;li&gt;각 모듈이 &lt;strong&gt;통합되면 검사&lt;/strong&gt;를 실시&lt;/li&gt;
  &lt;li&gt;통합될 때마다 &lt;strong&gt;회귀 검사&lt;/strong&gt;를 실시&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 전체를 실행하면서 검사 가능&lt;/li&gt;
  &lt;li&gt;중요 모듈을 우선 검사할 때에는 부적합&lt;/li&gt;
  &lt;li&gt;독립적인 구조로 검사할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;상향식bottom-up-통합-검사&quot;&gt;상향식(Bottom-Up) 통합 검사&lt;/h3&gt;
&lt;p&gt;최하위의 모듈부터 상위로 진행하면서 통합하는 방식으로 가짜 모듈은 필요없지만 통합 시에 통합된 클러스터(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cluster&lt;/code&gt;)를 실행할 수 있는 시험 가동기(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Driver&lt;/code&gt;)가 필요하다&lt;/p&gt;

&lt;p&gt;&lt;sub&gt;
클러스터 : 여러 개의 모듈을 하나로 묶어 놓은 단위&lt;br /&gt;
드라이버 : 임시로 실행시켜 검사해 보기 위한 임시 프로그램 모듈
&lt;/sub&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;낮은 수준의 모듈들을 클러스터로 &lt;strong&gt;결합&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;검사 사례 입/출력을 조정하기 위해 &lt;strong&gt;드라이버&lt;/strong&gt; 작성&lt;/li&gt;
  &lt;li&gt;클러스터 &lt;strong&gt;검사&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;드라이버 제거하고 클러스터를 &lt;strong&gt;상위&lt;/strong&gt;로 결합&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;중요 모듈을 우선 검사할 때 유리&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;혼합식mixed-통합-검사&quot;&gt;혼합식(Mixed) 통합 검사&lt;/h3&gt;
&lt;p&gt;하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 검사하는 방법. &lt;strong&gt;샌드위치식 통합 방식&lt;/strong&gt;이라고도 한다.&lt;/p&gt;

&lt;h2 id=&quot;검증-검사&quot;&gt;검증 검사&lt;/h2&gt;
&lt;p&gt;소프트웨어가 사용자의 &lt;strong&gt;요구사항을 충족시키는가&lt;/strong&gt;에 중점을 두고 검사하는 방법. 요구사항 명세서를 토대로 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블랙 박스 테스트&lt;/code&gt;를 사용&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;형상 검사&lt;/strong&gt; : 소프트웨어 구성요소, 목록, 유지보수를 지원하기 위해 필요한 사항 표현 검사&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;알파 검사&lt;/strong&gt; : 개발자의 장소에서 사용자가 개발자 앞에서 실행하는 검사&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;베타 검사&lt;/strong&gt; : 다수의 사용자를 제한되지 않은 환경에서 프로그램을 사용하게 하고 오류가 발견되면 개발자에게 통보하는 방식&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시스템-검사&quot;&gt;시스템 검사&lt;/h2&gt;
&lt;p&gt;개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 검사&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;확인 검사 : 이해관계가 있는 모든 사람이 참석하여 오류 검출하는 방법&lt;/li&gt;
  &lt;li&gt;보안 검사&lt;/li&gt;
  &lt;li&gt;무결성 검사&lt;/li&gt;
  &lt;li&gt;스트레스 검사&lt;/li&gt;
  &lt;li&gt;부피 검사&lt;/li&gt;
  &lt;li&gt;메모리 검사&lt;/li&gt;
  &lt;li&gt;성능 검사&lt;/li&gt;
  &lt;li&gt;호환성 검사&lt;/li&gt;
  &lt;li&gt;신뢰성 검사&lt;/li&gt;
  &lt;li&gt;회복 검사&lt;/li&gt;
  &lt;li&gt;사용 용이성 검사&lt;/li&gt;
  &lt;li&gt;유지보수 용이성 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;정형-기술-검토ftr--formal-technical-review&quot;&gt;정형 기술 검토(FTR : Formal Technical Review)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;목적
    &lt;ul&gt;
      &lt;li&gt;소프트웨어가 요구사항에 일치되는 정도를 확인&lt;/li&gt;
      &lt;li&gt;소프트웨어가 &lt;strong&gt;표준화되었는지 검토&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;정형화된 소프트웨어가 개발되도록 지원&lt;/li&gt;
      &lt;li&gt;프로젝트 관리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;검토 지침
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;제품 검토의 집중성&lt;/strong&gt; : 수정이 아닌 제품의 검토에 집중&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;사전 준비성&lt;/strong&gt; : 검토를 위한 자료를 사전에 배포하여 검토&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;의제의 제한성&lt;/strong&gt; : 의견을 제한하되 충분히 받아들인다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;안건 고수성&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;논쟁 반박의 제한성&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;문제 공개성&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;참가 인원의 제한성&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;문서성&lt;/strong&gt; : 발견된 오류는 문서화한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;오류-증폭-모형&quot;&gt;오류 증폭 모형&lt;/h2&gt;
&lt;p&gt;소프트웨어 개발 생명주기 중 검사 단계에서 오류를 찾는 것보다 &lt;strong&gt;생명주기의 단계마다 확인하고 검사&lt;/strong&gt;하면 많은 양의 오류 검출 및 수정이 가능하다.&lt;/p&gt;

&lt;p&gt;이러한 방법을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;검토 회의&lt;/code&gt;(Walk-through)라고 하며 검토 회의를 할 경우에 예측할 수 있는 &lt;strong&gt;오류 감소 비율을 이론적으로 정립한 것&lt;/strong&gt;을 &lt;strong&gt;오류 증폭 모델&lt;/strong&gt;이라 한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(전달된 오류수 + 오류 증폭수 + 생성된 오류수) X (100% - 오류 제거 비율)&lt;br /&gt;
오류 증폭수 = (이전 단계에서 전달된 오류수 - 전달된 오류 수) X 오류 증폭 비율&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">검사 관련 용어정의 검사(Testing) 오류를 찾는 작업 검증(Verification) 개발된 소프트웨어와 사용자의 요구분석 명세서와의 차이를 확인하는 작업 디버깅(Debugging) 검사로 찾아낸 오류를 수정하는 작업 검토 회의(Walk-through) 소프트웨어 생명주기의 단계마다 산출된 명세서를 가지고 다음 단계로 넘어가기 전에 오류를 찾아내는 작업 정형 기술 검토(FTR) 소프트웨어에 관련된 여러 사람이 모여 회의하는 정형화된 오류 검토 회의</summary></entry><entry><title type="html">[소프트웨어공학] 소프트웨어 유지보수</title><link href="https://many258.github.io/study/software-engineering-maintenance/" rel="alternate" type="text/html" title="[소프트웨어공학] 소프트웨어 유지보수" /><published>2021-03-25T00:00:00+09:00</published><updated>2021-03-09T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-maintenance%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-maintenance/">&lt;h1 id=&quot;소프트웨어-유지보수&quot;&gt;소프트웨어 유지보수&lt;/h1&gt;
&lt;p&gt;소프트웨어가 사용자에게 인수, 설치된 이후에 발생하는 모든 공학적인 작업 활동을 의미&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;소프트웨어 비용 중 &lt;strong&gt;유지보수 비용이 가장 큰 비중&lt;/strong&gt;을 차지&lt;/li&gt;
  &lt;li&gt;명세서의 유지보수란 명세서를 항상 최신의 상태로 만드는 것을 의미&lt;/li&gt;
  &lt;li&gt;소프트웨어는 계속 수정, 보완되기 때문에 명세서도 따라서 보완되지 않으면 일관성을 유지하기 어려움&lt;/li&gt;
  &lt;li&gt;소프트웨어 유지보수의 과정은 유지보수 요구, 현 시스템에 대한 이해, 수정 및 시험순으로 반복하여 일어남&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;문서화documentation&quot;&gt;문서화(Documentation)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;유지보수와 시스템 개발을 위한 분석 설계가 용이하고, 확장성이 좋다&lt;/li&gt;
  &lt;li&gt;여러 사람이 알아보기 쉽고, 유지보수 작업이 용이하려면 문서화 작업이 표준화되어야 한다&lt;/li&gt;
  &lt;li&gt;문서의 표준화가 되었다고 해서 신뢰성이 높아지거나 &lt;strong&gt;프로그램 처리 속도가 향상되거나 개발 인력이 감소하는 것은 아니다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;유지보수-작업의-종류&quot;&gt;유지보수 작업의 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;수리보수&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Corrective&lt;/code&gt; Maintenance, 수정보수)
    &lt;ul&gt;
      &lt;li&gt;밝혀지지 않은 모든 잠재적인 오류를 찾아 수정하는 활동&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;완전보수&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Perfective&lt;/code&gt; Maintenance, 기능개선/향상보수)
    &lt;ul&gt;
      &lt;li&gt;기능의 수정, 새 기능의 추가, 전반적인 기능 개선 등&lt;/li&gt;
      &lt;li&gt;유지보수 유형 중 제일 많은 비용이 소요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;적응보수&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Adaptive&lt;/code&gt; Maintenance, 환경적응)
    &lt;ul&gt;
      &lt;li&gt;환경 변화에 대응하여 소프트웨어를 변경하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;예방보수&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Preventive&lt;/code&gt; Maintenance, 예비조치)
    &lt;ul&gt;
      &lt;li&gt;프로그램의 변경을 미리 예측하여 준비하는 활동&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;유지보수-비용-측정-방법&quot;&gt;유지보수 비용 측정 방법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;BL(Belady와 Lehman) 방법&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;M=$P+K\cdot e^{(c-d)}$&lt;br /&gt;
&lt;sub&gt;M:유지보수를 위한 노력(인원/월)&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;P:생산적인 활동에 드는 비용(개발 비용)&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;K:통계값에 구한 상수(주관적평가)&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;c:복잡도&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;d:소프트웨어에 대한 지식 정도&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;COCOMO 방법&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;M = $ACT \times DE \times EAF$&lt;br /&gt;
&lt;sub&gt;ACT:유지보수 비율&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;DE:생산적인 활동에 드는 비용(개발 비용)&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;EAF:노력 조정 수치(주관적 평가)&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Vessey &amp;amp; Webber 방법&lt;/strong&gt;
    &lt;blockquote&gt;
      &lt;p&gt;M = $ACT \times 2.4 \times [KDSI]^{1.05}$&lt;br /&gt;
&lt;sub&gt;M:생산적인 활동에 드는 비용(개발 비용)&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;ACT:유지보수 비율&lt;/sub&gt;&lt;br /&gt;
&lt;sub&gt;KDSI:1000당 명령어 라인 수&lt;/sub&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;소프트웨어-품질-목표-항목&quot;&gt;소프트웨어 품질 목표 항목&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;정확성&lt;/li&gt;
  &lt;li&gt;신뢰성&lt;/li&gt;
  &lt;li&gt;효율성&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;무결성&lt;/strong&gt; : 허용하지 않은 사용이나 자료의 변경을 제어하는 정도&lt;/li&gt;
  &lt;li&gt;유지보수 용이성&lt;/li&gt;
  &lt;li&gt;사용 용이성&lt;/li&gt;
  &lt;li&gt;검사 용이성&lt;/li&gt;
  &lt;li&gt;이식성&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상호 운용성&lt;/strong&gt; : 다른 소프트웨어와 정보를 교환할 수 있는 정도&lt;/li&gt;
  &lt;li&gt;유연성 : 소프트웨어 품질 목표 중 새로운 요구사항에 접하여 쉽게 수정될 수 있는 시스템 능력을 요구하는 것의 정도&lt;/li&gt;
  &lt;li&gt;재사용성&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;소프트웨어-신뢰성&quot;&gt;소프트웨어 신뢰성&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;신뢰성&lt;/strong&gt;(Reliability) : 주어진 시간 동안 주어진 환경에서 프로그램이 &lt;strong&gt;고장 없이 운영될 확률&lt;/strong&gt;을 의미&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;가용성&lt;/strong&gt;(Availability) : 프로그램이 주어진 시점에서 요구사항을 수행하는 확률&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;평균 사용 시간&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTBF&lt;/code&gt; : Mean Time Between Failures)&lt;br /&gt;
고장 수리가 끝난 시간부터 다음 고장이 발생할 때까지의 시간 평균치
    &lt;blockquote&gt;
      &lt;p&gt;$\frac{(사용1 + 사용2 + … + 사용n)}{n}$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;평균 수리 시간&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTTR&lt;/code&gt; : Mean Time to Repair)&lt;br /&gt;
고장이 일어난 시점부터 고장 수리가 완료되는 시점까지의 평균치
    &lt;blockquote&gt;
      &lt;p&gt;$\frac{(고장1 + 고장2 + … + 고장n)}{n}$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;평균 고장 시간&lt;/strong&gt;(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MTTF&lt;/code&gt; : Mean Time To Failures)&lt;br /&gt;
고장이 발생한 시점부터 다음 고장이 발생할 때까지의 평균치
    &lt;blockquote&gt;
      &lt;p&gt;MTBF + MTTR&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;가용도&lt;/strong&gt; : 전체 시간 중에서 설계 가동하여 사용 중인 시간을 의미
    &lt;blockquote&gt;
      &lt;p&gt;$\frac{MTBF}{MTTF}$ = $\frac{MTBF}{MTBF+MTTR}$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;소프트웨어-재사용sw-reuse&quot;&gt;소프트웨어 재사용(S/W Reuse)&lt;/h1&gt;
&lt;p&gt;이미 개발된 소프트웨어를 반복 사용하여 생산성을 향상시키는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;생성 중심&lt;/strong&gt;(Generation Based, 모듈화)&lt;br /&gt;
재사용 단위를 찾아 발전시키는 기술&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;합성 중심&lt;/strong&gt;(Composition Based, 모듈화)&lt;br /&gt;
모듈을 생산성있게 조립하는 기술&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;모듈의 크기는 작을수록 재사용 비율이 높다&lt;/li&gt;
      &lt;li&gt;개발시간과 비용을 단축&lt;/li&gt;
      &lt;li&gt;개발 지식을 공유할 수 있다&lt;/li&gt;
      &lt;li&gt;소프트웨어 품질과 생산성을 향상&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;소프트웨어-재공학sw-re-engineering&quot;&gt;소프트웨어 재공학(S/W Re-Engineering)&lt;/h1&gt;
&lt;p&gt;과거에 사용하던 소프트웨어를 수명 연장을 위해 효과적으로 사용할 수 있도록 접근하는 기술&lt;/p&gt;

&lt;h2 id=&quot;출현-배경&quot;&gt;출현 배경&lt;/h2&gt;
&lt;p&gt;소프트웨어의 위기를 개발의 생산성이 아닌 &lt;strong&gt;유지보수의 생산성&lt;/strong&gt;으로 해결하기 위해 출현&lt;/p&gt;

&lt;p&gt;문서화 하는 과정에서 소프트웨어의 문제점들이 발견되고 이런 문제점을 수정 보완하여 다시금 소프트웨어를 수정하게 된 것이 재공학이 출현된 배경이다&lt;/p&gt;

&lt;p&gt;이미 개발된 소프트웨어를 보고 문서화했으므로 역으로 진행했다하여 역공학의 개념이 출현하였고, 재공학은 역공학 이후에 출현된 기술 개념&lt;/p&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;
&lt;p&gt;기존의 있던 소프트웨어를 &lt;strong&gt;파기하지 않고&lt;/strong&gt; 변경된 사용자의 요구사항이나 수정된 환경으로 &lt;strong&gt;기존 소프트웨어를 수정&lt;/strong&gt;, 보완하여 재구축하는 기술&lt;/p&gt;

&lt;p&gt;노후된 시스템에 대한 재분석/문서화 작업을 통해 공학적으로 우수한 시스템을 만드는 것을 의미&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;재구조화&lt;/strong&gt;(Restructuring) : 재공학의 한 유형으로 사용자의 요구사항이나 기술적인 변경 없이 프로그램을 개선&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;역공학&lt;/strong&gt;(Reverse Engineering) : 기존 소프트웨어를 분석하여 소프트웨어 개발 과정과 데이터 처리 과정을 설명하는 &lt;strong&gt;분석 및 설계 정보를 재발견&lt;/strong&gt;하거나 다시 만들어 내는 작업.&lt;br /&gt;
원시 프로그램으로부터 데이터, 아키텍처, 절차에 관한 분석 및 설계 정보를 추출하는 기술&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;코드&lt;/strong&gt;의 역공학 : 소스 코드로부터 &lt;strong&gt;자료 흐름도&lt;/strong&gt;를 추출하고 분석하여 변경&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터&lt;/strong&gt;의 역공학 : 소스 코드로부터 &lt;strong&gt;자료 사전&lt;/strong&gt;을 추출하고 분석하여 변경&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;특징&quot;&gt;특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;재공학은 유지보수 중 &lt;strong&gt;예비 조치&lt;/strong&gt;(Preventive)의 문제를 해결하기 위한 학문이다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자동화된 도구&lt;/strong&gt;를 사용하여 소프트웨어를 분석하고 수정하는 과정을 포함&lt;/li&gt;
  &lt;li&gt;재공학 활동은 분석, 재구성, 역공학, 이식 활동 등으로 구분&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;목표&quot;&gt;목표&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;유지보수성, 생산성, 품질&lt;/strong&gt;의 향상이 목적&lt;/li&gt;
  &lt;li&gt;소프트웨어 사용 기간을 연장시키고 비용을 감소시킨다&lt;/li&gt;
  &lt;li&gt;고수준의 추상을 합성할 수 있다&lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">소프트웨어 유지보수 소프트웨어가 사용자에게 인수, 설치된 이후에 발생하는 모든 공학적인 작업 활동을 의미</summary></entry><entry><title type="html">[소프트웨어공학] 비용 산정 방법론</title><link href="https://many258.github.io/study/software-engineering-cost-model/" rel="alternate" type="text/html" title="[소프트웨어공학] 비용 산정 방법론" /><published>2021-03-24T00:00:00+09:00</published><updated>2021-03-24T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-cost-model%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-cost-model/">&lt;h1 id=&quot;소프트웨어-개발비용-산정기법&quot;&gt;소프트웨어 개발비용 산정기법&lt;/h1&gt;

&lt;h2 id=&quot;상향식&quot;&gt;상향식&lt;/h2&gt;
&lt;p&gt;단계별로 측정한 결과들을 모아서 총비용을 측정하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LOC 기법 (원시 코드 라인 수 : Line Of Code)&lt;br /&gt;
프로젝트의 각 기능별 라인 수를 측정(&lt;strong&gt;비관치, 기대치, 낙관치&lt;/strong&gt;)하여 비용을 산정하는 방법
    &lt;ul&gt;
      &lt;li&gt;비관치 : 기능을 코딩할 때, 가장 많이 측정된 라인 수&lt;/li&gt;
      &lt;li&gt;기대치 : 기능을 코딩할 때, 제시한 측정된 라인 수의 평균&lt;/li&gt;
      &lt;li&gt;낙관치 : 기능을 코딩할 때, 가장 적게 측정된 라인 수&lt;/li&gt;
      &lt;li&gt;예측치 : $\frac{(비관치 + 4 \cdot 기대치 + 낙관치)}{6}$&lt;/li&gt;
      &lt;li&gt;평방 편차 : $({\frac{(비관치-낙관치)}6})^2$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개발 단계별 인월 수 방법&lt;br /&gt;
LOC 기법을 보완하기 위한 방법으로, 각 기능을 구현시키는데 필요한 노력을 생명주기의 각 단계별로 산정&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;수학적-산정-기법&quot;&gt;수학적 산정 기법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Walston Felix 모형&lt;/strong&gt;&lt;br /&gt;
60여 개 개발 업체의 다양한 규모의 프로젝트 비용 측정 자료를 모아 통계적으로 분석한 &lt;strong&gt;공식&lt;/strong&gt;으로 개발 비용을 측정하는 방법&lt;br /&gt;
인월 수를 계산하는데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KDSI&lt;/code&gt;(원시코드에서 주석라인, 라이브러리 루틴, 공백을 제외한 실제 수행 코드 라인 수)를 사용한다
    &lt;ul&gt;
      &lt;li&gt;COCOMO 비용 산정 공식의 모체이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;COCOMO&lt;/strong&gt;(COnstructive COst MOdel)&lt;br /&gt;
Boehm이 제시한 원시 프로그램의 규모에 의한 비용 예측 모형
변화 모형과 규모 유형이 존재한다
    &lt;ul&gt;
      &lt;li&gt;변화 모형
        &lt;ul&gt;
          &lt;li&gt;Basic : S/W 크기 + 개발 유형&lt;/li&gt;
          &lt;li&gt;Intermediate : Basic Model + 가중치&lt;/li&gt;
          &lt;li&gt;Detailed : Intermediate Model + 시스템 세분화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;규모 모형
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;Organic&lt;/strong&gt;(유기형)
            &lt;blockquote&gt;
              &lt;p&gt;인월(MM) = $2.4 \times [KDSI]^{1.05}$&lt;br /&gt;
개발기간(TDEV) = $2.5 \times [KDSI]^{0.38}$&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Semi-detached&lt;/strong&gt;(준 분리형)
            &lt;blockquote&gt;
              &lt;p&gt;인월(MM) = $3.0 \times [KDSI]^{1.12}$&lt;br /&gt;
개발기간(TDEV) = $2.5 \times [KDSI]^{0.35}$&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Embedded&lt;/strong&gt;(내재형)
            &lt;blockquote&gt;
              &lt;p&gt;인월(MM) = $3.6 \times [KDSI]^{1.20}$&lt;br /&gt;
개발기간(TDEV) = $2.5 \times [KDSI]^{0.32}$&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PUTNAM&lt;/strong&gt;&lt;br /&gt;
시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 한다&lt;br /&gt;
개발 기간이 연장될수록 프로젝트 적용 인원의 노력이 감소하므로 &lt;strong&gt;대형 프로젝트&lt;/strong&gt;의 노력 분포 산정으로 적당&lt;br /&gt;
Putnam 모형을 기초로 해서 만든 자동화 추정 도구는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SLIM&lt;/code&gt;이다&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;MM = $\frac{DSI^3}{[개발 기술 지수]^3 \times [개발 기간]^4\frac{3}{4}}$&lt;br /&gt;
LOC =  $[개발 기술 지수] \times[총인월]^{\frac{1}{3}} \times [개발 기간]^{\frac{3}{4}}$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Albrecht&lt;/strong&gt; 모형(&lt;strong&gt;기능점수, FP&lt;/strong&gt;)&lt;br /&gt;
프로젝트를 기능 별로 &lt;strong&gt;분해&lt;/strong&gt;하고 경험을 바탕으로 단순/보통/복잡한 정도에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가중치&lt;/code&gt;를 부여&lt;br /&gt;
요인별 가중치를 합산하여 총 기능점수 산출&lt;br /&gt;
총 기능점수와 영향도를 이용하여 실질 기능 점수를 구한 후 최종 비용 산정&lt;br /&gt;
FP 모형을 기초로 하여 개발된 자동화 도구는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESTIMACS&lt;/code&gt;
    &lt;blockquote&gt;
      &lt;p&gt;실질 기능 점수(FP) = $총기능점수 \times [0.65+ (0.1 \times 총영향도)]$&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;하향식&quot;&gt;하향식&lt;/h2&gt;
&lt;p&gt;프로젝트의 총비용을 측정한 후 단계별로 비용을 세분화하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전문가 감정 기법
    &lt;ul&gt;
      &lt;li&gt;조직 내 경험이 많은 두명 이상의 전문가에게 비용산정 의뢰&lt;/li&gt;
      &lt;li&gt;의뢰자로부터 신뢰를 얻을 수 있다&lt;/li&gt;
      &lt;li&gt;새로운 프로젝트와 유사한 프로젝트에 대한 경험이 없을 수 있고 개인직이고 주관적일 가능성이 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;델파이 기법
    &lt;ul&gt;
      &lt;li&gt;많은 전문가의 의견을 종합 후 산정하는 방법으로 전문가 감정 기법의 단점을 보완&lt;/li&gt;
      &lt;li&gt;전문가들의 의견을 중재하는 중재자가 반드시 필요&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">소프트웨어 개발비용 산정기법</summary></entry><entry><title type="html">[소프트웨어공학] 객체지향 개발 방법론</title><link href="https://many258.github.io/study/software-engineering-object-oriented/" rel="alternate" type="text/html" title="[소프트웨어공학] 객체지향 개발 방법론" /><published>2021-03-24T00:00:00+09:00</published><updated>2021-03-24T00:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-object-oriented%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-object-oriented/">&lt;h1 id=&quot;객체지향-개발-방법론&quot;&gt;객체지향 개발 방법론&lt;/h1&gt;
&lt;h2 id=&quot;객체지향-방법론의-정의&quot;&gt;객체지향 방법론의 정의&lt;/h2&gt;
&lt;p&gt;현실 세계의 개체(Entity)를 속성(Attribute)과 메소드(Method)가 결합된 형태의 객체(Object)로 표현하는 개념으로 객체간의 메시지 통신을 통해 시스템을 구현하는 개발 방법&lt;/p&gt;

&lt;h2 id=&quot;객체지향-기술의-장점&quot;&gt;객체지향 기술의 장점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;규모가 큰 대형 프로젝트에 적합&lt;/li&gt;
  &lt;li&gt;소프트웨어의 재사용률/확장성/유지보수 향상&lt;/li&gt;
  &lt;li&gt;신속하게 개발이 가능&lt;/li&gt;
  &lt;li&gt;사용자 타입 중심&lt;/li&gt;
  &lt;li&gt;대화식 프로그램 개발에 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체지향-기술의-단점&quot;&gt;객체지향 기술의 단점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;설계의 어려움&lt;/li&gt;
  &lt;li&gt;규모가 크기 때문에 실행속도 저하&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구성요소&quot;&gt;구성요소&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;클래스&lt;/strong&gt;(Class)&lt;br /&gt;
같은 종류(또는 문제 해결을 위한)의 집단에 속한 속성(attribute)과 행위(behavior)를 정의한 것&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;객체&lt;/strong&gt;(Object)&lt;br /&gt;
자신 고유의 데이터(attribute)를 가지며 클래스에서 정의한 행위(behavior)를 수행&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인스턴스&lt;/strong&gt;(Instance)&lt;br /&gt;
어떤 클래스에 속하는 구체적인 객체를 의미하며 클래스로 정의된 객체의 요소로 객체의 복사본이라 할 수 있다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;어트리뷰트&lt;/strong&gt;(Attribute)&lt;br /&gt;
객체 안에 존재하는 절대적 자료형.&lt;br /&gt;
객체에 존재하는 함수들이 동작하게 될 경우 같은 객체에 존재하는 어트리뷰트 값을 변경한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메서드&lt;/strong&gt;(Method)&lt;br /&gt;
객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산을 정의한 것&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메시지&lt;/strong&gt;(Message)&lt;br /&gt;
Sender와 Receiver객체들간의 상호작용의 수단으로 다른 객체에 특정 작업을 요청하는 신호&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;주요-특징&quot;&gt;주요 특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;캡슐화&lt;/strong&gt;(Encapsulation)&lt;br /&gt;
연관된 속성(데이터)과 메소드(연산)을 하나로 묶어서 객체로 구성&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;추상화&lt;/strong&gt;(Abstraction)&lt;br /&gt;
하위 객체의 공통된 특성을 묘사하기 위한 객체를 추상적인 객체. 이러한 추상적인 객체는 문제 대상의 공통 특성을 추출하여 객체를 정의하기에 유용하고 편리함을 제공한다&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;다형성&lt;/strong&gt;(Polymorphism)&lt;br /&gt;
같은 상위 객체에서 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;정보은닉&lt;/strong&gt;(Information Hiding)&lt;br /&gt;
캡슐화된 객체 내부에 자료 구조나 함수의 기능을 외부의 영향을 받거나 주지 않도록 설계하는 방법&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;상속성&lt;/strong&gt;(Inheritance)&lt;br /&gt;
상위클래스가 갖는 속성과 연산을 그대로 물려받는 것을 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체지향-개발-순서&quot;&gt;객체지향 개발 순서&lt;/h2&gt;
&lt;p&gt;전통적인 구조적 개발 순서 구분처럼 단계가 분명하게 구분되지는 않는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;계획&lt;/li&gt;
  &lt;li&gt;분석(OOA)
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;객체&lt;/code&gt; 모델링&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동적&lt;/code&gt; 모델링&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기능&lt;/code&gt; 모델링&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;설계(OOD)
    &lt;ul&gt;
      &lt;li&gt;객체 설계&lt;/li&gt;
      &lt;li&gt;시스템 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구현(OOP)&lt;/li&gt;
  &lt;li&gt;테스트 및 검증
    &lt;ul&gt;
      &lt;li&gt;단위 테스트&lt;/li&gt;
      &lt;li&gt;통합 테스트&lt;/li&gt;
      &lt;li&gt;검증과 시스템 테스팅&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;객체지향-분석ooa--object-oriented-analysis&quot;&gt;객체지향 분석(OOA : Object Oriented Analysis)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;특징&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;문제 영역의 분석 대상을 &lt;strong&gt;형식적인 전략&lt;/strong&gt;으로 기술하는 단계&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;E-R 다이어그램&lt;/strong&gt;은 객체지향 분석의 표기법으로 적합&lt;/li&gt;
      &lt;li&gt;클래스, 객체, 속성, 연산들을 표현해서 문제를 &lt;strong&gt;모형화&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석해내는 기법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체지향 분석의 순서(OMT : Object Modeling Technique, 람바우 방법)
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;객체 모델링&lt;/strong&gt;(Object Modeling)&lt;br /&gt;
객체를 찾아내고 객체의 속성, 연산을 식별하는 단계&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;동적 모델링&lt;/strong&gt;(Dynamic Modeling)&lt;br /&gt;
객체 모형들의 행위/상태/조건을 파악하는 단계&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;기능 모델링&lt;/strong&gt;(Functional Modeling)
        &lt;ul&gt;
          &lt;li&gt;입출력 결정&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자료 흐름도&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;객체들의 제어 흐름, 상호 반응 연산 순서를 나타내주는 과정&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;기능의 내용을 상세히 기술&lt;/li&gt;
          &lt;li&gt;제약사항을 결정하고 최소화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;객체지향-설계ood--object-oriented-design&quot;&gt;객체지향 설계(OOD : Object Oriented Design)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;특징&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;문제 영역의 분석 모형을 구체적인 절차로 표현&lt;/li&gt;
      &lt;li&gt;사용자 중심, 대화식 프로그램의 개발에 적합&lt;/li&gt;
      &lt;li&gt;시스템을 구성하는 클래스와 속성, 연산을 인식하여 클래스를 객체로, 속성을 자료 구조로, 연산을 알고리즘으로 표현하는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체지향 설계의 순서
    &lt;ul&gt;
      &lt;li&gt;문제의 정의&lt;/li&gt;
      &lt;li&gt;요구 명세화&lt;/li&gt;
      &lt;li&gt;객체 연산자 정의(객체 설계)&lt;br /&gt;
객체 분석에서 정의된 요구 명세서를 기반으로 객체 연산자를 정의하여 설계&lt;/li&gt;
      &lt;li&gt;객체 인터페이스 결정(시스템 설계)&lt;br /&gt;
객체 설계 단계에서 정의된 객체 간의 인터페이스를 정하여 전체적인 시스템을 설계&lt;br /&gt;
데이터, 자원 관리 방법을 결정&lt;br /&gt;
객체는 순차적으로 또는 동시적으로 제어할지를 결정&lt;/li&gt;
      &lt;li&gt;객체 구현&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;객체지향 설계의 계층
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Responsibilities&lt;/strong&gt; Layer&lt;br /&gt;
속성과 연산들에 대한 메타 데이터와 알고리즘을 표현&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Message&lt;/strong&gt; Layer&lt;br /&gt;
객체와 객체 간의 인터페이스를 표현&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Class &amp;amp; Object&lt;/strong&gt; Layer&lt;br /&gt;
전체 객체를 구체적으로 표현&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Subsystem&lt;/strong&gt; Layer&lt;br /&gt;
요구사항을 지원하는 기술적인 기반 구조를 구현&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;객체지향-테스트&quot;&gt;객체지향 테스트&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;쓰레드 기반 테스트(Thread-Based Testing)&lt;br /&gt;
시스템에 대한 하나의 입력이나 이벤트에 응답하는데 요구되는 클래스들의 집합을 통합(구조적 검사 기법의 &lt;strong&gt;하향식 통합 검사&lt;/strong&gt; 방법과 유사)&lt;/li&gt;
  &lt;li&gt;사용-기반 테스트(Use-Based Testing)&lt;br /&gt;
상위 클래스와 관계를 갖지 않는 수준에서 클래스들을 독립적으로 검사한 후 상위 클래스와 결합(구조적 검사 기법의 &lt;strong&gt;상향식 통합 방법&lt;/strong&gt;과 유사)&lt;/li&gt;
  &lt;li&gt;검증과 시스템 테스트&lt;br /&gt;
사용자의 요구가 객체에 정확히 반영되었는지, 성능이나 인터페이스상 오류는 없는지 검사&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;객체지향-분석-방법론의-종류&quot;&gt;객체지향 분석 방법론의 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;람바우(Rumbaugh) Method&lt;/strong&gt;&lt;br /&gt;
객체 모형, 동적 모형, 기능 모형으로 분리하여 접근하는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;E-R 다이어그램&lt;/strong&gt;&lt;br /&gt;
데이터 구조들과 그들 간의 관계를 표현하고 객체 모형을 만드는 방법론&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Booch Method&lt;/strong&gt;&lt;br /&gt;
미시적 개발 프로세스, 거시적 개발 프로세스로 접근하는 방법.&lt;br /&gt;
각 작업에 대한 다이어그램, 클래스 계층 정의, 클래스들의 클러스터링 작업 수행&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Coad &amp;amp; Yourdon Method&lt;/strong&gt;&lt;br /&gt;
E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성되는 방법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jacobson Method&lt;/strong&gt;&lt;br /&gt;
사용자가 제품 또는 시스템과 어떻게 상호 작용하는지를 서술한 시나리오로 접근&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Wirfs-Brocks Method&lt;/strong&gt;&lt;br /&gt;
분석과 설계 프로세스 간에 뚜렷한 구분이 없고, 고객 명세의 평가로 시작하여 설계로 끝나는 연속적인 프로세스로 접근한 방법&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><category term="(구)정보처리기사" /><summary type="html">객체지향 개발 방법론 객체지향 방법론의 정의 현실 세계의 개체(Entity)를 속성(Attribute)과 메소드(Method)가 결합된 형태의 객체(Object)로 표현하는 개념으로 객체간의 메시지 통신을 통해 시스템을 구현하는 개발 방법</summary></entry><entry><title type="html">[소프트웨어공학] 소프트웨어 설계</title><link href="https://many258.github.io/study/software-engineering-sw-design/" rel="alternate" type="text/html" title="[소프트웨어공학] 소프트웨어 설계" /><published>2021-03-23T00:00:00+09:00</published><updated>2021-03-23T23:37:34+09:00</updated><id>https://many258.github.io/study/%7Bsoftware-engineering-sw-design%7D</id><content type="html" xml:base="https://many258.github.io/study/software-engineering-sw-design/">&lt;h1 id=&quot;설계의-기본-개념&quot;&gt;설계의 기본 개념&lt;/h1&gt;
&lt;h2 id=&quot;소프트웨어-설계-절차&quot;&gt;소프트웨어 설계 절차&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DFD, DD 분석&lt;/li&gt;
  &lt;li&gt;외부 설계&lt;br /&gt;
파일 설계, 입출력 설계 등 S/W의 내적인 기능보다는 외부적은 특성을 설계&lt;/li&gt;
  &lt;li&gt;내부 설계(기본설계)&lt;br /&gt;
S/W의 내부 설계이며 주로 모듈의 기능을 정의하거나 모듈 간의 관계를 정의하는 설계&lt;/li&gt;
  &lt;li&gt;내부 설계(상세설계)&lt;br /&gt;
모듈 내부의 알고리즘을 정의&lt;/li&gt;
  &lt;li&gt;설계 명세서&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;설계-모형&quot;&gt;설계 모형&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;문서량 기준
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;데이터(Data) 설계&lt;br /&gt;
요구분석의 자료 사전(DD, 메타 데이터)을 분석&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;구조(Architectural) 설계&lt;br /&gt;
구조도 작성(외부 설계)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;관계(Interface) 설계&lt;br /&gt;
모듈 간의 관계를 표현(기본 설계)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;절차(Procedure) 설계&lt;br /&gt;
PDL로 알고리즘을 작성(상세 설계)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;노력 기준
    &lt;ul&gt;
      &lt;li&gt;절차 설계&lt;/li&gt;
      &lt;li&gt;관계 설계&lt;/li&gt;
      &lt;li&gt;구조 설계&lt;/li&gt;
      &lt;li&gt;데이터 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;설계의-종류&quot;&gt;설계의 종류&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;상위 설계(High-Level Design) : 아키텍처/예비 설계, 하위 설계를 위한 바탕
    &lt;ul&gt;
      &lt;li&gt;구조 설계&lt;/li&gt;
      &lt;li&gt;DB 설계&lt;/li&gt;
      &lt;li&gt;인터페이스 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;하위 설계(Low-Level Design) : 시스템 수준에서의 소프트웨어 구성 컴포넌트 간의 관계
    &lt;ul&gt;
      &lt;li&gt;컴포넌트 설계&lt;/li&gt;
      &lt;li&gt;자료구조 설계&lt;/li&gt;
      &lt;li&gt;알고리즘 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;구조적-설계의-원칙&quot;&gt;구조적 설계의 원칙&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;모듈화(Modularization)&lt;/strong&gt;&lt;br /&gt;
단일 기능을 갖출 수 있도록 부분적으로 묶어서 처리하는 기술&lt;br /&gt;
단위 프로그램, 함수, 서브 프로그램을 작성하기 위한 설계 기법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;추상화(Abstraction)&lt;/strong&gt;&lt;br /&gt;
세부적은 설계를 배제하고 전체 흐름과 구조를 알아볼 수 있도록 개관적인 설계부터 점차 세부적으로 진행하는 설계 기법
    &lt;ul&gt;
      &lt;li&gt;기능 추상화 : 수행의 흐름만을 정의&lt;/li&gt;
      &lt;li&gt;제어 추상화 : 선택, 반복, 분기 등의 설계를 추상화&lt;/li&gt;
      &lt;li&gt;자료 추상화 : 변수 및 레코드 등을 추상화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구조화(Structured)&lt;/strong&gt;&lt;br /&gt;
모듈을 수행하기 위한 위치나 시기를 전체 구조에 적절하게 배치시키는 설계 기법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;정보 은닉(Information Hiding)&lt;/strong&gt;&lt;br /&gt;
모듈 간의 관계성을 최소화시키는 설계 기법.(S/W 변경 용이)&lt;br /&gt;
설계상의 결정 사항들이 각 모듈 안에 숨겨져 있어 다른 모듈이 접근하거나 변경을 못한다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;분할과 정복&lt;/strong&gt;&lt;br /&gt;
Bottom-Up 방식으로 작은 시스템을 개발하고, 이를 합쳐 큰 시스템을 만든다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단계적 분해&lt;/strong&gt;&lt;br /&gt;
하향식 설계에서 사용. 문제를 상위 수준에서 점증적으로 더 구체적인 하위 수준으로 분할하는 기법
    &lt;ul&gt;
      &lt;li&gt;문제를 하위 수준의 독립된 단위로 나눈다&lt;/li&gt;
      &lt;li&gt;구분된 문제의 자세한 내용은 가능한 뒤로 미룬다&lt;/li&gt;
      &lt;li&gt;점증적으로 구체화 작업을 계속한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;좋은-설계&quot;&gt;좋은 설계&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;요구사항을 모두 표현(완전성)&lt;/li&gt;
  &lt;li&gt;유지보수하기 쉽고(변경이 용이) 가독성이 좋고 객관성 있게 작성&lt;/li&gt;
  &lt;li&gt;구현 관점에서 데이터/기능/행위 영역을 설명하는 완전한 그림을 제공&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;모듈적이어야 하며, 두 모듈 간의 상호 의존도는 약하게 해야 한다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모듈화&quot;&gt;모듈화&lt;/h1&gt;
&lt;h2 id=&quot;모듈의-특징&quot;&gt;모듈의 특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;구현, 컴파일, 설계는 독립적으로 수행, 실행은 종속적으로 수행&lt;/li&gt;
  &lt;li&gt;다른 모듈을 호출할 수도, 호출당할 수 있다&lt;/li&gt;
  &lt;li&gt;모듈 호출 시 매개변수를 전달하거나 전달받을 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;모듈화의-장점&quot;&gt;모듈화의 장점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;단위 프로그램을 독립적으로 설계할 수 있기 때문에 설계가 용이&lt;/li&gt;
  &lt;li&gt;모듈만을 구분하면 되므로 프로그램의 복잡도를 감소&lt;/li&gt;
  &lt;li&gt;다른 모듈에 영향을 주지 않을 수 있으므로 수정이 용이&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;공유도--제어도&quot;&gt;공유도 / 제어도&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;공유도(Fan-in)
얼마나 많은 모듈이 주어진 모듈을 호출하는가를 나타내는 척도.&lt;/li&gt;
  &lt;li&gt;제어도(Fan-out)
주어진 모듈이 호출하는 모듈의 개수&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모듈의-응집력cohesion&quot;&gt;모듈의 응집력(Cohesion)&lt;/h1&gt;
&lt;p&gt;모듈 안의 요소들이 서로 관련되어 있는 정도로 강할수록 좋은 설계(좋은 설계 순서)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;기능적(Functional)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부가 하나의 단일 기능으로 존재하는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;순차적(Sequential)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 이전의 명령어로부터 나온 출력 결과를 그 다음 명령어의 입력자료로 사용하는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;교환적(Communication)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 작업 대상이 같은 기능끼리 존재하는 경우나 동일한 입력과 출력을 사용하는 작업들이 모인 경우&lt;br /&gt;
예시) 하나의 파일을 대상으로 갱신 작업을 하는 루틴끼리 묶인 루틴&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;절차적(Procedural)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 수행 시기에 순위가 있는 기능끼리 존재하는 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;시간적(Temporal)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 시간상으로 수행 시기가 같은 기능끼리 존재&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;논리적(Logical)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 같은 범주에 속하는 기능끼리 묶은 모듈.&lt;br /&gt;
유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 하나의 모듈로 형성&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;우연적(Coincidental)&lt;/strong&gt; 응집&lt;br /&gt;
모듈 내부의 루틴들이 뚜렷한 관계없이 묶인 경우&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;모듈의-결합도coupling&quot;&gt;모듈의 결합도(Coupling)&lt;/h1&gt;
&lt;p&gt;두 모듈 간의 관계성(상호 의존성)의 척도로, 약할수록 좋은 설계(좋은 설계 순서)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;자료(Data)&lt;/strong&gt; 결합도&lt;br /&gt;
두 모듈 간의 인터페이스가 자료 요소만으로 구성된 결합도&lt;br /&gt;
Call By Value 기법으로 결합된 모듈&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;구조(Stamp)&lt;/strong&gt; 결합도&lt;br /&gt;
두 모듈 간의 인터페이스로 배열이나 레코드같은 자료 구조가 전달&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제어(Control)&lt;/strong&gt; 결합도&lt;br /&gt;
호출 모듈에서 전달된 자료에 의해서 운용되는 피 호출 모듈의 관계(종속적인 관계)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;외부(Extern)&lt;/strong&gt; 결합도&lt;br /&gt;
외부 변수에 의해 영향을 받는 두 모듈이 결합된 관계. 전역 변수 관련&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;공통(Common)&lt;/strong&gt; 결합도&lt;br /&gt;
공유되는 공통 데이터 영역을 여러 모듈이 사용하는 모듈 관계.&lt;br /&gt;
Call By Referrence, 메모리 번지의 공유&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;내용(Content)&lt;/strong&gt; 결합도&lt;br /&gt;
모듈이 다른 모듈 내부 기능 및 그 내부 자료를 참조하는 형태의 결합&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;구조적-설계-표기법&quot;&gt;구조적 설계 표기법&lt;/h1&gt;
&lt;h2 id=&quot;n-snassi-schneiderman-chart&quot;&gt;N-S(Nassi-Schneiderman) Chart&lt;/h2&gt;
&lt;p&gt;IBM사에 의해 개발되었으며 입출력 자료와 소프트웨어 모듈들 사이의 관계를 표현하는 뛰어난 능력을 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;고려사항
    &lt;ul&gt;
      &lt;li&gt;도표는 항상 직사각형&lt;/li&gt;
      &lt;li&gt;도표의 제어 흐름은 맨 위에서 시작&lt;/li&gt;
      &lt;li&gt;제어 흐름은 위에서 아래로 흐른다(하향식)&lt;/li&gt;
      &lt;li&gt;수평으로 그어진 줄은 모두 평행이 되어야 한다&lt;/li&gt;
      &lt;li&gt;사각형 안의 내용이 수행된 후에는 아래 방향으로 빠져나온다&lt;/li&gt;
      &lt;li&gt;사각형에 빈 공간이 있을 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/images/sw-engineering/n-s-chart.png&quot; alt=&quot;&quot; class=&quot;align-center&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;논리적 기술에 중점을 둔 도형을 이용한 표현 방법&lt;/li&gt;
      &lt;li&gt;연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현&lt;/li&gt;
      &lt;li&gt;임의의 제어 이동이 어렵다&lt;/li&gt;
      &lt;li&gt;상자 도표라고도 하며 프로그램으로 구현이 쉽다&lt;/li&gt;
      &lt;li&gt;조건이 복합된 곳의 처리를 시각적으로 명확히 식별하는데 적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hipohierarchy-plus-input-process-output&quot;&gt;HIPO(Hierarchy plus Input Process Output)&lt;/h2&gt;
&lt;p&gt;IBM에서 개발한 방법으로 프로그램을 기능 위주로 문서화하는 하향식 설계 기법.&lt;/p&gt;

&lt;p&gt;입력/처리/출력으로 구성되어 시각적으로 알아보기 쉽게 표현할 수 있으며 구조화된 방법으로 구현될 수 있도록 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;종류
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;도식 목차(가시적 도표, Visual Table of Contents)&lt;br /&gt;
전체적인 흐름과 구조를 나타내는 도표&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;총괄 도표(총체적 도표, Overview Diagram)&lt;br /&gt;
입력/처리/출력 등의 기능을 명확히 표현한 도표(&lt;strong&gt;사용자관점&lt;/strong&gt;)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;상세 도표(세부적 도표, Detail Diagram)&lt;br /&gt;
총괄 도표의 일부 기능을 구체적으로 표현한 모듈 도표(&lt;strong&gt;개발자관점&lt;/strong&gt;)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;분석 및 설계 도구로 사용&lt;/li&gt;
      &lt;li&gt;하향식(Top-Down) 개발에 적당&lt;/li&gt;
      &lt;li&gt;수정 및 유지보수가 용이&lt;/li&gt;
      &lt;li&gt;소규모 프로젝트에 적합&lt;/li&gt;
      &lt;li&gt;기능과 자료의 관계를 동시에 표현할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;설계-방법론&quot;&gt;설계 방법론&lt;/h1&gt;
&lt;h2 id=&quot;구조적-설계-방법론&quot;&gt;구조적 설계 방법론&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기본구조
    &lt;ul&gt;
      &lt;li&gt;순차(Sequence) 구조&lt;/li&gt;
      &lt;li&gt;선택(Condition) 구조&lt;/li&gt;
      &lt;li&gt;반복(Repetition) 구조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;특징
    &lt;ul&gt;
      &lt;li&gt;단일 입출력으로 처리&lt;/li&gt;
      &lt;li&gt;실행 효율성을 중시할 때 한정된 범위 내에서 GOTO문을 사용&lt;/li&gt;
      &lt;li&gt;프로그램의 이해가 쉽고 유지보수와 검증이 용이&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자료-흐름-중심-설계-방법론&quot;&gt;자료 흐름 중심 설계 방법론&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;자료 흐름 설계 과정
    &lt;ul&gt;
      &lt;li&gt;정보 &lt;strong&gt;흐름의 유형&lt;/strong&gt;을 설정&lt;/li&gt;
      &lt;li&gt;흐름의 &lt;strong&gt;경계&lt;/strong&gt;(Flow Boundaries)를 표시&lt;/li&gt;
      &lt;li&gt;자료 흐름도를 프로그램 구조로 &lt;strong&gt;사상&lt;/strong&gt; → &lt;strong&gt;변환 사상&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;제어 계층을 분해&lt;/strong&gt;시켜서 정의&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;경험적 방법&lt;/strong&gt;을 구체화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;변환 사상(Transform Mapping)&lt;/strong&gt;&lt;br /&gt;
변환 흐름에 특성을 갖는 &lt;strong&gt;DFD(Data Flow Diagram)&lt;/strong&gt; 을 전체 혹은 일부를 분할해서 &lt;strong&gt;구조도&lt;/strong&gt;로 변화하는 작업&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자료-구조-중심-설계-방법론&quot;&gt;자료 구조 중심 설계 방법론&lt;/h2&gt;
&lt;p&gt;입출력 자료의 구조 파악으로 소프트웨어 구조를 추출&lt;/p&gt;

&lt;h3 id=&quot;dssd-방법론-warnier-orr-기법&quot;&gt;DSSD 방법론 (Warnier-Orr 기법)&lt;/h3&gt;
&lt;p&gt;Warnier가 개발한 LCP(Logical of Program)를 Orr와 공동으로 개발한 자료 구조 지향 설계 방법으로 출력 자료를 중심으로 입력 자료를 설계하고 제어 구조도 설계하는 방법&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;출력 자료 정의 : 출력할 자료를 파악하여 배열&lt;/li&gt;
  &lt;li&gt;논리적 레코드 정의 : 출력할 레코드의 구조를 정의&lt;/li&gt;
  &lt;li&gt;사건 분석 : 출력할 레코드 항목을 기준으로 입력 항목을 정의&lt;/li&gt;
  &lt;li&gt;물리적 레코드 정의 : 입력할 레코드의 구조를 정의&lt;/li&gt;
  &lt;li&gt;논리적 절차 정의 : 입력/처리/출력 모듈로 구분하여 Warnier-Orr 도표를 그림&lt;/li&gt;
  &lt;li&gt;물리적 절차 정의 : 명시된 도표를 보고 알고리즘 기술&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;jsd-방법론-jackson-기법&quot;&gt;JSD 방법론 (Jackson 기법)&lt;/h3&gt;
&lt;p&gt;프로그램의 입력과 출력 자료의 구조를 대응시켜서 설계하는 자료 구조 지향 설계 방법론으로 자료 구조를 정의하면서 제어 구조를 유도하는 방식&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;자료 구조 정의&lt;br /&gt;
입출력 구조를 정의하여 일치되지 않는 부분을 처리 루틴으로 모듈화하고 일치하는 부분은 입력과 출력 루틴으로 모듈화&lt;/li&gt;
  &lt;li&gt;구조도 작성&lt;br /&gt;
입력/처리/출력으로 분류하여 잭슨 표기법으로 구조도를 세분화하여 작성&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;연산 목록 작성&lt;br /&gt;
  구조도를 보고 필요한 제어 구조 명시&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;구조문 작성&lt;br /&gt;
  명시된 제어 구조를 보고 알고리즘 기술&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;소프트웨어-설계-solid-원칙&quot;&gt;소프트웨어 설계 SOLID 원칙&lt;/h1&gt;
&lt;h2 id=&quot;single-responsibility-priciple단일-책임-원칙--srp&quot;&gt;Single Responsibility Priciple(단일 책임 원칙 : SRP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;소프트웨어의 설계 부품은 반드시 한 개의 책임을 가져야 한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;책임 대신 기능이라 해석해도 무방하다.&lt;/p&gt;

&lt;h2 id=&quot;open-closed-principle개방-폐쇠-원칙--ocp&quot;&gt;Open-Closed Principle(개방 폐쇠 원칙 : OCP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;한 번 설계가 되고 단위 테스트가 완료된 객체는 향후 외부에 변경 사항이 발생하더라도 객체 자체는 변경되지 않아야 한다는 것을 의미&lt;/p&gt;

&lt;h2 id=&quot;liskov-substitution-principle리스코프-치환-원칙--lsp&quot;&gt;Liskov Substitution Principle(리스코프 치환 원칙 : LSP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;자식 클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;MIT 컴퓨터 사이언스 교수인 리스코프가 제안한 설계 원칙으로 상속관계에 있는 두 객체에 있어서 부모 클래스의 인스턴스가 사용된 자리에 자식 클래스의 인스턴스를 넣어도 &lt;strong&gt;코드의 맥락이 변하지 않아야&lt;/strong&gt; 한다는 것을 의미한다.&lt;/p&gt;

&lt;p&gt;자식 클래스가 부모 클래스를 대체하기 위해서는 부모의 기능에 대해 오버라이드되지 않도록 하면 된다. 즉, 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않과 &lt;strong&gt;확장만 수행&lt;/strong&gt;하도록 해야 LSP를 만족하게 된다.&lt;/p&gt;

&lt;p&gt;LSP의 만족 여부는 [자식 클래스 &lt;strong&gt;is a kind of&lt;/strong&gt; 부모 클래스]의 참/거짓으로 간단히 파악이 가능&lt;/p&gt;

&lt;h2 id=&quot;interface-segregation-principle인터페이스-분리-원칙--isp&quot;&gt;Interface Segregation Principle(인터페이스 분리 원칙 : ISP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;객체 자신이 사용하지 않을 인터페이스는 구현하면 안된다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 자신이 &lt;strong&gt;사용하지 않는 기능에는 영향을 받지 말아야 한다&lt;/strong&gt;는 것을 의미한다&lt;/p&gt;

&lt;p&gt;가능한 경우라면, 범용 인터페이스를 구현하는 것보다 객체에 &lt;strong&gt;특화된 인터페이스를 분리&lt;/strong&gt;해내어 구현한다.&lt;/p&gt;

&lt;h2 id=&quot;dependency-inversion-principle의존-역전-원칙--dip&quot;&gt;Dependency Inversion Principle(의존 역전 원칙 : DIP)&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;의존 관계를 맺을 때, 변화하기 쉬운 것(구체화)보다 변화하기 어려운 것(추상화)에 의존해야 한다는 원칙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;구체적인 클래스보다 &lt;strong&gt;추상성이 높은 인터페이스나 추상클래스와 관계&lt;/strong&gt;를 맺는다는 것을 의미. 일반적으로 Interface를 활용 시 이 원칙을 준수할 수 있다.&lt;/p&gt;</content><author><name>SG Yoo.</name></author><category term="study" /><category term="SW Engineering" /><summary type="html">설계의 기본 개념 소프트웨어 설계 절차 DFD, DD 분석 외부 설계 파일 설계, 입출력 설계 등 S/W의 내적인 기능보다는 외부적은 특성을 설계 내부 설계(기본설계) S/W의 내부 설계이며 주로 모듈의 기능을 정의하거나 모듈 간의 관계를 정의하는 설계 내부 설계(상세설계) 모듈 내부의 알고리즘을 정의 설계 명세서 설계 모형 문서량 기준 데이터(Data) 설계 요구분석의 자료 사전(DD, 메타 데이터)을 분석</summary></entry></feed>